(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (Buffer){(function (){
const choo = require('choo')
const html = require('choo/html')
const sf = 0
const evm2wasm = require('@ark-us/evm2wasm')
const app = choo()

// add global css
;((require('insert-css')("code {\n  white-space: pre;\n  height: 95%;\n}\n\nmain,\ndiv,\nhtml, \nbody {\n  height: 100%;\n  overflow: hidden;\n  font-family: monospace;\n}\n\ndiv {\n  float: left;\n  width: 50%;\n}\n\nmain {\n  height: 85%; \n}\n\ntextarea {\n  width: 90%;\n  height: 80%;\n}") || true) && "_4bbf8dd2")

const scroll = ((require('insert-css')("._74479bd6 {\n    overflow: scroll;\n  }") || true) && "_74479bd6")

const demoEVMcode = '0x60606040526000357c010000000000000000000000000000000000000000000000000000000090048063771602F7146037576035565b005b60546004808035906020019091908035906020019091905050606A565b6040518082815260200191505060405180910390f35b6000818301905080505b9291505056'
const demoWastCode = compileEVM(demoEVMcode, true, true)

app.model({
  state: {
    evmCode: demoEVMcode,
    wastCode: demoWastCode,
    inlineOps: true,
    pprint: true
  },
  reducers: {
    compile: (data, state) => ({
      evmCode: data,
      wastCode: compileEVM(data, state.inlineOps, state.pprint)
    }),
    toggle: (data, state) => {
      const update = {}
      update[data] = !state[data]
      return update
    }
  }
})

const header = html`
  <header>
    <h1>EVM 2 EWASM</h1>
  </header>`

const footer = html`
  <footer>
   transcompiles EVM bytecode to <a href='https://github.com/ewasm/design'>ewasm</a> with <a href='https://github.com/ewasm/evm2wasm/'>evm2wasm</a> | <a href="https://github.com/ewasm/evm2wasm-frontend">source</a> | <a href="https://github.com/ewasm/evm2wasm-frontend/issues">issues</a>
  </footer>`

const clipboardCopy = (text) => {
  if (navigator.clipboard) {
      return navigator.clipboard.writeText(text);
  }
  const aux = document.createElement("textarea");
  aux.setAttribute("value", text);
  document.body.appendChild(aux);
  aux.select();
  document.execCommand("copy");
  document.body.removeChild(aux);
}

const mainView = (state, prev, send) => html `
  <main>
    <div>
      <textarea id="evmcode" onchange=${(e) => send('compile', e.target.value)}>${state.evmCode}</textarea>
      <br>
      <input type="checkbox" checked=${state.inlineOps} onchange=${(e) => {
        send('toggle', 'inlineOps')
        send('compile', state.evmCode)
      }} />inline EVM opcodes
      <input type="checkbox" checked=${state.pprint} onchange=${(e) => {
        send('toggle', 'pprint')
        send('compile', state.evmCode)
      }} />pretty print
    </div>
    <h3>Copy the wast source</h2>
    <h3>Go to the wat2wasm tool, paste the wast source. Click on download and get the .wasm file</h2>
    <button onclick=${() => clipboardCopy(state.wastCode)}>copy wast</button>
    <a href="https://webassembly.github.io/wabt/demo/wat2wasm/" target="_blank">go to wat2wasm</a>
    <div class=${scroll}>
      <code>${state.wastCode}</code>
    </div>
  </main>`


app.router((route) => [
  route('/', mainView)
])

setTimeout(() => {
  document.getElementById("evmcode").value = demoEVMcode;
}, 1000);

const tree = app.start()
document.body.appendChild(header)
document.body.appendChild(tree)
document.body.appendChild(footer)

function compileEVM (evm, inlineOps, pprint) {
  console.log(evm);
  if (evm.substring(0, 2) == "0x") {
    evm = evm.substring(2);
  }
  const source = evm2wasm.evm2wast(new Buffer(evm, 'hex'), {
    inlineOps: inlineOps,
    pprint: pprint
  })
  // console.log(source)
  return source;
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"@ark-us/evm2wasm":64,"buffer":11,"choo":13,"choo/html":12,"insert-css":25}],2:[function(require,module,exports){
(function (global){(function (){
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"object-assign":30,"util/":5}],3:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],4:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],5:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":4,"_process":34,"inherits":3}],6:[function(require,module,exports){
module.exports = applyHook

// apply arguments onto an array of functions, useful for hooks
// (arr, any?, any?, any?, any?, any?) -> null
function applyHook (arr, arg1, arg2, arg3, arg4, arg5) {
  arr.forEach(function (fn) {
    fn(arg1, arg2, arg3, arg4, arg5)
  })
}

},{}],7:[function(require,module,exports){
const mutate = require('xtend/mutable')
const assert = require('assert')
const xtend = require('xtend')

const applyHook = require('./apply-hook')

module.exports = dispatcher

// initialize a new barracks instance
// obj -> obj
function dispatcher (hooks) {
  hooks = hooks || {}
  assert.equal(typeof hooks, 'object', 'barracks: hooks should be undefined or an object')

  const onStateChangeHooks = []
  const onActionHooks = []
  const onErrorHooks = []

  const subscriptionWraps = []
  const initialStateWraps = []
  const reducerWraps = []
  const effectWraps = []

  use(hooks)

  var reducersCalled = false
  var effectsCalled = false
  var stateCalled = false
  var subsCalled = false

  const subscriptions = start._subscriptions = {}
  const reducers = start._reducers = {}
  const effects = start._effects = {}
  const models = start._models = []
  var _state = {}

  start.model = setModel
  start.state = getState
  start.start = start
  start.use = use
  return start

  // push an object of hooks onto an array
  // obj -> null
  function use (hooks) {
    assert.equal(typeof hooks, 'object', 'barracks.use: hooks should be an object')
    assert.ok(!hooks.onError || typeof hooks.onError === 'function', 'barracks.use: onError should be undefined or a function')
    assert.ok(!hooks.onAction || typeof hooks.onAction === 'function', 'barracks.use: onAction should be undefined or a function')
    assert.ok(!hooks.onStateChange || typeof hooks.onStateChange === 'function', 'barracks.use: onStateChange should be undefined or a function')

    if (hooks.onStateChange) onStateChangeHooks.push(hooks.onStateChange)
    if (hooks.onError) onErrorHooks.push(wrapOnError(hooks.onError))
    if (hooks.onAction) onActionHooks.push(hooks.onAction)
    if (hooks.wrapSubscriptions) subscriptionWraps.push(hooks.wrapSubscriptions)
    if (hooks.wrapInitialState) initialStateWraps.push(hooks.wrapInitialState)
    if (hooks.wrapReducers) reducerWraps.push(hooks.wrapReducers)
    if (hooks.wrapEffects) effectWraps.push(hooks.wrapEffects)
  }

  // push a model to be initiated
  // obj -> null
  function setModel (model) {
    assert.equal(typeof model, 'object', 'barracks.store.model: model should be an object')
    models.push(model)
  }

  // get the current state from the store
  // obj? -> obj
  function getState (opts) {
    opts = opts || {}
    assert.equal(typeof opts, 'object', 'barracks.store.state: opts should be an object')

    const state = opts.state
    if (!opts.state && opts.freeze === false) return xtend(_state)
    else if (!opts.state) return Object.freeze(xtend(_state))
    assert.equal(typeof state, 'object', 'barracks.store.state: state should be an object')

    const namespaces = []
    const newState = {}

    // apply all fields from the model, and namespaced fields from the passed
    // in state
    models.forEach(function (model) {
      const ns = model.namespace
      namespaces.push(ns)
      const modelState = model.state || {}
      if (ns) {
        newState[ns] = newState[ns] || {}
        apply(ns, modelState, newState)
        newState[ns] = xtend(newState[ns], state[ns])
      } else {
        mutate(newState, modelState)
      }
    })

    // now apply all fields that weren't namespaced from the passed in state
    Object.keys(state).forEach(function (key) {
      if (namespaces.indexOf(key) !== -1) return
      newState[key] = state[key]
    })

    const tmpState = xtend(_state, xtend(state, newState))
    const wrappedState = wrapHook(tmpState, initialStateWraps)

    return (opts.freeze === false)
      ? wrappedState
      : Object.freeze(wrappedState)
  }

  // initialize the store hooks, get the send() function
  // obj? -> fn
  function start (opts) {
    opts = opts || {}
    assert.equal(typeof opts, 'object', 'barracks.store.start: opts should be undefined or an object')

    // register values from the models
    models.forEach(function (model) {
      const ns = model.namespace
      if (!stateCalled && model.state && opts.state !== false) {
        const modelState = model.state || {}
        if (ns) {
          _state[ns] = _state[ns] || {}
          apply(ns, modelState, _state)
        } else {
          mutate(_state, modelState)
        }
      }
      if (!reducersCalled && model.reducers && opts.reducers !== false) {
        apply(ns, model.reducers, reducers, function (cb) {
          return wrapHook(cb, reducerWraps)
        })
      }
      if (!effectsCalled && model.effects && opts.effects !== false) {
        apply(ns, model.effects, effects, function (cb) {
          return wrapHook(cb, effectWraps)
        })
      }
      if (!subsCalled && model.subscriptions && opts.subscriptions !== false) {
        apply(ns, model.subscriptions, subscriptions, function (cb, key) {
          const send = createSend('subscription: ' + (ns ? ns + ':' + key : key))
          cb = wrapHook(cb, subscriptionWraps)
          cb(send, function (err) {
            applyHook(onErrorHooks, err, _state, createSend)
          })
          return cb
        })
      }
    })

    // the state wrap is special because we want to operate on the full
    // state rather than indvidual chunks, so we apply it outside the loop
    if (!stateCalled && opts.state !== false) {
      _state = wrapHook(_state, initialStateWraps)
    }

    if (!opts.noSubscriptions) subsCalled = true
    if (!opts.noReducers) reducersCalled = true
    if (!opts.noEffects) effectsCalled = true
    if (!opts.noState) stateCalled = true

    if (!onErrorHooks.length) onErrorHooks.push(wrapOnError(defaultOnError))

    return createSend

    // call an action from a view
    // (str, bool?) -> (str, any?, fn?) -> null
    function createSend (selfName, callOnError) {
      assert.equal(typeof selfName, 'string', 'barracks.store.start.createSend: selfName should be a string')
      assert.ok(!callOnError || typeof callOnError === 'boolean', 'barracks.store.start.send: callOnError should be undefined or a boolean')

      return function send (name, data, cb) {
        if (!cb && !callOnError) {
          cb = data
          data = null
        }
        data = (typeof data === 'undefined' ? null : data)

        assert.equal(typeof name, 'string', 'barracks.store.start.send: name should be a string')
        assert.ok(!cb || typeof cb === 'function', 'barracks.store.start.send: cb should be a function')

        const done = callOnError ? onErrorCallback : cb
        _send(name, data, selfName, done)

        function onErrorCallback (err) {
          err = err || null
          if (err) {
            applyHook(onErrorHooks, err, _state, function createSend (selfName) {
              return function send (name, data) {
                assert.equal(typeof name, 'string', 'barracks.store.start.send: name should be a string')
                data = (typeof data === 'undefined' ? null : data)
                _send(name, data, selfName, done)
              }
            })
          }
        }
      }
    }

    // call an action
    // (str, str, any, fn) -> null
    function _send (name, data, caller, cb) {
      assert.equal(typeof name, 'string', 'barracks._send: name should be a string')
      assert.equal(typeof caller, 'string', 'barracks._send: caller should be a string')
      assert.equal(typeof cb, 'function', 'barracks._send: cb should be a function')

      setTimeout(function () {
        var reducersCalled = false
        var effectsCalled = false
        const newState = xtend(_state)

        if (onActionHooks.length) {
          applyHook(onActionHooks, data, _state, name, caller, createSend)
        }

        // validate if a namespace exists. Namespaces are delimited by ':'.
        var actionName = name
        if (/:/.test(name)) {
          const arr = name.split(':')
          var ns = arr.shift()
          actionName = arr.join(':')
        }

        const _reducers = ns ? reducers[ns] : reducers
        if (_reducers && _reducers[actionName]) {
          if (ns) {
            const reducedState = _reducers[actionName](data, _state[ns])
            newState[ns] = xtend(_state[ns], reducedState)
          } else {
            mutate(newState, reducers[actionName](data, _state))
          }
          reducersCalled = true
          if (onStateChangeHooks.length) {
            applyHook(onStateChangeHooks, data, newState, _state, actionName, createSend)
          }
          _state = newState
          cb(null, newState)
        }

        const _effects = ns ? effects[ns] : effects
        if (!reducersCalled && _effects && _effects[actionName]) {
          const send = createSend('effect: ' + name)
          if (ns) _effects[actionName](data, _state[ns], send, cb)
          else _effects[actionName](data, _state, send, cb)
          effectsCalled = true
        }

        if (!reducersCalled && !effectsCalled) {
          throw new Error('Could not find action ' + actionName)
        }
      }, 0)
    }
  }
}

// compose an object conditionally
// optionally contains a namespace
// which is used to nest properties.
// (str, obj, obj, fn?) -> null
function apply (ns, source, target, wrap) {
  if (ns && !target[ns]) target[ns] = {}
  Object.keys(source).forEach(function (key) {
    const cb = wrap ? wrap(source[key], key) : source[key]
    if (ns) target[ns][key] = cb
    else target[key] = cb
  })
}

// handle errors all the way at the top of the trace
// err? -> null
function defaultOnError (err) {
  throw err
}

function wrapOnError (onError) {
  return function onErrorWrap (err, state, createSend) {
    if (err) onError(err, state, createSend)
  }
}

// take a apply an array of transforms onto a value. The new value
// must be returned synchronously from the transform
// (any, [fn]) -> any
function wrapHook (value, transforms) {
  transforms.forEach(function (transform) {
    value = transform(value)
  })
  return value
}

},{"./apply-hook":6,"assert":2,"xtend":60,"xtend/mutable":61}],8:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],9:[function(require,module,exports){
var document = require('global/document')
var hyperx = require('hyperx')
var onload = require('on-load')

var SVGNS = 'http://www.w3.org/2000/svg'
var XLINKNS = 'http://www.w3.org/1999/xlink'

var BOOL_PROPS = {
  autofocus: 1,
  checked: 1,
  defaultchecked: 1,
  disabled: 1,
  formnovalidate: 1,
  indeterminate: 1,
  readonly: 1,
  required: 1,
  selected: 1,
  willvalidate: 1
}
var COMMENT_TAG = '!--'
var SVG_TAGS = [
  'svg',
  'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor',
  'animateMotion', 'animateTransform', 'circle', 'clipPath', 'color-profile',
  'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix',
  'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting',
  'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB',
  'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode',
  'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting',
  'feSpotLight', 'feTile', 'feTurbulence', 'filter', 'font', 'font-face',
  'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri',
  'foreignObject', 'g', 'glyph', 'glyphRef', 'hkern', 'image', 'line',
  'linearGradient', 'marker', 'mask', 'metadata', 'missing-glyph', 'mpath',
  'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect',
  'set', 'stop', 'switch', 'symbol', 'text', 'textPath', 'title', 'tref',
  'tspan', 'use', 'view', 'vkern'
]

function belCreateElement (tag, props, children) {
  var el

  // If an svg tag, it needs a namespace
  if (SVG_TAGS.indexOf(tag) !== -1) {
    props.namespace = SVGNS
  }

  // If we are using a namespace
  var ns = false
  if (props.namespace) {
    ns = props.namespace
    delete props.namespace
  }

  // Create the element
  if (ns) {
    el = document.createElementNS(ns, tag)
  } else if (tag === COMMENT_TAG) {
    return document.createComment(props.comment)
  } else {
    el = document.createElement(tag)
  }

  // If adding onload events
  if (props.onload || props.onunload) {
    var load = props.onload || function () {}
    var unload = props.onunload || function () {}
    onload(el, function belOnload () {
      load(el)
    }, function belOnunload () {
      unload(el)
    },
    // We have to use non-standard `caller` to find who invokes `belCreateElement`
    belCreateElement.caller.caller.caller)
    delete props.onload
    delete props.onunload
  }

  // Create the properties
  for (var p in props) {
    if (props.hasOwnProperty(p)) {
      var key = p.toLowerCase()
      var val = props[p]
      // Normalize className
      if (key === 'classname') {
        key = 'class'
        p = 'class'
      }
      // The for attribute gets transformed to htmlFor, but we just set as for
      if (p === 'htmlFor') {
        p = 'for'
      }
      // If a property is boolean, set itself to the key
      if (BOOL_PROPS[key]) {
        if (val === 'true') val = key
        else if (val === 'false') continue
      }
      // If a property prefers being set directly vs setAttribute
      if (key.slice(0, 2) === 'on') {
        el[p] = val
      } else {
        if (ns) {
          if (p === 'xlink:href') {
            el.setAttributeNS(XLINKNS, p, val)
          } else if (/^xmlns($|:)/i.test(p)) {
            // skip xmlns definitions
          } else {
            el.setAttributeNS(null, p, val)
          }
        } else {
          el.setAttribute(p, val)
        }
      }
    }
  }

  function appendChild (childs) {
    if (!Array.isArray(childs)) return
    for (var i = 0; i < childs.length; i++) {
      var node = childs[i]
      if (Array.isArray(node)) {
        appendChild(node)
        continue
      }

      if (typeof node === 'number' ||
        typeof node === 'boolean' ||
        typeof node === 'function' ||
        node instanceof Date ||
        node instanceof RegExp) {
        node = node.toString()
      }

      if (typeof node === 'string') {
        if (el.lastChild && el.lastChild.nodeName === '#text') {
          el.lastChild.nodeValue += node
          continue
        }
        node = document.createTextNode(node)
      }

      if (node && node.nodeType) {
        el.appendChild(node)
      }
    }
  }
  appendChild(children)

  return el
}

module.exports = hyperx(belCreateElement, {comments: true})
module.exports.default = module.exports
module.exports.createElement = belCreateElement

},{"global/document":18,"hyperx":22,"on-load":31}],10:[function(require,module,exports){

},{}],11:[function(require,module,exports){
(function (global,Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"base64-js":8,"buffer":11,"ieee754":23,"isarray":26}],12:[function(require,module,exports){
module.exports = require('yo-yo')

},{"yo-yo":62}],13:[function(require,module,exports){
const history = require('sheet-router/history')
const sheetRouter = require('sheet-router')
const document = require('global/document')
const onReady = require('document-ready')
const href = require('sheet-router/href')
const hash = require('sheet-router/hash')
const hashMatch = require('hash-match')
const barracks = require('barracks')
const nanoraf = require('nanoraf')
const assert = require('assert')
const xtend = require('xtend')
const yo = require('yo-yo')

module.exports = choo

// framework for creating sturdy web applications
// null -> fn
function choo (opts) {
  opts = opts || {}

  const _store = start._store = barracks()
  var _router = start._router = null
  var _defaultRoute = null
  var _rootNode = null
  var _routes = null
  var _frame = null

  _store.use({ onStateChange: render })
  _store.use(opts)

  start.toString = toString
  start.router = router
  start.model = model
  start.start = start
  start.use = use

  return start

  // render the application to a string
  // (str, obj) -> str
  function toString (route, serverState) {
    serverState = serverState || {}
    assert.equal(typeof route, 'string', 'choo.app.toString: route must be a string')
    assert.equal(typeof serverState, 'object', 'choo.app.toString: serverState must be an object')
    _store.start({ subscriptions: false, reducers: false, effects: false })

    const state = _store.state({ state: serverState })
    const router = createRouter(_defaultRoute, _routes, createSend)
    const tree = router(route, state)
    return tree.outerHTML || tree.toString()

    function createSend () {
      return function send () {
        assert.ok(false, 'choo: send() cannot be called from Node')
      }
    }
  }

  // start the application
  // (str?, obj?) -> DOMNode
  function start (selector, startOpts) {
    if (!startOpts && typeof selector !== 'string') {
      startOpts = selector
      selector = null
    }
    startOpts = startOpts || {}

    _store.model(appInit(startOpts))
    const createSend = _store.start(startOpts)
    _router = start._router = createRouter(_defaultRoute, _routes, createSend)
    const state = _store.state({state: {}})

    if (!selector) {
      const tree = _router(state.location.pathname, state)
      _rootNode = tree
      return tree
    } else {
      onReady(function onReady () {
        const oldTree = document.querySelector(selector)
        assert.ok(oldTree, 'could not query selector: ' + selector)
        const newTree = _router(state.location.pathname, state)
        _rootNode = yo.update(oldTree, newTree)
      })
    }
  }

  // update the DOM after every state mutation
  // (obj, obj, obj, str, fn) -> null
  function render (data, state, prev, name, createSend) {
    if (!_frame) {
      _frame = nanoraf(function (state, prev) {
        const newTree = _router(state.location.pathname, state, prev)
        _rootNode = yo.update(_rootNode, newTree)
      })
    }
    _frame(state, prev)
  }

  // register all routes on the router
  // (str?, [fn|[fn]]) -> obj
  function router (defaultRoute, routes) {
    _defaultRoute = defaultRoute
    _routes = routes
  }

  // create a new model
  // (str?, obj) -> null
  function model (model) {
    _store.model(model)
  }

  // register a plugin
  // (obj) -> null
  function use (hooks) {
    assert.equal(typeof hooks, 'object', 'choo.use: hooks should be an object')
    _store.use(hooks)
  }

  // create a new router with a custom `createRoute()` function
  // (str?, obj, fn?) -> null
  function createRouter (defaultRoute, routes, createSend) {
    var prev = { params: {} }
    return sheetRouter(defaultRoute, routes, createRoute)

    function createRoute (routeFn) {
      return function (route, inline, child) {
        if (typeof inline === 'function') {
          inline = wrap(inline, route)
        }
        return routeFn(route, inline, child)
      }

      function wrap (child, route) {
        const send = createSend('view: ' + route, true)
        return function chooWrap (params, state) {
          const nwPrev = prev
          const nwState = prev = xtend(state, { params: params })
          if (opts.freeze !== false) Object.freeze(nwState)
          return child(nwState, nwPrev, send)
        }
      }
    }
  }
}

// initial application state model
// obj -> obj
function appInit (opts) {
  const loc = document.location
  const state = { pathname: (opts.hash) ? hashMatch(loc.hash) : loc.href }
  const reducers = {
    setLocation: function setLocation (data, state) {
      return { pathname: data.location.replace(/#.*/, '') }
    }
  }
  // if hash routing explicitly enabled, subscribe to it
  const subs = {}
  if (opts.hash === true) {
    pushLocationSub(function (navigate) {
      hash(function (fragment) {
        navigate(hashMatch(fragment))
      })
    }, 'handleHash', subs)
  } else {
    if (opts.history !== false) pushLocationSub(history, 'handleHistory', subs)
    if (opts.href !== false) pushLocationSub(href, 'handleHref', subs)
  }

  return {
    namespace: 'location',
    subscriptions: subs,
    reducers: reducers,
    state: state
  }

  // create a new subscription that modifies
  // 'app:location' and push it to be loaded
  // (fn, obj) -> null
  function pushLocationSub (cb, key, model) {
    model[key] = function (send, done) {
      cb(function navigate (pathname) {
        send('location:setLocation', { location: pathname }, done)
      })
    }
  }
}

},{"assert":2,"barracks":7,"document-ready":15,"global/document":18,"hash-match":20,"nanoraf":29,"sheet-router":53,"sheet-router/hash":50,"sheet-router/history":51,"sheet-router/href":52,"xtend":60,"yo-yo":62}],14:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('buffer').Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":11}],15:[function(require,module,exports){
'use strict'

var document = require('global/document')

module.exports = document.addEventListener ? ready : noop

function ready (callback) {
  var state = document.readyState
  if (state === 'complete' || state === 'interactive') {
    return setTimeout(callback, 0)
  }

  document.addEventListener('DOMContentLoaded', function onLoad () {
    callback()
  })
}

function noop () {}

},{"global/document":16}],16:[function(require,module,exports){
(function (global){(function (){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

var doccy;

if (typeof document !== 'undefined') {
    doccy = document;
} else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
}

module.exports = doccy;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"min-document":10}],17:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],18:[function(require,module,exports){
(function (global){(function (){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

var doccy;

if (typeof document !== 'undefined') {
    doccy = document;
} else {
    doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }
}

module.exports = doccy;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"min-document":10}],19:[function(require,module,exports){
(function (global){(function (){
var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
module.exports = function hashMatch (hash, prefix) {
  var pre = prefix || '/';
  if (hash.length === 0) return pre;
  hash = hash.replace('#', '');
  hash = hash.replace(/\/$/, '')
  if (hash.indexOf('/') != 0) hash = '/' + hash;
  if (pre == '/') return hash;
  else return hash.replace(pre, '');
}

},{}],21:[function(require,module,exports){
module.exports = attributeToProperty

var transform = {
  'class': 'className',
  'for': 'htmlFor',
  'http-equiv': 'httpEquiv'
}

function attributeToProperty (h) {
  return function (tagName, attrs, children) {
    for (var attr in attrs) {
      if (attr in transform) {
        attrs[transform[attr]] = attrs[attr]
        delete attrs[attr]
      }
    }
    return h(tagName, attrs, children)
  }
}

},{}],22:[function(require,module,exports){
var attrToProp = require('hyperscript-attribute-to-property')

var VAR = 0, TEXT = 1, OPEN = 2, CLOSE = 3, ATTR = 4
var ATTR_KEY = 5, ATTR_KEY_W = 6
var ATTR_VALUE_W = 7, ATTR_VALUE = 8
var ATTR_VALUE_SQ = 9, ATTR_VALUE_DQ = 10
var ATTR_EQ = 11, ATTR_BREAK = 12
var COMMENT = 13

module.exports = function (h, opts) {
  if (!opts) opts = {}
  var concat = opts.concat || function (a, b) {
    return String(a) + String(b)
  }
  if (opts.attrToProp !== false) {
    h = attrToProp(h)
  }

  return function (strings) {
    var state = TEXT, reg = ''
    var arglen = arguments.length
    var parts = []

    for (var i = 0; i < strings.length; i++) {
      if (i < arglen - 1) {
        var arg = arguments[i+1]
        var p = parse(strings[i])
        var xstate = state
        if (xstate === ATTR_VALUE_DQ) xstate = ATTR_VALUE
        if (xstate === ATTR_VALUE_SQ) xstate = ATTR_VALUE
        if (xstate === ATTR_VALUE_W) xstate = ATTR_VALUE
        if (xstate === ATTR) xstate = ATTR_KEY
        if (xstate === OPEN) {
          if (reg === '/') {
            p.push([ OPEN, '/', arg ])
            reg = ''
          } else {
            p.push([ OPEN, arg ])
          }
        } else if (xstate === COMMENT && opts.comments) {
          reg += String(arg)
        } else if (xstate !== COMMENT) {
          p.push([ VAR, xstate, arg ])
        }
        parts.push.apply(parts, p)
      } else parts.push.apply(parts, parse(strings[i]))
    }

    var tree = [null,{},[]]
    var stack = [[tree,-1]]
    for (var i = 0; i < parts.length; i++) {
      var cur = stack[stack.length-1][0]
      var p = parts[i], s = p[0]
      if (s === OPEN && /^\//.test(p[1])) {
        var ix = stack[stack.length-1][1]
        if (stack.length > 1) {
          stack.pop()
          stack[stack.length-1][0][2][ix] = h(
            cur[0], cur[1], cur[2].length ? cur[2] : undefined
          )
        }
      } else if (s === OPEN) {
        var c = [p[1],{},[]]
        cur[2].push(c)
        stack.push([c,cur[2].length-1])
      } else if (s === ATTR_KEY || (s === VAR && p[1] === ATTR_KEY)) {
        var key = ''
        var copyKey
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_KEY) {
            key = concat(key, parts[i][1])
          } else if (parts[i][0] === VAR && parts[i][1] === ATTR_KEY) {
            if (typeof parts[i][2] === 'object' && !key) {
              for (copyKey in parts[i][2]) {
                if (parts[i][2].hasOwnProperty(copyKey) && !cur[1][copyKey]) {
                  cur[1][copyKey] = parts[i][2][copyKey]
                }
              }
            } else {
              key = concat(key, parts[i][2])
            }
          } else break
        }
        if (parts[i][0] === ATTR_EQ) i++
        var j = i
        for (; i < parts.length; i++) {
          if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][1])
            else parts[i][1]==="" || (cur[1][key] = concat(cur[1][key], parts[i][1]));
          } else if (parts[i][0] === VAR
          && (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {
            if (!cur[1][key]) cur[1][key] = strfn(parts[i][2])
            else parts[i][2]==="" || (cur[1][key] = concat(cur[1][key], parts[i][2]));
          } else {
            if (key.length && !cur[1][key] && i === j
            && (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) {
              // https://html.spec.whatwg.org/multipage/infrastructure.html#boolean-attributes
              // empty string is falsy, not well behaved value in browser
              cur[1][key] = key.toLowerCase()
            }
            if (parts[i][0] === CLOSE) {
              i--
            }
            break
          }
        }
      } else if (s === ATTR_KEY) {
        cur[1][p[1]] = true
      } else if (s === VAR && p[1] === ATTR_KEY) {
        cur[1][p[2]] = true
      } else if (s === CLOSE) {
        if (selfClosing(cur[0]) && stack.length) {
          var ix = stack[stack.length-1][1]
          stack.pop()
          stack[stack.length-1][0][2][ix] = h(
            cur[0], cur[1], cur[2].length ? cur[2] : undefined
          )
        }
      } else if (s === VAR && p[1] === TEXT) {
        if (p[2] === undefined || p[2] === null) p[2] = ''
        else if (!p[2]) p[2] = concat('', p[2])
        if (Array.isArray(p[2][0])) {
          cur[2].push.apply(cur[2], p[2])
        } else {
          cur[2].push(p[2])
        }
      } else if (s === TEXT) {
        cur[2].push(p[1])
      } else if (s === ATTR_EQ || s === ATTR_BREAK) {
        // no-op
      } else {
        throw new Error('unhandled: ' + s)
      }
    }

    if (tree[2].length > 1 && /^\s*$/.test(tree[2][0])) {
      tree[2].shift()
    }

    if (tree[2].length > 2
    || (tree[2].length === 2 && /\S/.test(tree[2][1]))) {
      if (opts.createFragment) return opts.createFragment(tree[2])
      throw new Error(
        'multiple root elements must be wrapped in an enclosing tag'
      )
    }
    if (Array.isArray(tree[2][0]) && typeof tree[2][0][0] === 'string'
    && Array.isArray(tree[2][0][2])) {
      tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2])
    }
    return tree[2][0]

    function parse (str) {
      var res = []
      if (state === ATTR_VALUE_W) state = ATTR
      for (var i = 0; i < str.length; i++) {
        var c = str.charAt(i)
        if (state === TEXT && c === '<') {
          if (reg.length) res.push([TEXT, reg])
          reg = ''
          state = OPEN
        } else if (c === '>' && !quot(state) && state !== COMMENT) {
          if (state === OPEN && reg.length) {
            res.push([OPEN,reg])
          } else if (state === ATTR_KEY) {
            res.push([ATTR_KEY,reg])
          } else if (state === ATTR_VALUE && reg.length) {
            res.push([ATTR_VALUE,reg])
          }
          res.push([CLOSE])
          reg = ''
          state = TEXT
        } else if (state === COMMENT && /-$/.test(reg) && c === '-') {
          if (opts.comments) {
            res.push([ATTR_VALUE,reg.substr(0, reg.length - 1)])
          }
          reg = ''
          state = TEXT
        } else if (state === OPEN && /^!--$/.test(reg)) {
          if (opts.comments) {
            res.push([OPEN, reg],[ATTR_KEY,'comment'],[ATTR_EQ])
          }
          reg = c
          state = COMMENT
        } else if (state === TEXT || state === COMMENT) {
          reg += c
        } else if (state === OPEN && c === '/' && reg.length) {
          // no-op, self closing tag without a space <br/>
        } else if (state === OPEN && /\s/.test(c)) {
          if (reg.length) {
            res.push([OPEN, reg])
          }
          reg = ''
          state = ATTR
        } else if (state === OPEN) {
          reg += c
        } else if (state === ATTR && /[^\s"'=/]/.test(c)) {
          state = ATTR_KEY
          reg = c
        } else if (state === ATTR && /\s/.test(c)) {
          if (reg.length) res.push([ATTR_KEY,reg])
          res.push([ATTR_BREAK])
        } else if (state === ATTR_KEY && /\s/.test(c)) {
          res.push([ATTR_KEY,reg])
          reg = ''
          state = ATTR_KEY_W
        } else if (state === ATTR_KEY && c === '=') {
          res.push([ATTR_KEY,reg],[ATTR_EQ])
          reg = ''
          state = ATTR_VALUE_W
        } else if (state === ATTR_KEY) {
          reg += c
        } else if ((state === ATTR_KEY_W || state === ATTR) && c === '=') {
          res.push([ATTR_EQ])
          state = ATTR_VALUE_W
        } else if ((state === ATTR_KEY_W || state === ATTR) && !/\s/.test(c)) {
          res.push([ATTR_BREAK])
          if (/[\w-]/.test(c)) {
            reg += c
            state = ATTR_KEY
          } else state = ATTR
        } else if (state === ATTR_VALUE_W && c === '"') {
          state = ATTR_VALUE_DQ
        } else if (state === ATTR_VALUE_W && c === "'") {
          state = ATTR_VALUE_SQ
        } else if (state === ATTR_VALUE_DQ && c === '"') {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE_SQ && c === "'") {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE_W && !/\s/.test(c)) {
          state = ATTR_VALUE
          i--
        } else if (state === ATTR_VALUE && /\s/.test(c)) {
          res.push([ATTR_VALUE,reg],[ATTR_BREAK])
          reg = ''
          state = ATTR
        } else if (state === ATTR_VALUE || state === ATTR_VALUE_SQ
        || state === ATTR_VALUE_DQ) {
          reg += c
        }
      }
      if (state === TEXT && reg.length) {
        res.push([TEXT,reg])
        reg = ''
      } else if (state === ATTR_VALUE && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_VALUE_DQ && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_VALUE_SQ && reg.length) {
        res.push([ATTR_VALUE,reg])
        reg = ''
      } else if (state === ATTR_KEY) {
        res.push([ATTR_KEY,reg])
        reg = ''
      }
      return res
    }
  }

  function strfn (x) {
    if (typeof x === 'function') return x
    else if (typeof x === 'string') return x
    else if (x && typeof x === 'object') return x
    else if (x === null || x === undefined) return x
    else return concat('', x)
  }
}

function quot (state) {
  return state === ATTR_VALUE_SQ || state === ATTR_VALUE_DQ
}

var closeRE = RegExp('^(' + [
  'area', 'base', 'basefont', 'bgsound', 'br', 'col', 'command', 'embed',
  'frame', 'hr', 'img', 'input', 'isindex', 'keygen', 'link', 'meta', 'param',
  'source', 'track', 'wbr', '!--',
  // SVG TAGS
  'animate', 'animateTransform', 'circle', 'cursor', 'desc', 'ellipse',
  'feBlend', 'feColorMatrix', 'feComposite',
  'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap',
  'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR',
  'feGaussianBlur', 'feImage', 'feMergeNode', 'feMorphology',
  'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile',
  'feTurbulence', 'font-face-format', 'font-face-name', 'font-face-uri',
  'glyph', 'glyphRef', 'hkern', 'image', 'line', 'missing-glyph', 'mpath',
  'path', 'polygon', 'polyline', 'rect', 'set', 'stop', 'tref', 'use', 'view',
  'vkern'
].join('|') + ')(?:[\.#][a-zA-Z0-9\u007F-\uFFFF_:-]+)*$')
function selfClosing (tag) { return closeRE.test(tag) }

},{"hyperscript-attribute-to-property":21}],23:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],24:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],25:[function(require,module,exports){
var containers = []; // will store container HTMLElement references
var styleElements = []; // will store {prepend: HTMLElement, append: HTMLElement}

function insertCss(css, options) {
    options = options || {};

    var position = options.prepend === true ? 'prepend' : 'append';
    var container = options.container !== undefined ? options.container : document.querySelector('head');
    var containerId = containers.indexOf(container);

    // first time we see this container, create the necessary entries
    if (containerId === -1) {
        containerId = containers.push(container) - 1;
        styleElements[containerId] = {};
    }

    // try to get the correponding container + position styleElement, create it otherwise
    var styleElement;

    if (styleElements[containerId] !== undefined && styleElements[containerId][position] !== undefined) {
        styleElement = styleElements[containerId][position];
    } else {
        styleElement = styleElements[containerId][position] = createStyleElement();

        if (position === 'prepend') {
            container.insertBefore(styleElement, container.childNodes[0]);
        } else {
            container.appendChild(styleElement);
        }
    }

    // strip potential UTF-8 BOM if css was read from a file
    if (css.charCodeAt(0) === 0xFEFF) { css = css.substr(1, css.length); }

    // actually add the stylesheet
    if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText += css
    } else {
        styleElement.textContent += css;
    }

    return styleElement;
};

function createStyleElement() {
    var styleElement = document.createElement('style');
    styleElement.setAttribute('type', 'text/css');
    return styleElement;
}

module.exports = insertCss;
module.exports.insertCss = insertCss;

},{}],26:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],27:[function(require,module,exports){
'use strict';

var DOCUMENT_FRAGMENT_NODE = 11;

function morphAttrs(fromNode, toNode) {
    var toNodeAttrs = toNode.attributes;
    var attr;
    var attrName;
    var attrNamespaceURI;
    var attrValue;
    var fromValue;

    // document-fragments dont have attributes so lets not do anything
    if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return;
    }

    // update attributes on original DOM element
    for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
        attr = toNodeAttrs[i];
        attrName = attr.name;
        attrNamespaceURI = attr.namespaceURI;
        attrValue = attr.value;

        if (attrNamespaceURI) {
            attrName = attr.localName || attrName;
            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);

            if (fromValue !== attrValue) {
                if (attr.prefix === 'xmlns'){
                    attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix
                }
                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
            }
        } else {
            fromValue = fromNode.getAttribute(attrName);

            if (fromValue !== attrValue) {
                fromNode.setAttribute(attrName, attrValue);
            }
        }
    }

    // Remove any extra attributes found on the original DOM element that
    // weren't found on the target element.
    var fromNodeAttrs = fromNode.attributes;

    for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
        attr = fromNodeAttrs[d];
        attrName = attr.name;
        attrNamespaceURI = attr.namespaceURI;

        if (attrNamespaceURI) {
            attrName = attr.localName || attrName;

            if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
                fromNode.removeAttributeNS(attrNamespaceURI, attrName);
            }
        } else {
            if (!toNode.hasAttribute(attrName)) {
                fromNode.removeAttribute(attrName);
            }
        }
    }
}

var range; // Create a range object for efficently rendering strings to elements.
var NS_XHTML = 'http://www.w3.org/1999/xhtml';

var doc = typeof document === 'undefined' ? undefined : document;
var HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');
var HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();

function createFragmentFromTemplate(str) {
    var template = doc.createElement('template');
    template.innerHTML = str;
    return template.content.childNodes[0];
}

function createFragmentFromRange(str) {
    if (!range) {
        range = doc.createRange();
        range.selectNode(doc.body);
    }

    var fragment = range.createContextualFragment(str);
    return fragment.childNodes[0];
}

function createFragmentFromWrap(str) {
    var fragment = doc.createElement('body');
    fragment.innerHTML = str;
    return fragment.childNodes[0];
}

/**
 * This is about the same
 * var html = new DOMParser().parseFromString(str, 'text/html');
 * return html.body.firstChild;
 *
 * @method toElement
 * @param {String} str
 */
function toElement(str) {
    str = str.trim();
    if (HAS_TEMPLATE_SUPPORT) {
      // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which
      // createContextualFragment doesn't support
      // <template> support not available in IE
      return createFragmentFromTemplate(str);
    } else if (HAS_RANGE_SUPPORT) {
      return createFragmentFromRange(str);
    }

    return createFragmentFromWrap(str);
}

/**
 * Returns true if two node's names are the same.
 *
 * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same
 *       nodeName and different namespace URIs.
 *
 * @param {Element} a
 * @param {Element} b The target element
 * @return {boolean}
 */
function compareNodeNames(fromEl, toEl) {
    var fromNodeName = fromEl.nodeName;
    var toNodeName = toEl.nodeName;
    var fromCodeStart, toCodeStart;

    if (fromNodeName === toNodeName) {
        return true;
    }

    fromCodeStart = fromNodeName.charCodeAt(0);
    toCodeStart = toNodeName.charCodeAt(0);

    // If the target element is a virtual DOM node or SVG node then we may
    // need to normalize the tag name before comparing. Normal HTML elements that are
    // in the "http://www.w3.org/1999/xhtml"
    // are converted to upper case
    if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower
        return fromNodeName === toNodeName.toUpperCase();
    } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower
        return toNodeName === fromNodeName.toUpperCase();
    } else {
        return false;
    }
}

/**
 * Create an element, optionally with a known namespace URI.
 *
 * @param {string} name the element name, e.g. 'div' or 'svg'
 * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of
 * its `xmlns` attribute or its inferred namespace.
 *
 * @return {Element}
 */
function createElementNS(name, namespaceURI) {
    return !namespaceURI || namespaceURI === NS_XHTML ?
        doc.createElement(name) :
        doc.createElementNS(namespaceURI, name);
}

/**
 * Copies the children of one DOM element to another DOM element
 */
function moveChildren(fromEl, toEl) {
    var curChild = fromEl.firstChild;
    while (curChild) {
        var nextChild = curChild.nextSibling;
        toEl.appendChild(curChild);
        curChild = nextChild;
    }
    return toEl;
}

function syncBooleanAttrProp(fromEl, toEl, name) {
    if (fromEl[name] !== toEl[name]) {
        fromEl[name] = toEl[name];
        if (fromEl[name]) {
            fromEl.setAttribute(name, '');
        } else {
            fromEl.removeAttribute(name);
        }
    }
}

var specialElHandlers = {
    OPTION: function(fromEl, toEl) {
        var parentNode = fromEl.parentNode;
        if (parentNode) {
            var parentName = parentNode.nodeName.toUpperCase();
            if (parentName === 'OPTGROUP') {
                parentNode = parentNode.parentNode;
                parentName = parentNode && parentNode.nodeName.toUpperCase();
            }
            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {
                if (fromEl.hasAttribute('selected') && !toEl.selected) {
                    // Workaround for MS Edge bug where the 'selected' attribute can only be
                    // removed if set to a non-empty value:
                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/
                    fromEl.setAttribute('selected', 'selected');
                    fromEl.removeAttribute('selected');
                }
                // We have to reset select element's selectedIndex to -1, otherwise setting
                // fromEl.selected using the syncBooleanAttrProp below has no effect.
                // The correct selectedIndex will be set in the SELECT special handler below.
                parentNode.selectedIndex = -1;
            }
        }
        syncBooleanAttrProp(fromEl, toEl, 'selected');
    },
    /**
     * The "value" attribute is special for the <input> element since it sets
     * the initial value. Changing the "value" attribute without changing the
     * "value" property will have no effect since it is only used to the set the
     * initial value.  Similar for the "checked" attribute, and "disabled".
     */
    INPUT: function(fromEl, toEl) {
        syncBooleanAttrProp(fromEl, toEl, 'checked');
        syncBooleanAttrProp(fromEl, toEl, 'disabled');

        if (fromEl.value !== toEl.value) {
            fromEl.value = toEl.value;
        }

        if (!toEl.hasAttribute('value')) {
            fromEl.removeAttribute('value');
        }
    },

    TEXTAREA: function(fromEl, toEl) {
        var newValue = toEl.value;
        if (fromEl.value !== newValue) {
            fromEl.value = newValue;
        }

        var firstChild = fromEl.firstChild;
        if (firstChild) {
            // Needed for IE. Apparently IE sets the placeholder as the
            // node value and vise versa. This ignores an empty update.
            var oldValue = firstChild.nodeValue;

            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {
                return;
            }

            firstChild.nodeValue = newValue;
        }
    },
    SELECT: function(fromEl, toEl) {
        if (!toEl.hasAttribute('multiple')) {
            var selectedIndex = -1;
            var i = 0;
            // We have to loop through children of fromEl, not toEl since nodes can be moved
            // from toEl to fromEl directly when morphing.
            // At the time this special handler is invoked, all children have already been morphed
            // and appended to / removed from fromEl, so using fromEl here is safe and correct.
            var curChild = fromEl.firstChild;
            var optgroup;
            var nodeName;
            while(curChild) {
                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
                if (nodeName === 'OPTGROUP') {
                    optgroup = curChild;
                    curChild = optgroup.firstChild;
                } else {
                    if (nodeName === 'OPTION') {
                        if (curChild.hasAttribute('selected')) {
                            selectedIndex = i;
                            break;
                        }
                        i++;
                    }
                    curChild = curChild.nextSibling;
                    if (!curChild && optgroup) {
                        curChild = optgroup.nextSibling;
                        optgroup = null;
                    }
                }
            }

            fromEl.selectedIndex = selectedIndex;
        }
    }
};

var ELEMENT_NODE = 1;
var DOCUMENT_FRAGMENT_NODE$1 = 11;
var TEXT_NODE = 3;
var COMMENT_NODE = 8;

function noop() {}

function defaultGetNodeKey(node) {
  if (node) {
      return (node.getAttribute && node.getAttribute('id')) || node.id;
  }
}

function morphdomFactory(morphAttrs) {

    return function morphdom(fromNode, toNode, options) {
        if (!options) {
            options = {};
        }

        if (typeof toNode === 'string') {
            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {
                var toNodeHtml = toNode;
                toNode = doc.createElement('html');
                toNode.innerHTML = toNodeHtml;
            } else {
                toNode = toElement(toNode);
            }
        }

        var getNodeKey = options.getNodeKey || defaultGetNodeKey;
        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
        var onNodeAdded = options.onNodeAdded || noop;
        var onBeforeElUpdated = options.onBeforeElUpdated || noop;
        var onElUpdated = options.onElUpdated || noop;
        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
        var onNodeDiscarded = options.onNodeDiscarded || noop;
        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
        var childrenOnly = options.childrenOnly === true;

        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.
        var fromNodesLookup = Object.create(null);
        var keyedRemovalList = [];

        function addKeyedRemoval(key) {
            keyedRemovalList.push(key);
        }

        function walkDiscardedChildNodes(node, skipKeyedNodes) {
            if (node.nodeType === ELEMENT_NODE) {
                var curChild = node.firstChild;
                while (curChild) {

                    var key = undefined;

                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {
                        // If we are skipping keyed nodes then we add the key
                        // to a list so that it can be handled at the very end.
                        addKeyedRemoval(key);
                    } else {
                        // Only report the node as discarded if it is not keyed. We do this because
                        // at the end we loop through all keyed elements that were unmatched
                        // and then discard them in one final pass.
                        onNodeDiscarded(curChild);
                        if (curChild.firstChild) {
                            walkDiscardedChildNodes(curChild, skipKeyedNodes);
                        }
                    }

                    curChild = curChild.nextSibling;
                }
            }
        }

        /**
         * Removes a DOM node out of the original DOM
         *
         * @param  {Node} node The node to remove
         * @param  {Node} parentNode The nodes parent
         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.
         * @return {undefined}
         */
        function removeNode(node, parentNode, skipKeyedNodes) {
            if (onBeforeNodeDiscarded(node) === false) {
                return;
            }

            if (parentNode) {
                parentNode.removeChild(node);
            }

            onNodeDiscarded(node);
            walkDiscardedChildNodes(node, skipKeyedNodes);
        }

        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future
        // function indexTree(root) {
        //     var treeWalker = document.createTreeWalker(
        //         root,
        //         NodeFilter.SHOW_ELEMENT);
        //
        //     var el;
        //     while((el = treeWalker.nextNode())) {
        //         var key = getNodeKey(el);
        //         if (key) {
        //             fromNodesLookup[key] = el;
        //         }
        //     }
        // }

        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future
        //
        // function indexTree(node) {
        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);
        //     var el;
        //     while((el = nodeIterator.nextNode())) {
        //         var key = getNodeKey(el);
        //         if (key) {
        //             fromNodesLookup[key] = el;
        //         }
        //     }
        // }

        function indexTree(node) {
            if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
                var curChild = node.firstChild;
                while (curChild) {
                    var key = getNodeKey(curChild);
                    if (key) {
                        fromNodesLookup[key] = curChild;
                    }

                    // Walk recursively
                    indexTree(curChild);

                    curChild = curChild.nextSibling;
                }
            }
        }

        indexTree(fromNode);

        function handleNodeAdded(el) {
            onNodeAdded(el);

            var curChild = el.firstChild;
            while (curChild) {
                var nextSibling = curChild.nextSibling;

                var key = getNodeKey(curChild);
                if (key) {
                    var unmatchedFromEl = fromNodesLookup[key];
                    // if we find a duplicate #id node in cache, replace `el` with cache value
                    // and morph it to the child node.
                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
                        morphEl(unmatchedFromEl, curChild);
                    } else {
                      handleNodeAdded(curChild);
                    }
                } else {
                  // recursively call for curChild and it's children to see if we find something in
                  // fromNodesLookup
                  handleNodeAdded(curChild);
                }

                curChild = nextSibling;
            }
        }

        function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
            // We have processed all of the "to nodes". If curFromNodeChild is
            // non-null then we still have some from nodes left over that need
            // to be removed
            while (curFromNodeChild) {
                var fromNextSibling = curFromNodeChild.nextSibling;
                if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {
                    // Since the node is keyed it might be matched up later so we defer
                    // the actual removal to later
                    addKeyedRemoval(curFromNodeKey);
                } else {
                    // NOTE: we skip nested keyed nodes from being removed since there is
                    //       still a chance they will be matched up later
                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                }
                curFromNodeChild = fromNextSibling;
            }
        }

        function morphEl(fromEl, toEl, childrenOnly) {
            var toElKey = getNodeKey(toEl);

            if (toElKey) {
                // If an element with an ID is being morphed then it will be in the final
                // DOM so clear it out of the saved elements collection
                delete fromNodesLookup[toElKey];
            }

            if (!childrenOnly) {
                // optional
                if (onBeforeElUpdated(fromEl, toEl) === false) {
                    return;
                }

                // update attributes on original DOM element first
                morphAttrs(fromEl, toEl);
                // optional
                onElUpdated(fromEl);

                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
                    return;
                }
            }

            if (fromEl.nodeName !== 'TEXTAREA') {
              morphChildren(fromEl, toEl);
            } else {
              specialElHandlers.TEXTAREA(fromEl, toEl);
            }
        }

        function morphChildren(fromEl, toEl) {
            var curToNodeChild = toEl.firstChild;
            var curFromNodeChild = fromEl.firstChild;
            var curToNodeKey;
            var curFromNodeKey;

            var fromNextSibling;
            var toNextSibling;
            var matchingFromEl;

            // walk the children
            outer: while (curToNodeChild) {
                toNextSibling = curToNodeChild.nextSibling;
                curToNodeKey = getNodeKey(curToNodeChild);

                // walk the fromNode children all the way through
                while (curFromNodeChild) {
                    fromNextSibling = curFromNodeChild.nextSibling;

                    if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                        curToNodeChild = toNextSibling;
                        curFromNodeChild = fromNextSibling;
                        continue outer;
                    }

                    curFromNodeKey = getNodeKey(curFromNodeChild);

                    var curFromNodeType = curFromNodeChild.nodeType;

                    // this means if the curFromNodeChild doesnt have a match with the curToNodeChild
                    var isCompatible = undefined;

                    if (curFromNodeType === curToNodeChild.nodeType) {
                        if (curFromNodeType === ELEMENT_NODE) {
                            // Both nodes being compared are Element nodes

                            if (curToNodeKey) {
                                // The target node has a key so we want to match it up with the correct element
                                // in the original DOM tree
                                if (curToNodeKey !== curFromNodeKey) {
                                    // The current element in the original DOM tree does not have a matching key so
                                    // let's check our lookup to see if there is a matching element in the original
                                    // DOM tree
                                    if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {
                                        if (fromNextSibling === matchingFromEl) {
                                            // Special case for single element removals. To avoid removing the original
                                            // DOM node out of the tree (since that can break CSS transitions, etc.),
                                            // we will instead discard the current node and wait until the next
                                            // iteration to properly match up the keyed target element with its matching
                                            // element in the original tree
                                            isCompatible = false;
                                        } else {
                                            // We found a matching keyed element somewhere in the original DOM tree.
                                            // Let's move the original DOM node into the current position and morph
                                            // it.

                                            // NOTE: We use insertBefore instead of replaceChild because we want to go through
                                            // the `removeNode()` function for the node that is being discarded so that
                                            // all lifecycle hooks are correctly invoked
                                            fromEl.insertBefore(matchingFromEl, curFromNodeChild);

                                            // fromNextSibling = curFromNodeChild.nextSibling;

                                            if (curFromNodeKey) {
                                                // Since the node is keyed it might be matched up later so we defer
                                                // the actual removal to later
                                                addKeyedRemoval(curFromNodeKey);
                                            } else {
                                                // NOTE: we skip nested keyed nodes from being removed since there is
                                                //       still a chance they will be matched up later
                                                removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                                            }

                                            curFromNodeChild = matchingFromEl;
                                        }
                                    } else {
                                        // The nodes are not compatible since the "to" node has a key and there
                                        // is no matching keyed node in the source tree
                                        isCompatible = false;
                                    }
                                }
                            } else if (curFromNodeKey) {
                                // The original has a key
                                isCompatible = false;
                            }

                            isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                            if (isCompatible) {
                                // We found compatible DOM elements so transform
                                // the current "from" node to match the current
                                // target DOM node.
                                // MORPH
                                morphEl(curFromNodeChild, curToNodeChild);
                            }

                        } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                            // Both nodes being compared are Text or Comment nodes
                            isCompatible = true;
                            // Simply update nodeValue on the original node to
                            // change the text value
                            if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                                curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                            }

                        }
                    }

                    if (isCompatible) {
                        // Advance both the "to" child and the "from" child since we found a match
                        // Nothing else to do as we already recursively called morphChildren above
                        curToNodeChild = toNextSibling;
                        curFromNodeChild = fromNextSibling;
                        continue outer;
                    }

                    // No compatible match so remove the old node from the DOM and continue trying to find a
                    // match in the original DOM. However, we only do this if the from node is not keyed
                    // since it is possible that a keyed node might match up with a node somewhere else in the
                    // target tree and we don't want to discard it just yet since it still might find a
                    // home in the final DOM tree. After everything is done we will remove any keyed nodes
                    // that didn't find a home
                    if (curFromNodeKey) {
                        // Since the node is keyed it might be matched up later so we defer
                        // the actual removal to later
                        addKeyedRemoval(curFromNodeKey);
                    } else {
                        // NOTE: we skip nested keyed nodes from being removed since there is
                        //       still a chance they will be matched up later
                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                    }

                    curFromNodeChild = fromNextSibling;
                } // END: while(curFromNodeChild) {}

                // If we got this far then we did not find a candidate match for
                // our "to node" and we exhausted all of the children "from"
                // nodes. Therefore, we will just append the current "to" node
                // to the end
                if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
                    fromEl.appendChild(matchingFromEl);
                    // MORPH
                    morphEl(matchingFromEl, curToNodeChild);
                } else {
                    var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
                    if (onBeforeNodeAddedResult !== false) {
                        if (onBeforeNodeAddedResult) {
                            curToNodeChild = onBeforeNodeAddedResult;
                        }

                        if (curToNodeChild.actualize) {
                            curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                        }
                        fromEl.appendChild(curToNodeChild);
                        handleNodeAdded(curToNodeChild);
                    }
                }

                curToNodeChild = toNextSibling;
                curFromNodeChild = fromNextSibling;
            }

            cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);

            var specialElHandler = specialElHandlers[fromEl.nodeName];
            if (specialElHandler) {
                specialElHandler(fromEl, toEl);
            }
        } // END: morphChildren(...)

        var morphedNode = fromNode;
        var morphedNodeType = morphedNode.nodeType;
        var toNodeType = toNode.nodeType;

        if (!childrenOnly) {
            // Handle the case where we are given two DOM nodes that are not
            // compatible (e.g. <div> --> <span> or <div> --> TEXT)
            if (morphedNodeType === ELEMENT_NODE) {
                if (toNodeType === ELEMENT_NODE) {
                    if (!compareNodeNames(fromNode, toNode)) {
                        onNodeDiscarded(fromNode);
                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
                    }
                } else {
                    // Going from an element node to a text node
                    morphedNode = toNode;
                }
            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node
                if (toNodeType === morphedNodeType) {
                    if (morphedNode.nodeValue !== toNode.nodeValue) {
                        morphedNode.nodeValue = toNode.nodeValue;
                    }

                    return morphedNode;
                } else {
                    // Text node to something else
                    morphedNode = toNode;
                }
            }
        }

        if (morphedNode === toNode) {
            // The "to node" was not compatible with the "from node" so we had to
            // toss out the "from node" and use the "to node"
            onNodeDiscarded(fromNode);
        } else {
            if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
                return;
            }

            morphEl(morphedNode, toNode, childrenOnly);

            // We now need to loop over any keyed nodes that might need to be
            // removed. We only do the removal if we know that the keyed node
            // never found a match. When a keyed node is matched up we remove
            // it out of fromNodesLookup and we use fromNodesLookup to determine
            // if a keyed node has been matched up or not
            if (keyedRemovalList) {
                for (var i=0, len=keyedRemovalList.length; i<len; i++) {
                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];
                    if (elToRemove) {
                        removeNode(elToRemove, elToRemove.parentNode, false);
                    }
                }
            }
        }

        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
            if (morphedNode.actualize) {
                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
            }
            // If we had to swap out the from node with a new node because the old
            // node was not compatible with the target node then we need to
            // replace the old DOM node in the original DOM tree. This is only
            // possible if the original DOM node was part of a DOM tree which
            // we know is the case if it has a parent node.
            fromNode.parentNode.replaceChild(morphedNode, fromNode);
        }

        return morphedNode;
    };
}

var morphdom = morphdomFactory(morphAttrs);

module.exports = morphdom;

},{}],28:[function(require,module,exports){
assert.notEqual = notEqual
assert.notOk = notOk
assert.equal = equal
assert.ok = assert

module.exports = assert

function equal (a, b, m) {
  assert(a == b, m) // eslint-disable-line eqeqeq
}

function notEqual (a, b, m) {
  assert(a != b, m) // eslint-disable-line eqeqeq
}

function notOk (t, m) {
  assert(!t, m)
}

function assert (t, m) {
  if (!t) throw new Error(m || 'AssertionError')
}

},{}],29:[function(require,module,exports){
var window = require('global/window')
var assert = require('assert')

module.exports = nanoraf

// Only call RAF when needed
// (fn, fn?) -> fn
function nanoraf (render, raf) {
  assert.equal(typeof render, 'function', 'nanoraf: render should be a function')
  assert.ok(typeof raf === 'function' || typeof raf === 'undefined', 'nanoraf: raf should be a function or undefined')

  raf = raf || window.requestAnimationFrame

  var inRenderingTransaction = false
  var redrawScheduled = false
  var currentState = null

  // pass new state to be rendered
  // (obj, obj?) -> null
  return function frame (state, prev) {
    assert.equal(typeof state, 'object', 'nanoraf: state should be an object')
    assert.equal(typeof prev, 'object', 'nanoraf: prev should be an object')
    assert.equal(inRenderingTransaction, false, 'nanoraf: new frame was created before previous frame finished')

    // request a redraw for next frame
    if (currentState === null && !redrawScheduled) {
      redrawScheduled = true

      raf(function redraw () {
        redrawScheduled = false
        if (!currentState) return

        inRenderingTransaction = true
        render(currentState, prev)
        inRenderingTransaction = false

        currentState = null
      })
    }

    // update data for redraw
    currentState = state
  }
}

},{"assert":2,"global/window":19}],30:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],31:[function(require,module,exports){
/* global MutationObserver */
var document = require('global/document')
var window = require('global/window')
var assert = require('assert')
var watch = Object.create(null)
var KEY_ID = 'onloadid' + (new Date() % 9e6).toString(36)
var KEY_ATTR = 'data-' + KEY_ID
var INDEX = 0

if (window && window.MutationObserver) {
  var observer = new MutationObserver(function (mutations) {
    if (Object.keys(watch).length < 1) return
    for (var i = 0; i < mutations.length; i++) {
      if (mutations[i].attributeName === KEY_ATTR) {
        eachAttr(mutations[i], turnon, turnoff)
        continue
      }
      eachMutation(mutations[i].removedNodes, turnoff)
      eachMutation(mutations[i].addedNodes, turnon)
    }
  })
  if (document.body) {
    beginObserve(observer)
  } else {
    document.addEventListener('DOMContentLoaded', function (event) {
      beginObserve(observer)
    })
  }
}

function beginObserve (observer) {
  observer.observe(document.documentElement, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeOldValue: true,
    attributeFilter: [KEY_ATTR]
  })
}

module.exports = function onload (el, on, off, caller) {
  assert(document.body, 'on-load: will not work prior to DOMContentLoaded')
  on = on || function () {}
  off = off || function () {}
  el.setAttribute(KEY_ATTR, 'o' + INDEX)
  watch['o' + INDEX] = [on, off, 0, caller || onload.caller]
  INDEX += 1
  return el
}

module.exports.KEY_ATTR = KEY_ATTR
module.exports.KEY_ID = KEY_ID

function turnon (index, el) {
  if (watch[index][0] && watch[index][2] === 0) {
    watch[index][0](el)
    watch[index][2] = 1
  }
}

function turnoff (index, el) {
  if (watch[index][1] && watch[index][2] === 1) {
    watch[index][1](el)
    watch[index][2] = 0
  }
}

function eachAttr (mutation, on, off) {
  var newValue = mutation.target.getAttribute(KEY_ATTR)
  if (sameOrigin(mutation.oldValue, newValue)) {
    watch[newValue] = watch[mutation.oldValue]
    return
  }
  if (watch[mutation.oldValue]) {
    off(mutation.oldValue, mutation.target)
  }
  if (watch[newValue]) {
    on(newValue, mutation.target)
  }
}

function sameOrigin (oldValue, newValue) {
  if (!oldValue || !newValue) return false
  return watch[oldValue][3] === watch[newValue][3]
}

function eachMutation (nodes, fn) {
  var keys = Object.keys(watch)
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i] && nodes[i].getAttribute && nodes[i].getAttribute(KEY_ATTR)) {
      var onloadid = nodes[i].getAttribute(KEY_ATTR)
      keys.forEach(function (k) {
        if (onloadid === k) {
          fn(k, nodes[i])
        }
      })
    }
    if (nodes[i].childNodes.length > 0) {
      eachMutation(nodes[i].childNodes, fn)
    }
  }
}

},{"assert":28,"global/document":18,"global/window":19}],32:[function(require,module,exports){
const assert = require('assert')

module.exports = match

// get url path section from a url
// strip querystrings / hashes
// strip protocol
// strip hostname and port (both ip and route)
// str -> str
function match (route) {
  assert.equal(typeof route, 'string')

  return route.trim()
    .replace(/[\?|#].*$/, '')
    .replace(/^(?:https?\:)\/\//, '')
    .replace(/^.*?(\/.*)/, '$1')
    .replace(/\/$/, '')
}

},{"assert":2}],33:[function(require,module,exports){
(function (process){(function (){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this)}).call(this,require('_process'))

},{"_process":34}],34:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],35:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":36}],36:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":38,"./_stream_writable":40,"core-util-is":14,"inherits":24,"process-nextick-args":33}],37:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":39,"core-util-is":14,"inherits":24}],38:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":36,"./internal/streams/BufferList":41,"./internal/streams/destroy":42,"./internal/streams/stream":43,"_process":34,"core-util-is":14,"events":17,"inherits":24,"isarray":26,"process-nextick-args":33,"safe-buffer":44,"string_decoder/":45,"util":10}],39:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":36,"core-util-is":14,"inherits":24}],40:[function(require,module,exports){
(function (process,global,setImmediate){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"./_stream_duplex":36,"./internal/streams/destroy":42,"./internal/streams/stream":43,"_process":34,"core-util-is":14,"inherits":24,"process-nextick-args":33,"safe-buffer":44,"timers":56,"util-deprecate":57}],41:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":44,"util":10}],42:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":33}],43:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":17}],44:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":11}],45:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":44}],46:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":47}],47:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":36,"./lib/_stream_passthrough.js":37,"./lib/_stream_readable.js":38,"./lib/_stream_transform.js":39,"./lib/_stream_writable.js":40}],48:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":47}],49:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":40}],50:[function(require,module,exports){
const window = require('global/window')
const assert = require('assert')

module.exports = hash

// listen to window hashchange events
// and update router accordingly
// fn(cb) -> null
function hash (cb) {
  assert.equal(typeof cb, 'function', 'cb must be a function')
  window.onhashchange = function (e) {
    cb(window.location.hash)
  }
}

},{"assert":2,"global/window":19}],51:[function(require,module,exports){
const document = require('global/document')
const window = require('global/window')
const assert = require('assert')

module.exports = history

// listen to html5 pushstate events
// and update router accordingly
// fn(str) -> null
function history (cb) {
  assert.equal(typeof cb, 'function', 'cb must be a function')
  window.onpopstate = function () {
    cb(document.location.href)
  }
}

},{"assert":2,"global/document":18,"global/window":19}],52:[function(require,module,exports){
const window = require('global/window')
const assert = require('assert')

module.exports = href

// handle a click if is anchor tag with an href
// and url lives on the same domain. Replaces
// trailing '#' so empty links work as expected.
// fn(str) -> null
function href (cb) {
  assert.equal(typeof cb, 'function', 'cb must be a function')

  window.onclick = function (e) {
    const node = (function traverse (node) {
      if (!node) return
      if (node.localName !== 'a') return traverse(node.parentNode)
      if (node.href === undefined) return traverse(node.parentNode)
      if (window.location.host !== node.host) return traverse(node.parentNode)
      return node
    })(e.target)

    if (!node) return

    e.preventDefault()
    const href = node.href.replace(/#$/, '')
    cb(href)
    window.history.pushState({}, null, href)
  }
}

},{"assert":2,"global/window":19}],53:[function(require,module,exports){
const pathname = require('pathname-match')
const wayfarer = require('wayfarer')
const assert = require('assert')

module.exports = sheetRouter

// Fast, modular client router
// fn(str, any[..], fn?) -> fn(str, any[..])
function sheetRouter (dft, createTree, createRoute) {
  createRoute = (createRoute ? createRoute(_createRoute) : _createRoute)

  if (!createTree) {
    createTree = dft
    dft = ''
  }

  assert.equal(typeof dft, 'string', 'sheet-router: dft must be a string')
  assert.equal(typeof createTree, 'function', 'sheet-router: createTree must be a function')
  assert.equal(typeof createRoute, 'function', 'sheet-router: createRoute must be a function')

  const router = wayfarer(dft)
  const tree = createTree(createRoute)

  // register tree in router
  ;(function walk (tree, route) {
    if (Array.isArray(tree[0])) {
      // walk over all routes at the root of the tree
      tree.forEach(function (node) {
        walk(node, route)
      })
    } else if (tree[1]) {
      // handle inline functions as args
      const innerRoute = tree[0]
        ? route.concat(tree[0]).join('/')
        : route.length ? route.join('/') : tree[0]
      router.on(innerRoute, tree[1])
      walk(tree[2], route.concat(tree[0]))
    } else if (Array.isArray(tree[2])) {
      // traverse and append route
      walk(tree[2], route.concat(tree[0]))
    } else {
      // register path in router
      const nwRoute = tree[0]
        ? route.concat(tree[0]).join('/')
        : route.length ? route.join('/') : tree[0]
      router.on(nwRoute, tree[2])
    }
  })(tree, [])

  // match a route on the router
  return function match (route) {
    assert.equal(typeof route, 'string', 'route must be a string')
    const args = [].slice.call(arguments)
    args[0] = pathname(args[0])
    return router.apply(null, args)
  }
}

// register regular route
function _createRoute (route, inline, child) {
  if (!child) {
    child = inline
    inline = null
  }
  assert.equal(typeof route, 'string', 'route must be a string')
  assert.ok(child, 'child exists')
  route = route.replace(/^\//, '')
  return [ route, inline, child ]
}

},{"assert":2,"pathname-match":32,"wayfarer":58}],54:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":17,"inherits":24,"readable-stream/duplex.js":35,"readable-stream/passthrough.js":46,"readable-stream/readable.js":47,"readable-stream/transform.js":48,"readable-stream/writable.js":49}],55:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":11}],56:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":34,"timers":56}],57:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],58:[function(require,module,exports){
var assert = require('assert')
var trie = require('./trie')

module.exports = Wayfarer

// create a router
// str -> obj
function Wayfarer (dft) {
  if (!(this instanceof Wayfarer)) return new Wayfarer(dft)

  var _default = (dft || '').replace(/^\//, '')
  var _trie = trie()

  emit._trie = _trie
  emit.on = on
  emit.emit = emit
  emit.match = match
  emit._wayfarer = true

  return emit

  // define a route
  // (str, fn) -> obj
  function on (route, fn) {
    assert.equal(typeof route, 'string')
    assert.equal(typeof fn, 'function')

    var cb = fn._wayfarer && fn._trie ? fn : proxy
    route = route || '/'
    cb.route = route

    if (cb._wayfarer && cb._trie) {
      _trie.mount(route, cb._trie.trie)
    } else {
      var node = _trie.create(route)
      node.cb = cb
    }

    return emit

    function proxy () {
      return fn.apply(this, Array.prototype.slice.call(arguments))
    }
  }

  // match and call a route
  // (str, obj?) -> null
  function emit (route) {
    var matched = match(route)

    var args = new Array(arguments.length)
    args[0] = matched.params
    for (var i = 1; i < args.length; i++) {
      args[i] = arguments[i]
    }

    return matched.cb.apply(matched.cb, args)
  }

  function match (route) {
    assert.notEqual(route, undefined, "'route' must be defined")

    var matched = _trie.match(route)
    if (matched && matched.cb) return new Route(matched)

    var dft = _trie.match(_default)
    if (dft && dft.cb) return new Route(dft)

    throw new Error("route '" + route + "' did not match")
  }

  function Route (matched) {
    this.cb = matched.cb
    this.route = matched.cb.route
    this.params = matched.params
  }
}

},{"./trie":59,"assert":2}],59:[function(require,module,exports){
var mutate = require('xtend/mutable')
var assert = require('assert')
var xtend = require('xtend')

module.exports = Trie

// create a new trie
// null -> obj
function Trie () {
  if (!(this instanceof Trie)) return new Trie()
  this.trie = { nodes: {} }
}

// create a node on the trie at route
// and return a node
// str -> null
Trie.prototype.create = function (route) {
  assert.equal(typeof route, 'string', 'route should be a string')
  // strip leading '/' and split routes
  var routes = route.replace(/^\//, '').split('/')

  function createNode (index, trie) {
    var thisRoute = (routes.hasOwnProperty(index) && routes[index])
    if (thisRoute === false) return trie

    var node = null
    if (/^:|^\*/.test(thisRoute)) {
      // if node is a name match, set name and append to ':' node
      if (!trie.nodes.hasOwnProperty('$$')) {
        node = { nodes: {} }
        trie.nodes['$$'] = node
      } else {
        node = trie.nodes['$$']
      }

      if (thisRoute[0] === '*') {
        trie.wildcard = true
      }

      trie.name = thisRoute.replace(/^:|^\*/, '')
    } else if (!trie.nodes.hasOwnProperty(thisRoute)) {
      node = { nodes: {} }
      trie.nodes[thisRoute] = node
    } else {
      node = trie.nodes[thisRoute]
    }

    // we must recurse deeper
    return createNode(index + 1, node)
  }

  return createNode(0, this.trie)
}

// match a route on the trie
// and return the node
// str -> obj
Trie.prototype.match = function (route) {
  assert.equal(typeof route, 'string', 'route should be a string')

  var routes = route.replace(/^\//, '').split('/')
  var params = {}

  function search (index, trie) {
    // either there's no match, or we're done searching
    if (trie === undefined) return undefined
    var thisRoute = routes[index]
    if (thisRoute === undefined) return trie

    if (trie.nodes.hasOwnProperty(thisRoute)) {
      // match regular routes first
      return search(index + 1, trie.nodes[thisRoute])
    } else if (trie.name) {
      // match named routes
      try {
        params[trie.name] = decodeURIComponent(thisRoute)
      } catch (e) {
        return search(index, undefined)
      }
      return search(index + 1, trie.nodes['$$'])
    } else if (trie.wildcard) {
      // match wildcards
      try {
        params['wildcard'] = decodeURIComponent(routes.slice(index).join('/'))
      } catch (e) {
        return search(index, undefined)
      }
      // return early, or else search may keep recursing through the wildcard
      return trie.nodes['$$']
    } else {
      // no matches found
      return search(index + 1)
    }
  }

  var node = search(0, this.trie)

  if (!node) return undefined
  node = xtend(node)
  node.params = params
  return node
}

// mount a trie onto a node at route
// (str, obj) -> null
Trie.prototype.mount = function (route, trie) {
  assert.equal(typeof route, 'string', 'route should be a string')
  assert.equal(typeof trie, 'object', 'trie should be a object')

  var split = route.replace(/^\//, '').split('/')
  var node = null
  var key = null

  if (split.length === 1) {
    key = split[0]
    node = this.create(key)
  } else {
    var head = split.join('/')
    key = split[0]
    node = this.create(head)
  }

  mutate(node.nodes, trie.nodes)
  if (trie.name) node.name = trie.name

  // delegate properties from '/' to the new node
  // '/' cannot be reached once mounted
  if (node.nodes['']) {
    Object.keys(node.nodes['']).forEach(function (key) {
      if (key === 'nodes') return
      node[key] = node.nodes[''][key]
    })
    mutate(node.nodes, node.nodes[''].nodes)
    delete node.nodes[''].nodes
  }
}

},{"assert":2,"xtend":60,"xtend/mutable":61}],60:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],61:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],62:[function(require,module,exports){
var bel = require('bel') // turns template tag into DOM elements
var morphdom = require('morphdom') // efficiently diffs + morphs two DOM elements
var defaultEvents = require('./update-events.js') // default events to be copied when dom elements update

module.exports = bel

// TODO move this + defaultEvents to a new module once we receive more feedback
module.exports.update = function (fromNode, toNode, opts) {
  if (!opts) opts = {}
  if (opts.events !== false) {
    if (!opts.onBeforeElUpdated) opts.onBeforeElUpdated = copier
  }

  return morphdom(fromNode, toNode, opts)

  // morphdom only copies attributes. we decided we also wanted to copy events
  // that can be set via attributes
  function copier (f, t) {
    // copy events:
    var events = opts.events || defaultEvents
    for (var i = 0; i < events.length; i++) {
      var ev = events[i]
      if (t[ev]) { // if new element has a whitelisted attribute
        f[ev] = t[ev] // update existing element
      } else if (f[ev]) { // if existing element has it and new one doesnt
        f[ev] = undefined // remove it from existing element
      }
    }
    var oldValue = f.value
    var newValue = t.value
    // copy values for form elements
    if ((f.nodeName === 'INPUT' && f.type !== 'file') || f.nodeName === 'SELECT') {
      if (!newValue && !t.hasAttribute('value')) {
        t.value = f.value
      } else if (newValue !== oldValue) {
        f.value = newValue
      }
    } else if (f.nodeName === 'TEXTAREA') {
      if (t.getAttribute('value') === null) f.value = t.value
    }
  }
}

},{"./update-events.js":63,"bel":9,"morphdom":27}],63:[function(require,module,exports){
module.exports = [
  // attribute events (can be set with attributes)
  'onclick',
  'ondblclick',
  'onmousedown',
  'onmouseup',
  'onmouseover',
  'onmousemove',
  'onmouseout',
  'ondragstart',
  'ondrag',
  'ondragenter',
  'ondragleave',
  'ondragover',
  'ondrop',
  'ondragend',
  'onkeydown',
  'onkeypress',
  'onkeyup',
  'onunload',
  'onabort',
  'onerror',
  'onresize',
  'onscroll',
  'onselect',
  'onchange',
  'onsubmit',
  'onreset',
  'onfocus',
  'onblur',
  'oninput',
  // other common events
  'oncontextmenu',
  'onfocusin',
  'onfocusout'
]

},{}],64:[function(require,module,exports){
(function (Buffer){(function (){
const BN = require('bn.js')
const ethUtil = require('ethereumjs-util')
const opcodes = require('./opcodes.js')
const wastSyncInterface = require('./wasm/wast.json')
const wastAsyncInterface = require('./wasm/wast-async.json')
// const wabt = require('wabt')

// map to track dependent WASM functions
const depMap = new Map([
  ['callback_256', ['bswap_m256']],
  ['callback_160', ['bswap_m160']],
  ['callback_128', ['bswap_m128']],
  ['bswap_m256', ['bswap_i64']],
  ['bswap_m128', ['bswap_i64']],
  ['bswap_m160', ['bswap_i64', 'bswap_i32']],
  ['keccak', ['memcpy', 'memset']],
  ['mod_320', ['iszero_320', 'gte_320']],
  ['mod_512', ['iszero_512', 'gte_512']],
  ['MOD', ['iszero_256', 'gte_256']],
  ['ADDMOD', ['mod_320']],
  ['MULMOD', ['mod_512']],
  ['SDIV', ['iszero_256', 'gte_256']],
  ['SMOD', ['iszero_256', 'gte_256']],
  ['DIV', ['iszero_256', 'gte_256']],
  ['EXP', ['iszero_256', 'mul_256']],
  ['MUL', ['mul_256']],
  ['ISZERO', ['iszero_256']],
  ['MSTORE', ['memusegas', 'bswap_m256', 'check_overflow']],
  ['MLOAD', ['memusegas', 'bswap_m256', 'check_overflow']],
  ['MSTORE8', ['memusegas', 'check_overflow']],
  ['CODECOPY', ['callback', 'memusegas', 'check_overflow', 'memset']],
  ['CALLDATALOAD', ['bswap_m256', 'bswap_i64', 'check_overflow']],
  ['CALLDATACOPY', ['memusegas', 'check_overflow', 'memset']],
  ['CALLVALUE', ['bswap_m256']],
  ['EXTCODECOPY', ['bswap_m256', 'callback', 'memusegas', 'check_overflow', 'memset']],
  ['EXTCODESIZE', ['bswap_m256', 'callback_32']],
  ['EXTCODEHASH', ['bswap_m256', 'callback_256']],
  ['RETURNDATACOPY', ['memusegas', 'check_overflow', 'memset']],
  ['LOG', ['memusegas', 'bswap_m256', 'check_overflow']],
  ['BLOCKHASH', ['check_overflow', 'callback_256']],
  ['SHA3', ['memusegas', 'bswap_m256', 'check_overflow', 'keccak']],
  ['CALL', ['bswap_m256', 'bswap_m256', 'callback', 'memusegas', 'check_overflow_i64', 'check_overflow', 'check_overflow_i64', 'memset', 'callback_32']],
  ['DELEGATECALL', ['bswap_m256', 'callback', 'memusegas', 'check_overflow_i64', 'check_overflow', 'memset', 'callback_32']],
  ['STATICCALL', ['bswap_m256', 'callback', 'memusegas', 'check_overflow_i64', 'check_overflow', 'memset', 'callback_32']],
  ['CALLCODE', ['bswap_m256', 'bswap_m256', 'callback', 'memusegas', 'check_overflow_i64', 'check_overflow', 'check_overflow_i64', 'memset', 'callback_32']],
  ['CREATE', ['bswap_m256', 'bswap_m160', 'callback_256', 'memusegas', 'check_overflow']],
  ['CREATE2', ['bswap_m256', 'bswap_m160', 'callback_256', 'memusegas', 'check_overflow']],
  ['RETURN', ['memusegas', 'check_overflow']],
  ['REVERT', ['memusegas', 'check_overflow']],
  ['BALANCE', ['bswap_m256', 'callback_256']],
  ['SELFBALANCE', ['callback_256']],
  ['SELFDESTRUCT', ['bswap_m256']],
  ['SSTORE', ['bswap_m256', 'callback']],
  ['SLOAD', ['bswap_m256', 'callback_256']],
  ['CODESIZE', ['callback_32']],
  ['DIFFICULTY', ['bswap_m256']],
  ['CHAINID', ['bswap_m256']],
  ['BASEFEE', ['bswap_m160']],
  ['COINBASE', ['bswap_m256']],
  ['ORIGIN', ['bswap_m256']],
  ['ADDRESS', ['bswap_m256']],
  ['CALLER', ['bswap_m256']]
])

// maps the async ops to their call back function
const callbackFuncs = new Map([
  ['SSTORE', '$callback'],
  ['SLOAD', '$callback_256'],
  ['CREATE', '$callback_256'],
  ['CREATE2', '$callback_256'],
  ['CALL', '$callback_32'],
  ['DELEGATECALL', '$callback'],
  ['CALLCODE', '$callback_32'],
  ['EXTCODECOPY', '$callback'],
  ['EXTCODESIZE', '$callback_32'],
  ['EXTCODEHASH', '$callback_256'],
  ['CODECOPY', '$callback'],
  ['CODESIZE', '$callback_32'],
  ['BALANCE', '$callback_256'],
  ['SELFBALANCE', '$callback_256'],
  ['CHAINID', '$callback_256'],
  ['BLOCKHASH', '$callback_256']
])

const INTERFACE_CLASSIC = "ewasm_env_1";
const INTERFACE_INTERPRETER = "ewasm_ewasm_1";

// /**
//  * compiles evmCode to wasm in the binary format
//  * @param {Array} evmCode
//  * @param {Object} opts
//  * @param {boolean} opts.stackTrace if `true` generates an runtime EVM stack trace (default: false)
//  * @param {boolean} opts.inlineOps if `true` inlines the EVM1 operations (default: true)
//  * @param {String} opts.testName is the name used for the wast file (default: 'temp')
//  * @param {boolean} opts.chargePerOp if `true` adds metering statements for the wasm code section corresponding to each EVM opcode as opposed to metering once per branch segment (default: false).
//  * @return {string}
//  */
// exports.evm2wasm = function (evmCode, opts = {
//   'stackTrace': false,
//   'useAsyncAPI': false,
//   'inlineOps': true,
//   'testName': 'temp',
//   'chargePerOp': false,
//   'isConstructor':false,
// }) {
//   const wast = exports.evm2wast(evmCode, opts)
//   const mod = wabt.parseWat('arbitraryModuleName', wast)
//   mod.resolveNames()
//   mod.validate()
//   const bin = mod.toBinary({log: false, write_debug_names: false}).buffer
//   mod.destroy()
//   return Promise.resolve(bin)
// }

/**
 * Transcompiles EVM code to ewasm in the sexpression text format. The EVM code
 * is broken into segments and each instruction in those segments is replaced
 * with a `call` to wasm function that does the equivalent operation. Each
 * opcode function takes in and returns the stack pointer.
 *
 * Segments are sections of EVM code in between flow control
 * opcodes (JUMPI. JUMP).
 * All segments start at
 * * the beginning for EVM code
 * * a GAS opcode
 * * a JUMPDEST opcode
 * * After a JUMPI opcode
 * @param {Integer} evmCode the evm byte code
 * @param {Object} opts
 * @param {boolean} opts.stackTrace if `true` generates a stack trace (default: false)
 * @param {boolean} opts.inlineOps if `true` inlines the EVM1 operations (default: true)
 * @param {boolean} opts.chargePerOp if `true` adds metering statements for the wasm code section corresponding to each EVM opcode as opposed to metering once per branch segment (default: false).
 * @return {string}
 */
exports.evm2wast = function (deploymentEvmCode, opts = {
  'stackTrace': false,
  'useAsyncAPI': false,
  'inlineOps': true,
  'chargePerOp': false,
  'isConstructor':false,
  'nogas': true,
}) {
  // sol: 39 60 00 f3 fe
  // yul: 39 610196 60 00 f3 fe
  // codecopy + (push2?) + push1 0 + return + invalid

  function splitConstructor(code) {
    if (code.length < 5) return [new Buffer(0), code];
    for (let i = 3 ; i < code.length; i++) {
      // "6000f3fe" "6000f300"
      if (code[i-3] == 0x60 && code[i-2] == 0x00 && code[i-1] == 0xf3 && (code[i] == 0xfe || code[i] == 0x00)) {
        return [
          new Buffer.from(Uint8Array.prototype.slice.call(code).slice(0,i+1)),
          new Buffer.from(Uint8Array.prototype.slice.call(code).slice(i+1)),
        ];
      }
    }
    return [new Buffer(0), code];
  }

  // adds stack height checks to the beginning of a segment
  function addStackCheck () {
    let check = ''
    if (segmentStackHigh !== 0) {
      check = `(if (i32.gt_s (global.get $sp) (i32.const ${(1023 - segmentStackHigh) * 32}))
                 (then (unreachable)))`
    }
    if (segmentStackLow !== 0) {
      check += `(if (i32.lt_s (global.get $sp) (i32.const ${-segmentStackLow * 32 - 32}))
                  (then (unreachable)))`
    }
    segment = check + segment
    segmentStackHigh = 0
    segmentStackLow = 0
    segmentStackDelta = 0
  }

  // add a metering statment at the beginning of a segment
  // TODO fixme - this needs to be integrated in the interpreter opcodes
  function addMetering () {
    if (!opts.chargePerOp && !opts.nogas) {
      if (gasCount !== 0) {
        wast += `(call $useGas (i64.const ${gasCount})) `
      }
    }

    wast += segment
    segment = ''
    gasCount = 0
  }

  // finishes off a segment
  function endSegment () {
    segment += ')'
    addStackCheck()
    addMetering()
  }

  let interfaceVersion = INTERFACE_CLASSIC;
  if (!opts.inlineOps) {
    interfaceVersion = INTERFACE_INTERPRETER;
  }

  // this keep track of the opcode we have found so far. This will be used to
  // to figure out what .wast files to include
  const opcodesUsed = new Set()
  const ignoredOps = new Set(['JUMP', 'JUMPI', 'JUMPDEST', 'POP', 'STOP', 'INVALID'])
  let callbackTable = []

  // an array of found segments
  const jumpSegments = []
  // the transcompiled EVM code
  let wast = ''
  let segment = ''
  // keeps track of the gas that each section uses
  let gasCount = 0
  // used for pruning dead code
  let jumpFound = false
  // the accumlitive stack difference for the current segmnet
  let segmentStackDelta = 0
  let segmentStackHigh = 0
  let segmentStackLow = 0

  let evmCode = deploymentEvmCode;
  let evmConstructorCode = new Buffer(0)
  let addFuncs = [];
  if (!opts.isConstructor) {
    const [__evmConstructor, __evmCode] = splitConstructor(deploymentEvmCode);
    console.log('constructor', ethUtil.bufferToHex(__evmConstructor));
    console.log('runtime', ethUtil.bufferToHex(__evmCode));

    if (__evmConstructor.length > 5) {
      evmConstructorCode = __evmConstructor;
      const [constructorCode, constructorOpcodes] = exports.evm2wast(__evmConstructor, {isConstructor: true});
      addFuncs = [constructorCode];
      // add the sources for the constructor opcodes
      for (const value of constructorOpcodes.values()) {
        opcodesUsed.add(value);
      }
    }
    evmCode = __evmCode;
  }

  // pre-analysis for custom messages
  let cosmosImports = new Set();
  const COSMOS_MSG_MARKER = "0x000000000000000000000000000000000000e2b891e911223344556677889900";
  const COSMOS_QUERY_MARKER = "0x000000000000000000000000000000000000fe143b3911223344556677889900";
  function replaceAllOccurrences(mainArray, subArray, replacementArray) {
    const sublen = subArray.length;
    let copyMainArray = new Buffer.from([...mainArray]);
    const indexes = [...mainArray].map((_, i) => i);
    const filteredIndexes = indexes.filter(i => mainArray.slice(i, i + sublen).every((elem, j) => elem === subArray[j]));

    filteredIndexes.reverse().map(i => {
      copyMainArray = new Buffer.from([
        ...Uint8Array.prototype.slice.call(copyMainArray).slice(0, i),
        ...replacementArray,
        ...Uint8Array.prototype.slice.call(copyMainArray).slice(i + sublen),
      ]);
    });
    return copyMainArray;
  }

  // for cosmos msg 0xe2b891e9, replace jumpdest -> jump that contains PUSH14 0xe2b891e911223344556677889900
  // with
  // JUMPDEST PUSHX 0xe2b891e911223344556677889900000..  0x40 mload returndatasize dup1 dup3 add 0x40 mstore 0x00 dup3 returndatacopy swap1 swap2 JUMP
  evmCode = replaceAllOccurrences(evmCode, ethUtil.toBuffer("0x6000606060006de2b891e91122334455667788990090506001925050915091"), ethUtil.toBuffer("0x6de2b891e9112233445566778899006040513d8082016040526000823e9091"))

  // replace for cosmos queries 0xfe143b39
  evmCode = replaceAllOccurrences(evmCode, ethUtil.toBuffer("0x6000606060006dfe143b391122334455667788990090506001925050915091"), ethUtil.toBuffer("0x6dfe143b39112233445566778899006040513d8082016040526000823e9091"))

  // https://docs.soliditylang.org/en/latest/metadata.html#encoding-of-the-metadata-hash-in-the-bytecode
  // TODO find metadata hash & keep it in the wasmcode

  for (let pc = 0; pc < evmCode.length; pc++) {
    const opint = evmCode[pc]
    const op = opcodes(opint)

    // creates a stack trace
    if (opts.stackTrace) {
      segment += `(call $stackTrace (i32.const ${pc}) (i32.const ${opint}) (i32.const ${op.fee}) (global.get $sp))\n`
    }

    let bytes
    if (opts.chargePerOp && !opts.nogas) {
      if (op.fee !== 0) {
        segment += `(call $useGas (i64.const ${op.fee})) `
      }
    }
    // do not charge gas for interface methods
    // TODO: implement proper gas charging and enable this here
    if (opint < 0x30 || (opint > 0x45 && opint < 0xa0)) {
      gasCount += op.fee
    }

    segmentStackDelta += op.on
    if (segmentStackDelta > segmentStackHigh) {
      segmentStackHigh = segmentStackDelta
    }

    segmentStackDelta -= op.off
    if (segmentStackDelta < segmentStackLow) {
      segmentStackLow = segmentStackDelta
    }
    let canIncreaseSp = true;

    switch (op.name) {
      case 'JUMP':
        jumpFound = true
        segment += `;; jump
                      (local.set $jump_dest (call $check_overflow
                                             (i64.load (global.get $sp))
                                             (i64.load (i32.add (global.get $sp) (i32.const 8)))
                                             (i64.load (i32.add (global.get $sp) (i32.const 16)))
                                             (i64.load (i32.add (global.get $sp) (i32.const 24)))))
                      (global.set $sp (i32.sub (global.get $sp) (i32.const 32)))
                      (br $loop)`
        opcodesUsed.add('check_overflow')
        pc = findNextJumpDest(evmCode, pc)
        break
      case 'JUMPI':
        jumpFound = true
        segment += `(local.set $jump_dest (call $check_overflow
                                             (i64.load (global.get $sp))
                                             (i64.load (i32.add (global.get $sp) (i32.const 8)))
                                             (i64.load (i32.add (global.get $sp) (i32.const 16)))
                                             (i64.load (i32.add (global.get $sp) (i32.const 24)))))

                    (global.set $sp (i32.sub (global.get $sp) (i32.const 64)))
                    (br_if $loop (i32.eqz (i64.eqz (i64.or
                      (i64.load (i32.add (global.get $sp) (i32.const 32)))
                      (i64.or
                        (i64.load (i32.add (global.get $sp) (i32.const 40)))
                        (i64.or
                          (i64.load (i32.add (global.get $sp) (i32.const 48)))
                          (i64.load (i32.add (global.get $sp) (i32.const 56)))
                        )
                      )
                    ))))\n`
        opcodesUsed.add('check_overflow')
        addStackCheck()
        addMetering()
        break
      case 'JUMPDEST':
        endSegment()
        jumpSegments.push({
          number: pc,
          type: 'jump_dest'
        })
        gasCount = 1
        break
      case 'GAS':
        segment += `(call $GAS)\n`
        // addMetering() // this causes an unreachable error in stackOverflowM1 -d 14
        break
      case 'LOG':
        segment += `(call $LOG (i32.const ${op.number}))\n`
        break
      case 'DUP':
      case 'SWAP':
        // adds the number on the stack to SWAP
        segment += `(call $${op.name} (i32.const ${op.number - 1}))\n`
        break
      case 'PC':
        segment += `(call $PC (i32.const ${pc}))\n`
        break
      case 'PUSH':
        pc++
        bytes = ethUtil.setLength(evmCode.slice(pc, pc += op.number), 32)
        const bytesRounded = Math.ceil(op.number / 8)
        let push = ''
        let q = 0
        // pad the remaining of the word with 0
        for (; q < 4 - bytesRounded; q++) {
          push = '(i64.const 0)' + push
        }

        for (; q < 4; q++) {
          const int64 = bytes2int64(bytes.slice(q * 8, q * 8 + 8))
          push = push + `(i64.const ${int64})`
        }

        if (ethUtil.bufferToHex(bytes) === COSMOS_MSG_MARKER) {
          canIncreaseSp = false;
          segment += `(call $SENDCOSMOSMSG)`
          cosmosImports.add("SENDCOSMOSMSG");
        }
        else if (ethUtil.bufferToHex(bytes) === COSMOS_QUERY_MARKER) {
          canIncreaseSp = false;
          segment += `(call $SENDCOSMOSQUERY)`
          cosmosImports.add("SENDCOSMOSQUERY");
        }
        else {
          segment += `(call $PUSH ${push})`
        }

        pc--
        break
      case 'POP':
        // do nothing
        break
      case 'STOP':
        segment += '(br $done)'
        if (jumpFound) {
          pc = findNextJumpDest(evmCode, pc)
        } else {
          // the rest is dead code
          pc = evmCode.length
        }
        break
      case 'SELFDESTRUCT':
      case 'RETURN':
      case 'REVERT':
        segment += `(call $${op.name}) (br $done)\n`
        if (jumpFound) {
          pc = findNextJumpDest(evmCode, pc)
        } else {
          // the rest is dead code
          pc = evmCode.length
        }
        break
      case 'INVALID':
        segment = '(unreachable)'
        pc = findNextJumpDest(evmCode, pc)
        break
      default:
        if (opts.useAsyncAPI && callbackFuncs.has(op.name)) {
          const cbFunc = callbackFuncs.get(op.name)
          let index = callbackTable.indexOf(cbFunc)
          if (index === -1) {
            index = callbackTable.push(cbFunc) - 1
          }
          segment += `(call $${op.name} (i32.const ${index}))\n`
        } else {
          // use synchronous API
          segment += `(call $${op.name})\n`
        }
    }

    if (!ignoredOps.has(op.name)) {
      opcodesUsed.add(op.name)
    }

    const stackDelta = op.on - op.off
    // update the stack pointer
    if (stackDelta !== 0 && canIncreaseSp) {
      segment += `(global.set $sp (i32.add (global.get $sp) (i32.const ${stackDelta * 32})))\n`
    }

    // adds the logic to save the stack pointer before exiting to wiat to for a callback
    // note, this must be done before the sp is updated above^
    if (opts.useAsyncAPI && callbackFuncs.has(op.name)) {
      segment += `(global.set $cb_dest (i32.const ${jumpSegments.length + 1}))
          (br $done))`
      jumpSegments.push({
        type: 'cb_dest'
      })
    }
  }

  endSegment()

  if (opts.isConstructor) {
    wast = assembleInstantiate(jumpSegments) + wast + '))'
    return [wast, opcodesUsed];
  } else {

    wast = assembleSegments(jumpSegments, evmConstructorCode.length > 0) + wast + '))'
  }

  let wastFiles = wastSyncInterface // default to synchronous interface
  if (opts.useAsyncAPI) {
    wastFiles = wastAsyncInterface
  }

  let imports = []
  let funcs = []
  // inline EVM opcode implemention
  if (opts.inlineOps) {
    [funcs, imports] = exports.resolveFunctions(opcodesUsed, wastFiles)
  } else {
    [,, inline_imports] = exports.resolveFunctions(opcodesUsed, wastFiles)
    imports = inline_imports;
    imports.push('(import "ewasm" "GLOBAL_GET_SP" (func $GLOBAL_GET_SP (result i32)))')
    imports.push('(import "ewasm" "GLOBAL_SET_SP" (func $GLOBAL_SET_SP (param i32)))')
    imports.push('(import "ewasm" "ethereum_useGas" (func $useGas (param i64)))')
  }
  for (let cosmosImport of cosmosImports.values()) {
    imports.push(cosmosFunctions[cosmosImport].import);
    funcs.push(cosmosFunctions[cosmosImport].def);
  }
  funcs = addFuncs.concat(funcs);

  // import stack trace function
  if (opts.stackTrace) {
    imports.push('(import "env" "ethereum_debugPrintMemHex" (func $printMem (param i32 i32)))')
    imports.push('(import "env" "ethereum_debugPrinti32" (func $printI32 (param i32)))')
    imports.push('(import "env" "ethereum_debugPrinti64" (func $printI64 (param i64)))')
    imports.push('(import "env" "ethereum_debug_evmTrace" (func $stackTrace (param i32 i32 i32 i32)))')
  }
  if (opts.inlineOps) {
    imports.push('(import "env" "ethereum_useGas" (func $useGas (param i64)))')
  }


  funcs.push(wast)
  wast = exports.buildModule(funcs, imports, callbackTable, evmConstructorCode, evmCode, opts.isConstructor, interfaceVersion)

  if (interfaceVersion === INTERFACE_INTERPRETER) {
    wast = wast.replace(/\(global\.get \$sp\)/g, "(call $GLOBAL_GET_SP)")
    wast = wast.replace(/\(global\.set \$sp /g, "(call $GLOBAL_SET_SP ")
  }

  return wast
}

// given an array for segments builds a wasm module from those segments
// @param {Array} segments
// @return {String}
function assembleSegments (segments, hasConstructor) {
  let wasm = buildJumpMap(segments)

  segments.forEach((seg, index) => {
    wasm = `(block $${index + 1} ${wasm}`
  })

  return `
  ${hasConstructor ? "" : `(func $instantiate (export "instantiate"))`}
  (func $main
    (export "main")
    (local $jump_dest i32) (local $jump_map_switch i32)
    (local.set $jump_dest (i32.const -1))

    (block $done
      (loop $loop
        ${wasm}`
}

function assembleInstantiate (segments) {
  let wasm = buildJumpMap(segments)

  segments.forEach((seg, index) => {
    wasm = `(block $${index + 1} ${wasm}`
  })

  return `
  (func $instantiate
    (export "instantiate")
    (local $jump_dest i32) (local $jump_map_switch i32)
    (local.set $jump_dest (i32.const -1))

    (block $done
      (loop $loop
        ${wasm}`
}

// Builds the Jump map, which maps EVM jump location to a block label
// @param {Array} segments
// @return {String}
function buildJumpMap (segments) {
  let wasm = '(unreachable)'

  let brTable = ''
  segments.forEach((seg, index) => {
    brTable += ' $' + (index + 1)
    if (seg.type === 'jump_dest') {
      wasm = `(if (i32.eq (local.get $jump_dest) (i32.const ${seg.number}))
                (then (br $${index + 1}))
                (else ${wasm}))`
    }
  })

  wasm = `
  (block $0
    (if
      (i32.eqz (global.get $init))
      (then
        (global.set $init (i32.const 1))
        (br $0))
      (else
        ;; the callback dest can never be in the first block
        (if (i32.eq (global.get $cb_dest) (i32.const 0))
          (then
            ${wasm}
          )
          (else
            ;; return callback destination and zero out $cb_dest
            (local.set $jump_map_switch (global.get $cb_dest))
            (global.set $cb_dest (i32.const 0))
            (br_table $0 ${brTable} (local.get $jump_map_switch))
          )))))`

  return wasm
}

// returns the index of the next jump destination opcode in given EVM code in an
// array and a starting index
// @param {Array} evmCode
// @param {Integer} index
// @return {Integer}
function findNextJumpDest (evmCode, i) {
  for (; i < evmCode.length; i++) {
    const opint = evmCode[i]
    const op = opcodes(opint)
    switch (op.name) {
      case 'PUSH':
        // skip add how many bytes where pushed
        i += op.number
        break
      case 'JUMPDEST':
        return --i
    }
  }
  return --i
}

// converts 8 bytes into a int 64
// @param {Integer}
// @return {String}
function bytes2int64 (bytes) {
  return new BN(bytes).fromTwos(64).toString()
}

// Ensure that dependencies are only imported once (use the Set)
// @param {Set} funcSet a set of wasm function that need to be linked to their dependencies
// @return {Set}
function resolveFunctionDeps (funcSet) {
  let funcs = funcSet
  for (let func of funcSet) {
    const deps = depMap.get(func)
    if (deps) {
      for (const dep of deps) {
        funcs.add(dep)
      }
    }
  }
  return funcs
}

/**
 * given a Set of wasm function this return an array for wasm equivalents
 * @param {Set} funcSet
 * @return {Array}
 */
exports.resolveFunctions = function (funcSet, wastFiles) {
  let funcs = []
  let imports = []
  let inline_imports = []
  console.log("resolveFunctions", funcSet)
  for (let func of resolveFunctionDeps(funcSet)) {
    funcs.push(wastFiles[func].wast)
    if (func !== 'CALLDATALOAD' || !funcSet.has("CALLDATACOPY")) {
      imports.push(wastFiles[func].imports)
      inline_imports.push(wastFiles[func].inline_imports)
    }
  }
  return [funcs, imports, inline_imports]
}

/**
 * builds a wasm module
 * @param {Array} funcs the function to include in the module
 * @param {Array} imports the imports for the module's import table
 * @return {string}
 */
exports.buildModule = function (funcs, imports = [], callbacks = [], evmConstructorCode, evmCode, isConstructor, interfaceVersion) {
  let funcStr = ''
  for (let func of funcs) {
    funcStr += func
  }

  let callbackTableStr = ''
  if (callbacks.length) {
    callbackTableStr = `
    (table
      (export "callback") ;; name of table
        anyfunc
        (elem ${callbacks.join(' ')}) ;; elements will have indexes in order
      )`
  }
  let evmCodeStr = ''
  if (evmCode && !isConstructor) {
    let evmbytecodestart = 33832
    let evmruntimestart = evmbytecodestart + evmConstructorCode.length
    let constructorCode = ''
    for (const val of evmConstructorCode.values()) {
      constructorCode += "\\"+val.toString(16).padStart(2, "0");
    }
    let runtimeCode = ''
    for (const val of evmCode.values()) {
      runtimeCode += "\\"+val.toString(16).padStart(2, "0");
    }
    evmCodeStr = `
(data (i32.const ${evmbytecodestart}) "${constructorCode}")
(data (i32.const ${evmruntimestart}) "${runtimeCode}")
(func $evm_bytecode (export "evm_bytecode") (result i32 i32 i32)
    i32.const ${evmbytecodestart}
    i32.const ${evmConstructorCode.length}
    i32.const ${evmCode.length})
    `
  }

  let opcodeHelpers;
  if (interfaceVersion === INTERFACE_CLASSIC) {
    opcodeHelpers = `
  (global $cb_dest (mut i32) (i32.const 0))
  (global $sp (mut i32) (i32.const -32))
  (global $init (mut i32) (i32.const 0))

  ;; memory related global
  ;; (global $evmbytecodestart i32  (i32.const 33832))
  (global $memstart i32  (i32.const 62632))
  ;; the number of 256 words stored in memory
  (global $wordCount (mut i64) (i64.const 0))
  ;; what was charged for the last memory allocation
  (global $prevMemCost (mut i64) (i64.const 0))

  ;; for SHL, SHR, SAR
  (global $global_ (mut i64) (i64.const 0))
  (global $global__1 (mut i64) (i64.const 0))
  (global $global__2 (mut i64) (i64.const 0))
    `
  } else {
    opcodeHelpers = `
  (global $cb_dest (mut i32) (i32.const 0))
  (global $init (mut i32) (i32.const 0))
    `
  }

  return `
(module
  ${imports.join('\n')}

  (type $et12 (func))
  (func $${interfaceVersion} (export "${interfaceVersion}") (type $et12) (nop))


  ${opcodeHelpers}

  ;; TODO: memory should only be 1, but can't resize right now
  (memory 500)
  (export "memory" (memory 0))

  ${callbackTableStr}

  ${funcStr}

  ${evmCodeStr}

)`
}

const cosmosFunctions = {
  "SENDCOSMOSMSG":{
    import: `(import "env" "ethereum_sendCosmosMsg" (func $sendCosmosMsg (param i32 i32) (result i32) ))`,
    def: `(func $SENDCOSMOSMSG (local $offset0 i32)(local $length0 i32)(local.set $offset0 (call $check_overflow
      (i64.load (global.get $sp))
      (i64.load (i32.add (global.get $sp) (i32.const 8)))
      (i64.load (i32.add (global.get $sp) (i32.const 16)))
      (i64.load (i32.add (global.get $sp) (i32.const 24)))))

  (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0)))

  ;; todo fix length - read from memory and increment offset with 32
  (local.set $length0 (i32.const 0))
  (call $memusegas (local.get $offset0) (i32.const 32))

  ;; (local.set $offset0 (i32.add (local.get $offset0) (i32.const 32)))

  (i64.store (i32.add (global.get $sp) (i32.const 0)) (i64.extend_i32_u (i32.eqz (call $sendCosmosMsg(local.get $offset0)(local.get $length0)))))
  ;; zero out mem
  (i64.store (i32.add (global.get $sp) (i32.const 8)) (i64.const 0))
  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.const 0))
  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.const 0)))`
  },
  "SENDCOSMOSQUERY":{
    import: `(import "env" "ethereum_sendCosmosQuery" (func $sendCosmosQuery (param i32 i32) (result i32) ))`,
    def: `(func $SENDCOSMOSQUERY (local $offset0 i32)(local $length0 i32)(local.set $offset0 (call $check_overflow
      (i64.load (global.get $sp))
      (i64.load (i32.add (global.get $sp) (i32.const 8)))
      (i64.load (i32.add (global.get $sp) (i32.const 16)))
      (i64.load (i32.add (global.get $sp) (i32.const 24)))))

  (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0)))

  ;; todo fix length - read from memory and increment offset with 32
  (local.set $length0 (i32.const 0))
  (call $memusegas (local.get $offset0) (i32.const 32))

  ;; (local.set $offset0 (i32.add (local.get $offset0) (i32.const 32)))

  (i64.store (i32.add (global.get $sp) (i32.const 0)) (i64.extend_i32_u (i32.eqz (call $sendCosmosQuery(local.get $offset0)(local.get $length0)))))
  ;; zero out mem
  (i64.store (i32.add (global.get $sp) (i32.const 8)) (i64.const 0))
  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.const 0))
  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.const 0)))`,
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"./opcodes.js":169,"./wasm/wast-async.json":170,"./wasm/wast.json":171,"bn.js":65,"buffer":11,"ethereumjs-util":89}],65:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":10}],66:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}

},{"crypto":10}],67:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var StringDecoder = require('string_decoder').StringDecoder
var inherits = require('inherits')

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase

},{"inherits":123,"safe-buffer":153,"stream":54,"string_decoder":55}],68:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var MD5 = require('md5.js')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Base = require('cipher-base')

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}

},{"cipher-base":67,"inherits":123,"md5.js":146,"ripemd160":150,"sha.js":158}],69:[function(require,module,exports){
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":84,"./elliptic/curve":72,"./elliptic/curves":75,"./elliptic/ec":76,"./elliptic/eddsa":79,"./elliptic/utils":83,"brorand":66}],70:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../utils":83,"bn.js":65}],71:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../utils":83,"./base":70,"bn.js":65,"inherits":123}],72:[function(require,module,exports){
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":70,"./edwards":71,"./mont":73,"./short":74}],73:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var utils = require('../utils');

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../utils":83,"./base":70,"bn.js":65,"inherits":123}],74:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../utils":83,"./base":70,"bn.js":65,"inherits":123}],75:[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');
var curve = require('./curve');
var utils = require('./utils');

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});

},{"./curve":72,"./precomputed/secp256k1":82,"./utils":83,"hash.js":110}],76:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var HmacDRBG = require('hmac-drbg');
var utils = require('../utils');
var curves = require('../curves');
var rand = require('brorand');
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../curves":75,"../utils":83,"./key":77,"./signature":78,"bn.js":65,"brorand":66,"hmac-drbg":122}],77:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"../utils":83,"bn.js":65}],78:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var utils = require('../utils');
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../utils":83,"bn.js":65}],79:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var curves = require('../curves');
var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../curves":75,"../utils":83,"./key":80,"./signature":81,"hash.js":110}],80:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../utils":83}],81:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"../utils":83,"bn.js":65}],82:[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};

},{}],83:[function(require,module,exports){
'use strict';

var utils = exports;
var BN = require('bn.js');
var minAssert = require('minimalistic-assert');
var minUtils = require('minimalistic-crypto-utils');

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":65,"minimalistic-assert":147,"minimalistic-crypto-utils":148}],84:[function(require,module,exports){
module.exports={
  "name": "elliptic",
  "version": "6.5.4",
  "description": "EC cryptography",
  "main": "lib/elliptic.js",
  "files": [
    "lib"
  ],
  "scripts": {
    "lint": "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "test": "npm run lint && npm run unit",
    "version": "grunt dist && git add dist/"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:indutny/elliptic"
  },
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "author": "Fedor Indutny <fedor@indutny.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "homepage": "https://github.com/indutny/elliptic",
  "devDependencies": {
    "brfs": "^2.0.2",
    "coveralls": "^3.1.0",
    "eslint": "^7.6.0",
    "grunt": "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    "istanbul": "^0.4.5",
    "mocha": "^8.0.1"
  },
  "dependencies": {
    "bn.js": "^4.11.9",
    "brorand": "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    "inherits": "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  }
}

},{}],85:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function createHashFunction(hashConstructor) {
    return function (msg) {
        var hash = hashConstructor();
        hash.update(msg);
        return Buffer.from(hash.digest());
    };
}
exports.createHashFunction = createHashFunction;

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":11}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var hash_utils_1 = require("./hash-utils");
var createKeccakHash = require("keccak");
exports.keccak224 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak224");
});
exports.keccak256 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak256");
});
exports.keccak384 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak384");
});
exports.keccak512 = hash_utils_1.createHashFunction(function () {
    return createKeccakHash("keccak512");
});

},{"./hash-utils":85,"keccak":125}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var randombytes = require("randombytes");
function getRandomBytes(bytes) {
    return new Promise(function (resolve, reject) {
        randombytes(bytes, function (err, resp) {
            if (err) {
                reject(err);
                return;
            }
            resolve(resp);
        });
    });
}
exports.getRandomBytes = getRandomBytes;
function getRandomBytesSync(bytes) {
    return randombytes(bytes);
}
exports.getRandomBytesSync = getRandomBytesSync;

},{"randombytes":149}],88:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var secp256k1_1 = require("secp256k1");
var random_1 = require("./random");
var SECP256K1_PRIVATE_KEY_SIZE = 32;
function createPrivateKey() {
    return __awaiter(this, void 0, void 0, function () {
        var pk;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!true) return [3 /*break*/, 2];
                    return [4 /*yield*/, random_1.getRandomBytes(SECP256K1_PRIVATE_KEY_SIZE)];
                case 1:
                    pk = _a.sent();
                    if (secp256k1_1.privateKeyVerify(pk)) {
                        return [2 /*return*/, pk];
                    }
                    return [3 /*break*/, 0];
                case 2: return [2 /*return*/];
            }
        });
    });
}
exports.createPrivateKey = createPrivateKey;
function createPrivateKeySync() {
    while (true) {
        var pk = random_1.getRandomBytesSync(SECP256K1_PRIVATE_KEY_SIZE);
        if (secp256k1_1.privateKeyVerify(pk)) {
            return pk;
        }
    }
}
exports.createPrivateKeySync = createPrivateKeySync;
__export(require("secp256k1"));

},{"./random":87,"secp256k1":154}],89:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('ethereum-cryptography/keccak'),
    keccak224 = _require.keccak224,
    keccak384 = _require.keccak384,
    k256 = _require.keccak256,
    keccak512 = _require.keccak512;

var secp256k1 = require('./secp256k1-adapter');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  switch (bits) {
    case 224:
      {
        return keccak224(a);
      }
    case 256:
      {
        return k256(a);
      }
    case 384:
      {
        return keccak384(a);
      }
    case 512:
      {
        return keccak512(a);
      }
    default:
      {
        throw new Error('Invald algorithm: keccak' + bits);
      }
  }
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
},{"./secp256k1-adapter":90,"assert":2,"bn.js":65,"create-hash":68,"ethereum-cryptography/keccak":86,"ethjs-util":93,"rlp":151,"safe-buffer":153}],90:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';

var secp256k1 = require('ethereum-cryptography/secp256k1');

var secp256k1v3 = require('./secp256k1-lib/index');
var der = require('./secp256k1-lib/der');

/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */
var privateKeyVerify = function privateKeyVerify(privateKey) {
  // secp256k1 v4 version throws when privateKey length is not 32
  if (privateKey.length !== 32) {
    return false;
  }

  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
};

/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */
var privateKeyExport = function privateKeyExport(privateKey, compressed) {
  // privateKeyExport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);

  return der.privateKeyExport(privateKey, publicKey, compressed);
};

/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */

var privateKeyImport = function privateKeyImport(privateKey) {
  // privateKeyImport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  privateKey = der.privateKeyImport(privateKey);
  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
    return privateKey;
  }

  throw new Error("couldn't import from DER format");
};

/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyNegate = function privateKeyNegate(privateKey) {
  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
};

/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyModInverse = function privateKeyModInverse(privateKey) {
  if (privateKey.length !== 32) {
    throw new Error('private key length is invalid');
  }

  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};

/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};

/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};

/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCreate = function publicKeyCreate(privateKey, compressed) {
  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};

/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyConvert = function publicKeyConvert(publicKey, compressed) {
  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};

/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var publicKeyVerify = function publicKeyVerify(publicKey) {
  // secp256k1 v4 version throws when publicKey length is not 33 or 65
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    return false;
  }

  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
};

/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {
  var keys = [];
  publicKeys.forEach(function (publicKey) {
    keys.push(Uint8Array.from(publicKey));
  });

  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
};

/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureNormalize = function signatureNormalize(signature) {
  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
};

/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureExport = function signatureExport(signature) {
  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImport = function signatureImport(signature) {
  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImportLax = function signatureImportLax(signature) {
  // signatureImportLax method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure that signature is greater than 0
  if (signature.length === 0) {
    throw new RangeError('signature length is invalid');
  }

  var sigObj = der.signatureImportLax(signature);
  if (sigObj === null) {
    throw new Error("couldn't parse DER signature");
  }

  return secp256k1v3.signatureImport(sigObj);
};

/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */
var sign = function sign(message, privateKey, options) {
  if (options === null) {
    throw new TypeError('options should be an Object');
  }

  var signOptions = void 0;

  if (options) {
    signOptions = {};

    if (options.data === null) {
      throw new TypeError('options.data should be a Buffer');
    }

    if (options.data) {
      // validate option.data length
      if (options.data.length !== 32) {
        throw new RangeError('options.data length is invalid');
      }

      signOptions.data = new Uint8Array(options.data);
    }

    if (options.noncefn === null) {
      throw new TypeError('options.noncefn should be a Function');
    }

    if (options.noncefn) {
      //  convert option.noncefn function signature
      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
        var bufferAlgo = algo != null ? Buffer.from(algo) : null;
        var bufferData = data != null ? Buffer.from(data) : null;

        var buffer = Buffer.from('');

        if (options.noncefn) {
          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
        }

        return Uint8Array.from(buffer);
      };
    }
  }

  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);

  return {
    signature: Buffer.from(sig.signature),
    recovery: sig.recid
  };
};

/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var verify = function verify(message, signature, publicKey) {
  // note: secp256k1 v4 verify method has a different argument order
  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};

/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */
var recover = function recover(message, signature, recid, compressed) {
  // note: secp256k1 v4 recover method has a different argument order
  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};

/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var ecdh = function ecdh(publicKey, privateKey) {
  // note: secp256k1 v3 doesn't allow optional parameter
  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};

/**
 * Compute an EC Diffie-Hellman secret and return public key as result
 * @method ecdhUnsafe
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {
  // ecdhUnsafe method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure valid publicKey length
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    throw new RangeError('public key length is invalid');
  }

  // ensure valid privateKey length
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

module.exports = {
  privateKeyVerify: privateKeyVerify,
  privateKeyExport: privateKeyExport,
  privateKeyImport: privateKeyImport,
  privateKeyNegate: privateKeyNegate,
  privateKeyModInverse: privateKeyModInverse,
  privateKeyTweakAdd: privateKeyTweakAdd,
  privateKeyTweakMul: privateKeyTweakMul,

  publicKeyCreate: publicKeyCreate,
  publicKeyConvert: publicKeyConvert,
  publicKeyVerify: publicKeyVerify,
  publicKeyTweakAdd: publicKeyTweakAdd,
  publicKeyTweakMul: publicKeyTweakMul,
  publicKeyCombine: publicKeyCombine,

  signatureNormalize: signatureNormalize,
  signatureExport: signatureExport,
  signatureImport: signatureImport,
  signatureImportLax: signatureImportLax,

  sign: sign,
  verify: verify,
  recover: recover,

  ecdh: ecdh,
  ecdhUnsafe: ecdhUnsafe
};
}).call(this)}).call(this,require("buffer").Buffer)

},{"./secp256k1-lib/der":91,"./secp256k1-lib/index":92,"buffer":11,"ethereum-cryptography/secp256k1":88}],91:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
// begin
0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
// begin
0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
  privateKey.copy(result, compressed ? 8 : 9);
  publicKey.copy(result, compressed ? 181 : 214);
  return result;
};

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length;

  // sequence header
  var index = 0;
  if (length < index + 1 || privateKey[index] !== 0x30) return null;
  index += 1;

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return null;

  var lenb = privateKey[index] & 0x7f;
  index += 1;
  if (lenb < 1 || lenb > 2) return null;
  if (length < index + lenb) return null;

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
  index += lenb;
  if (length < index + len) return null;

  // sequence element 0: version number (=1)
  if (length < index + 3 || privateKey[index] !== 0x02 || privateKey[index + 1] !== 0x01 || privateKey[index + 2] !== 0x01) {
    return null;
  }
  index += 3;

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 || privateKey[index] !== 0x04 || privateKey[index + 1] > 0x20 || length < index + 2 + privateKey[index + 1]) {
    return null;
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};

exports.signatureImportLax = function (signature) {
  var r = Buffer.alloc(32, 0);
  var s = Buffer.alloc(32, 0);

  var length = signature.length;
  var index = 0;

  // sequence tag byte
  if (signature[index++] !== 0x30) {
    return null;
  }

  // sequence length byte
  var lenbyte = signature[index++];
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80;
    if (index > length) {
      return null;
    }
  }

  // sequence tag byte for r
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for r
  var rlen = signature[index++];
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      rlen = (rlen << 8) + signature[index];
    }
  }
  if (rlen > length - index) {
    return null;
  }
  var rindex = index;
  index += rlen;

  // sequence tag byte for s
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for s
  var slen = signature[index++];
  if (slen & 0x80) {
    lenbyte = slen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      slen = (slen << 8) + signature[index];
    }
  }
  if (slen > length - index) {
    return null;
  }
  var sindex = index;
  index += slen;

  // ignore leading zeros in r
  for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1) {}
  // copy r value
  if (rlen > 32) {
    return null;
  }
  var rvalue = signature.slice(rindex, rindex + rlen);
  rvalue.copy(r, 32 - rvalue.length);

  // ignore leading zeros in s
  for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1) {}
  // copy s value
  if (slen > 32) {
    return null;
  }
  var svalue = signature.slice(sindex, sindex + slen);
  svalue.copy(s, 32 - svalue.length);

  return { r: r, s: s };
};
}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":11}],92:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var BN = require('bn.js');
var EC = require('elliptic').ec;

var ec = new EC('secp256k1');
var ecparams = ec.curve;

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey);
  if (d.ucmp(ecparams.n) >= 0) {
    throw new Error('couldn\'t export to DER format');
  }

  var point = ec.g.mul(d);
  return toPublicKey(point.getX(), point.getY(), compressed);
};

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey);
  if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
    throw new Error('private key range is invalid');
  }

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);
};

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r);
  if (r.ucmp(ecparams.n) >= 0) {
    r = new BN(0);
  }

  var s = new BN(sigObj.s);
  if (s.ucmp(ecparams.n) >= 0) {
    s = new BN(0);
  }

  return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);
};

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var point = ec.keyFromPublic(publicKey);

  var scalar = new BN(privateKey);
  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
    throw new Error('scalar was invalid (zero or overflow)');
  }

  var shared = point.pub.mul(scalar);
  return toPublicKey(shared.getX(), shared.getY(), compressed);
};

var toPublicKey = function toPublicKey(x, y, compressed) {
  var publicKey = void 0;

  if (compressed) {
    publicKey = Buffer.alloc(33);
    publicKey[0] = y.isOdd() ? 0x03 : 0x02;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
  } else {
    publicKey = Buffer.alloc(65);
    publicKey[0] = 0x04;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
    y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);
  }

  return publicKey;
};
}).call(this)}).call(this,require("buffer").Buffer)

},{"bn.js":65,"buffer":11,"elliptic":69}],93:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":11,"is-hex-prefixed":124,"strip-hex-prefix":167}],94:[function(require,module,exports){
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('readable-stream').Transform
var inherits = require('inherits')

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

},{"inherits":123,"readable-stream":109,"safe-buffer":153}],95:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],96:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":98,"./_stream_writable":100,"_process":34,"inherits":123}],97:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":99,"inherits":123}],98:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":95,"./_stream_duplex":96,"./internal/streams/async_iterator":101,"./internal/streams/buffer_list":102,"./internal/streams/destroy":103,"./internal/streams/from":105,"./internal/streams/state":107,"./internal/streams/stream":108,"_process":34,"buffer":11,"events":17,"inherits":123,"string_decoder/":165,"util":10}],99:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":95,"./_stream_duplex":96,"inherits":123}],100:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":95,"./_stream_duplex":96,"./internal/streams/destroy":103,"./internal/streams/state":107,"./internal/streams/stream":108,"_process":34,"buffer":11,"inherits":123,"util-deprecate":168}],101:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

},{"./end-of-stream":104,"_process":34}],102:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":11,"util":10}],103:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

},{"_process":34}],104:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":95}],105:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],106:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":95,"./end-of-stream":104}],107:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":95}],108:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43,"events":17}],109:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":96,"./lib/_stream_passthrough.js":97,"./lib/_stream_readable.js":98,"./lib/_stream_transform.js":99,"./lib/_stream_writable.js":100,"./lib/internal/streams/end-of-stream.js":104,"./lib/internal/streams/pipeline.js":106}],110:[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":111,"./hash/hmac":112,"./hash/ripemd":113,"./hash/sha":114,"./hash/utils":121}],111:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"./utils":121,"minimalistic-assert":147}],112:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"./utils":121,"minimalistic-assert":147}],113:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var common = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"./common":111,"./utils":121}],114:[function(require,module,exports){
'use strict';

exports.sha1 = require('./sha/1');
exports.sha224 = require('./sha/224');
exports.sha256 = require('./sha/256');
exports.sha384 = require('./sha/384');
exports.sha512 = require('./sha/512');

},{"./sha/1":115,"./sha/224":116,"./sha/256":117,"./sha/384":118,"./sha/512":119}],115:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":111,"../utils":121,"./common":120}],116:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var SHA256 = require('./256');

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};


},{"../utils":121,"./256":117}],117:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var assert = require('minimalistic-assert');

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":111,"../utils":121,"./common":120,"minimalistic-assert":147}],118:[function(require,module,exports){
'use strict';

var utils = require('../utils');

var SHA512 = require('./512');

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

},{"../utils":121,"./512":119}],119:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var assert = require('minimalistic-assert');

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../common":111,"../utils":121,"minimalistic-assert":147}],120:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;

},{"../utils":121}],121:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"inherits":123,"minimalistic-assert":147}],122:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var utils = require('minimalistic-crypto-utils');
var assert = require('minimalistic-assert');

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};

},{"hash.js":110,"minimalistic-assert":147,"minimalistic-crypto-utils":148}],123:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24}],124:[function(require,module,exports){
/**
 * Returns a `Boolean` on whether or not the a `String` starts with '0x'
 * @param {String} str the string input value
 * @return {Boolean} a boolean if it is or is not hex prefixed
 * @throws if the str input is not a string
 */
module.exports = function isHexPrefixed(str) {
  if (typeof str !== 'string') {
    throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + (typeof str) + ", while checking isHexPrefixed.");
  }

  return str.slice(0, 2) === '0x';
}

},{}],125:[function(require,module,exports){
module.exports = require('./lib/api')(require('./lib/keccak'))

},{"./lib/api":126,"./lib/keccak":130}],126:[function(require,module,exports){
const createKeccak = require('./keccak')
const createShake = require('./shake')

module.exports = function (KeccakState) {
  const Keccak = createKeccak(KeccakState)
  const Shake = createShake(KeccakState)

  return function (algorithm, options) {
    const hash = typeof algorithm === 'string' ? algorithm.toLowerCase() : algorithm
    switch (hash) {
      case 'keccak224': return new Keccak(1152, 448, null, 224, options)
      case 'keccak256': return new Keccak(1088, 512, null, 256, options)
      case 'keccak384': return new Keccak(832, 768, null, 384, options)
      case 'keccak512': return new Keccak(576, 1024, null, 512, options)

      case 'sha3-224': return new Keccak(1152, 448, 0x06, 224, options)
      case 'sha3-256': return new Keccak(1088, 512, 0x06, 256, options)
      case 'sha3-384': return new Keccak(832, 768, 0x06, 384, options)
      case 'sha3-512': return new Keccak(576, 1024, 0x06, 512, options)

      case 'shake128': return new Shake(1344, 256, 0x1f, options)
      case 'shake256': return new Shake(1088, 512, 0x1f, options)

      default: throw new Error('Invald algorithm: ' + algorithm)
    }
  }
}

},{"./keccak":127,"./shake":128}],127:[function(require,module,exports){
(function (Buffer){(function (){
const { Transform } = require('readable-stream')

module.exports = (KeccakState) => class Keccak extends Transform {
  constructor (rate, capacity, delimitedSuffix, hashBitLength, options) {
    super(options)

    this._rate = rate
    this._capacity = capacity
    this._delimitedSuffix = delimitedSuffix
    this._hashBitLength = hashBitLength
    this._options = options

    this._state = new KeccakState()
    this._state.initialize(rate, capacity)
    this._finalized = false
  }

  _transform (chunk, encoding, callback) {
    let error = null
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }

    callback(error)
  }

  _flush (callback) {
    let error = null
    try {
      this.push(this.digest())
    } catch (err) {
      error = err
    }

    callback(error)
  }

  update (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
    if (this._finalized) throw new Error('Digest already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

    this._state.absorb(data)

    return this
  }

  digest (encoding) {
    if (this._finalized) throw new Error('Digest already called')
    this._finalized = true

    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix)
    let digest = this._state.squeeze(this._hashBitLength / 8)
    if (encoding !== undefined) digest = digest.toString(encoding)

    this._resetState()

    return digest
  }

  // remove result from memory
  _resetState () {
    this._state.initialize(this._rate, this._capacity)
    return this
  }

  // because sometimes we need hash right now and little later
  _clone () {
    const clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options)
    this._state.copy(clone._state)
    clone._finalized = this._finalized

    return clone
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":11,"readable-stream":145}],128:[function(require,module,exports){
(function (Buffer){(function (){
const { Transform } = require('readable-stream')

module.exports = (KeccakState) => class Shake extends Transform {
  constructor (rate, capacity, delimitedSuffix, options) {
    super(options)

    this._rate = rate
    this._capacity = capacity
    this._delimitedSuffix = delimitedSuffix
    this._options = options

    this._state = new KeccakState()
    this._state.initialize(rate, capacity)
    this._finalized = false
  }

  _transform (chunk, encoding, callback) {
    let error = null
    try {
      this.update(chunk, encoding)
    } catch (err) {
      error = err
    }

    callback(error)
  }

  _flush () {}

  _read (size) {
    this.push(this.squeeze(size))
  }

  update (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer')
    if (this._finalized) throw new Error('Squeeze already called')
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

    this._state.absorb(data)

    return this
  }

  squeeze (dataByteLength, encoding) {
    if (!this._finalized) {
      this._finalized = true
      this._state.absorbLastFewBits(this._delimitedSuffix)
    }

    let data = this._state.squeeze(dataByteLength)
    if (encoding !== undefined) data = data.toString(encoding)

    return data
  }

  _resetState () {
    this._state.initialize(this._rate, this._capacity)
    return this
  }

  _clone () {
    const clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options)
    this._state.copy(clone._state)
    clone._finalized = this._finalized

    return clone
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":11,"readable-stream":145}],129:[function(require,module,exports){
const P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648]

exports.p1600 = function (s) {
  for (let round = 0; round < 24; ++round) {
    // theta
    const lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40]
    const hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41]
    const lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42]
    const hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43]
    const lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44]
    const hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45]
    const lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46]
    const hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47]
    const lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48]
    const hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49]

    let lo = lo4 ^ (lo1 << 1 | hi1 >>> 31)
    let hi = hi4 ^ (hi1 << 1 | lo1 >>> 31)
    const t1slo0 = s[0] ^ lo
    const t1shi0 = s[1] ^ hi
    const t1slo5 = s[10] ^ lo
    const t1shi5 = s[11] ^ hi
    const t1slo10 = s[20] ^ lo
    const t1shi10 = s[21] ^ hi
    const t1slo15 = s[30] ^ lo
    const t1shi15 = s[31] ^ hi
    const t1slo20 = s[40] ^ lo
    const t1shi20 = s[41] ^ hi
    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31)
    hi = hi0 ^ (hi2 << 1 | lo2 >>> 31)
    const t1slo1 = s[2] ^ lo
    const t1shi1 = s[3] ^ hi
    const t1slo6 = s[12] ^ lo
    const t1shi6 = s[13] ^ hi
    const t1slo11 = s[22] ^ lo
    const t1shi11 = s[23] ^ hi
    const t1slo16 = s[32] ^ lo
    const t1shi16 = s[33] ^ hi
    const t1slo21 = s[42] ^ lo
    const t1shi21 = s[43] ^ hi
    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31)
    hi = hi1 ^ (hi3 << 1 | lo3 >>> 31)
    const t1slo2 = s[4] ^ lo
    const t1shi2 = s[5] ^ hi
    const t1slo7 = s[14] ^ lo
    const t1shi7 = s[15] ^ hi
    const t1slo12 = s[24] ^ lo
    const t1shi12 = s[25] ^ hi
    const t1slo17 = s[34] ^ lo
    const t1shi17 = s[35] ^ hi
    const t1slo22 = s[44] ^ lo
    const t1shi22 = s[45] ^ hi
    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31)
    hi = hi2 ^ (hi4 << 1 | lo4 >>> 31)
    const t1slo3 = s[6] ^ lo
    const t1shi3 = s[7] ^ hi
    const t1slo8 = s[16] ^ lo
    const t1shi8 = s[17] ^ hi
    const t1slo13 = s[26] ^ lo
    const t1shi13 = s[27] ^ hi
    const t1slo18 = s[36] ^ lo
    const t1shi18 = s[37] ^ hi
    const t1slo23 = s[46] ^ lo
    const t1shi23 = s[47] ^ hi
    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31)
    hi = hi3 ^ (hi0 << 1 | lo0 >>> 31)
    const t1slo4 = s[8] ^ lo
    const t1shi4 = s[9] ^ hi
    const t1slo9 = s[18] ^ lo
    const t1shi9 = s[19] ^ hi
    const t1slo14 = s[28] ^ lo
    const t1shi14 = s[29] ^ hi
    const t1slo19 = s[38] ^ lo
    const t1shi19 = s[39] ^ hi
    const t1slo24 = s[48] ^ lo
    const t1shi24 = s[49] ^ hi

    // rho & pi
    const t2slo0 = t1slo0
    const t2shi0 = t1shi0
    const t2slo16 = (t1shi5 << 4 | t1slo5 >>> 28)
    const t2shi16 = (t1slo5 << 4 | t1shi5 >>> 28)
    const t2slo7 = (t1slo10 << 3 | t1shi10 >>> 29)
    const t2shi7 = (t1shi10 << 3 | t1slo10 >>> 29)
    const t2slo23 = (t1shi15 << 9 | t1slo15 >>> 23)
    const t2shi23 = (t1slo15 << 9 | t1shi15 >>> 23)
    const t2slo14 = (t1slo20 << 18 | t1shi20 >>> 14)
    const t2shi14 = (t1shi20 << 18 | t1slo20 >>> 14)
    const t2slo10 = (t1slo1 << 1 | t1shi1 >>> 31)
    const t2shi10 = (t1shi1 << 1 | t1slo1 >>> 31)
    const t2slo1 = (t1shi6 << 12 | t1slo6 >>> 20)
    const t2shi1 = (t1slo6 << 12 | t1shi6 >>> 20)
    const t2slo17 = (t1slo11 << 10 | t1shi11 >>> 22)
    const t2shi17 = (t1shi11 << 10 | t1slo11 >>> 22)
    const t2slo8 = (t1shi16 << 13 | t1slo16 >>> 19)
    const t2shi8 = (t1slo16 << 13 | t1shi16 >>> 19)
    const t2slo24 = (t1slo21 << 2 | t1shi21 >>> 30)
    const t2shi24 = (t1shi21 << 2 | t1slo21 >>> 30)
    const t2slo20 = (t1shi2 << 30 | t1slo2 >>> 2)
    const t2shi20 = (t1slo2 << 30 | t1shi2 >>> 2)
    const t2slo11 = (t1slo7 << 6 | t1shi7 >>> 26)
    const t2shi11 = (t1shi7 << 6 | t1slo7 >>> 26)
    const t2slo2 = (t1shi12 << 11 | t1slo12 >>> 21)
    const t2shi2 = (t1slo12 << 11 | t1shi12 >>> 21)
    const t2slo18 = (t1slo17 << 15 | t1shi17 >>> 17)
    const t2shi18 = (t1shi17 << 15 | t1slo17 >>> 17)
    const t2slo9 = (t1shi22 << 29 | t1slo22 >>> 3)
    const t2shi9 = (t1slo22 << 29 | t1shi22 >>> 3)
    const t2slo5 = (t1slo3 << 28 | t1shi3 >>> 4)
    const t2shi5 = (t1shi3 << 28 | t1slo3 >>> 4)
    const t2slo21 = (t1shi8 << 23 | t1slo8 >>> 9)
    const t2shi21 = (t1slo8 << 23 | t1shi8 >>> 9)
    const t2slo12 = (t1slo13 << 25 | t1shi13 >>> 7)
    const t2shi12 = (t1shi13 << 25 | t1slo13 >>> 7)
    const t2slo3 = (t1slo18 << 21 | t1shi18 >>> 11)
    const t2shi3 = (t1shi18 << 21 | t1slo18 >>> 11)
    const t2slo19 = (t1shi23 << 24 | t1slo23 >>> 8)
    const t2shi19 = (t1slo23 << 24 | t1shi23 >>> 8)
    const t2slo15 = (t1slo4 << 27 | t1shi4 >>> 5)
    const t2shi15 = (t1shi4 << 27 | t1slo4 >>> 5)
    const t2slo6 = (t1slo9 << 20 | t1shi9 >>> 12)
    const t2shi6 = (t1shi9 << 20 | t1slo9 >>> 12)
    const t2slo22 = (t1shi14 << 7 | t1slo14 >>> 25)
    const t2shi22 = (t1slo14 << 7 | t1shi14 >>> 25)
    const t2slo13 = (t1slo19 << 8 | t1shi19 >>> 24)
    const t2shi13 = (t1shi19 << 8 | t1slo19 >>> 24)
    const t2slo4 = (t1slo24 << 14 | t1shi24 >>> 18)
    const t2shi4 = (t1shi24 << 14 | t1slo24 >>> 18)

    // chi
    s[0] = t2slo0 ^ (~t2slo1 & t2slo2)
    s[1] = t2shi0 ^ (~t2shi1 & t2shi2)
    s[10] = t2slo5 ^ (~t2slo6 & t2slo7)
    s[11] = t2shi5 ^ (~t2shi6 & t2shi7)
    s[20] = t2slo10 ^ (~t2slo11 & t2slo12)
    s[21] = t2shi10 ^ (~t2shi11 & t2shi12)
    s[30] = t2slo15 ^ (~t2slo16 & t2slo17)
    s[31] = t2shi15 ^ (~t2shi16 & t2shi17)
    s[40] = t2slo20 ^ (~t2slo21 & t2slo22)
    s[41] = t2shi20 ^ (~t2shi21 & t2shi22)
    s[2] = t2slo1 ^ (~t2slo2 & t2slo3)
    s[3] = t2shi1 ^ (~t2shi2 & t2shi3)
    s[12] = t2slo6 ^ (~t2slo7 & t2slo8)
    s[13] = t2shi6 ^ (~t2shi7 & t2shi8)
    s[22] = t2slo11 ^ (~t2slo12 & t2slo13)
    s[23] = t2shi11 ^ (~t2shi12 & t2shi13)
    s[32] = t2slo16 ^ (~t2slo17 & t2slo18)
    s[33] = t2shi16 ^ (~t2shi17 & t2shi18)
    s[42] = t2slo21 ^ (~t2slo22 & t2slo23)
    s[43] = t2shi21 ^ (~t2shi22 & t2shi23)
    s[4] = t2slo2 ^ (~t2slo3 & t2slo4)
    s[5] = t2shi2 ^ (~t2shi3 & t2shi4)
    s[14] = t2slo7 ^ (~t2slo8 & t2slo9)
    s[15] = t2shi7 ^ (~t2shi8 & t2shi9)
    s[24] = t2slo12 ^ (~t2slo13 & t2slo14)
    s[25] = t2shi12 ^ (~t2shi13 & t2shi14)
    s[34] = t2slo17 ^ (~t2slo18 & t2slo19)
    s[35] = t2shi17 ^ (~t2shi18 & t2shi19)
    s[44] = t2slo22 ^ (~t2slo23 & t2slo24)
    s[45] = t2shi22 ^ (~t2shi23 & t2shi24)
    s[6] = t2slo3 ^ (~t2slo4 & t2slo0)
    s[7] = t2shi3 ^ (~t2shi4 & t2shi0)
    s[16] = t2slo8 ^ (~t2slo9 & t2slo5)
    s[17] = t2shi8 ^ (~t2shi9 & t2shi5)
    s[26] = t2slo13 ^ (~t2slo14 & t2slo10)
    s[27] = t2shi13 ^ (~t2shi14 & t2shi10)
    s[36] = t2slo18 ^ (~t2slo19 & t2slo15)
    s[37] = t2shi18 ^ (~t2shi19 & t2shi15)
    s[46] = t2slo23 ^ (~t2slo24 & t2slo20)
    s[47] = t2shi23 ^ (~t2shi24 & t2shi20)
    s[8] = t2slo4 ^ (~t2slo0 & t2slo1)
    s[9] = t2shi4 ^ (~t2shi0 & t2shi1)
    s[18] = t2slo9 ^ (~t2slo5 & t2slo6)
    s[19] = t2shi9 ^ (~t2shi5 & t2shi6)
    s[28] = t2slo14 ^ (~t2slo10 & t2slo11)
    s[29] = t2shi14 ^ (~t2shi10 & t2shi11)
    s[38] = t2slo19 ^ (~t2slo15 & t2slo16)
    s[39] = t2shi19 ^ (~t2shi15 & t2shi16)
    s[48] = t2slo24 ^ (~t2slo20 & t2slo21)
    s[49] = t2shi24 ^ (~t2shi20 & t2shi21)

    // iota
    s[0] ^= P1600_ROUND_CONSTANTS[round * 2]
    s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1]
  }
}

},{}],130:[function(require,module,exports){
(function (Buffer){(function (){
const keccakState = require('./keccak-state-unroll')

function Keccak () {
  // much faster than `new Array(50)`
  this.state = [
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
  ]

  this.blockSize = null
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.initialize = function (rate, capacity) {
  for (let i = 0; i < 50; ++i) this.state[i] = 0
  this.blockSize = rate / 8
  this.count = 0
  this.squeezing = false
}

Keccak.prototype.absorb = function (data) {
  for (let i = 0; i < data.length; ++i) {
    this.state[~~(this.count / 4)] ^= data[i] << (8 * (this.count % 4))
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }
}

Keccak.prototype.absorbLastFewBits = function (bits) {
  this.state[~~(this.count / 4)] ^= bits << (8 * (this.count % 4))
  if ((bits & 0x80) !== 0 && this.count === (this.blockSize - 1)) keccakState.p1600(this.state)
  this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << (8 * ((this.blockSize - 1) % 4))
  keccakState.p1600(this.state)
  this.count = 0
  this.squeezing = true
}

Keccak.prototype.squeeze = function (length) {
  if (!this.squeezing) this.absorbLastFewBits(0x01)

  const output = Buffer.alloc(length)
  for (let i = 0; i < length; ++i) {
    output[i] = (this.state[~~(this.count / 4)] >>> (8 * (this.count % 4))) & 0xff
    this.count += 1
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state)
      this.count = 0
    }
  }

  return output
}

Keccak.prototype.copy = function (dest) {
  for (let i = 0; i < 50; ++i) dest.state[i] = this.state[i]
  dest.blockSize = this.blockSize
  dest.count = this.count
  dest.squeezing = this.squeezing
}

module.exports = Keccak

}).call(this)}).call(this,require("buffer").Buffer)

},{"./keccak-state-unroll":129,"buffer":11}],131:[function(require,module,exports){
arguments[4][95][0].apply(exports,arguments)
},{"dup":95}],132:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))

},{"./_stream_readable":134,"./_stream_writable":136,"_process":34,"inherits":123}],133:[function(require,module,exports){
arguments[4][97][0].apply(exports,arguments)
},{"./_stream_transform":135,"dup":97,"inherits":123}],134:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":131,"./_stream_duplex":132,"./internal/streams/async_iterator":137,"./internal/streams/buffer_list":138,"./internal/streams/destroy":139,"./internal/streams/from":141,"./internal/streams/state":143,"./internal/streams/stream":144,"_process":34,"buffer":11,"events":17,"inherits":123,"string_decoder/":165,"util":10}],135:[function(require,module,exports){
arguments[4][99][0].apply(exports,arguments)
},{"../errors":131,"./_stream_duplex":132,"dup":99,"inherits":123}],136:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../errors":131,"./_stream_duplex":132,"./internal/streams/destroy":139,"./internal/streams/state":143,"./internal/streams/stream":144,"_process":34,"buffer":11,"inherits":123,"util-deprecate":168}],137:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))

},{"./end-of-stream":140,"_process":34}],138:[function(require,module,exports){
arguments[4][102][0].apply(exports,arguments)
},{"buffer":11,"dup":102,"util":10}],139:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))

},{"_process":34}],140:[function(require,module,exports){
arguments[4][104][0].apply(exports,arguments)
},{"../../../errors":131,"dup":104}],141:[function(require,module,exports){
arguments[4][105][0].apply(exports,arguments)
},{"dup":105}],142:[function(require,module,exports){
arguments[4][106][0].apply(exports,arguments)
},{"../../../errors":131,"./end-of-stream":140,"dup":106}],143:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"../../../errors":131,"dup":107}],144:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"dup":43,"events":17}],145:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"./lib/_stream_duplex.js":132,"./lib/_stream_passthrough.js":133,"./lib/_stream_readable.js":134,"./lib/_stream_transform.js":135,"./lib/_stream_writable.js":136,"./lib/internal/streams/end-of-stream.js":140,"./lib/internal/streams/pipeline.js":142,"dup":109}],146:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var HashBase = require('hash-base')
var Buffer = require('safe-buffer').Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5

},{"hash-base":94,"inherits":123,"safe-buffer":153}],147:[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],148:[function(require,module,exports){
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

},{}],149:[function(require,module,exports){
(function (process,global){(function (){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":34,"safe-buffer":153}],150:[function(require,module,exports){
'use strict'
var Buffer = require('buffer').Buffer
var inherits = require('inherits')
var HashBase = require('hash-base')

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

},{"buffer":11,"hash-base":94,"inherits":123}],151:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLength = exports.decode = exports.encode = void 0;
var bn_js_1 = __importDefault(require("bn.js"));
/**
 * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
 * This function takes in a data, convert it to buffer if not, and a length for recursion
 * @param input - will be converted to buffer
 * @returns returns buffer of encoded data
 **/
function encode(input) {
    if (Array.isArray(input)) {
        var output = [];
        for (var i = 0; i < input.length; i++) {
            output.push(encode(input[i]));
        }
        var buf = Buffer.concat(output);
        return Buffer.concat([encodeLength(buf.length, 192), buf]);
    }
    else {
        var inputBuf = toBuffer(input);
        return inputBuf.length === 1 && inputBuf[0] < 128
            ? inputBuf
            : Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
    }
}
exports.encode = encode;
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 * @param base The base to parse the integer into
 */
function safeParseInt(v, base) {
    if (v[0] === '0' && v[1] === '0') {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseInt(v, base);
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Buffer.from([len + offset]);
    }
    else {
        var hexLength = intToHex(len);
        var lLength = hexLength.length / 2;
        var firstByte = intToHex(offset + 55 + lLength);
        return Buffer.from(firstByte + hexLength, 'hex');
    }
}
function decode(input, stream) {
    if (stream === void 0) { stream = false; }
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    var inputBuffer = toBuffer(input);
    var decoded = _decode(inputBuffer);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid remainder');
    }
    return decoded.data;
}
exports.decode = decode;
/**
 * Get the length of the RLP input
 * @param input
 * @returns The length of the input or an empty Buffer if no input
 */
function getLength(input) {
    if (!input || input.length === 0) {
        return Buffer.from([]);
    }
    var inputBuffer = toBuffer(input);
    var firstByte = inputBuffer[0];
    if (firstByte <= 0x7f) {
        return inputBuffer.length;
    }
    else if (firstByte <= 0xb7) {
        return firstByte - 0x7f;
    }
    else if (firstByte <= 0xbf) {
        return firstByte - 0xb6;
    }
    else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        return firstByte - 0xbf;
    }
    else {
        // a list  over 55 bytes long
        var llength = firstByte - 0xf6;
        var length_1 = safeParseInt(inputBuffer.slice(1, llength).toString('hex'), 16);
        return llength + length_1;
    }
}
exports.getLength = getLength;
/** Decode an input with RLP */
function _decode(input) {
    var length, llength, data, innerRemainder, d;
    var decoded = [];
    var firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Buffer.from([]);
        }
        else {
            data = input.slice(1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid rlp encoding: byte must be less 0x80');
        }
        return {
            data: data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = input.slice(llength, length + llength);
        if (data.length < length) {
            throw new Error('invalid RLP: not enough bytes for string');
        }
        return {
            data: data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between  0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = input.slice(1, length);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list  over 55 bytes long
        llength = firstByte - 0xf6;
        length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
        var totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid rlp: total length is larger than the data');
        }
        innerRemainder = input.slice(llength, totalLength);
        if (innerRemainder.length === 0) {
            throw new Error('invalid rlp, List has a invalid length');
        }
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed(str) {
    return str.slice(0, 2) === '0x';
}
/** Removes 0x from a given String */
function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform an integer into its hexadecimal value */
function intToHex(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    var hex = integer.toString(16);
    return hex.length % 2 ? "0" + hex : hex;
}
/** Pad a string to be even */
function padToEven(a) {
    return a.length % 2 ? "0" + a : a;
}
/** Transform an integer into a Buffer */
function intToBuffer(integer) {
    var hex = intToHex(integer);
    return Buffer.from(hex, 'hex');
}
/** Transform anything into a Buffer */
function toBuffer(v) {
    if (!Buffer.isBuffer(v)) {
        if (typeof v === 'string') {
            if (isHexPrefixed(v)) {
                return Buffer.from(padToEven(stripHexPrefix(v)), 'hex');
            }
            else {
                return Buffer.from(v);
            }
        }
        else if (typeof v === 'number' || typeof v === 'bigint') {
            if (!v) {
                return Buffer.from([]);
            }
            else {
                return intToBuffer(v);
            }
        }
        else if (v === null || v === undefined) {
            return Buffer.from([]);
        }
        else if (v instanceof Uint8Array) {
            return Buffer.from(v);
        }
        else if (bn_js_1.default.isBN(v)) {
            // converts a BN to a Buffer
            return Buffer.from(v.toArray());
        }
        else {
            throw new Error('invalid type');
        }
    }
    return v;
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"bn.js":152,"buffer":11}],152:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":10}],153:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":11}],154:[function(require,module,exports){
module.exports = require('./lib')(require('./lib/elliptic'))

},{"./lib":156,"./lib/elliptic":155}],155:[function(require,module,exports){
const EC = require('elliptic').ec

const ec = new EC('secp256k1')
const ecparams = ec.curve

// Hack, we can not use bn.js@5, while elliptic uses bn.js@4
// See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758
const BN = ecparams.n.constructor

function loadCompressedPublicKey (first, xbuf) {
  let x = new BN(xbuf)

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null
  x = x.toRed(ecparams.red)

  // compute corresponding Y
  let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadUncompressedPublicKey (first, xbuf, ybuf) {
  let x = new BN(xbuf)
  let y = new BN(ybuf)

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

  x = x.toRed(ecparams.red)
  y = y.toRed(ecparams.red)

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

  // x*x*x + b = y*y
  const x3 = x.redSqr().redIMul(x)
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadPublicKey (pubkey) {
  // length should be validated in interface
  const first = pubkey[0]
  switch (first) {
    case 0x02:
    case 0x03:
      if (pubkey.length !== 33) return null
      return loadCompressedPublicKey(first, pubkey.subarray(1, 33))
    case 0x04:
    case 0x06:
    case 0x07:
      if (pubkey.length !== 65) return null
      return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65))
    default:
      return null
  }
}

function savePublicKey (output, point) {
  const pubkey = point.encode(null, output.length === 33)
  // Loop should be faster because we do not need create extra Uint8Array
  // output.set(new Uint8Array(pubkey))
  for (let i = 0; i < output.length; ++i) output[i] = pubkey[i]
}

module.exports = {
  contextRandomize () {
    return 0
  },

  privateKeyVerify (seckey) {
    const bn = new BN(seckey)
    return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1
  },

  privateKeyNegate (seckey) {
    const bn = new BN(seckey)
    const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32)
    seckey.set(negate)
    return 0
  },

  privateKeyTweakAdd (seckey, tweak) {
    const bn = new BN(tweak)
    if (bn.cmp(ecparams.n) >= 0) return 1

    bn.iadd(new BN(seckey))
    if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
    if (bn.isZero()) return 1

    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
    seckey.set(tweaked)

    return 0
  },

  privateKeyTweakMul (seckey, tweak) {
    let bn = new BN(tweak)
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

    bn.imul(new BN(seckey))
    if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n)

    const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
    seckey.set(tweaked)

    return 0
  },

  publicKeyVerify (pubkey) {
    const pair = loadPublicKey(pubkey)
    return pair === null ? 1 : 0
  },

  publicKeyCreate (output, seckey) {
    const bn = new BN(seckey)
    if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

    const point = ec.keyFromPrivate(seckey).getPublic()
    savePublicKey(output, point)

    return 0
  },

  publicKeyConvert (output, pubkey) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const point = pair.getPublic()
    savePublicKey(output, point)

    return 0
  },

  publicKeyNegate (output, pubkey) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const point = pair.getPublic()
    point.y = point.y.redNeg()
    savePublicKey(output, point)

    return 0
  },

  publicKeyCombine (output, pubkeys) {
    const pairs = new Array(pubkeys.length)
    for (let i = 0; i < pubkeys.length; ++i) {
      pairs[i] = loadPublicKey(pubkeys[i])
      if (pairs[i] === null) return 1
    }

    let point = pairs[0].getPublic()
    for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub)
    if (point.isInfinity()) return 2

    savePublicKey(output, point)

    return 0
  },

  publicKeyTweakAdd (output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    tweak = new BN(tweak)
    if (tweak.cmp(ecparams.n) >= 0) return 2

    const point = pair.getPublic().add(ecparams.g.mul(tweak))
    if (point.isInfinity()) return 2

    savePublicKey(output, point)

    return 0
  },

  publicKeyTweakMul (output, pubkey, tweak) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    tweak = new BN(tweak)
    if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2

    const point = pair.getPublic().mul(tweak)
    savePublicKey(output, point)

    return 0
  },

  signatureNormalize (sig) {
    const r = new BN(sig.subarray(0, 32))
    const s = new BN(sig.subarray(32, 64))
    if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1

    if (s.cmp(ec.nh) === 1) {
      sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32)
    }

    return 0
  },

  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureExport (obj, sig) {
    const sigR = sig.subarray(0, 32)
    const sigS = sig.subarray(32, 64)
    if (new BN(sigR).cmp(ecparams.n) >= 0) return 1
    if (new BN(sigS).cmp(ecparams.n) >= 0) return 1

    const { output } = obj

    // Prepare R
    let r = output.subarray(4, 4 + 33)
    r[0] = 0x00
    r.set(sigR, 1)

    let lenR = 33
    let posR = 0
    for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

    r = r.subarray(posR)
    if (r[0] & 0x80) return 1
    if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) return 1

    // Prepare S
    let s = output.subarray(6 + 33, 6 + 33 + 33)
    s[0] = 0x00
    s.set(sigS, 1)

    let lenS = 33
    let posS = 0
    for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

    s = s.subarray(posS)
    if (s[0] & 0x80) return 1
    if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) return 1

    // Set output length for return
    obj.outputlen = 6 + lenR + lenS

    // Output in specified format
    // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
    output[0] = 0x30
    output[1] = obj.outputlen - 2
    output[2] = 0x02
    output[3] = r.length
    output.set(r, 4)
    output[4 + lenR] = 0x02
    output[5 + lenR] = s.length
    output.set(s, 6 + lenR)

    return 0
  },

  // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
  // Adapted for Uint8Array instead Buffer
  signatureImport (output, sig) {
    if (sig.length < 8) return 1
    if (sig.length > 72) return 1
    if (sig[0] !== 0x30) return 1
    if (sig[1] !== sig.length - 2) return 1
    if (sig[2] !== 0x02) return 1

    const lenR = sig[3]
    if (lenR === 0) return 1
    if (5 + lenR >= sig.length) return 1
    if (sig[4 + lenR] !== 0x02) return 1

    const lenS = sig[5 + lenR]
    if (lenS === 0) return 1
    if ((6 + lenR + lenS) !== sig.length) return 1

    if (sig[4] & 0x80) return 1
    if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80)) return 1

    if (sig[lenR + 6] & 0x80) return 1
    if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80)) return 1

    let sigR = sig.subarray(4, 4 + lenR)
    if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1)
    if (sigR.length > 32) return 1

    let sigS = sig.subarray(6 + lenR)
    if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1)
    if (sigS.length > 32) throw new Error('S length is too long')

    let r = new BN(sigR)
    if (r.cmp(ecparams.n) >= 0) r = new BN(0)

    let s = new BN(sig.subarray(6 + lenR))
    if (s.cmp(ecparams.n) >= 0) s = new BN(0)

    output.set(r.toArrayLike(Uint8Array, 'be', 32), 0)
    output.set(s.toArrayLike(Uint8Array, 'be', 32), 32)

    return 0
  },

  ecdsaSign (obj, message, seckey, data, noncefn) {
    if (noncefn) {
      const _noncefn = noncefn
      noncefn = (counter) => {
        const nonce = _noncefn(message, seckey, null, data, counter)

        const isValid = nonce instanceof Uint8Array && nonce.length === 32
        if (!isValid) throw new Error('This is the way')

        return new BN(nonce)
      }
    }

    const d = new BN(seckey)
    if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1

    let sig
    try {
      sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data })
    } catch (err) {
      return 1
    }

    obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0)
    obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32)
    obj.recid = sig.recoveryParam

    return 0
  },

  ecdsaVerify (sig, msg32, pubkey) {
    const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) }

    const sigr = new BN(sigObj.r)
    const sigs = new BN(sigObj.s)
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1
    if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3

    const pair = loadPublicKey(pubkey)
    if (pair === null) return 2

    const point = pair.getPublic()
    const isValid = ec.verify(msg32, sigObj, point)
    return isValid ? 0 : 3
  },

  ecdsaRecover (output, sig, recid, msg32) {
    const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) }

    const sigr = new BN(sigObj.r)
    const sigs = new BN(sigObj.s)
    if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1

    if (sigr.isZero() || sigs.isZero()) return 2

    // Can throw `throw new Error('Unable to find sencond key candinate');`
    let point
    try {
      point = ec.recoverPubKey(msg32, sigObj, recid)
    } catch (err) {
      return 2
    }

    savePublicKey(output, point)

    return 0
  },

  ecdh (output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
    const pair = loadPublicKey(pubkey)
    if (pair === null) return 1

    const scalar = new BN(seckey)
    if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2

    const point = pair.getPublic().mul(scalar)

    if (hashfn === undefined) {
      const data = point.encode(null, true)
      const sha256 = ec.hash().update(data).digest()
      for (let i = 0; i < 32; ++i) output[i] = sha256[i]
    } else {
      if (!xbuf) xbuf = new Uint8Array(32)
      const x = point.getX().toArray('be', 32)
      for (let i = 0; i < 32; ++i) xbuf[i] = x[i]

      if (!ybuf) ybuf = new Uint8Array(32)
      const y = point.getY().toArray('be', 32)
      for (let i = 0; i < 32; ++i) ybuf[i] = y[i]

      const hash = hashfn(xbuf, ybuf, data)

      const isValid = hash instanceof Uint8Array && hash.length === output.length
      if (!isValid) return 2

      output.set(hash)
    }

    return 0
  }
}

},{"elliptic":69}],156:[function(require,module,exports){
const errors = {
  IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
  TWEAK_ADD:
    'The tweak was out of range or the resulted private key is invalid',
  TWEAK_MUL: 'The tweak was out of range or equal to zero',
  CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
  SECKEY_INVALID: 'Private Key is invalid',
  PUBKEY_PARSE: 'Public Key could not be parsed',
  PUBKEY_SERIALIZE: 'Public Key serialization error',
  PUBKEY_COMBINE: 'The sum of the public keys is not valid',
  SIG_PARSE: 'Signature could not be parsed',
  SIGN: 'The nonce generation function failed, or the private key was invalid',
  RECOVER: 'Public key could not be recover',
  ECDH: 'Scalar was invalid (zero or overflow)'
}

function assert (cond, msg) {
  if (!cond) throw new Error(msg)
}

function isUint8Array (name, value, length) {
  assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)

  if (length !== undefined) {
    if (Array.isArray(length)) {
      const numbers = length.join(', ')
      const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`
      assert(length.includes(value.length), msg)
    } else {
      const msg = `Expected ${name} to be an Uint8Array with length ${length}`
      assert(value.length === length, msg)
    }
  }
}

function isCompressed (value) {
  assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')
}

function getAssertedOutput (output = (len) => new Uint8Array(len), length) {
  if (typeof output === 'function') output = output(length)
  isUint8Array('output', output, length)
  return output
}

function toTypeString (value) {
  return Object.prototype.toString.call(value).slice(8, -1)
}

module.exports = (secp256k1) => {
  return {
    contextRandomize (seed) {
      assert(
        seed === null || seed instanceof Uint8Array,
        'Expected seed to be an Uint8Array or null'
      )
      if (seed !== null) isUint8Array('seed', seed, 32)

      switch (secp256k1.contextRandomize(seed)) {
        case 1:
          throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)
      }
    },

    privateKeyVerify (seckey) {
      isUint8Array('private key', seckey, 32)

      return secp256k1.privateKeyVerify(seckey) === 0
    },

    privateKeyNegate (seckey) {
      isUint8Array('private key', seckey, 32)

      switch (secp256k1.privateKeyNegate(seckey)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    privateKeyTweakAdd (seckey, tweak) {
      isUint8Array('private key', seckey, 32)
      isUint8Array('tweak', tweak, 32)

      switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.TWEAK_ADD)
      }
    },

    privateKeyTweakMul (seckey, tweak) {
      isUint8Array('private key', seckey, 32)
      isUint8Array('tweak', tweak, 32)

      switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
        case 0:
          return seckey
        case 1:
          throw new Error(errors.TWEAK_MUL)
      }
    },

    publicKeyVerify (pubkey) {
      isUint8Array('public key', pubkey, [33, 65])

      return secp256k1.publicKeyVerify(pubkey) === 0
    },

    publicKeyCreate (seckey, compressed = true, output) {
      isUint8Array('private key', seckey, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyCreate(output, seckey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SECKEY_INVALID)
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyConvert (pubkey, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyConvert(output, pubkey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyNegate (pubkey, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyNegate(output, pubkey)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyCombine (pubkeys, compressed = true, output) {
      assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')
      assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')
      for (const pubkey of pubkeys) {
        isUint8Array('public key', pubkey, [33, 65])
      }
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyCombine(output, pubkeys)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_COMBINE)
        case 3:
          throw new Error(errors.PUBKEY_SERIALIZE)
      }
    },

    publicKeyTweakAdd (pubkey, tweak, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('tweak', tweak, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.TWEAK_ADD)
      }
    },

    publicKeyTweakMul (pubkey, tweak, compressed = true, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('tweak', tweak, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.TWEAK_MUL)
      }
    },

    signatureNormalize (sig) {
      isUint8Array('signature', sig, 64)

      switch (secp256k1.signatureNormalize(sig)) {
        case 0:
          return sig
        case 1:
          throw new Error(errors.SIG_PARSE)
      }
    },

    signatureExport (sig, output) {
      isUint8Array('signature', sig, 64)
      output = getAssertedOutput(output, 72)

      const obj = { output, outputlen: 72 }
      switch (secp256k1.signatureExport(obj, sig)) {
        case 0:
          return output.slice(0, obj.outputlen)
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    signatureImport (sig, output) {
      isUint8Array('signature', sig)
      output = getAssertedOutput(output, 64)

      switch (secp256k1.signatureImport(output, sig)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdsaSign (msg32, seckey, options = {}, output) {
      isUint8Array('message', msg32, 32)
      isUint8Array('private key', seckey, 32)
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
      if (options.data !== undefined) isUint8Array('options.data', options.data)
      if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')
      output = getAssertedOutput(output, 64)

      const obj = { signature: output, recid: null }
      switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
        case 0:
          return obj
        case 1:
          throw new Error(errors.SIGN)
        case 2:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdsaVerify (sig, msg32, pubkey) {
      isUint8Array('signature', sig, 64)
      isUint8Array('message', msg32, 32)
      isUint8Array('public key', pubkey, [33, 65])

      switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
        case 0:
          return true
        case 3:
          return false
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.PUBKEY_PARSE)
      }
    },

    ecdsaRecover (sig, recid, msg32, compressed = true, output) {
      isUint8Array('signature', sig, 64)
      assert(
        toTypeString(recid) === 'Number' &&
          recid >= 0 &&
          recid <= 3,
        'Expected recovery id to be a Number within interval [0, 3]'
      )
      isUint8Array('message', msg32, 32)
      isCompressed(compressed)
      output = getAssertedOutput(output, compressed ? 33 : 65)

      switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.SIG_PARSE)
        case 2:
          throw new Error(errors.RECOVER)
        case 3:
          throw new Error(errors.IMPOSSIBLE_CASE)
      }
    },

    ecdh (pubkey, seckey, options = {}, output) {
      isUint8Array('public key', pubkey, [33, 65])
      isUint8Array('private key', seckey, 32)
      assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
      if (options.data !== undefined) isUint8Array('options.data', options.data)
      if (options.hashfn !== undefined) {
        assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')
        if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)
        if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)
        isUint8Array('output', output)
      } else {
        output = getAssertedOutput(output, 32)
      }

      switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
        case 0:
          return output
        case 1:
          throw new Error(errors.PUBKEY_PARSE)
        case 2:
          throw new Error(errors.ECDH)
      }
    }
  }
}

},{}],157:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

},{"safe-buffer":153}],158:[function(require,module,exports){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":159,"./sha1":160,"./sha224":161,"./sha256":162,"./sha384":163,"./sha512":164}],159:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

},{"./hash":157,"inherits":123,"safe-buffer":153}],160:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

},{"./hash":157,"inherits":123,"safe-buffer":153}],161:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

},{"./hash":157,"./sha256":162,"inherits":123,"safe-buffer":153}],162:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

},{"./hash":157,"inherits":123,"safe-buffer":153}],163:[function(require,module,exports){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

},{"./hash":157,"./sha512":164,"inherits":123,"safe-buffer":153}],164:[function(require,module,exports){
var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

},{"./hash":157,"inherits":123,"safe-buffer":153}],165:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"dup":45,"safe-buffer":166}],166:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"buffer":11,"dup":44}],167:[function(require,module,exports){
var isHexPrefixed = require('is-hex-prefixed');

/**
 * Removes '0x' from a given `String` is present
 * @param {String} str the string value
 * @return {String|Optional} a string by pass if necessary
 */
module.exports = function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }

  return isHexPrefixed(str) ? str.slice(2) : str;
}

},{"is-hex-prefixed":124}],168:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],169:[function(require,module,exports){
const codes = {
  // 0x0 range - arithmetic ops
  // name, baseCost, off stack, on stack
  0x00: ['STOP', 0, 0, 0],
  0x01: ['ADD', 3, 2, 1],
  0x02: ['MUL', 5, 2, 1],
  0x03: ['SUB', 3, 2, 1],
  0x04: ['DIV', 5, 2, 1],
  0x05: ['SDIV', 5, 2, 1],
  0x06: ['MOD', 5, 2, 1],
  0x07: ['SMOD', 5, 2, 1],
  0x08: ['ADDMOD', 8, 3, 1],
  0x09: ['MULMOD', 8, 3, 1],
  0x0a: ['EXP', 10, 2, 1],
  0x0b: ['SIGNEXTEND', 5, 2, 1],

  // 0x10 range - bit ops
  0x10: ['LT', 3, 2, 1],
  0x11: ['GT', 3, 2, 1],
  0x12: ['SLT', 3, 2, 1],
  0x13: ['SGT', 3, 2, 1],
  0x14: ['EQ', 3, 2, 1],
  0x15: ['ISZERO', 3, 1, 1],
  0x16: ['AND', 3, 2, 1],
  0x17: ['OR', 3, 2, 1],
  0x18: ['XOR', 3, 2, 1],
  0x19: ['NOT', 3, 1, 1],
  0x1a: ['BYTE', 3, 2, 1],
  0x1b: ['SHL', 3, 2, 1],
  0x1c: ['SHR', 3, 2, 1],
  0x1d: ['SAR', 3, 2, 1],

  // 0x20 range - crypto
  0x20: ['SHA3', 30, 2, 1],

  // 0x30 range - closure state
  0x30: ['ADDRESS', 0, 0, 1],
  0x31: ['BALANCE', 0, 1, 1],
  0x32: ['ORIGIN', 0, 0, 1],
  0x33: ['CALLER', 0, 0, 1],
  0x34: ['CALLVALUE', 0, 0, 1],
  0x35: ['CALLDATALOAD', 0, 1, 1],
  0x36: ['CALLDATASIZE', 0, 0, 1],
  0x37: ['CALLDATACOPY', 0, 3, 0],
  0x38: ['CODESIZE', 0, 0, 1],
  0x39: ['CODECOPY', 0, 3, 0],
  0x3a: ['GASPRICE', 0, 0, 1],
  0x3b: ['EXTCODESIZE', 0, 1, 1],
  0x3c: ['EXTCODECOPY', 0, 4, 0],
  0x3d: ['RETURNDATASIZE', 0, 0, 1],
  0x3e: ['RETURNDATACOPY', 0, 3, 0],

  // '0x40' range - block operations
  0x3f: ['EXTCODEHASH', 0, 1, 1],
  0x40: ['BLOCKHASH', 0, 1, 1],
  0x41: ['COINBASE', 0, 0, 1],
  0x42: ['TIMESTAMP', 0, 0, 1],
  0x43: ['NUMBER', 0, 0, 1],
  0x44: ['DIFFICULTY', 0, 0, 1],
  0x45: ['GASLIMIT', 0, 0, 1],
  0x46: ['CHAINID', 2, 0, 1],
  0x47: ['SELFBALANCE', 5, 0, 1],
  0x48: ['BASEFEE', 2, 0, 1],

  // 0x50 range - 'storage' and execution
  0x50: ['POP', 2, 1, 0],
  0x51: ['MLOAD', 3, 1, 1],
  0x52: ['MSTORE', 3, 2, 0],
  0x53: ['MSTORE8', 3, 2, 0],
  0x54: ['SLOAD', 0, 1, 1],
  0x55: ['SSTORE', 0, 2, 0],
  0x56: ['JUMP', 8, 0, 0],
  0x57: ['JUMPI', 10, 0, 0],
  0x58: ['PC', 2, 0, 1],
  0x59: ['MSIZE', 2, 0, 1],
  0x5a: ['GAS', 0, 0, 1],
  0x5b: ['JUMPDEST', 0, 0, 0],

  // 0x60, range
  0x60: ['PUSH', 3, 0, 1],
  0x61: ['PUSH', 3, 0, 1],
  0x62: ['PUSH', 3, 0, 1],
  0x63: ['PUSH', 3, 0, 1],
  0x64: ['PUSH', 3, 0, 1],
  0x65: ['PUSH', 3, 0, 1],
  0x66: ['PUSH', 3, 0, 1],
  0x67: ['PUSH', 3, 0, 1],
  0x68: ['PUSH', 3, 0, 1],
  0x69: ['PUSH', 3, 0, 1],
  0x6a: ['PUSH', 3, 0, 1],
  0x6b: ['PUSH', 3, 0, 1],
  0x6c: ['PUSH', 3, 0, 1],
  0x6d: ['PUSH', 3, 0, 1],
  0x6e: ['PUSH', 3, 0, 1],
  0x6f: ['PUSH', 3, 0, 1],
  0x70: ['PUSH', 3, 0, 1],
  0x71: ['PUSH', 3, 0, 1],
  0x72: ['PUSH', 3, 0, 1],
  0x73: ['PUSH', 3, 0, 1],
  0x74: ['PUSH', 3, 0, 1],
  0x75: ['PUSH', 3, 0, 1],
  0x76: ['PUSH', 3, 0, 1],
  0x77: ['PUSH', 3, 0, 1],
  0x78: ['PUSH', 3, 0, 1],
  0x79: ['PUSH', 3, 0, 1],
  0x7a: ['PUSH', 3, 0, 1],
  0x7b: ['PUSH', 3, 0, 1],
  0x7c: ['PUSH', 3, 0, 1],
  0x7d: ['PUSH', 3, 0, 1],
  0x7e: ['PUSH', 3, 0, 1],
  0x7f: ['PUSH', 3, 0, 1],

  0x80: ['DUP', 3, 0, 1],
  0x81: ['DUP', 3, 0, 1],
  0x82: ['DUP', 3, 0, 1],
  0x83: ['DUP', 3, 0, 1],
  0x84: ['DUP', 3, 0, 1],
  0x85: ['DUP', 3, 0, 1],
  0x86: ['DUP', 3, 0, 1],
  0x87: ['DUP', 3, 0, 1],
  0x88: ['DUP', 3, 0, 1],
  0x89: ['DUP', 3, 0, 1],
  0x8a: ['DUP', 3, 0, 1],
  0x8b: ['DUP', 3, 0, 1],
  0x8c: ['DUP', 3, 0, 1],
  0x8d: ['DUP', 3, 0, 1],
  0x8e: ['DUP', 3, 0, 1],
  0x8f: ['DUP', 3, 0, 1],

  0x90: ['SWAP', 3, 0, 0],
  0x91: ['SWAP', 3, 0, 0],
  0x92: ['SWAP', 3, 0, 0],
  0x93: ['SWAP', 3, 0, 0],
  0x94: ['SWAP', 3, 0, 0],
  0x95: ['SWAP', 3, 0, 0],
  0x96: ['SWAP', 3, 0, 0],
  0x97: ['SWAP', 3, 0, 0],
  0x98: ['SWAP', 3, 0, 0],
  0x99: ['SWAP', 3, 0, 0],
  0x9a: ['SWAP', 3, 0, 0],
  0x9b: ['SWAP', 3, 0, 0],
  0x9c: ['SWAP', 3, 0, 0],
  0x9d: ['SWAP', 3, 0, 0],
  0x9e: ['SWAP', 3, 0, 0],
  0x9f: ['SWAP', 3, 0, 0],

  0xa0: ['LOG', 0, 2, 0],
  0xa1: ['LOG', 0, 3, 0],
  0xa2: ['LOG', 0, 4, 0],
  0xa3: ['LOG', 0, 5, 0],
  0xa4: ['LOG', 0, 6, 0],

  // '0xf0' range - closures
  0xf0: ['CREATE', 0, 3, 1],
  0xf1: ['CALL', 0, 7, 1],
  0xf2: ['CALLCODE', 0, 7, 1],
  0xf3: ['RETURN', 0, 2, 0],
  0xf4: ['DELEGATECALL', 0, 6, 1],
  0xf5: ['CREATE2', 0, 4, 1],
  0xfa: ['STATICCALL', 0, 6, 1],

  // '0x70', range - other
  0xfd: ['REVERT', 0, 2, 0],
  0xfe: ['INVALID', 0, 0, 0],
  0xff: ['SELFDESTRUCT', 0, 1, 0]
}

module.exports = function (op) {
  // Map invalid opcodes to the INVALID opcode
  if (!codes[op] && op != 0xfe) {
    console.info("Opcode not supported or part of the metadata tail: ", op.toString(16));
  }
  const code = codes[op] ? codes[op] : codes[0xfe]
  let opcode = code[0]
  let number

  switch (opcode) {
    case 'LOG':
      number = op - 0xa0
      break

    case 'PUSH':
      number = op - 0x5f
      break

    case 'DUP':
      number = op - 0x7f
      break

    case 'SWAP':
      number = op - 0x8f
      break
  }

  return {
    name: opcode,
    fee: code[1],
    off: code[2],
    on: code[3],
    number: number
  }
}

},{}],170:[function(require,module,exports){
module.exports={
  "LOG": {
    "wast": "(func $LOG\n  (param $number i32)\n\n  (local $offset i32)\n  (local $offset0 i64)\n  (local $offset1 i64)\n  (local $offset2 i64)\n  (local $offset3 i64)\n\n  (local $length i32)\n  (local $length0 i64)\n  (local $length1 i64)\n  (local $length2 i64)\n  (local $length3 i64)\n\n  (local.set $offset0 (i64.load          (global.get $sp)))\n  (local.set $offset1 (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $offset2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $offset3 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n\n  (local.set $length0 (i64.load (i32.sub (global.get $sp) (i32.const 32))))\n  (local.set $length1 (i64.load (i32.sub (global.get $sp) (i32.const 24))))\n  (local.set $length2 (i64.load (i32.sub (global.get $sp) (i32.const 16))))\n  (local.set $length3 (i64.load (i32.sub (global.get $sp) (i32.const  8))))\n\n  (local.set $offset\n             (call $check_overflow (local.get $offset0)\n                                   (local.get $offset1)\n                                   (local.get $offset2)\n                                   (local.get $offset3)))\n\n  (local.set $length\n             (call $check_overflow (local.get $length0)\n                                   (local.get $length1)\n                                   (local.get $length2)\n                                   (local.get $length3)))\n\n  (call $memusegas (local.get $offset) (local.get $length))\n\n  (if (i32.eq (local.get $number) (i32.const 0))\n    (then\n      (call $log\n             (local.get $offset)\n             (local.get $length)\n             (local.get $number)\n             (i32.const  0)\n             (i32.const  0)\n             (i32.const  0)\n             (i32.const  0))\n    )\n  )\n  (if (i32.eq (local.get $number) (i32.const 1))\n    (then\n    (call $log\n             (local.get $offset)\n             (local.get $length)\n             (local.get $number)\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  64)))\n             (i32.const  0)\n             (i32.const  0)\n             (i32.const  0))\n    )\n  )\n  (if (i32.eq (local.get $number) (i32.const 2))\n    (then\n    (call $log\n             (local.get $offset)\n             (local.get $length)\n             (local.get $number)\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  64)))\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  96)))\n             (i32.const  0)\n             (i32.const  0))\n    )\n  )\n  (if (i32.eq (local.get $number) (i32.const 3))\n    (then\n    (call $log\n             (local.get $offset)\n             (local.get $length)\n             (local.get $number)\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  64)))\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  96)))\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const 128)))\n             (i32.const  0))\n    )\n  )\n  (if (i32.eq (local.get $number) (i32.const 4))\n    (then\n    (call $log\n             (local.get $offset)\n             (local.get $length)\n             (local.get $number)\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  64)))\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  96)))\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const 128)))\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const 160))))\n    )\n  )\n)\n",
    "imports": "(import \"env\" \"ethereum_log\" (func $log (param i32 i32 i32 i32 i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"LOG\" (func $LOG))"
  },
  "CALLDATALOAD": {
    "wast": ";; stack:\n;;  0: dataOffset\n(func $CALLDATALOAD\n  (local $writeOffset i32)\n  (local $writeOffset0 i64)\n  (local $writeOffset1 i64)\n  (local $writeOffset2 i64)\n  (local $writeOffset3 i64)\n\n  (local.set $writeOffset0 (i64.load (i32.add (global.get $sp) (i32.const  0))))\n  (local.set $writeOffset1 (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $writeOffset2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $writeOffset3 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n\n  (i64.store (i32.add (global.get $sp) (i32.const  0)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.const 0))\n\n  (local.set $writeOffset\n             (call $check_overflow (local.get $writeOffset0)\n                                   (local.get $writeOffset1)\n                                   (local.get $writeOffset2)\n                                   (local.get $writeOffset3)))\n\n  (call $callDataCopy (global.get $sp) (local.get $writeOffset) (i32.const 32))\n  ;; swap top stack item\n  (drop (call $bswap_m256 (global.get $sp)))\n)\n",
    "imports": "(import \"env\" \"ethereum_callDataCopy\" (func $callDataCopy (param i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"CALLDATALOAD\" (func $CALLDATALOAD))"
  },
  "GAS": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $GAS   (i64.store (i32.add (global.get $sp) (i32.const 32)) (call $getGasLeft))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getGasLeft\" (func $getGasLeft  (result i64)))",
    "inline_imports": "(import \"ewasm\" \"GAS\" (func $GAS))"
  },
  "ADDRESS": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $ADDRESS   (call $getAddress(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getAddress\" (func $getAddress (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"ADDRESS\" (func $ADDRESS))"
  },
  "BALANCE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $BALANCE (param $callback i32)  (call $getExternalBalance(call $bswap_m256 (global.get $sp))(global.get $sp)(local.get $callback))(drop (call $bswap_m256 (global.get $sp))))",
    "imports": "(import \"env\" \"ethereum_getExternalBalance\" (func $getExternalBalance (param i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"BALANCE\" (func $BALANCE))"
  },
  "SELFBALANCE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $SELFBALANCE (param $callback i32)  (call $getBalance(i32.add (global.get $sp) (i32.const 32))(local.get $callback))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getBalance\" (func $getBalance (param i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"SELFBALANCE\" (func $SELFBALANCE))"
  },
  "CHAINID": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CHAINID (param $callback i32)  (call $getChainId(i32.add (global.get $sp) (i32.const 32))(local.get $callback))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getChainId\" (func $getChainId (param i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"CHAINID\" (func $CHAINID))"
  },
  "BASEFEE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $BASEFEE (param $callback i32)  (call $getBaseFee(i32.add (global.get $sp) (i32.const 32))(local.get $callback))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getBaseFee\" (func $getBaseFee (param i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"BASEFEE\" (func $BASEFEE))"
  },
  "ORIGIN": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $ORIGIN   (call $getTxOrigin(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getTxOrigin\" (func $getTxOrigin (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"ORIGIN\" (func $ORIGIN))"
  },
  "CALLER": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLER   (call $getCaller(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getCaller\" (func $getCaller (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"CALLER\" (func $CALLER))"
  },
  "CALLVALUE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLVALUE   (call $getCallValue(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getCallValue\" (func $getCallValue (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"CALLVALUE\" (func $CALLVALUE))"
  },
  "CALLDATASIZE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLDATASIZE   (i64.store (i32.add (global.get $sp) (i32.const 32)) (i64.extend_i32_u (call $getCallDataSize)))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getCallDataSize\" (func $getCallDataSize  (result i32)))",
    "inline_imports": "(import \"ewasm\" \"CALLDATASIZE\" (func $CALLDATASIZE))"
  },
  "CALLDATACOPY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLDATACOPY (local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $callDataCopy(local.get $offset0)(call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8))))(local.get $length0)))",
    "imports": "(import \"env\" \"ethereum_callDataCopy\" (func $callDataCopy (param i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"CALLDATACOPY\" (func $CALLDATACOPY))"
  },
  "CODESIZE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CODESIZE (param $callback i32)  (i64.store (i32.add (global.get $sp) (i32.const 32)) (i64.extend_i32_u (call $getCodeSize(local.get $callback))))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getCodeSize\" (func $getCodeSize (param i32) (result i32)))",
    "inline_imports": "(import \"ewasm\" \"CODESIZE\" (func $CODESIZE))"
  },
  "CODECOPY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CODECOPY (param $callback i32)(local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $codeCopy(local.get $offset0)(call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8))))(local.get $length0)(local.get $callback)))",
    "imports": "(import \"env\" \"ethereum_codeCopy\" (func $codeCopy (param i32 i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"CODECOPY\" (func $CODECOPY))"
  },
  "EXTCODESIZE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $EXTCODESIZE (param $callback i32)  (i64.store (global.get $sp) (i64.extend_i32_u (call $getExternalCodeSize(call $bswap_m256 (global.get $sp))(local.get $callback))))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 8)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getExternalCodeSize\" (func $getExternalCodeSize (param i32 i32) (result i32)))",
    "inline_imports": "(import \"ewasm\" \"EXTCODESIZE\" (func $EXTCODESIZE))"
  },
  "EXTCODEHASH": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $EXTCODEHASH (param $callback i32)  (call $getExternalCodeHash(call $bswap_m256 (global.get $sp))(global.get $sp)(local.get $callback))(drop (call $bswap_m256 (global.get $sp))))",
    "imports": "(import \"env\" \"ethereum_getExternalCodeHash\" (func $getExternalCodeHash (param i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"EXTCODEHASH\" (func $EXTCODEHASH))"
  },
  "EXTCODECOPY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $EXTCODECOPY (param $callback i32)(local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -96)))\n          (i64.load (i32.add (global.get $sp) (i32.const -88)))\n          (i64.load (i32.add (global.get $sp) (i32.const -80)))\n          (i64.load (i32.add (global.get $sp) (i32.const -72)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $externalCodeCopy(call $bswap_m256 (global.get $sp))(local.get $offset0)(call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40))))(local.get $length0)(local.get $callback)))",
    "imports": "(import \"env\" \"ethereum_externalCodeCopy\" (func $externalCodeCopy (param i32 i32 i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"EXTCODECOPY\" (func $EXTCODECOPY))"
  },
  "GASPRICE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $GASPRICE   (call $getTxGasPrice(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getTxGasPrice\" (func $getTxGasPrice (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"GASPRICE\" (func $GASPRICE))"
  },
  "BLOCKHASH": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $BLOCKHASH (param $callback i32)  (call $getBlockHash(call $check_overflow_i64\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24))))(global.get $sp)(local.get $callback))(drop (call $bswap_m256 (global.get $sp))))",
    "imports": "(import \"env\" \"ethereum_getBlockHash\" (func $getBlockHash (param i64 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"BLOCKHASH\" (func $BLOCKHASH))"
  },
  "COINBASE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $COINBASE   (call $getBlockCoinbase(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getBlockCoinbase\" (func $getBlockCoinbase (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"COINBASE\" (func $COINBASE))"
  },
  "TIMESTAMP": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $TIMESTAMP   (i64.store (i32.add (global.get $sp) (i32.const 32)) (call $getBlockTimestamp))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getBlockTimestamp\" (func $getBlockTimestamp  (result i64)))",
    "inline_imports": "(import \"ewasm\" \"TIMESTAMP\" (func $TIMESTAMP))"
  },
  "NUMBER": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $NUMBER   (i64.store (i32.add (global.get $sp) (i32.const 32)) (call $getBlockNumber))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getBlockNumber\" (func $getBlockNumber  (result i64)))",
    "inline_imports": "(import \"ewasm\" \"NUMBER\" (func $NUMBER))"
  },
  "DIFFICULTY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $DIFFICULTY   (call $getBlockDifficulty(i32.add (global.get $sp) (i32.const 32))))",
    "imports": "(import \"env\" \"ethereum_getBlockDifficulty\" (func $getBlockDifficulty (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"DIFFICULTY\" (func $DIFFICULTY))"
  },
  "GASLIMIT": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $GASLIMIT   (i64.store (i32.add (global.get $sp) (i32.const 32)) (call $getBlockGasLimit))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getBlockGasLimit\" (func $getBlockGasLimit  (result i64)))",
    "inline_imports": "(import \"ewasm\" \"GASLIMIT\" (func $GASLIMIT))"
  },
  "CREATE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CREATE (param $callback i32)(local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $create(call $bswap_m256 (global.get $sp))(local.get $offset0)(local.get $length0)(i32.add (global.get $sp) (i32.const -64))(local.get $callback))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const -64)))))",
    "imports": "(import \"env\" \"ethereum_create\" (func $create (param i32 i32 i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"CREATE\" (func $CREATE))"
  },
  "CREATE2": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CREATE2 (param $callback i32)(local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $create2(call $bswap_m256 (global.get $sp))(local.get $offset0)(local.get $length0)(call $bswap_m256 (i32.add (global.get $sp) (i32.const -96)))(i32.add (global.get $sp) (i32.const -96))(local.get $callback))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const -96)))))",
    "imports": "(import \"env\" \"ethereum_create2\" (func $create2 (param i32 i32 i32 i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"CREATE2\" (func $CREATE2))"
  },
  "CALL": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALL (param $callback i32)(local $offset0 i32)(local $length0 i32)(local $offset1 i32)(local $length1 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -96)))\n          (i64.load (i32.add (global.get $sp) (i32.const -88)))\n          (i64.load (i32.add (global.get $sp) (i32.const -80)))\n          (i64.load (i32.add (global.get $sp) (i32.const -72)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -128)))\n          (i64.load (i32.add (global.get $sp) (i32.const -120)))\n          (i64.load (i32.add (global.get $sp) (i32.const -112)))\n          (i64.load (i32.add (global.get $sp) (i32.const -104)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0)))(local.set $offset1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -160)))\n          (i64.load (i32.add (global.get $sp) (i32.const -152)))\n          (i64.load (i32.add (global.get $sp) (i32.const -144)))\n          (i64.load (i32.add (global.get $sp) (i32.const -136)))))(local.set $length1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -192)))\n          (i64.load (i32.add (global.get $sp) (i32.const -184)))\n          (i64.load (i32.add (global.get $sp) (i32.const -176)))\n          (i64.load (i32.add (global.get $sp) (i32.const -168)))))\n    (call $memusegas (local.get $offset1) (local.get $length1))\n    (local.set $offset1 (i32.add (global.get $memstart) (local.get $offset1))) (i64.store (i32.add (global.get $sp) (i32.const -192)) (i64.extend_i32_u (i32.eqz (call $call(call $check_overflow_i64\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24))))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -32)))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -64)))(local.get $offset0)(local.get $length0)(local.get $offset1)(local.get $length1)(local.get $callback)))))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const -168)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -176)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -184)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_call\" (func $call (param i64 i32 i32 i32 i32 i32 i32 i32) (result i32)))",
    "inline_imports": "(import \"ewasm\" \"CALL\" (func $CALL))"
  },
  "CALLCODE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLCODE (param $callback i32)(local $offset0 i32)(local $length0 i32)(local $offset1 i32)(local $length1 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -96)))\n          (i64.load (i32.add (global.get $sp) (i32.const -88)))\n          (i64.load (i32.add (global.get $sp) (i32.const -80)))\n          (i64.load (i32.add (global.get $sp) (i32.const -72)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -128)))\n          (i64.load (i32.add (global.get $sp) (i32.const -120)))\n          (i64.load (i32.add (global.get $sp) (i32.const -112)))\n          (i64.load (i32.add (global.get $sp) (i32.const -104)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0)))(local.set $offset1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -160)))\n          (i64.load (i32.add (global.get $sp) (i32.const -152)))\n          (i64.load (i32.add (global.get $sp) (i32.const -144)))\n          (i64.load (i32.add (global.get $sp) (i32.const -136)))))(local.set $length1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -192)))\n          (i64.load (i32.add (global.get $sp) (i32.const -184)))\n          (i64.load (i32.add (global.get $sp) (i32.const -176)))\n          (i64.load (i32.add (global.get $sp) (i32.const -168)))))\n    (call $memusegas (local.get $offset1) (local.get $length1))\n    (local.set $offset1 (i32.add (global.get $memstart) (local.get $offset1))) (i64.store (i32.add (global.get $sp) (i32.const -192)) (i64.extend_i32_u (i32.eqz (call $callCode(call $check_overflow_i64\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24))))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -32)))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -64)))(local.get $offset0)(local.get $length0)(local.get $offset1)(local.get $length1)(local.get $callback)))))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const -168)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -176)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -184)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_callCode\" (func $callCode (param i64 i32 i32 i32 i32 i32 i32 i32) (result i32)))",
    "inline_imports": "(import \"ewasm\" \"CALLCODE\" (func $CALLCODE))"
  },
  "DELEGATECALL": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $DELEGATECALL (param $callback i32)(local $offset0 i32)(local $length0 i32)(local $offset1 i32)(local $length1 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -96)))\n          (i64.load (i32.add (global.get $sp) (i32.const -88)))\n          (i64.load (i32.add (global.get $sp) (i32.const -80)))\n          (i64.load (i32.add (global.get $sp) (i32.const -72)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0)))(local.set $offset1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -128)))\n          (i64.load (i32.add (global.get $sp) (i32.const -120)))\n          (i64.load (i32.add (global.get $sp) (i32.const -112)))\n          (i64.load (i32.add (global.get $sp) (i32.const -104)))))(local.set $length1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -160)))\n          (i64.load (i32.add (global.get $sp) (i32.const -152)))\n          (i64.load (i32.add (global.get $sp) (i32.const -144)))\n          (i64.load (i32.add (global.get $sp) (i32.const -136)))))\n    (call $memusegas (local.get $offset1) (local.get $length1))\n    (local.set $offset1 (i32.add (global.get $memstart) (local.get $offset1))) (i64.store (i32.add (global.get $sp) (i32.const -160)) (i64.extend_i32_u (i32.eqz (call $callDelegate(call $check_overflow_i64\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24))))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -32)))(local.get $offset0)(local.get $length0)(local.get $offset1)(local.get $length1)(local.get $callback)))))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const -136)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -144)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -152)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_callDelegate\" (func $callDelegate (param i64 i32 i32 i32 i32 i32 i32) (result i32)))",
    "inline_imports": "(import \"ewasm\" \"DELEGATECALL\" (func $DELEGATECALL))"
  },
  "STATICCALL": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $STATICCALL (param $callback i32)(local $offset0 i32)(local $length0 i32)(local $offset1 i32)(local $length1 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -96)))\n          (i64.load (i32.add (global.get $sp) (i32.const -88)))\n          (i64.load (i32.add (global.get $sp) (i32.const -80)))\n          (i64.load (i32.add (global.get $sp) (i32.const -72)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0)))(local.set $offset1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -128)))\n          (i64.load (i32.add (global.get $sp) (i32.const -120)))\n          (i64.load (i32.add (global.get $sp) (i32.const -112)))\n          (i64.load (i32.add (global.get $sp) (i32.const -104)))))(local.set $length1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -160)))\n          (i64.load (i32.add (global.get $sp) (i32.const -152)))\n          (i64.load (i32.add (global.get $sp) (i32.const -144)))\n          (i64.load (i32.add (global.get $sp) (i32.const -136)))))\n    (call $memusegas (local.get $offset1) (local.get $length1))\n    (local.set $offset1 (i32.add (global.get $memstart) (local.get $offset1))) (i64.store (i32.add (global.get $sp) (i32.const -160)) (i64.extend_i32_u (i32.eqz (call $callStatic(call $check_overflow_i64\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24))))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -32)))(local.get $offset0)(local.get $length0)(local.get $offset1)(local.get $length1)(local.get $callback)))))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const -136)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -144)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -152)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_callStatic\" (func $callStatic (param i64 i32 i32 i32 i32 i32 i32) (result i32)))",
    "inline_imports": "(import \"ewasm\" \"STATICCALL\" (func $STATICCALL))"
  },
  "RETURNDATACOPY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $RETURNDATACOPY (local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $returnDataCopy(local.get $offset0)(call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8))))(local.get $length0)))",
    "imports": "(import \"env\" \"ethereum_returnDataCopy\" (func $returnDataCopy (param i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"RETURNDATACOPY\" (func $RETURNDATACOPY))"
  },
  "RETURNDATASIZE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $RETURNDATASIZE   (i64.store (i32.add (global.get $sp) (i32.const 32)) (i64.extend_i32_u (call $getReturnDataSize)))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getReturnDataSize\" (func $getReturnDataSize  (result i32)))",
    "inline_imports": "(import \"ewasm\" \"RETURNDATASIZE\" (func $RETURNDATASIZE))"
  },
  "SSTORE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $SSTORE (param $callback i32)  (call $storageStore(call $bswap_m256 (global.get $sp))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -32)))(local.get $callback)))",
    "imports": "(import \"env\" \"ethereum_storageStore\" (func $storageStore (param i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"SSTORE\" (func $SSTORE))"
  },
  "SLOAD": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $SLOAD (param $callback i32)  (call $storageLoad(call $bswap_m256 (global.get $sp))(global.get $sp)(local.get $callback))(drop (call $bswap_m256 (global.get $sp))))",
    "imports": "(import \"env\" \"ethereum_storageLoad\" (func $storageLoad (param i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"SLOAD\" (func $SLOAD))"
  },
  "SELFDESTRUCT": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $SELFDESTRUCT   (call $selfDestruct(call $bswap_m256 (global.get $sp))))",
    "imports": "(import \"env\" \"ethereum_selfDestruct\" (func $selfDestruct (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"SELFDESTRUCT\" (func $SELFDESTRUCT))"
  },
  "RETURN": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $RETURN (local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $finish(local.get $offset0)(local.get $length0)))",
    "imports": "(import \"env\" \"ethereum_finish\" (func $finish (param i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"RETURN\" (func $RETURN))"
  },
  "REVERT": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $REVERT (local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $revert(local.get $offset0)(local.get $length0)))",
    "imports": "(import \"env\" \"ethereum_revert\" (func $revert (param i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"REVERT\" (func $REVERT))"
  },
  "PUSH": {
    "inline_imports": "(import \"ewasm\" \"PUSH\" (func $PUSH (param i64 i64 i64 i64) ))",
    "wast": "(func $PUSH\n  (param $a0 i64)\n  (param $a1 i64)\n  (param $a2 i64)\n  (param $a3 i64)\n  (local $sp i32)\n\n  ;; increament stack pointer\n  (local.set $sp (i32.add (global.get $sp) (i32.const 32)))\n\n  (i64.store (local.get $sp) (local.get $a3))\n  (i64.store (i32.add (local.get $sp) (i32.const 8)) (local.get $a2))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $a1))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $a0))\n)\n"
  },
  "MSTORE": {
    "inline_imports": "(import \"ewasm\" \"MSTORE\" (func $MSTORE ))",
    "wast": ";; stack:\n;;  0: word\n;; -1: offset\n(func $MSTORE\n  (local $sp i32)\n\n  (local $offset   i32)\n  \n  (local $offset0 i64)\n  (local $offset1 i64)\n  (local $offset2 i64)\n  (local $offset3 i64)\n\n  ;; load args from the stack\n  (local.set $offset0 (i64.load          (global.get $sp)))\n  (local.set $offset1 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $offset2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $offset3 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n\n  (local.set $offset \n             (call $check_overflow (local.get $offset0)\n                                   (local.get $offset1)\n                                   (local.get $offset2)\n                                   (local.get $offset3)))\n  ;; subtrace gas useage\n  (call $memusegas (local.get $offset) (i32.const 32))\n\n  ;; pop item from the stack\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  ;; swap top stack item\n  (drop (call $bswap_m256 (local.get $sp)))\n\n  (local.set $offset (i32.add (local.get $offset) (global.get $memstart)))\n  ;; store word to memory\n  (i64.store          (local.get $offset)                 (i64.load          (local.get $sp)))\n  (i64.store (i32.add (local.get $offset) (i32.const 8))  (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (i64.store (i32.add (local.get $offset) (i32.const 16)) (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (i64.store (i32.add (local.get $offset) (i32.const 24)) (i64.load (i32.add (local.get $sp) (i32.const 24))))\n)\n"
  },
  "MLOAD": {
    "inline_imports": "(import \"ewasm\" \"MLOAD\" (func $MLOAD ))",
    "wast": ";; stack:\n;;  0: offset\n(func $MLOAD\n  (local $offset i32)\n  (local $offset0 i64)\n  (local $offset1 i64)\n  (local $offset2 i64)\n  (local $offset3 i64)\n\n  ;; load args from the stack\n  (local.set $offset0 (i64.load          (global.get $sp)))\n  (local.set $offset1 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $offset2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $offset3 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n\n  (local.set $offset \n             (call $check_overflow (local.get $offset0)\n                                   (local.get $offset1)\n                                   (local.get $offset2)\n                                   (local.get $offset3)))\n  ;; subttract gas useage\n  (call $memusegas (local.get $offset) (i32.const  32))\n\n  ;; FIXME: how to deal with overflow?\n  (local.set $offset (i32.add (local.get $offset) (global.get $memstart)))\n\n  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.load (i32.add (local.get $offset) (i32.const 24))))\n  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.load (i32.add (local.get $offset) (i32.const 16))))\n  (i64.store (i32.add (global.get $sp) (i32.const  8)) (i64.load (i32.add (local.get $offset) (i32.const  8))))\n  (i64.store          (global.get $sp)                 (i64.load          (local.get $offset)))\n\n  ;; swap\n  (drop (call $bswap_m256 (global.get $sp)))\n)\n"
  },
  "DUP": {
    "inline_imports": "(import \"ewasm\" \"DUP\" (func $DUP (param i32) ))",
    "wast": "(func $DUP\n  (param $a0 i32)\n  (local $sp i32)\n\n  (local $sp_ref i32)\n  \n  (local.set $sp (i32.add (global.get $sp) (i32.const 32)))\n  (local.set $sp_ref (i32.sub (i32.sub (local.get $sp) (i32.const 8)) (i32.mul (local.get $a0) (i32.const 32))))\n  \n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.load (local.get $sp_ref)))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.load (i32.sub (local.get $sp_ref) (i32.const 8))))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (i64.load (i32.sub (local.get $sp_ref) (i32.const 16))))\n  (i64.store          (local.get $sp)                 (i64.load (i32.sub (local.get $sp_ref) (i32.const 24))))\n)\n"
  },
  "ISZERO": {
    "inline_imports": "(import \"ewasm\" \"ISZERO\" (func $ISZERO ))",
    "wast": "(func $ISZERO\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n\n  ;; load args from the stack\n  (local.set $a0 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $a1 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $a2 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $a3 (i64.load (global.get $sp)))\n\n  (i64.store (global.get $sp)\n    (i64.extend_i32_u\n      (call $iszero_256 (local.get $a0) (local.get $a1) (local.get $a2) (local.get $a3))\n    )\n  )\n\n  ;; zero out the rest of memory\n  (i64.store (i32.add (global.get $sp) (i32.const 8)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "LT": {
    "inline_imports": "(import \"ewasm\" \"LT\" (func $LT ))",
    "wast": "(func $LT\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n\n  (local.set $sp (global.get $sp))\n\n  ;; load args from the stack\n  (local.set $a0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $a2 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $a3 (i64.load (local.get $sp)))\n\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 32)))\n\n  (local.set $b0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $b2 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $b3 (i64.load (local.get $sp)))\n\n  (i64.store (local.get $sp) (i64.extend_i32_u\n    (i32.or  (i64.lt_u (local.get $a0) (local.get $b0)) ;; a0 < b0\n    (i32.and (i64.eq   (local.get $a0) (local.get $b0)) ;; a0 == b0\n    (i32.or  (i64.lt_u (local.get $a1) (local.get $b1)) ;; a1 < b1\n    (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n    (i32.or  (i64.lt_u (local.get $a2) (local.get $b2)) ;; a2 < b2\n    (i32.and (i64.eq   (local.get $a2) (local.get $b2)) ;; a2 == b2\n             (i64.lt_u (local.get $a3) (local.get $b3)))))))))) ;; a3 < b3\n\n  ;; zero  out the rest of the stack item\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "GT": {
    "inline_imports": "(import \"ewasm\" \"GT\" (func $GT ))",
    "wast": "(func $GT\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n\n  (local.set $sp (global.get $sp))\n\n  ;; load args from the stack\n  (local.set $a0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $a2 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $a3 (i64.load (local.get $sp)))\n\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 32)))\n\n  (local.set $b0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $b2 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $b3 (i64.load (local.get $sp)))\n\n  (i64.store (local.get $sp) (i64.extend_i32_u\n    (i32.or (i64.gt_u (local.get $a0) (local.get $b0)) ;; a0 > b0\n    (i32.and (i64.eq   (local.get $a0) (local.get $b0)) ;; a0 == a1\n    (i32.or  (i64.gt_u (local.get $a1) (local.get $b1)) ;; a1 > b1\n    (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n    (i32.or  (i64.gt_u (local.get $a2) (local.get $b2)) ;; a2 > b2\n    (i32.and (i64.eq   (local.get $a2) (local.get $b2)) ;; a2 == b2\n             (i64.gt_u (local.get $a3) (local.get $b3)))))))))) ;; a3 > b3\n\n  ;; zero  out the rest of the stack item\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "SLT": {
    "inline_imports": "(import \"ewasm\" \"SLT\" (func $SLT ))",
    "wast": "(func $SLT\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n\n  ;; load args from the stack\n  (local.set $a0 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $a1 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $a2 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $a3 (i64.load (global.get $sp)))\n\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (local.set $b0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $b2 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $b3 (i64.load (local.get $sp)))\n\n  (i64.store (local.get $sp) (i64.extend_i32_u\n    (i32.or  (i64.lt_s (local.get $a0) (local.get $b0)) ;; a0 < b0\n    (i32.and (i64.eq   (local.get $a0) (local.get $b0)) ;; a0 == b0\n    (i32.or  (i64.lt_u (local.get $a1) (local.get $b1)) ;; a1 < b1\n    (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n    (i32.or  (i64.lt_u (local.get $a2) (local.get $b2)) ;; a2 < b2\n    (i32.and (i64.eq   (local.get $a2) (local.get $b2)) ;; a2 == b2\n             (i64.lt_u (local.get $a3) (local.get $b3)))))))))) ;; a3 < b3\n\n  ;; zero  out the rest of the stack item\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "SHR": {
    "inline_imports": "(import \"ewasm\" \"SHR\" (func $SHR ))",
    "wast": "(func $SHR\n    (local $sp i32)\n    (local $x1 i64)\n    (local $x2 i64)\n    (local $x3 i64)\n    (local $x4 i64)\n    (local $y1 i64)\n    (local $y2 i64)\n    (local $y3 i64)\n    (local $y4 i64)\n\n    (local $z1 i64)\n    (local $z2 i64)\n    (local $z3 i64)\n    (local $z4 i64)\n    (local $t i64)\n\n    ;; load args from the stack\n    (local.set $x1 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n    (local.set $x2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n    (local.set $x3 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n    (local.set $x4 (i64.load (global.get $sp)))\n\n    (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n    (local.set $y1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n    (local.set $y2 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n    (local.set $y3 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n    (local.set $y4 (i64.load (local.get $sp)))\n\n    (block\n        (if (i32.and (i64.eqz (local.get $x1)) (i64.eqz (local.get $x2))) (then\n            (if (i64.eqz (local.get $x3)) (then\n                (if (i64.eqz (local.get $x4))\n                    (then\n                        (local.set $z1 (local.get $y1))\n                        (local.set $z2 (local.get $y2))\n                        (local.set $z3 (local.get $y3))\n                        (local.set $z4 (local.get $y4))\n                    )\n                    (else\n                        (if (i64.lt_u (local.get $x4) (i64.const 256)) (then\n                            (if (i64.ge_u (local.get $x4) (i64.const 128)) (then\n                                (local.set $y4 (local.get $y2))\n                                (local.set $y3 (local.get $y1))\n                                (local.set $y2 (i64.const 0))\n                                (local.set $y1 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 128)))\n                            ))\n                            (if (i64.ge_u (local.get $x4) (i64.const 64)) (then\n                                (local.set $y4 (local.get $y3))\n                                (local.set $y3 (local.get $y2))\n                                (local.set $y2 (local.get $y1))\n                                (local.set $y1 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 64)))\n                            ))\n                            (nop)\n                            (block\n                                (local.set $z4 (call $shr_single (local.get $y4) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (block\n                                (local.set $z3 (call $shr_single (local.get $y3) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (local.set $z4 (i64.or (local.get $z4) (local.get $t)))\n                            (block\n                                (local.set $z2 (call $shr_single (local.get $y2) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (local.set $z3 (i64.or (local.get $z3) (local.get $t)))\n                            (block\n                                (local.set $z1 (call $shr_single (local.get $y1) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (local.set $z2 (i64.or (local.get $z2) (local.get $t)))\n                        ))\n                    )\n                )\n            ))\n        ))\n\n    )\n    (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $z1))\n    (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $z2))\n    (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $z3))\n    (i64.store          (local.get $sp)                 (local.get $z4))\n)\n\n(func $shr_single\n    (param $a i64)\n    (param $amount i64)\n    (result i64)\n    (local $x i64)\n    (local $y i64)\n    (block\n        (local.set $y (i64.shl (local.get $a) (i64.sub (i64.const 64) (local.get $amount))))\n        (local.set $x (i64.shr_u (local.get $a) (local.get $amount)))\n\n    )\n    (global.set $global_ (local.get $y))\n    (local.get $x)\n)\n"
  },
  "EQ": {
    "inline_imports": "(import \"ewasm\" \"EQ\" (func $EQ ))",
    "wast": "(func $EQ\n  (local $sp i32)\n\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n  (i64.store (local.get $sp)\n    (i64.extend_i32_u\n      (i32.and (i64.eq   (i64.load (i32.add (local.get $sp) (i32.const 56))) (i64.load (i32.add (local.get $sp) (i32.const 24))))\n      (i32.and (i64.eq   (i64.load (i32.add (local.get $sp) (i32.const 48))) (i64.load (i32.add (local.get $sp) (i32.const 16))))\n      (i32.and (i64.eq   (i64.load (i32.add (local.get $sp) (i32.const 40))) (i64.load (i32.add (local.get $sp) (i32.const  8))))\n               (i64.eq   (i64.load (i32.add (local.get $sp) (i32.const 32))) (i64.load          (local.get $sp))))))))\n\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (i64.const 0))\n)\n"
  },
  "ADD": {
    "inline_imports": "(import \"ewasm\" \"ADD\" (func $ADD ))",
    "wast": "(func $ADD\n  (local $sp i32)\n\n  (local $a i64)\n  (local $c i64)\n  (local $d i64)\n  (local $carry i64)\n\n  (local.set $sp (global.get $sp))\n\n  ;; d c b a\n  ;; pop the stack\n  (local.set $a (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $c (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $d (i64.load (local.get $sp)))\n  ;; decement the stack pointer\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 8)))\n\n  ;; d\n  (local.set $carry (i64.add (local.get $d) (i64.load (i32.sub (local.get $sp) (i32.const 24)))))\n  ;; save d  to mem\n  (i64.store (i32.sub (local.get $sp) (i32.const 24)) (local.get $carry))\n  ;; check  for overflow\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $carry) (local.get $d))))\n\n  ;; c use $d as reg\n  (local.set $d     (i64.add (i64.load (i32.sub (local.get $sp) (i32.const 16))) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $d) (local.get $carry))))\n  (local.set $d     (i64.add (local.get $c) (local.get $d)))\n  ;; store the result\n  (i64.store (i32.sub (local.get $sp) (i32.const 16)) (local.get $d))\n  ;; check overflow\n  (local.set $carry (i64.or (i64.extend_i32_u  (i64.lt_u (local.get $d) (local.get $c))) (local.get $carry)))\n\n  ;; b\n  ;; add carry\n  (local.set $d     (i64.add (i64.load (i32.sub (local.get $sp) (i32.const 8))) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $d) (local.get $carry))))\n\n  ;; use reg c\n  (local.set $c (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $d (i64.add (local.get $c) (local.get $d)))\n  (i64.store (i32.sub (local.get $sp) (i32.const 8)) (local.get $d))\n  ;; a\n  (i64.store (local.get $sp)\n             (i64.add        ;; add a\n               (local.get $a)\n               (i64.add\n                 (i64.load (local.get $sp))  ;; load the operand\n                 (i64.or  ;; carry\n                   (i64.extend_i32_u (i64.lt_u (local.get $d) (local.get $c)))\n                   (local.get $carry)))))\n)\n"
  },
  "SUB": {
    "inline_imports": "(import \"ewasm\" \"SUB\" (func $SUB ))",
    "wast": "(func $SUB\n  (local $sp i32)\n\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  (local $carry i64)\n  (local $temp i64)\n\n  (local.set $a (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $b (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $c (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $d (i64.load          (global.get $sp)))\n  ;; decement the stack pointer\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c1 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (local.set $d1 (i64.load          (local.get $sp)))\n\n  ;; a * 64^3 + b*64^2 + c*64 + d\n  ;; d\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $d) (local.get $d1))))\n  (local.set $d (i64.sub (local.get $d) (local.get $d1)))\n\n  ;; c\n  (local.set $temp (i64.sub (local.get $c) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.gt_u (local.get $temp) (local.get $c))))\n  (local.set $c (i64.sub (local.get $temp) (local.get $c1)))\n  (local.set $carry (i64.or (i64.extend_i32_u (i64.gt_u (local.get $c) (local.get $temp))) (local.get $carry)))\n\n  ;; b\n  (local.set $temp (i64.sub (local.get $b) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.gt_u (local.get $temp) (local.get $b))))\n  (local.set $b (i64.sub (local.get $temp) (local.get $b1)))\n\n  ;; a\n  (local.set $a (i64.sub (i64.sub (local.get $a) (i64.or (i64.extend_i32_u (i64.gt_u (local.get $b) (local.get $temp))) (local.get $carry))) (local.get $a1)))\n\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $a))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $b))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $c))\n  (i64.store          (local.get $sp)                 (local.get $d))\n)\n"
  },
  "SWAP": {
    "inline_imports": "(import \"ewasm\" \"SWAP\" (func $SWAP (param i32) ))",
    "wast": "(func $SWAP\n  (param $a0 i32)\n  (local $sp_ref i32)\n\n  (local $topa i64)\n  (local $topb i64)\n  (local $topc i64)\n  (local $topd i64)\n  \n  (local.set $sp_ref (i32.sub (i32.add  (global.get $sp) (i32.const 24)) (i32.mul (i32.add (local.get $a0) (i32.const 1)) (i32.const 32))))\n\n  (local.set $topa (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $topb (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $topc (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $topd (i64.load          (global.get $sp)))\n  \n  ;; replace the top element\n  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.load (local.get $sp_ref)))\n  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.load (i32.sub (local.get $sp_ref) (i32.const 8))))\n  (i64.store (i32.add (global.get $sp) (i32.const  8)) (i64.load (i32.sub (local.get $sp_ref) (i32.const 16))))\n  (i64.store          (global.get $sp)                 (i64.load (i32.sub (local.get $sp_ref) (i32.const 24))))\n\n  ;; store the old top element\n  (i64.store (local.get $sp_ref)                          (local.get $topa))\n  (i64.store (i32.sub (local.get $sp_ref) (i32.const 8))  (local.get $topb))\n  (i64.store (i32.sub (local.get $sp_ref) (i32.const 16)) (local.get $topc))\n  (i64.store (i32.sub (local.get $sp_ref) (i32.const 24)) (local.get $topd))\n)\n"
  },
  "check_overflow": {
    "inline_imports": "(import \"ewasm\" \"check_overflow\" (func $check_overflow (param i64 i64 i64 i64)  (result i32) ))",
    "wast": "(func $check_overflow\n  (param $a i64)\n  (param $b i64)\n  (param $c i64)\n  (param $d i64)\n  (result i32)\n\n  (local $MAX_INT i32)\n  (local.set $MAX_INT (i32.const -1))\n\n  (if\n    (i32.and\n      (i32.and\n        (i64.eqz  (local.get $d))\n        (i64.eqz  (local.get $c)))\n      (i32.and\n        (i64.eqz  (local.get $b))\n        (i64.lt_u (local.get $a) (i64.extend_i32_u (local.get $MAX_INT)))))\n     (return (i32.wrap_i64 (local.get $a))))\n\n     (return (local.get $MAX_INT))\n)\n"
  },
  "ADDMOD": {
    "wast": ";; stack:\n;;  0: A\n;; -1: B\n;; -2: MOD\n(func $ADDMOD\n  (local $sp i32)\n\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  (local $moda i64)\n  (local $modb i64)\n  (local $modc i64)\n  (local $modd i64)\n\n  (local $carry i64)\n\n  (local.set $sp (global.get $sp))\n\n  ;; load args from the stack\n  (local.set $a (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $d (i64.load (local.get $sp)))\n\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 32)))\n\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c1 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $d1 (i64.load (local.get $sp)))\n\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 32)))\n\n  (local.set $moda (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $modb (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $modc (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $modd (i64.load (local.get $sp)))\n\n  ;; a * 64^3 + b*64^2 + c*64 + d\n  ;; d\n  (local.set $d     (i64.add (local.get $d1) (local.get $d)))\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $d) (local.get $d1))))\n  ;; c\n  (local.set $c     (i64.add (local.get $c) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $c) (local.get $carry))))\n  (local.set $c     (i64.add (local.get $c1) (local.get $c)))\n  (local.set $carry (i64.or (i64.extend_i32_u  (i64.lt_u (local.get $c) (local.get $c1))) (local.get $carry)))\n  ;; b\n  (local.set $b     (i64.add (local.get $b) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $b) (local.get $carry))))\n  (local.set $b     (i64.add (local.get $b1) (local.get $b)))\n  (local.set $carry (i64.or (i64.extend_i32_u  (i64.lt_u (local.get $b) (local.get $b1))) (local.get $carry)))\n  ;; a\n  (local.set $a     (i64.add (local.get $a) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $a) (local.get $carry))))\n  (local.set $a     (i64.add (local.get $a1) (local.get $a)))\n  (local.set $carry (i64.or (i64.extend_i32_u  (i64.lt_u (local.get $a) (local.get $a1))) (local.get $carry)))\n\n  (call $mod_320\n        (local.get $carry) (local.get $a)    (local.get $b)    (local.get $c)    (local.get $d)\n        (i64.const 0)      (local.get $moda) (local.get $modb) (local.get $modc) (local.get $modd) (local.get $sp))\n)\n"
  },
  "AND": {
    "wast": "(func $AND\n  (i64.store (i32.sub (global.get $sp) (i32.const 8))  (i64.and (i64.load (i32.sub (global.get $sp) (i32.const 8)))  (i64.load (i32.add (global.get $sp) (i32.const 24)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 16)) (i64.and (i64.load (i32.sub (global.get $sp) (i32.const 16))) (i64.load (i32.add (global.get $sp) (i32.const 16)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 24)) (i64.and (i64.load (i32.sub (global.get $sp) (i32.const 24))) (i64.load (i32.add (global.get $sp) (i32.const 8)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 32)) (i64.and (i64.load (i32.sub (global.get $sp) (i32.const 32))) (i64.load (global.get $sp))))\n)\n"
  },
  "BYTE": {
    "wast": ";; stack:\n;;  0: offset\n;; -1: value\n(func $BYTE\n    (local $sp i32)\n\n    (local $x1 i64)\n    (local $x2 i64)\n    (local $x3 i64)\n    (local $x4 i64)\n    (local $y1 i64)\n    (local $y2 i64)\n    (local $y3 i64)\n    (local $y4 i64)\n\n    (local $r1 i64)\n    (local $r2 i64)\n    (local $r3 i64)\n    (local $r4 i64)\n    (local $component i64)\n    (local $condition i64)\n\n    ;; load args from the stack\n    (local.set $x1 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n    (local.set $x2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n    (local.set $x3 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n    (local.set $x4 (i64.load (global.get $sp)))\n\n    (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n    (local.set $y1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n    (local.set $y2 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n    (local.set $y3 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n    (local.set $y4 (i64.load (local.get $sp)))\n\n    (block\n        (if (i64.eqz (i64.or (i64.or (local.get $x1) (local.get $x2)) (local.get $x3))) (then\n            (nop)\n            (block\n                (local.set $condition (i64.div_u (local.get $x4) (i64.const 8)))\n                (if (i64.eq (local.get $condition) (i64.const 0)) (then\n                    (local.set $component (local.get $y1))\n                )(else\n                    (if (i64.eq (local.get $condition) (i64.const 1)) (then\n                        (local.set $component (local.get $y2))\n                    )(else\n                        (if (i64.eq (local.get $condition) (i64.const 2)) (then\n                            (local.set $component (local.get $y3))\n                        )(else\n                            (if (i64.eq (local.get $condition) (i64.const 3)) (then\n                                (local.set $component (local.get $y4))\n                            ))\n                        ))\n                    ))\n                ))\n\n            )\n            (local.set $x4 (i64.mul (i64.rem_u (local.get $x4) (i64.const 8)) (i64.const 8)))\n            (local.set $r4 (i64.shr_u (local.get $component) (i64.sub (i64.const 56) (local.get $x4))))\n            (local.set $r4 (i64.and (i64.const 255) (local.get $r4)))\n        ))\n\n    )\n    (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $r1))\n    (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $r2))\n    (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $r3))\n    (i64.store          (local.get $sp)                 (local.get $r4))\n)\n"
  },
  "DIV": {
    "wast": "(func $DIV\n  (local $sp i32)\n  ;; dividend\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  ;; divisor\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $carry i32)\n  (local $temp  i64)\n  (local $temp2  i64)\n\n  (local.set $sp (global.get $sp))\n  (local.set $maskd (i64.const 1))\n\n  ;; load args from the stack\n  (local.set $a (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $d (i64.load (local.get $sp)))\n\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 32)))\n\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c1 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $d1 (i64.load (local.get $sp)))\n\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n      (br $main)\n    )\n\n    ;; align bits\n    (block $done\n      (loop $loop\n        ;; align bits;\n        (if\n          ;; check to make sure we are not overflowing\n          (i32.or (i64.eqz (i64.clz (local.get $a1)))\n          ;;  divisor < dividend\n          (call $gte_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $a) (local.get $b) (local.get $c) (local.get $d)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (local.set $a1 (i64.add (i64.shl (local.get $a1) (i64.const 1)) (i64.shr_u (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shl (local.get $b1) (i64.const 1)) (i64.shr_u (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shl (local.get $c1) (i64.const 1)) (i64.shr_u (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.shl (local.get $d1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (local.set $maska (i64.add (i64.shl (local.get $maska) (i64.const 1)) (i64.shr_u (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shl (local.get $maskb) (i64.const 1)) (i64.shr_u (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shl (local.get $maskc) (i64.const 1)) (i64.shr_u (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.shl (local.get $maskd) (i64.const 1)))\n\n        (br $loop)\n      )\n    )\n\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_256 (local.get $maska) (local.get $maskb) (local.get $maskc) (local.get $maskd))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_256 (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n          (then\n            ;; dividend = dividend - divisor\n            (local.set $carry (i64.lt_u (local.get $d) (local.get $d1)))\n            (local.set $d     (i64.sub  (local.get $d) (local.get $d1)))\n            (local.set $temp  (i64.sub  (local.get $c) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $c)))\n            (local.set $c     (i64.sub  (local.get $temp) (local.get $c1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $c) (local.get $temp)) (local.get $carry)))\n            (local.set $temp  (i64.sub  (local.get $b) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $b)))\n            (local.set $b     (i64.sub  (local.get $temp) (local.get $b1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $b) (local.get $temp)) (local.get $carry)))\n            (local.set $a     (i64.sub  (i64.sub (local.get $a) (i64.extend_i32_u (local.get $carry))) (local.get $a1)))\n\n            ;; result = result + mask\n            (local.set $dq   (i64.add (local.get $maskd) (local.get $dq)))\n            (local.set $temp (i64.extend_i32_u (i64.lt_u (local.get $dq) (local.get $maskd))))\n            (local.set $cq   (i64.add (local.get $cq) (local.get $temp)))\n            (local.set $temp (i64.extend_i32_u (i64.lt_u (local.get $cq) (local.get $temp))))\n            (local.set $cq   (i64.add (local.get $maskc) (local.get $cq)))\n            (local.set $temp (i64.or (i64.extend_i32_u  (i64.lt_u (local.get $cq) (local.get $maskc))) (local.get $temp)))\n            (local.set $bq   (i64.add (local.get $bq) (local.get $temp)))\n            (local.set $temp (i64.extend_i32_u (i64.lt_u (local.get $bq) (local.get $temp))))\n            (local.set $bq   (i64.add (local.get $maskb) (local.get $bq)))\n            (local.set $aq   (i64.add (local.get $maska) (i64.add (local.get $aq) (i64.or (i64.extend_i32_u (i64.lt_u (local.get $bq) (local.get $maskb))) (local.get $temp)))))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (local.set $d1 (i64.add (i64.shr_u (local.get $d1) (i64.const 1)) (i64.shl (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shr_u (local.get $c1) (i64.const 1)) (i64.shl (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shr_u (local.get $b1) (i64.const 1)) (i64.shl (local.get $a1) (i64.const 63))))\n        (local.set $a1 (i64.shr_u (local.get $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (local.set $maskd (i64.add (i64.shr_u (local.get $maskd) (i64.const 1)) (i64.shl (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shr_u (local.get $maskc) (i64.const 1)) (i64.shl (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shr_u (local.get $maskb) (i64.const 1)) (i64.shl (local.get $maska) (i64.const 63))))\n        (local.set $maska (i64.shr_u (local.get $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $aq))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $bq))\n  (i64.store (i32.add (local.get $sp) (i32.const 8))  (local.get $cq))\n  (i64.store (local.get $sp) (local.get $dq))\n)\n"
  },
  "EXP": {
    "wast": "(func $EXP\n  (local $sp i32)\n\n  ;; base\n  (local $base0 i64)\n  (local $base1 i64)\n  (local $base2 i64)\n  (local $base3 i64)\n\n  ;; exp\n  (local $exp0 i64)\n  (local $exp1 i64)\n  (local $exp2 i64)\n  (local $exp3 i64)\n\n  (local $r0 i64)\n  (local $r1 i64)\n  (local $r2 i64)\n  (local $r3 i64)\n\n  (local $gasCounter i32)\n  (local.set $sp (global.get $sp))\n\n  ;; load args from the stack\n  (local.set $base0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $base1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $base2 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (local.set $base3 (i64.load          (local.get $sp)))\n\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 32)))\n\n  (local.set $exp0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $exp1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $exp2 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (local.set $exp3 (i64.load          (local.get $sp)))\n\n  ;; let result = new BN[1]\n  (local.set $r3 (i64.const 1))\n\n  (block $done\n    (loop $loop\n       ;; while [exp > 0] {\n      (if (call $iszero_256 (local.get $exp0) (local.get $exp1) (local.get $exp2) (local.get $exp3))\n        (br $done)\n      )\n\n      ;; if[exp.modn[2] === 1]\n      ;; is odd?\n      (if (i64.eqz (i64.ctz (local.get $exp3)))\n\n        ;; result = result.mul[base].mod[TWO_POW256]\n        ;; r = r * a\n        (then\n          (call $mul_256 (local.get $r0) (local.get $r1) (local.get $r2) (local.get $r3) (local.get $base0) (local.get $base1) (local.get $base2) (local.get $base3) (i32.add (local.get $sp) (i32.const 24)))\n          (local.set $r0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n          (local.set $r1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n          (local.set $r2 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n          (local.set $r3 (i64.load          (local.get $sp)))\n        )\n      )\n      ;; exp = exp.shrn 1\n      (local.set $exp3 (i64.add (i64.shr_u (local.get $exp3) (i64.const 1)) (i64.shl (local.get $exp2) (i64.const 63))))\n      (local.set $exp2 (i64.add (i64.shr_u (local.get $exp2) (i64.const 1)) (i64.shl (local.get $exp1) (i64.const 63))))\n      (local.set $exp1 (i64.add (i64.shr_u (local.get $exp1) (i64.const 1)) (i64.shl (local.get $exp0) (i64.const 63))))\n      (local.set $exp0 (i64.shr_u (local.get $exp0) (i64.const 1)))\n\n      ;; base = base.mulr[baser].modr[TWO_POW256]\n      (call $mul_256 (local.get $base0) (local.get $base1) (local.get $base2) (local.get $base3) (local.get $base0) (local.get $base1) (local.get $base2) (local.get $base3) (i32.add (local.get $sp) (i32.const 24)))\n      (local.set $base0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n      (local.set $base1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n      (local.set $base2 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n      (local.set $base3 (i64.load          (local.get $sp)))\n\n      (local.set $gasCounter (i32.add (local.get $gasCounter) (i32.const 1)))\n      (br $loop)\n    )\n  )\n\n  ;; use gas\n  ;; Log256[Exponent] * 10\n  (call $useGas\n    (i64.extend_i32_u\n      (i32.mul\n        (i32.const 10)\n        (i32.div_u\n          (i32.add (local.get $gasCounter) (i32.const 7))\n          (i32.const 8)))))\n\n  ;; decement the stack pointer\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $r0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $r1))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $r2))\n  (i64.store          (local.get $sp)                 (local.get $r3))\n)\n"
  },
  "MOD": {
    "wast": "(func $MOD\n  (local $sp i32)\n\n  ;; dividend\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  ;; divisor\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $carry i32)\n  (local $temp i64)\n\n  (local.set $maskd (i64.const 1))\n\n  ;; load args from the stack\n  (local.set $a (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $b (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $c (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $d (i64.load          (global.get $sp)))\n  ;; decement the stack pointer\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c1 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (local.set $d1 (i64.load          (local.get $sp)))\n\n\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n      (then\n        (local.set $a (i64.const 0))\n        (local.set $b (i64.const 0))\n        (local.set $c (i64.const 0))\n        (local.set $d (i64.const 0))\n        (br $main)\n      )\n    )\n\n    ;; align bits\n    (block $done\n        (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (local.get $a1))) (call $gte_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $a) (local.get $b) (local.get $c) (local.get $d)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (local.set $a1 (i64.add (i64.shl (local.get $a1) (i64.const 1)) (i64.shr_u (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shl (local.get $b1) (i64.const 1)) (i64.shr_u (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shl (local.get $c1) (i64.const 1)) (i64.shr_u (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.shl (local.get $d1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (local.set $maska (i64.add (i64.shl (local.get $maska) (i64.const 1)) (i64.shr_u (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shl (local.get $maskb) (i64.const 1)) (i64.shr_u (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shl (local.get $maskc) (i64.const 1)) (i64.shr_u (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.shl (local.get $maskd) (i64.const 1)))\n\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_256 (local.get $maska) (local.get $maskb) (local.get $maskc) (local.get $maskd))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_256 (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n          (then\n            ;; dividend = dividend - divisor\n            (local.set $carry (i64.lt_u (local.get $d) (local.get $d1)))\n            (local.set $d     (i64.sub  (local.get $d) (local.get $d1)))\n            (local.set $temp  (i64.sub  (local.get $c) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $c)))\n            (local.set $c     (i64.sub  (local.get $temp) (local.get $c1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $c) (local.get $temp)) (local.get $carry)))\n            (local.set $temp  (i64.sub  (local.get $b) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $b)))\n            (local.set $b     (i64.sub  (local.get $temp) (local.get $b1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $b) (local.get $temp)) (local.get $carry)))\n            (local.set $a     (i64.sub  (i64.sub (local.get $a) (i64.extend_i32_u (local.get $carry))) (local.get $a1)))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (local.set $d1 (i64.add (i64.shr_u (local.get $d1) (i64.const 1)) (i64.shl (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shr_u (local.get $c1) (i64.const 1)) (i64.shl (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shr_u (local.get $b1) (i64.const 1)) (i64.shl (local.get $a1) (i64.const 63))))\n        (local.set $a1 (i64.shr_u (local.get $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (local.set $maskd (i64.add (i64.shr_u (local.get $maskd) (i64.const 1)) (i64.shl (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shr_u (local.get $maskc) (i64.const 1)) (i64.shl (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shr_u (local.get $maskb) (i64.const 1)) (i64.shl (local.get $maska) (i64.const 63))))\n        (local.set $maska (i64.shr_u (local.get $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $a))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $b))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $c))\n  (i64.store          (local.get $sp)                 (local.get $d))\n)\n"
  },
  "MSIZE": {
    "wast": "(func $MSIZE\n  (local $sp i32)\n\n  ;; there's no input item for us to overwrite\n  (local.set $sp (i32.add (global.get $sp) (i32.const 32)))\n\n  (i64.store (i32.add (local.get $sp) (i32.const 0)) \n             (i64.mul (global.get $wordCount) (i64.const 32)))\n  (i64.store (i32.add (local.get $sp) (i32.const 8)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "MSTORE8": {
    "wast": ";; stack:\n;;  0: offset\n;; -1: word\n(func $MSTORE8\n  (local $sp i32)\n\n  (local $offset i32)\n\n  (local $offset0 i64)\n  (local $offset1 i64)\n  (local $offset2 i64)\n  (local $offset3 i64)\n\n  ;; load args from the stack\n  (local.set $offset0 (i64.load          (global.get $sp)))\n  (local.set $offset1 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $offset2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $offset3 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n\n  (local.set $offset \n             (call $check_overflow (local.get $offset0)\n                                   (local.get $offset1)\n                                   (local.get $offset2)\n                                   (local.get $offset3)))\n\n  (call $memusegas (local.get $offset) (i32.const 1))\n\n  ;; pop stack\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n  (local.set $offset (i32.add (local.get $offset) (global.get $memstart)))\n  (i32.store8 (i32.add (local.get $offset) (i32.const 0)) (i32.load (local.get $sp)))\n)\n"
  },
  "MUL": {
    "wast": "(func $MUL\n  (call $mul_256\n        (i64.load (i32.add (global.get $sp) (i32.const 24)))\n        (i64.load (i32.add (global.get $sp) (i32.const 16)))\n        (i64.load (i32.add (global.get $sp) (i32.const  8)))\n        (i64.load          (global.get $sp))\n        (i64.load (i32.sub (global.get $sp) (i32.const  8)))\n        (i64.load (i32.sub (global.get $sp) (i32.const 16)))\n        (i64.load (i32.sub (global.get $sp) (i32.const 24)))\n        (i64.load (i32.sub (global.get $sp) (i32.const 32)))\n        (i32.sub (global.get $sp) (i32.const 8))\n  )\n)\n"
  },
  "MULMOD": {
    "wast": "(func $MULMOD\n  (local $sp i32)\n\n  (local $a i64)\n  (local $c i64)\n  (local $e i64)\n  (local $g i64)\n  (local $i i64)\n  (local $k i64)\n  (local $m i64)\n  (local $o i64)\n  (local $b i64)\n  (local $d i64)\n  (local $f i64)\n  (local $h i64)\n  (local $j i64)\n  (local $l i64)\n  (local $n i64)\n  (local $p i64)\n  (local $temp7 i64)\n  (local $temp6 i64)\n  (local $temp5 i64)\n  (local $temp4 i64)\n  (local $temp3 i64)\n  (local $temp2 i64)\n  (local $temp1 i64)\n  (local $temp0 i64)\n  (local $rowCarry i64)\n\n  (local $moda i64)\n  (local $modb i64)\n  (local $modc i64)\n  (local $modd i64)\n\n  ;; pop two items of the stack\n  (local.set $a (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $c (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $e (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $g (i64.load          (global.get $sp)))\n  (local.set $i (i64.load (i32.sub (global.get $sp) (i32.const  8))))\n  (local.set $k (i64.load (i32.sub (global.get $sp) (i32.const 16))))\n  (local.set $m (i64.load (i32.sub (global.get $sp) (i32.const 24))))\n  (local.set $o (i64.load (i32.sub (global.get $sp) (i32.const 32))))\n\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 64)))\n\n  ;; MUL\n  ;;  a b c d e f g h\n  ;;* i j k l m n o p\n  ;;----------------\n\n  ;; split the ops\n  (local.set $b (i64.and (local.get $a) (i64.const 4294967295)))\n  (local.set $a (i64.shr_u (local.get $a) (i64.const 32))) \n\n  (local.set $d (i64.and (local.get $c) (i64.const 4294967295)))\n  (local.set $c (i64.shr_u (local.get $c) (i64.const 32))) \n\n  (local.set $f (i64.and (local.get $e) (i64.const 4294967295)))\n  (local.set $e (i64.shr_u (local.get $e) (i64.const 32)))\n\n  (local.set $h (i64.and (local.get $g) (i64.const 4294967295)))\n  (local.set $g (i64.shr_u (local.get $g) (i64.const 32)))\n\n  (local.set $j (i64.and (local.get $i) (i64.const 4294967295)))\n  (local.set $i (i64.shr_u (local.get $i) (i64.const 32))) \n\n  (local.set $l (i64.and (local.get $k) (i64.const 4294967295)))\n  (local.set $k (i64.shr_u (local.get $k) (i64.const 32))) \n\n  (local.set $n (i64.and (local.get $m) (i64.const 4294967295)))\n  (local.set $m (i64.shr_u (local.get $m) (i64.const 32)))\n\n  (local.set $p (i64.and (local.get $o) (i64.const 4294967295)))\n  (local.set $o (i64.shr_u (local.get $o) (i64.const 32)))\n\n   ;; first row multiplication \n  ;; p * h\n  (local.set $temp0 (i64.mul (local.get $p) (local.get $h)))\n  ;; p * g + carry\n  (local.set $temp1 (i64.add (i64.mul (local.get $p) (local.get $g)) (i64.shr_u (local.get $temp0) (i64.const 32))))\n  ;; p * f + carry\n  (local.set $temp2 (i64.add (i64.mul (local.get $p) (local.get $f)) (i64.shr_u (local.get $temp1) (i64.const 32))))\n  ;; p * e + carry\n  (local.set $temp3 (i64.add (i64.mul (local.get $p) (local.get $e)) (i64.shr_u (local.get $temp2) (i64.const 32))))\n  ;; p * d + carry\n  (local.set $temp4 (i64.add (i64.mul (local.get $p) (local.get $d)) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; p * c + carry\n  (local.set $temp5 (i64.add (i64.mul (local.get $p) (local.get $c)) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; p * b + carry\n  (local.set $temp6 (i64.add (i64.mul (local.get $p) (local.get $b)) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; p * a + carry\n  (local.set $temp7 (i64.add (i64.mul (local.get $p) (local.get $a)) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  (local.set $rowCarry (i64.shr_u (local.get $temp7) (i64.const 32)))\n\n  ;; second row\n  ;; o * h + $temp1 \n  (local.set $temp1 (i64.add (i64.mul (local.get $o) (local.get $h)) (i64.and (local.get $temp1) (i64.const 4294967295))))\n  ;; o * g + $temp2 + carry\n  (local.set $temp2 (i64.add (i64.add (i64.mul (local.get $o) (local.get $g)) (i64.and (local.get $temp2) (i64.const 4294967295))) (i64.shr_u (local.get $temp1) (i64.const 32))))\n  ;; o * f + $temp3 + carry\n  (local.set $temp3 (i64.add (i64.add (i64.mul (local.get $o) (local.get $f)) (i64.and (local.get $temp3) (i64.const 4294967295))) (i64.shr_u (local.get $temp2) (i64.const 32))))\n  ;; o * e + $temp4 + carry\n  (local.set $temp4 (i64.add (i64.add (i64.mul (local.get $o) (local.get $e)) (i64.and (local.get $temp4) (i64.const 4294967295))) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; o * d + $temp5 + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $o) (local.get $d)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; o * c + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $o) (local.get $c)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; o * b + $temp7 + carry\n  (local.set $temp7 (i64.add (i64.add (i64.mul (local.get $o) (local.get $b)) (i64.and (local.get $temp7) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; o * a + carry + rowCarry\n  (local.set $p (i64.add (i64.add (i64.mul (local.get $o) (local.get $a)) (i64.shr_u (local.get $temp7) (i64.const 32))) (local.get $rowCarry)))\n  (local.set $rowCarry (i64.shr_u (local.get $p) (i64.const 32)))\n\n  ;; third row - n\n  ;; n * h + $temp2 \n  (local.set $temp2 (i64.add (i64.mul (local.get $n) (local.get $h)) (i64.and (local.get $temp2) (i64.const 4294967295))))\n  ;; n * g + $temp3  carry\n  (local.set $temp3 (i64.add (i64.add (i64.mul (local.get $n) (local.get $g)) (i64.and (local.get $temp3) (i64.const 4294967295))) (i64.shr_u (local.get $temp2) (i64.const 32))))\n  ;; n * f + $temp4) + carry\n  (local.set $temp4 (i64.add (i64.add (i64.mul (local.get $n) (local.get $f)) (i64.and (local.get $temp4) (i64.const 4294967295))) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; n * e + $temp5 + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $n) (local.get $e)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; n * d + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $n) (local.get $d)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; n * c + $temp7 + carry\n  (local.set $temp7 (i64.add (i64.add (i64.mul (local.get $n) (local.get $c)) (i64.and (local.get $temp7) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; n * b + $p + carry\n  (local.set $p     (i64.add (i64.add (i64.mul (local.get $n) (local.get $b)) (i64.and (local.get $p)     (i64.const 4294967295))) (i64.shr_u (local.get $temp7) (i64.const 32))))\n  ;; n * a + carry\n  (local.set $o (i64.add (i64.add (i64.mul (local.get $n) (local.get $a)) (i64.shr_u (local.get $p) (i64.const 32))) (local.get $rowCarry)))\n  (local.set $rowCarry (i64.shr_u (local.get $o) (i64.const 32)))\n\n  ;; forth row \n  ;; m * h + $temp3\n  (local.set $temp3 (i64.add (i64.mul (local.get $m) (local.get $h)) (i64.and (local.get $temp3) (i64.const 4294967295))))\n  ;; m * g + $temp4 + carry\n  (local.set $temp4 (i64.add (i64.add (i64.mul (local.get $m) (local.get $g)) (i64.and (local.get $temp4) (i64.const 4294967295))) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; m * f + $temp5 + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $m) (local.get $f)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; m * e + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $m) (local.get $e)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; m * d + $temp7 + carry\n  (local.set $temp7 (i64.add (i64.add (i64.mul (local.get $m) (local.get $d)) (i64.and (local.get $temp7) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; m * c + $p + carry\n  (local.set $p     (i64.add (i64.add (i64.mul (local.get $m) (local.get $c)) (i64.and (local.get $p)     (i64.const 4294967295))) (i64.shr_u (local.get $temp7) (i64.const 32))))\n  ;; m * b + $o + carry\n  (local.set $o     (i64.add (i64.add (i64.mul (local.get $m) (local.get $b)) (i64.and (local.get $o)     (i64.const 4294967295))) (i64.shr_u (local.get $p)     (i64.const 32))))\n  ;; m * a + carry + rowCarry\n  (local.set $n     (i64.add (i64.add (i64.mul (local.get $m) (local.get $a)) (i64.shr_u (local.get $o) (i64.const 32))) (local.get $rowCarry)))\n  (local.set $rowCarry (i64.shr_u (local.get $n) (i64.const 32)))\n\n  ;; fith row\n  ;; l * h + $temp4\n  (local.set $temp4 (i64.add (i64.mul (local.get $l) (local.get $h)) (i64.and (local.get $temp4) (i64.const 4294967295))))\n  ;; l * g + $temp5 + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $l) (local.get $g)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; l * f + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $l) (local.get $f)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; l * e + $temp7 + carry\n  (local.set $temp7 (i64.add (i64.add (i64.mul (local.get $l) (local.get $e)) (i64.and (local.get $temp7) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; l * d + $p + carry\n  (local.set $p     (i64.add (i64.add (i64.mul (local.get $l) (local.get $d)) (i64.and (local.get $p)     (i64.const 4294967295))) (i64.shr_u (local.get $temp7) (i64.const 32))))\n  ;; l * c + $o + carry\n  (local.set $o     (i64.add (i64.add (i64.mul (local.get $l) (local.get $c)) (i64.and (local.get $o)     (i64.const 4294967295))) (i64.shr_u (local.get $p)     (i64.const 32))))\n  ;; l * b + $n + carry\n  (local.set $n     (i64.add (i64.add (i64.mul (local.get $l) (local.get $b)) (i64.and (local.get $n)     (i64.const 4294967295))) (i64.shr_u (local.get $o)     (i64.const 32))))\n  ;; l * a + carry + rowCarry\n  (local.set $m     (i64.add (i64.add (i64.mul (local.get $l) (local.get $a)) (i64.shr_u (local.get $n) (i64.const 32))) (local.get $rowCarry)))\n  (local.set $rowCarry (i64.shr_u (local.get $m) (i64.const 32)))\n\n  ;; sixth row \n  ;; k * h + $temp5\n  (local.set $temp5 (i64.add (i64.mul (local.get $k) (local.get $h)) (i64.and (local.get $temp5) (i64.const 4294967295))))\n  ;; k * g + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $k) (local.get $g)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; k * f + $temp7 + carry\n  (local.set $temp7 (i64.add (i64.add (i64.mul (local.get $k) (local.get $f)) (i64.and (local.get $temp7) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; k * e + $p + carry\n  (local.set $p     (i64.add (i64.add (i64.mul (local.get $k) (local.get $e)) (i64.and (local.get $p)     (i64.const 4294967295))) (i64.shr_u (local.get $temp7) (i64.const 32))))\n  ;; k * d + $o + carry\n  (local.set $o     (i64.add (i64.add (i64.mul (local.get $k) (local.get $d)) (i64.and (local.get $o)     (i64.const 4294967295))) (i64.shr_u (local.get $p)     (i64.const 32))))\n  ;; k * c + $n + carry\n  (local.set $n     (i64.add (i64.add (i64.mul (local.get $k) (local.get $c)) (i64.and (local.get $n)     (i64.const 4294967295))) (i64.shr_u (local.get $o)     (i64.const 32))))\n  ;; k * b + $m + carry\n  (local.set $m     (i64.add (i64.add (i64.mul (local.get $k) (local.get $b)) (i64.and (local.get $m)     (i64.const 4294967295))) (i64.shr_u (local.get $n)     (i64.const 32))))\n  ;; k * a + carry\n  (local.set $l     (i64.add (i64.add (i64.mul (local.get $k) (local.get $a)) (i64.shr_u (local.get $m) (i64.const 32))) (local.get $rowCarry)))\n  (local.set $rowCarry (i64.shr_u (local.get $l) (i64.const 32)))\n\n  ;; seventh row\n  ;; j * h + $temp6\n  (local.set $temp6 (i64.add (i64.mul (local.get $j) (local.get $h)) (i64.and (local.get $temp6) (i64.const 4294967295))))\n  ;; j * g + $temp7 + carry\n  (local.set $temp7 (i64.add (i64.add (i64.mul (local.get $j) (local.get $g)) (i64.and (local.get $temp7) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; j * f + $p +carry\n  (local.set $p     (i64.add (i64.add (i64.mul (local.get $j) (local.get $f)) (i64.and (local.get $p)     (i64.const 4294967295))) (i64.shr_u (local.get $temp7) (i64.const 32))))\n  ;; j * e + $o + carry\n  (local.set $o     (i64.add (i64.add (i64.mul (local.get $j) (local.get $e)) (i64.and (local.get $o)     (i64.const 4294967295))) (i64.shr_u (local.get $p)     (i64.const 32))))\n  ;; j * d + $n + carry\n  (local.set $n     (i64.add (i64.add (i64.mul (local.get $j) (local.get $d)) (i64.and (local.get $n)     (i64.const 4294967295))) (i64.shr_u (local.get $o)     (i64.const 32))))\n  ;; j * c + $m + carry\n  (local.set $m     (i64.add (i64.add (i64.mul (local.get $j) (local.get $c)) (i64.and (local.get $m)     (i64.const 4294967295))) (i64.shr_u (local.get $n)     (i64.const 32))))\n  ;; j * b + $l + carry\n  (local.set $l     (i64.add (i64.add (i64.mul (local.get $j) (local.get $b)) (i64.and (local.get $l)     (i64.const 4294967295))) (i64.shr_u (local.get $m)     (i64.const 32))))\n  ;; j * a + carry\n  (local.set $k     (i64.add (i64.add (i64.mul (local.get $j) (local.get $a)) (i64.shr_u (local.get $l) (i64.const 32))) (local.get $rowCarry)))\n  (local.set $rowCarry (i64.shr_u (local.get $k) (i64.const 32)))\n\n  ;; eigth row\n  ;; i * h + $temp7 \n  (local.set $temp7 (i64.add (i64.mul (local.get $i) (local.get $h)) (i64.and (local.get $temp7) (i64.const 4294967295))))\n  ;; i * g + $p \n  (local.set $p     (i64.add (i64.add (i64.mul (local.get $i) (local.get $g)) (i64.and (local.get $p)     (i64.const 4294967295))) (i64.shr_u (local.get $temp7) (i64.const 32))))\n  ;; i * f + $o + carry\n  (local.set $o     (i64.add (i64.add (i64.mul (local.get $i) (local.get $f)) (i64.and (local.get $o)     (i64.const 4294967295))) (i64.shr_u (local.get $p)     (i64.const 32))))\n  ;; i * e + $n + carry\n  (local.set $n     (i64.add (i64.add (i64.mul (local.get $i) (local.get $e)) (i64.and (local.get $n)     (i64.const 4294967295))) (i64.shr_u (local.get $o)     (i64.const 32))))\n  ;; i * d + $m + carry\n  (local.set $m     (i64.add (i64.add (i64.mul (local.get $i) (local.get $d)) (i64.and (local.get $m)     (i64.const 4294967295))) (i64.shr_u (local.get $n)     (i64.const 32))))\n  ;; i * c + $l + carry\n  (local.set $l     (i64.add (i64.add (i64.mul (local.get $i) (local.get $c)) (i64.and (local.get $l)     (i64.const 4294967295))) (i64.shr_u (local.get $m)     (i64.const 32))))\n  ;; i * b + $k + carry\n  (local.set $k     (i64.add (i64.add (i64.mul (local.get $i) (local.get $b)) (i64.and (local.get $k)     (i64.const 4294967295))) (i64.shr_u (local.get $l)     (i64.const 32))))\n  ;; i * a + carry\n  (local.set $j     (i64.add (i64.add (i64.mul (local.get $i) (local.get $a)) (i64.shr_u (local.get $k) (i64.const 32))) (local.get $rowCarry)))\n\n  ;; combine terms\n  (local.set $a (local.get $j))\n  (local.set $b (i64.or (i64.shl (local.get $k)     (i64.const 32)) (i64.and (local.get $l)     (i64.const 4294967295))))\n  (local.set $c (i64.or (i64.shl (local.get $m)     (i64.const 32)) (i64.and (local.get $n)     (i64.const 4294967295))))\n  (local.set $d (i64.or (i64.shl (local.get $o)     (i64.const 32)) (i64.and (local.get $p)     (i64.const 4294967295))))\n  (local.set $e (i64.or (i64.shl (local.get $temp7) (i64.const 32)) (i64.and (local.get $temp6) (i64.const 4294967295))))\n  (local.set $f (i64.or (i64.shl (local.get $temp5) (i64.const 32)) (i64.and (local.get $temp4) (i64.const 4294967295))))\n  (local.set $g (i64.or (i64.shl (local.get $temp3) (i64.const 32)) (i64.and (local.get $temp2) (i64.const 4294967295))))\n  (local.set $h (i64.or (i64.shl (local.get $temp1) (i64.const 32)) (i64.and (local.get $temp0) (i64.const 4294967295))))\n\n  ;; pop the MOD argmunet off the stack\n  (local.set $moda (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $modb (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $modc (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (local.set $modd (i64.load          (local.get $sp)))\n\n  (call $mod_512\n         (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $e) (local.get $f) (local.get $g) (local.get $h) \n         (i64.const 0)  (i64.const 0) (i64.const 0)  (i64.const 0)  (local.get $moda) (local.get $modb) (local.get $modc) (local.get $modd) (i32.add (local.get $sp) (i32.const 24))\n  )\n)\n"
  },
  "NOT": {
    "wast": "(func $NOT\n  ;; FIXME: consider using 0xffffffffffffffff instead of -1?\n  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.xor (i64.load (i32.add (global.get $sp) (i32.const 24))) (i64.const -1)))\n  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.xor (i64.load (i32.add (global.get $sp) (i32.const 16))) (i64.const -1)))\n  (i64.store (i32.add (global.get $sp) (i32.const  8)) (i64.xor (i64.load (i32.add (global.get $sp) (i32.const  8))) (i64.const -1)))\n  (i64.store (i32.add (global.get $sp) (i32.const  0)) (i64.xor (i64.load (i32.add (global.get $sp) (i32.const  0))) (i64.const -1)))\n)\n"
  },
  "OR": {
    "wast": "(func $OR\n  (i64.store (i32.sub (global.get $sp) (i32.const  8)) (i64.or (i64.load (i32.sub (global.get $sp) (i32.const  8))) (i64.load (i32.add (global.get $sp) (i32.const 24)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 16)) (i64.or (i64.load (i32.sub (global.get $sp) (i32.const 16))) (i64.load (i32.add (global.get $sp) (i32.const 16)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 24)) (i64.or (i64.load (i32.sub (global.get $sp) (i32.const 24))) (i64.load (i32.add (global.get $sp) (i32.const  8)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 32)) (i64.or (i64.load (i32.sub (global.get $sp) (i32.const 32))) (i64.load          (global.get $sp))))\n)\n"
  },
  "PC": {
    "wast": "(func $PC\n  (param $pc i32)\n  (local $sp i32)\n\n  ;; add one to the stack\n  (local.set $sp (i32.add (global.get $sp) (i32.const 32)))\n  (i64.store (local.get $sp) (i64.extend_i32_u (local.get $pc)))\n\n  ;; zero out rest of stack\n  (i64.store (i32.add (local.get $sp) (i32.const 8)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "SAR": {
    "wast": "(func $SAR\n    (local $sp i32)\n    (local $x1 i64)\n    (local $x2 i64)\n    (local $x3 i64)\n    (local $x4 i64)\n    (local $y1 i64)\n    (local $y2 i64)\n    (local $y3 i64)\n    (local $y4 i64)\n\n    (local $z1 i64)\n    (local $z2 i64)\n    (local $z3 i64)\n    (local $z4 i64)\n\n    ;; load args from the stack\n    (local.set $x1 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n    (local.set $x2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n    (local.set $x3 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n    (local.set $x4 (i64.load (global.get $sp)))\n\n    (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n    (local.set $y1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n    (local.set $y2 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n    (local.set $y3 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n    (local.set $y4 (i64.load (local.get $sp)))\n\n    (block $label_sar_internal\n        (if (i64.gt_u (i64.clz (local.get $y1)) (i64.const 0)) (then\n            (block\n                (local.set $z1 (call $shr_ (local.get $x1) (local.get $x2) (local.get $x3) (local.get $x4) (local.get $y1) (local.get $y2) (local.get $y3) (local.get $y4)))\n                (local.set $z2 (global.get $global_))\n                (local.set $z3 (global.get $global__1))\n                (local.set $z4 (global.get $global__2))\n\n            )\n            (br $label_sar_internal)\n        ))\n        (if (call $gte_256x256_64 (local.get $x1) (local.get $x2) (local.get $x3) (local.get $x4) (i64.const 0) (i64.const 0) (i64.const 0) (i64.const 256)) (then\n            (local.set $z1 (i64.const 18446744073709551615))\n            (local.set $z2 (i64.const 18446744073709551615))\n            (local.set $z3 (i64.const 18446744073709551615))\n            (local.set $z4 (i64.const 18446744073709551615))\n        ))\n        (if (call $lt_256x256_64 (local.get $x1) (local.get $x2) (local.get $x3) (local.get $x4) (i64.const 0) (i64.const 0) (i64.const 0) (i64.const 256)) (then\n            (block\n                (local.set $y1 (call $shr_ (i64.const 0) (i64.const 0) (i64.const 0) (local.get $x4) (local.get $y1) (local.get $y2) (local.get $y3) (local.get $y4)))\n                (local.set $y2 (global.get $global_))\n                (local.set $y3 (global.get $global__1))\n                (local.set $y4 (global.get $global__2))\n\n            )\n            (block\n                (local.set $z1 (call $shl_ (i64.const 0) (i64.const 0) (i64.const 0) (i64.sub (i64.const 256) (local.get $x4)) (i64.const 18446744073709551615) (i64.const 18446744073709551615) (i64.const 18446744073709551615) (i64.const 18446744073709551615)))\n                (local.set $z2 (global.get $global_))\n                (local.set $z3 (global.get $global__1))\n                (local.set $z4 (global.get $global__2))\n\n            )\n            (block\n                (local.set $z1 (call $or_ (local.get $y1) (local.get $y2) (local.get $y3) (local.get $y4) (local.get $z1) (local.get $z2) (local.get $z3) (local.get $z4)))\n                (local.set $z2 (global.get $global_))\n                (local.set $z3 (global.get $global__1))\n                (local.set $z4 (global.get $global__2))\n\n            )\n        ))\n\n    )\n    (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $z1))\n    (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $z2))\n    (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $z3))\n    (i64.store          (local.get $sp)                 (local.get $z4))\n)\n\n(func $lt_256x256_64\n    (param $x1 i64)\n    (param $x2 i64)\n    (param $x3 i64)\n    (param $x4 i64)\n    (param $y1 i64)\n    (param $y2 i64)\n    (param $y3 i64)\n    (param $y4 i64)\n    (result i32)\n    (local $z i32)\n    (local $condition_106 i32)\n    (local $condition_107 i32)\n    (local $condition_108 i32)\n    (block\n        (block\n            (local.set $condition_106 (call $cmp (local.get $x1) (local.get $y1)))\n            (if (i32.eq (local.get $condition_106) (i32.const 0)) (then\n                (block\n                    (local.set $condition_107 (call $cmp (local.get $x2) (local.get $y2)))\n                    (if (i32.eq (local.get $condition_107) (i32.const 0)) (then\n                        (block\n                            (local.set $condition_108 (call $cmp (local.get $x3) (local.get $y3)))\n                            (if (i32.eq (local.get $condition_108) (i32.const 0)) (then\n                                (local.set $z (i64.lt_u (local.get $x4) (local.get $y4)))\n                            )(else\n                                (if (i32.eq (local.get $condition_108) (i32.const 1)) (then\n                                    (local.set $z (i32.const 0))\n                                )(else\n                                    (local.set $z (i32.const 1))\n                                ))\n                            ))\n\n                        )\n                    )(else\n                        (if (i32.eq (local.get $condition_107) (i32.const 1)) (then\n                            (local.set $z (i32.const 0))\n                        )(else\n                            (local.set $z (i32.const 1))\n                        ))\n                    ))\n\n                )\n            )(else\n                (if (i32.eq (local.get $condition_106) (i32.const 1)) (then\n                    (local.set $z (i32.const 0))\n                )(else\n                    (local.set $z (i32.const 1))\n                ))\n            ))\n\n        )\n\n    )\n    (local.get $z)\n)\n\n(func $gte_256x256_64\n    (param $x1 i64)\n    (param $x2 i64)\n    (param $x3 i64)\n    (param $x4 i64)\n    (param $y1 i64)\n    (param $y2 i64)\n    (param $y3 i64)\n    (param $y4 i64)\n    (result i32)\n    (local $z i32)\n    (block\n        (local.set $z (i32.eqz (call $lt_256x256_64 (local.get $x1) (local.get $x2) (local.get $x3) (local.get $x4) (local.get $y1) (local.get $y2) (local.get $y3) (local.get $y4))))\n\n    )\n    (local.get $z)\n)\n\n\n(func $or_\n    (param $x1 i64)\n    (param $x2 i64)\n    (param $x3 i64)\n    (param $x4 i64)\n    (param $y1 i64)\n    (param $y2 i64)\n    (param $y3 i64)\n    (param $y4 i64)\n    (result i64)\n    (local $r1 i64)\n    (local $r2 i64)\n    (local $r3 i64)\n    (local $r4 i64)\n    (block\n        (local.set $r1 (i64.or (local.get $x1) (local.get $y1)))\n        (local.set $r2 (i64.or (local.get $x2) (local.get $y2)))\n        (local.set $r3 (i64.or (local.get $x3) (local.get $y3)))\n        (local.set $r4 (i64.or (local.get $x4) (local.get $y4)))\n\n    )\n    (global.set $global_ (local.get $r2))\n    (global.set $global__1 (local.get $r3))\n    (global.set $global__2 (local.get $r4))\n    (local.get $r1)\n)\n\n\n(func $cmp\n    (param $a i64)\n    (param $b i64)\n    (result i32)\n    (local $r i32)\n    (block\n        (local.set $r (select (i32.const 4294967295) (i64.ne (local.get $a) (local.get $b)) (i64.lt_u (local.get $a) (local.get $b))))\n\n    )\n    (local.get $r)\n)\n\n\n(func $shr_single_\n    (param $a i64)\n    (param $amount i64)\n    (result i64)\n    (local $x i64)\n    (local $y i64)\n    (block\n        (local.set $y (i64.shl (local.get $a) (i64.sub (i64.const 64) (local.get $amount))))\n        (local.set $x (i64.shr_u (local.get $a) (local.get $amount)))\n\n    )\n    (global.set $global_ (local.get $y))\n    (local.get $x)\n)\n\n(func $shr_\n    (param $x1 i64)\n    (param $x2 i64)\n    (param $x3 i64)\n    (param $x4 i64)\n    (param $y1 i64)\n    (param $y2 i64)\n    (param $y3 i64)\n    (param $y4 i64)\n    (result i64)\n    (local $z1 i64)\n    (local $z2 i64)\n    (local $z3 i64)\n    (local $z4 i64)\n    (local $t i64)\n    (block\n        (if (i32.and (i64.eqz (local.get $x1)) (i64.eqz (local.get $x2))) (then\n            (if (i64.eqz (local.get $x3)) (then\n                (if (i64.eqz (local.get $x4))\n                    (then\n                        (local.set $z1 (local.get $y1))\n                        (local.set $z2 (local.get $y2))\n                        (local.set $z3 (local.get $y3))\n                        (local.set $z4 (local.get $y4))\n                    )\n                    (else\n                        (if (i64.lt_u (local.get $x4) (i64.const 256)) (then\n                            (if (i64.ge_u (local.get $x4) (i64.const 128)) (then\n                                (local.set $y4 (local.get $y2))\n                                (local.set $y3 (local.get $y1))\n                                (local.set $y2 (i64.const 0))\n                                (local.set $y1 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 128)))\n                            ))\n                            (if (i64.ge_u (local.get $x4) (i64.const 64)) (then\n                                (local.set $y4 (local.get $y3))\n                                (local.set $y3 (local.get $y2))\n                                (local.set $y2 (local.get $y1))\n                                (local.set $y1 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 64)))\n                            ))\n                            (nop)\n                            (block\n                                (local.set $z4 (call $shr_single_ (local.get $y4) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (block\n                                (local.set $z3 (call $shr_single_ (local.get $y3) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (local.set $z4 (i64.or (local.get $z4) (local.get $t)))\n                            (block\n                                (local.set $z2 (call $shr_single_ (local.get $y2) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (local.set $z3 (i64.or (local.get $z3) (local.get $t)))\n                            (block\n                                (local.set $z1 (call $shr_single_ (local.get $y1) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (local.set $z2 (i64.or (local.get $z2) (local.get $t)))\n                        ))\n                    )\n                )\n            ))\n        ))\n\n    )\n    (global.set $global_ (local.get $z2))\n    (global.set $global__1 (local.get $z3))\n    (global.set $global__2 (local.get $z4))\n    (local.get $z1)\n)\n\n\n(func $shl_single_\n    (param $a i64)\n    (param $amount i64)\n    (result i64)\n    (local $x i64)\n    (local $y i64)\n    (block\n        (local.set $x (i64.shr_u (local.get $a) (i64.sub (i64.const 64) (local.get $amount))))\n        (local.set $y (i64.shl (local.get $a) (local.get $amount)))\n\n    )\n    (global.set $global_ (local.get $y))\n    (local.get $x)\n)\n\n(func $shl_\n    (param $x1 i64)\n    (param $x2 i64)\n    (param $x3 i64)\n    (param $x4 i64)\n    (param $y1 i64)\n    (param $y2 i64)\n    (param $y3 i64)\n    (param $y4 i64)\n    (result i64)\n    (local $z1 i64)\n    (local $z2 i64)\n    (local $z3 i64)\n    (local $z4 i64)\n    (local $t i64)\n    (local $r i64)\n    (block\n        (if (i32.and (i64.eqz (local.get $x1)) (i64.eqz (local.get $x2))) (then\n            (if (i64.eqz (local.get $x3)) (then\n                (if (i64.eqz (local.get $x4))\n                    (then\n                        (local.set $z1 (local.get $y1))\n                        (local.set $z2 (local.get $y2))\n                        (local.set $z3 (local.get $y3))\n                        (local.set $z4 (local.get $y4))\n                    )\n                    (else\n                        (if (i64.lt_u (local.get $x4) (i64.const 256)) (then\n                            (if (i64.ge_u (local.get $x4) (i64.const 128)) (then\n                                (local.set $y1 (local.get $y3))\n                                (local.set $y2 (local.get $y4))\n                                (local.set $y3 (i64.const 0))\n                                (local.set $y4 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 128)))\n                            ))\n                            (if (i64.ge_u (local.get $x4) (i64.const 64)) (then\n                                (local.set $y1 (local.get $y2))\n                                (local.set $y2 (local.get $y3))\n                                (local.set $y3 (local.get $y4))\n                                (local.set $y4 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 64)))\n                            ))\n                            (nop)\n                            (block\n                                (local.set $t (call $shl_single_ (local.get $y4) (local.get $x4)))\n                                (local.set $z4 (global.get $global_))\n\n                            )\n                            (block\n                                (local.set $r (call $shl_single_ (local.get $y3) (local.get $x4)))\n                                (local.set $z3 (global.get $global_))\n\n                            )\n                            (local.set $z3 (i64.or (local.get $z3) (local.get $t)))\n                            (block\n                                (local.set $t (call $shl_single_ (local.get $y2) (local.get $x4)))\n                                (local.set $z2 (global.get $global_))\n\n                            )\n                            (local.set $z2 (i64.or (local.get $z2) (local.get $r)))\n                            (block\n                                (local.set $r (call $shl_single_ (local.get $y1) (local.get $x4)))\n                                (local.set $z1 (global.get $global_))\n\n                            )\n                            (local.set $z1 (i64.or (local.get $z1) (local.get $t)))\n                        ))\n                    )\n                )\n            ))\n        ))\n\n    )\n    (global.set $global_ (local.get $z2))\n    (global.set $global__1 (local.get $z3))\n    (global.set $global__2 (local.get $z4))\n    (local.get $z1)\n)\n"
  },
  "SDIV": {
    "wast": "(func $SDIV\n  (local $sp i32)\n\n  ;; dividend\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  ;; divisor\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $carry i32)\n  (local $temp  i64)\n  (local $temp2 i64)\n  (local $sign i32)\n\n  (local.set $maskd (i64.const 1))\n\n  ;; load args from the stack\n  (local.set $a (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $b (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $c (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $d (i64.load (global.get $sp)))\n\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c1 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $d1 (i64.load (local.get $sp)))\n\n  ;; get the resulting sign\n  (local.set $sign (i32.wrap_i64 (i64.shr_u (i64.xor (local.get $a1) (local.get $a)) (i64.const 63))))\n\n  ;; convert to unsigned value\n  (if (i64.eqz (i64.clz (local.get $a)))\n    (then\n      (local.set $a (i64.xor (local.get $a) (i64.const -1)))\n      (local.set $b (i64.xor (local.get $b) (i64.const -1)))\n      (local.set $c (i64.xor (local.get $c) (i64.const -1)))\n      (local.set $d (i64.xor (local.get $d) (i64.const -1)))\n\n      ;; a = a + 1\n      (local.set $d (i64.add (local.get $d) (i64.const 1)))\n      (local.set $carry (i64.eqz (local.get $d)))\n      (local.set $c (i64.add (local.get $c) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $c)) (local.get $carry)))\n      (local.set $b (i64.add (local.get $b) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $b)) (local.get $carry)))\n      (local.set $a (i64.add (local.get $a) (i64.extend_i32_u (local.get $carry))))\n    )\n  )\n  (if (i64.eqz (i64.clz (local.get $a1)))\n    (then\n      (local.set $a1 (i64.xor (local.get $a1) (i64.const -1)))\n      (local.set $b1 (i64.xor (local.get $b1) (i64.const -1)))\n      (local.set $c1 (i64.xor (local.get $c1) (i64.const -1)))\n      (local.set $d1 (i64.xor (local.get $d1) (i64.const -1)))\n\n      (local.set $d1 (i64.add (local.get $d1) (i64.const 1)))\n      (local.set $carry (i64.eqz (local.get $d1)))\n      (local.set $c1 (i64.add (local.get $c1) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $c1)) (local.get $carry)))\n      (local.set $b1 (i64.add (local.get $b1) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $b1)) (local.get $carry)))\n      (local.set $a1 (i64.add (local.get $a1) (i64.extend_i32_u (local.get $carry))))\n    )\n  )\n\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n      (br $main)\n    )\n\n    ;; align bits\n    (block $done\n      (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (local.get $a1))) (call $gte_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $a) (local.get $b) (local.get $c) (local.get $d)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (local.set $a1 (i64.add (i64.shl (local.get $a1) (i64.const 1)) (i64.shr_u (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shl (local.get $b1) (i64.const 1)) (i64.shr_u (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shl (local.get $c1) (i64.const 1)) (i64.shr_u (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.shl (local.get $d1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (local.set $maska (i64.add (i64.shl (local.get $maska) (i64.const 1)) (i64.shr_u (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shl (local.get $maskb) (i64.const 1)) (i64.shr_u (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shl (local.get $maskc) (i64.const 1)) (i64.shr_u (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.shl (local.get $maskd) (i64.const 1)))\n\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_256 (local.get $maska) (local.get $maskb) (local.get $maskc) (local.get $maskd))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_256 (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n          (then\n            ;; dividend = dividend - divisor\n            (local.set $carry (i64.lt_u (local.get $d) (local.get $d1)))\n            (local.set $d     (i64.sub  (local.get $d) (local.get $d1)))\n            (local.set $temp  (i64.sub  (local.get $c) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $c)))\n            (local.set $c     (i64.sub  (local.get $temp) (local.get $c1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $c) (local.get $temp)) (local.get $carry)))\n            (local.set $temp  (i64.sub  (local.get $b) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $b)))\n            (local.set $b     (i64.sub  (local.get $temp) (local.get $b1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $b) (local.get $temp)) (local.get $carry)))\n            (local.set $a     (i64.sub  (i64.sub (local.get $a) (i64.extend_i32_u (local.get $carry))) (local.get $a1)))\n\n            ;; result = result + mask\n            (local.set $dq    (i64.add  (local.get $maskd) (local.get $dq)))\n            (local.set $carry (i64.lt_u (local.get $dq) (local.get $maskd)))\n            (local.set $temp  (i64.add  (local.get $cq) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.lt_u (local.get $temp) (local.get $cq)))\n            (local.set $cq    (i64.add  (local.get $maskc) (local.get $temp)))\n            (local.set $carry (i32.or   (i64.lt_u (local.get $cq) (local.get $maskc)) (local.get $carry)))\n            (local.set $temp  (i64.add  (local.get $bq) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.lt_u (local.get $temp) (local.get $bq)))\n            (local.set $bq    (i64.add  (local.get $maskb) (local.get $temp)))\n            (local.set $carry (i32.or   (i64.lt_u (local.get $bq) (local.get $maskb)) (local.get $carry)))\n            (local.set $aq    (i64.add  (local.get $maska) (i64.add (local.get $aq) (i64.extend_i32_u (local.get $carry)))))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (local.set $d1 (i64.add (i64.shr_u (local.get $d1) (i64.const 1)) (i64.shl (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shr_u (local.get $c1) (i64.const 1)) (i64.shl (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shr_u (local.get $b1) (i64.const 1)) (i64.shl (local.get $a1) (i64.const 63))))\n        (local.set $a1 (i64.shr_u (local.get $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (local.set $maskd (i64.add (i64.shr_u (local.get $maskd) (i64.const 1)) (i64.shl (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shr_u (local.get $maskc) (i64.const 1)) (i64.shl (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shr_u (local.get $maskb) (i64.const 1)) (i64.shl (local.get $maska) (i64.const 63))))\n        (local.set $maska (i64.shr_u (local.get $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n\n  ;; convert to signed\n  (if (local.get $sign)\n    (then\n      (local.set $aq (i64.xor (local.get $aq) (i64.const -1)))\n      (local.set $bq (i64.xor (local.get $bq) (i64.const -1)))\n      (local.set $cq (i64.xor (local.get $cq) (i64.const -1)))\n      (local.set $dq (i64.xor (local.get $dq) (i64.const -1)))\n\n      (local.set $dq (i64.add (local.get $dq) (i64.const 1)))\n      (local.set $cq (i64.add (local.get $cq) (i64.extend_i32_u (i64.eqz (local.get $dq)))))\n      (local.set $bq (i64.add (local.get $bq) (i64.extend_i32_u (i64.eqz (local.get $cq)))))\n      (local.set $aq (i64.add (local.get $aq) (i64.extend_i32_u (i64.eqz (local.get $bq)))))\n    )\n  )\n\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $aq))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $bq))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $cq))\n  (i64.store          (local.get $sp)                 (local.get $dq))\n)\n"
  },
  "SGT": {
    "wast": "(func $SGT\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n\n  ;; load args from the stack\n  (local.set $a0 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $a1 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $a2 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $a3 (i64.load (global.get $sp)))\n\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (local.set $b0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $b2 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $b3 (i64.load (local.get $sp)))\n\n  (i64.store (local.get $sp) (i64.extend_i32_u\n    (i32.or  (i64.gt_s (local.get $a0) (local.get $b0)) ;; a0 > b0\n    (i32.and (i64.eq   (local.get $a0) (local.get $b0)) ;; a0 == a1\n    (i32.or  (i64.gt_u (local.get $a1) (local.get $b1)) ;; a1 > b1\n    (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n    (i32.or  (i64.gt_u (local.get $a2) (local.get $b2)) ;; a2 > b2\n    (i32.and (i64.eq   (local.get $a2) (local.get $b2)) ;; a2 == b2\n             (i64.gt_u (local.get $a3) (local.get $b3)))))))))) ;; a3 > b3\n\n  ;; zero  out the rest of the stack item\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "SHA3": {
    "wast": "(func $SHA3\n  (local $dataOffset i32)\n  (local $dataOffset0 i64)\n  (local $dataOffset1 i64)\n  (local $dataOffset2 i64)\n  (local $dataOffset3 i64)\n\n  (local $length i32)\n  (local $length0 i64)\n  (local $length1 i64)\n  (local $length2 i64)\n  (local $length3 i64)\n\n  (local $contextOffset i32)\n  (local $outputOffset i32)\n\n  (local.set $length0 (i64.load (i32.sub (global.get $sp) (i32.const 32))))\n  (local.set $length1 (i64.load (i32.sub (global.get $sp) (i32.const 24))))\n  (local.set $length2 (i64.load (i32.sub (global.get $sp) (i32.const 16))))\n  (local.set $length3 (i64.load (i32.sub (global.get $sp) (i32.const 8))))\n\n  (local.set $dataOffset0 (i64.load (i32.add (global.get $sp) (i32.const 0))))\n  (local.set $dataOffset1 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $dataOffset2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $dataOffset3 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n\n  (local.set $length\n             (call $check_overflow (local.get $length0)\n                                   (local.get $length1)\n                                   (local.get $length2)\n                                   (local.get $length3)))\n  (local.set $dataOffset\n             (call $check_overflow (local.get $dataOffset0)\n                                   (local.get $dataOffset1)\n                                   (local.get $dataOffset2)\n                                   (local.get $dataOffset3)))\n\n  ;; charge copy fee ceil(words/32) * 6\n  (call $useGas (i64.extend_i32_u (i32.mul (i32.div_u (i32.add (local.get $length) (i32.const 31)) (i32.const 32)) (i32.const 6))))\n  (call $memusegas (local.get $dataOffset) (local.get $length))\n\n  (local.set $dataOffset (i32.add (global.get $memstart) (local.get $dataOffset)))\n\n  (local.set $contextOffset (i32.const 32808))\n  (local.set $outputOffset (i32.sub (global.get $sp) (i32.const 32)))\n\n  (call $keccak (local.get $contextOffset) (local.get $dataOffset) (local.get $length) (local.get $outputOffset))\n\n  (drop (call $bswap_m256 (local.get $outputOffset)))\n)\n"
  },
  "SHL": {
    "wast": "(func $SHL\n    (local $sp i32)\n    (local $x1 i64)\n    (local $x2 i64)\n    (local $x3 i64)\n    (local $x4 i64)\n    (local $y1 i64)\n    (local $y2 i64)\n    (local $y3 i64)\n    (local $y4 i64)\n\n    (local $z1 i64)\n    (local $z2 i64)\n    (local $z3 i64)\n    (local $z4 i64)\n    (local $t i64)\n    (local $r i64)\n\n    ;; load args from the stack\n    (local.set $x1 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n    (local.set $x2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n    (local.set $x3 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n    (local.set $x4 (i64.load (global.get $sp)))\n\n    (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n    (local.set $y1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n    (local.set $y2 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n    (local.set $y3 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n    (local.set $y4 (i64.load (local.get $sp)))\n\n    (block\n        (if (i32.and (i64.eqz (local.get $x1)) (i64.eqz (local.get $x2))) (then\n            (if (i64.eqz (local.get $x3)) (then\n                (if (i64.eqz (local.get $x4))\n                    (then\n                        (local.set $z1 (local.get $y1))\n                        (local.set $z2 (local.get $y2))\n                        (local.set $z3 (local.get $y3))\n                        (local.set $z4 (local.get $y4))\n                    )\n                    (else\n                        (if (i64.lt_u (local.get $x4) (i64.const 256)) (then\n                            (if (i64.ge_u (local.get $x4) (i64.const 128)) (then\n                                (local.set $y1 (local.get $y3))\n                                (local.set $y2 (local.get $y4))\n                                (local.set $y3 (i64.const 0))\n                                (local.set $y4 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 128)))\n                            ))\n                            (if (i64.ge_u (local.get $x4) (i64.const 64)) (then\n                                (local.set $y1 (local.get $y2))\n                                (local.set $y2 (local.get $y3))\n                                (local.set $y3 (local.get $y4))\n                                (local.set $y4 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 64)))\n                            ))\n                            (nop)\n                            (block\n                                (local.set $t (call $shl_single (local.get $y4) (local.get $x4)))\n                                (local.set $z4 (global.get $global_))\n\n                            )\n                            (block\n                                (local.set $r (call $shl_single (local.get $y3) (local.get $x4)))\n                                (local.set $z3 (global.get $global_))\n\n                            )\n                            (local.set $z3 (i64.or (local.get $z3) (local.get $t)))\n                            (block\n                                (local.set $t (call $shl_single (local.get $y2) (local.get $x4)))\n                                (local.set $z2 (global.get $global_))\n\n                            )\n                            (local.set $z2 (i64.or (local.get $z2) (local.get $r)))\n                            (block\n                                (local.set $r (call $shl_single (local.get $y1) (local.get $x4)))\n                                (local.set $z1 (global.get $global_))\n\n                            )\n                            (local.set $z1 (i64.or (local.get $z1) (local.get $t)))\n                        ))\n                    )\n                )\n            ))\n        ))\n\n    )\n    (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $z1))\n    (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $z2))\n    (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $z3))\n    (i64.store          (local.get $sp)                 (local.get $z4))\n)\n\n(func $shl_single\n    (param $a i64)\n    (param $amount i64)\n    (result i64)\n    (local $x i64)\n    (local $y i64)\n    (block\n        (local.set $x (i64.shr_u (local.get $a) (i64.sub (i64.const 64) (local.get $amount))))\n        (local.set $y (i64.shl (local.get $a) (local.get $amount)))\n\n    )\n    (global.set $global_ (local.get $y))\n    (local.get $x)\n)\n"
  },
  "SIGNEXTEND": {
    "wast": "(func $SIGNEXTEND\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n  (local $sign i64)\n  (local $t i32)\n  (local $end i32)\n\n  (local.set $a0 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $a1 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $a2 (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $a3 (i64.load          (global.get $sp)))\n\n  (local.set $end (global.get $sp))\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (if (i32.and\n        (i32.and\n          (i32.and\n            (i64.lt_u (local.get $a3) (i64.const 32))\n            (i64.eqz (local.get $a2)))\n          (i64.eqz (local.get $a1)))\n        (i64.eqz (local.get $a0)))\n    (then\n      (local.set $t (i32.add (i32.wrap_i64 (local.get $a3)) (local.get $sp)))\n      (local.set $sign (i64.shr_s (i64.load8_s (local.get $t)) (i64.const 8)))\n      (local.set $t (i32.add (local.get $t) (i32.const 1)))\n      (block $done\n        (loop $loop\n          (if (i32.lt_u (local.get $end) (local.get $t))\n            (br $done)\n          )\n          (i64.store (local.get $t) (local.get $sign))\n          (local.set $t (i32.add (local.get $t) (i32.const 8)))\n          (br $loop)\n        )\n      )\n    )\n  )\n)\n\n"
  },
  "SMOD": {
    "wast": "(func $SMOD\n  (local $sp i32)\n  ;; dividend\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  ;; divisor\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $carry i32)\n  (local $sign i32)\n  (local $temp  i64)\n  (local $temp2  i64)\n\n  ;; load args from the stack\n  (local.set $a (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $b (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $c (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $d (i64.load          (global.get $sp)))\n  ;; decement the stack pointer\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c1 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (local.set $d1 (i64.load          (local.get $sp)))\n\n  (local.set $maskd (i64.const 1))\n  (local.set $sign (i32.wrap_i64 (i64.shr_u (local.get $d) (i64.const 63))))\n\n  ;; convert to unsigned value\n  (if (i64.eqz (i64.clz (local.get $a)))\n    (then\n      (local.set $a (i64.xor (local.get $a) (i64.const -1)))\n      (local.set $b (i64.xor (local.get $b) (i64.const -1)))\n      (local.set $c (i64.xor (local.get $c) (i64.const -1)))\n      (local.set $d (i64.xor (local.get $d) (i64.const -1)))\n\n      ;; a = a + 1\n      (local.set $d (i64.add (local.get $d) (i64.const 1)))\n      (local.set $carry (i64.eqz (local.get $d)))\n      (local.set $c (i64.add (local.get $c) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $c)) (local.get $carry)))\n      (local.set $b (i64.add (local.get $b) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $b)) (local.get $carry)))\n      (local.set $a (i64.add (local.get $a) (i64.extend_i32_u (local.get $carry))))\n    )\n  )\n\n  (if (i64.eqz (i64.clz (local.get $a1)))\n    (then\n      (local.set $a1 (i64.xor (local.get $a1) (i64.const -1)))\n      (local.set $b1 (i64.xor (local.get $b1) (i64.const -1)))\n      (local.set $c1 (i64.xor (local.get $c1) (i64.const -1)))\n      (local.set $d1 (i64.xor (local.get $d1) (i64.const -1)))\n\n      (local.set $d1 (i64.add (local.get $d1) (i64.const 1)))\n      (local.set $carry (i64.eqz (local.get $d1)))\n      (local.set $c1 (i64.add (local.get $c1) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $c1)) (local.get $carry)))\n      (local.set $b1 (i64.add (local.get $b1) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $b1)) (local.get $carry)))\n      (local.set $a1 (i64.add (local.get $a1) (i64.extend_i32_u (local.get $carry))))\n    )\n  )\n\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n      (then\n        (local.set $a (i64.const 0))\n        (local.set $b (i64.const 0))\n        (local.set $c (i64.const 0))\n        (local.set $d (i64.const 0))\n        (br $main)\n      )\n    )\n\n    ;; align bits\n    (block $done\n      (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (local.get $a1))) (call $gte_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $a) (local.get $b) (local.get $c) (local.get $d)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (local.set $a1 (i64.add (i64.shl (local.get $a1) (i64.const 1)) (i64.shr_u (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shl (local.get $b1) (i64.const 1)) (i64.shr_u (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shl (local.get $c1) (i64.const 1)) (i64.shr_u (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.shl (local.get $d1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (local.set $maska (i64.add (i64.shl (local.get $maska) (i64.const 1)) (i64.shr_u (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shl (local.get $maskb) (i64.const 1)) (i64.shr_u (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shl (local.get $maskc) (i64.const 1)) (i64.shr_u (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.shl (local.get $maskd) (i64.const 1)))\n\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_256 (local.get $maska) (local.get $maskb) (local.get $maskc) (local.get $maskd))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_256 (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n          (then\n            ;; dividend = dividend - divisor\n            (local.set $carry (i64.lt_u (local.get $d) (local.get $d1)))\n            (local.set $d     (i64.sub  (local.get $d) (local.get $d1)))\n            (local.set $temp  (i64.sub  (local.get $c) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $c)))\n            (local.set $c     (i64.sub  (local.get $temp) (local.get $c1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $c) (local.get $temp)) (local.get $carry)))\n            (local.set $temp  (i64.sub  (local.get $b) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $b)))\n            (local.set $b     (i64.sub  (local.get $temp) (local.get $b1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $b) (local.get $temp)) (local.get $carry)))\n            (local.set $a     (i64.sub  (i64.sub (local.get $a) (i64.extend_i32_u (local.get $carry))) (local.get $a1)))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (local.set $d1 (i64.add (i64.shr_u (local.get $d1) (i64.const 1)) (i64.shl (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shr_u (local.get $c1) (i64.const 1)) (i64.shl (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shr_u (local.get $b1) (i64.const 1)) (i64.shl (local.get $a1) (i64.const 63))))\n        (local.set $a1 (i64.shr_u (local.get $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (local.set $maskd (i64.add (i64.shr_u (local.get $maskd) (i64.const 1)) (i64.shl (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shr_u (local.get $maskc) (i64.const 1)) (i64.shl (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shr_u (local.get $maskb) (i64.const 1)) (i64.shl (local.get $maska) (i64.const 63))))\n        (local.set $maska (i64.shr_u (local.get $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  )\n\n  ;; convert to signed\n  (if (local.get $sign)\n    (then\n      (local.set $a (i64.xor (local.get $a) (i64.const -1)))\n      (local.set $b (i64.xor (local.get $b) (i64.const -1)))\n      (local.set $c (i64.xor (local.get $c) (i64.const -1)))\n      (local.set $d (i64.xor (local.get $d) (i64.const -1)))\n\n      (local.set $d (i64.add (local.get $d) (i64.const 1)))\n      (local.set $c (i64.add (local.get $c) (i64.extend_i32_u (i64.eqz (local.get $d)))))\n      (local.set $b (i64.add (local.get $b) (i64.extend_i32_u (i64.eqz (local.get $c)))))\n      (local.set $a (i64.add (local.get $a) (i64.extend_i32_u (i64.eqz (local.get $b)))))\n    )\n  )\n\n  ;; save the stack\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $a))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $b))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $c))\n  (i64.store          (local.get $sp)                 (local.get $d))\n) ;; end for SMOD\n"
  },
  "XOR": {
    "wast": "(func $XOR\n  (i64.store (i32.sub (global.get $sp) (i32.const  8)) (i64.xor (i64.load (i32.sub (global.get $sp) (i32.const  8))) (i64.load (i32.add (global.get $sp) (i32.const 24)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 16)) (i64.xor (i64.load (i32.sub (global.get $sp) (i32.const 16))) (i64.load (i32.add (global.get $sp) (i32.const 16)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 24)) (i64.xor (i64.load (i32.sub (global.get $sp) (i32.const 24))) (i64.load (i32.add (global.get $sp) (i32.const  8)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 32)) (i64.xor (i64.load (i32.sub (global.get $sp) (i32.const 32))) (i64.load (i32.add (global.get $sp) (i32.const  0)))))\n)\n"
  },
  "bswap_i32": {
    "wast": "(func $bswap_i32\n  (param $int i32)\n  (result i32)\n\n  (i32.or\n    (i32.or\n      (i32.and (i32.shr_u (local.get $int) (i32.const 24)) (i32.const 0xff)) ;; 7 -> 0\n      (i32.and (i32.shr_u (local.get $int) (i32.const 8)) (i32.const 0xff00))) ;; 6 -> 1\n    (i32.or\n      (i32.and (i32.shl (local.get $int) (i32.const 8)) (i32.const 0xff0000)) ;; 5 -> 2\n      (i32.and (i32.shl (local.get $int) (i32.const 24)) (i32.const 0xff000000)))) ;; 4 -> 3\n)\n"
  },
  "bswap_i64": {
    "wast": "(func $bswap_i64\n  (param $int i64)\n  (result i64)\n\n  (i64.or\n    (i64.or\n      (i64.or\n        (i64.and (i64.shr_u (local.get $int) (i64.const 56)) (i64.const 0xff)) ;; 7 -> 0\n        (i64.and (i64.shr_u (local.get $int) (i64.const 40)) (i64.const 0xff00))) ;; 6 -> 1\n      (i64.or\n        (i64.and (i64.shr_u (local.get $int) (i64.const 24)) (i64.const 0xff0000)) ;; 5 -> 2\n        (i64.and (i64.shr_u (local.get $int) (i64.const  8)) (i64.const 0xff000000)))) ;; 4 -> 3\n    (i64.or\n      (i64.or\n        (i64.and (i64.shl (local.get $int) (i64.const 8))   (i64.const 0xff00000000)) ;; 3 -> 4\n        (i64.and (i64.shl (local.get $int) (i64.const 24))   (i64.const 0xff0000000000))) ;; 2 -> 5\n      (i64.or\n        (i64.and (i64.shl (local.get $int) (i64.const 40))   (i64.const 0xff000000000000)) ;; 1 -> 6\n        (i64.and (i64.shl (local.get $int) (i64.const 56))   (i64.const 0xff00000000000000))))) ;; 0 -> 7\n)\n"
  },
  "bswap_m128": {
    "wast": "(func $bswap_m128\n  (param $sp i32)\n  (result i32)\n  (local $temp i64)\n\n  (local.set $temp (call $bswap_i64 (i64.load (local.get $sp))))\n  (i64.store (local.get $sp) (call $bswap_i64 (i64.load (i32.add (local.get $sp) (i32.const 8)))))\n  (i64.store (i32.add (local.get $sp) (i32.const 8)) (local.get $temp))\n  (local.get $sp)\n)\n"
  },
  "bswap_m160": {
    "wast": "(func $bswap_m160\n  (param $sp i32)\n  (result i32)\n  (local $temp i64)\n\n  (local.set $temp (call $bswap_i64 (i64.load (local.get $sp))))\n  (i64.store (local.get $sp) (call $bswap_i64 (i64.load (i32.add (local.get $sp) (i32.const 12)))))\n  (i64.store (i32.add (local.get $sp) (i32.const 12)) (local.get $temp))\n\n  (i32.store (i32.add (local.get $sp) (i32.const 8)) (call $bswap_i32 (i32.load (i32.add (local.get $sp) (i32.const 8)))))\n  (local.get $sp)\n)\n"
  },
  "bswap_m256": {
    "wast": "(func $bswap_m256\n  (param $sp i32)\n  (result i32)\n  (local $temp i64)\n\n  (local.set $temp (call $bswap_i64 (i64.load (local.get $sp))))\n  (i64.store (local.get $sp) (call $bswap_i64 (i64.load (i32.add (local.get $sp) (i32.const 24)))))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $temp))\n\n  (local.set $temp (call $bswap_i64 (i64.load (i32.add (local.get $sp) (i32.const 8)))))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (call $bswap_i64 (i64.load (i32.add (local.get $sp) (i32.const 16)))))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $temp))\n  (local.get $sp)\n)\n"
  },
  "callback": {
    "wast": "(func $callback\n  (call $main)\n)\n"
  },
  "callback_128": {
    "wast": "(func $callback_128\n  (param $result i32)\n\n  (drop (call $bswap_m128 (global.get $sp)))\n  (call $main)\n)\n"
  },
  "callback_160": {
    "wast": "(func $callback_160\n  (param $result i32)\n\n  (drop (call $bswap_m160 (global.get $sp)))\n  (call $main)\n)\n"
  },
  "callback_256": {
    "wast": "(func $callback_256\n  (param $result i32)\n\n  (drop (call $bswap_m256 (global.get $sp)))\n  (call $main)\n)\n"
  },
  "callback_32": {
    "wast": "(func $callback_32\n  (param $result i32)\n\n  (i64.store (global.get $sp) (i64.extend_i32_u (local.get $result)))\n  ;; zero out mem\n  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const 8)) (i64.const 0))\n\n  (call $main)\n)\n"
  },
  "check_overflow_i64": {
    "wast": "(func $check_overflow_i64\n  (param $a i64)\n  (param $b i64)\n  (param $c i64)\n  (param $d i64)\n  (result i64)\n\n  (if\n    (i32.and \n      (i32.and \n        (i64.eqz  (local.get $d))\n        (i64.eqz  (local.get $c)))\n      (i64.eqz  (local.get $b)))\n    (return (local.get $a)))\n\n    (return (i64.const 0xffffffffffffffff))\n)\n"
  },
  "gte_256": {
    "wast": ";; is a less than or equal to b // a >= b\n(func $gte_256\n  (param $a0 i64)\n  (param $a1 i64)\n  (param $a2 i64)\n  (param $a3 i64)\n\n  (param $b0 i64)\n  (param $b1 i64)\n  (param $b2 i64)\n  (param $b3 i64)\n\n  (result i32)\n\n  ;; a0 > b0 || [a0 == b0 && [a1 > b1 || [a1 == b1 && [a2 > b2 || [a2 == b2 && a3 >= b3 ]]]]\n  (i32.or  (i64.gt_u (local.get $a0) (local.get $b0)) ;; a0 > b0\n  (i32.and (i64.eq   (local.get $a0) (local.get $b0))\n  (i32.or  (i64.gt_u (local.get $a1) (local.get $b1)) ;; a1 > b1\n  (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n  (i32.or  (i64.gt_u (local.get $a2) (local.get $b2)) ;; a2 > b2\n  (i32.and (i64.eq   (local.get $a2) (local.get $b2))\n           (i64.ge_u (local.get $a3) (local.get $b3))))))))\n)\n"
  },
  "gte_320": {
    "wast": "(func $gte_320\n  (param $a0 i64)\n  (param $a1 i64)\n  (param $a2 i64)\n  (param $a3 i64)\n  (param $a4 i64)\n\n  (param $b0 i64)\n  (param $b1 i64)\n  (param $b2 i64)\n  (param $b3 i64)\n  (param $b4 i64)\n\n  (result i32)\n\n  ;; a0 > b0 || [a0 == b0 && [a1 > b1 || [a1 == b1 && [a2 > b2 || [a2 == b2 && a3 >= b3 ]]]]\n  (i32.or  (i64.gt_u (local.get $a0) (local.get $b0)) ;; a0 > b0\n  (i32.and (i64.eq   (local.get $a0) (local.get $b0))\n  (i32.or  (i64.gt_u (local.get $a1) (local.get $b1)) ;; a1 > b1\n  (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n  (i32.or  (i64.gt_u (local.get $a2) (local.get $b2)) ;; a2 > b2\n  (i32.and (i64.eq   (local.get $a2) (local.get $b2))\n  (i32.or  (i64.gt_u (local.get $a3) (local.get $b3)) ;; a2 > b2\n  (i32.and (i64.eq   (local.get $a3) (local.get $b3))\n           (i64.ge_u (local.get $a4) (local.get $b4))))))))))\n)\n"
  },
  "gte_512": {
    "wast": "(func $gte_512\n  (param $a0 i64)\n  (param $a1 i64)\n  (param $a2 i64)\n  (param $a3 i64)\n  (param $a4 i64)\n  (param $a5 i64)\n  (param $a6 i64)\n  (param $a7 i64)\n\n  (param $b0 i64)\n  (param $b1 i64)\n  (param $b2 i64)\n  (param $b3 i64)\n  (param $b4 i64)\n  (param $b5 i64)\n  (param $b6 i64)\n  (param $b7 i64)\n\n  (result i32)\n\n  ;; a0 > b0 || [a0 == b0 && [a1 > b1 || [a1 == b1 && [a2 > b2 || [a2 == b2 && a3 >= b3 ]]]]\n  (i32.or  (i64.gt_u (local.get $a0) (local.get $b0)) ;; a0 > b0\n  (i32.and (i64.eq   (local.get $a0) (local.get $b0))\n  (i32.or  (i64.gt_u (local.get $a1) (local.get $b1)) ;; a1 > b1\n  (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n  (i32.or  (i64.gt_u (local.get $a2) (local.get $b2)) ;; a2 > b2\n  (i32.and (i64.eq   (local.get $a2) (local.get $b2))\n  (i32.or  (i64.gt_u (local.get $a3) (local.get $b3)) ;; a3 > b3\n  (i32.and (i64.eq   (local.get $a3) (local.get $b3))\n  (i32.or  (i64.gt_u (local.get $a4) (local.get $b4)) ;; a4 > b4\n  (i32.and (i64.eq   (local.get $a4) (local.get $b4))\n  (i32.or  (i64.gt_u (local.get $a5) (local.get $b5)) ;; a5 > b5\n  (i32.and (i64.eq   (local.get $a5) (local.get $b5))\n  (i32.or  (i64.gt_u (local.get $a6) (local.get $b6)) ;; a6 > b6\n  (i32.and (i64.eq   (local.get $a6) (local.get $b6))\n           (i64.ge_u (local.get $a7) (local.get $b7))))))))))))))))\n)\n"
  },
  "iszero_256": {
    "wast": "(func $iszero_256\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (result i32)\n\n  (i64.eqz (i64.or (i64.or (i64.or (local.get 0) (local.get 1)) (local.get 2)) (local.get 3))) \n)\n"
  },
  "iszero_320": {
    "wast": "(func $iszero_320\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (result i32)\n\n  (i64.eqz (i64.or (i64.or (i64.or (i64.or (local.get 0) (local.get 1)) (local.get 2)) (local.get 3)) (local.get 4)))\n)\n"
  },
  "iszero_512": {
    "wast": "(func $iszero_512\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (result i32)\n  (i64.eqz (i64.or (i64.or (i64.or (i64.or (i64.or (i64.or (i64.or (local.get 0) (local.get 1)) (local.get 2)) (local.get 3)) (local.get 4)) (local.get 5)) (local.get 6)) (local.get 7)))\n)\n"
  },
  "keccak": {
    "wast": ";;\n;; Copied from https://github.com/axic/keccak-wasm (has more comments)\n;;\n\n(func $keccak_theta\n  (param $context_offset i32)\n\n  (local $C0 i64)\n  (local $C1 i64)\n  (local $C2 i64)\n  (local $C3 i64)\n  (local $C4 i64)\n  (local $D0 i64)\n  (local $D1 i64)\n  (local $D2 i64)\n  (local $D3 i64)\n  (local $D4 i64)\n\n  ;; C[x] = A[x] ^ A[x + 5] ^ A[x + 10] ^ A[x + 15] ^ A[x + 20];\n  (local.set $C0\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 0)))\n      (i64.xor\n        (i64.load (i32.add (local.get $context_offset) (i32.const 40)))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.const 80)))\n          (i64.xor\n            (i64.load (i32.add (local.get $context_offset) (i32.const 120)))\n            (i64.load (i32.add (local.get $context_offset) (i32.const 160)))\n          )\n        )\n      )\n    )\n  )\n\n  (local.set $C1\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 8)))\n      (i64.xor\n        (i64.load (i32.add (local.get $context_offset) (i32.const 48)))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.const 88)))\n          (i64.xor\n            (i64.load (i32.add (local.get $context_offset) (i32.const 128)))\n            (i64.load (i32.add (local.get $context_offset) (i32.const 168)))\n          )\n        )\n      )\n    )\n  )\n\n  (local.set $C2\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 16)))\n      (i64.xor\n        (i64.load (i32.add (local.get $context_offset) (i32.const 56)))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.const 96)))\n          (i64.xor\n            (i64.load (i32.add (local.get $context_offset) (i32.const 136)))\n            (i64.load (i32.add (local.get $context_offset) (i32.const 176)))\n          )\n        )\n      )\n    )\n  )\n\n  (local.set $C3\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 24)))\n      (i64.xor\n        (i64.load (i32.add (local.get $context_offset) (i32.const 64)))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.const 104)))\n          (i64.xor\n            (i64.load (i32.add (local.get $context_offset) (i32.const 144)))\n            (i64.load (i32.add (local.get $context_offset) (i32.const 184)))\n          )\n        )\n      )\n    )\n  )\n\n  (local.set $C4\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 32)))\n      (i64.xor\n        (i64.load (i32.add (local.get $context_offset) (i32.const 72)))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.const 112)))\n          (i64.xor\n            (i64.load (i32.add (local.get $context_offset) (i32.const 152)))\n            (i64.load (i32.add (local.get $context_offset) (i32.const 192)))\n          )\n        )\n      )\n    )\n  )\n\n  ;; D[0] = ROTL64(C[1], 1) ^ C[4];\n  (local.set $D0\n    (i64.xor\n      (local.get $C4)\n      (i64.rotl\n        (local.get $C1)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; D[1] = ROTL64(C[2], 1) ^ C[0];\n  (local.set $D1\n    (i64.xor\n      (local.get $C0)\n      (i64.rotl\n        (local.get $C2)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; D[2] = ROTL64(C[3], 1) ^ C[1];\n  (local.set $D2\n    (i64.xor\n      (local.get $C1)\n      (i64.rotl\n        (local.get $C3)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; D[3] = ROTL64(C[4], 1) ^ C[2];\n  (local.set $D3\n    (i64.xor\n      (local.get $C2)\n      (i64.rotl\n        (local.get $C4)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; D[4] = ROTL64(C[0], 1) ^ C[3];\n  (local.set $D4\n    (i64.xor\n      (local.get $C3)\n      (i64.rotl\n        (local.get $C0)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; A[x]      ^= D[x];\n  ;; A[x + 5]  ^= D[x];\n  ;; A[x + 10] ^= D[x];\n  ;; A[x + 15] ^= D[x];\n  ;; A[x + 20] ^= D[x];\n  \n  ;; x = 0\n  (i64.store (i32.add (local.get $context_offset) (i32.const 0))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 0)))\n      (local.get $D0)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 40))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 40)))\n      (local.get $D0)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 80))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 80)))\n      (local.get $D0)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 120))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 120)))\n      (local.get $D0)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 160))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 160)))\n      (local.get $D0)\n    )\n  )\n\n  ;; x = 1\n  (i64.store (i32.add (local.get $context_offset) (i32.const 8))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 8)))\n      (local.get $D1)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 48))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 48)))\n      (local.get $D1)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 88))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 88)))\n      (local.get $D1)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 128))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 128)))\n      (local.get $D1)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 168))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 168)))\n      (local.get $D1)\n    )\n  )\n\n  ;; x = 2\n  (i64.store (i32.add (local.get $context_offset) (i32.const 16))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 16)))\n      (local.get $D2)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 56))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 56)))\n      (local.get $D2)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 96))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 96)))\n      (local.get $D2)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 136))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 136)))\n      (local.get $D2)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 176))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 176)))\n      (local.get $D2)\n    )\n  )\n\n  ;; x = 3\n  (i64.store (i32.add (local.get $context_offset) (i32.const 24))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 24)))\n      (local.get $D3)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 64))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 64)))\n      (local.get $D3)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 104))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 104)))\n      (local.get $D3)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 144))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 144)))\n      (local.get $D3)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 184))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 184)))\n      (local.get $D3)\n    )\n  )\n\n  ;; x = 4\n  (i64.store (i32.add (local.get $context_offset) (i32.const 32))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 32)))\n      (local.get $D4)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 72))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 72)))\n      (local.get $D4)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 112))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 112)))\n      (local.get $D4)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 152))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 152)))\n      (local.get $D4)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 192))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 192)))\n      (local.get $D4)\n    )\n  )\n)\n\n(func $keccak_rho\n  (param $context_offset i32)\n  (param $rotation_consts i32)\n\n  ;;(local $tmp i32)\n\n  ;; state[ 1] = ROTL64(state[ 1],  1);\n  ;;(local.set $tmp (i32.add (local.get $context_offset) (i32.const 1)))\n  ;;(i64.store (local.get $tmp) (i64.rotl (i64.load (local.get $context_offset)) (i64.const 1)))\n\n  ;;(local.set $tmp (i32.add (local.get $context_offset) (i32.const 2)))\n  ;;(i64.store (local.get $tmp) (i64.rotl (i64.load (local.get $context_offset)) (i64.const 62)))\n\n  (local $tmp i32)\n  (local $i i32)\n\n  ;; for (i = 0; i <= 24; i++)\n  (local.set $i (i32.const 0))\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (local.get $i) (i32.const 24))\n        (br $done)\n      )\n\n      (local.set $tmp (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (i32.const 1) (local.get $i)))))\n\n      (i64.store (local.get $tmp) (i64.rotl (i64.load (local.get $tmp)) (i64.load8_u (i32.add (local.get $rotation_consts) (local.get $i)))))\n\n      (local.set $i (i32.add (local.get $i) (i32.const 1)))\n      (br $loop)\n    )\n  )\n)\n\n(func $keccak_pi\n  (param $context_offset i32)\n\n  (local $A1 i64)\n  (local.set $A1 (i64.load (i32.add (local.get $context_offset) (i32.const 8))))\n\n  ;; Swap non-overlapping fields, i.e. $A1 = $A6, etc.\n  ;; NOTE: $A0 is untouched\n  (i64.store (i32.add (local.get $context_offset) (i32.const 8)) (i64.load (i32.add (local.get $context_offset) (i32.const 48))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 48)) (i64.load (i32.add (local.get $context_offset) (i32.const 72))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 72)) (i64.load (i32.add (local.get $context_offset) (i32.const 176))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 176)) (i64.load (i32.add (local.get $context_offset) (i32.const 112))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 112)) (i64.load (i32.add (local.get $context_offset) (i32.const 160))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 160)) (i64.load (i32.add (local.get $context_offset) (i32.const 16))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 16)) (i64.load (i32.add (local.get $context_offset) (i32.const 96))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 96)) (i64.load (i32.add (local.get $context_offset) (i32.const 104))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 104)) (i64.load (i32.add (local.get $context_offset) (i32.const 152))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 152)) (i64.load (i32.add (local.get $context_offset) (i32.const 184))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 184)) (i64.load (i32.add (local.get $context_offset) (i32.const 120))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 120)) (i64.load (i32.add (local.get $context_offset) (i32.const 32))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 32)) (i64.load (i32.add (local.get $context_offset) (i32.const 192))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 192)) (i64.load (i32.add (local.get $context_offset) (i32.const 168))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 168)) (i64.load (i32.add (local.get $context_offset) (i32.const 64))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 64)) (i64.load (i32.add (local.get $context_offset) (i32.const 128))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 128)) (i64.load (i32.add (local.get $context_offset) (i32.const 40))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 40)) (i64.load (i32.add (local.get $context_offset) (i32.const 24))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 24)) (i64.load (i32.add (local.get $context_offset) (i32.const 144))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 144)) (i64.load (i32.add (local.get $context_offset) (i32.const 136))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 136)) (i64.load (i32.add (local.get $context_offset) (i32.const 88))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 88)) (i64.load (i32.add (local.get $context_offset) (i32.const 56))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 56)) (i64.load (i32.add (local.get $context_offset) (i32.const 80))))\n\n  ;; Place the previously saved overlapping field\n  (i64.store (i32.add (local.get $context_offset) (i32.const 80)) (local.get $A1))\n)\n\n(func $keccak_chi\n  (param $context_offset i32)\n\n  (local $A0 i64)\n  (local $A1 i64)\n  (local $i i32)\n\n  ;; for (round = 0; round < 25; i += 5)\n  (local.set $i (i32.const 0))\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (local.get $i) (i32.const 25))\n        (br $done)\n      )\n\n      (local.set $A0 (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (local.get $i)))))\n      (local.set $A1 (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 1))))))\n\n      ;; A[0 + i] ^= ~A1 & A[2 + i];\n      (i64.store (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (local.get $i)))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (local.get $i))))\n          (i64.and\n            (i64.xor (local.get $A1) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 2)))))\n          )\n        )\n      )\n\n      ;; A[1 + i] ^= ~A[2 + i] & A[3 + i];\n      (i64.store (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 1))))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 1)))))\n          (i64.and\n            (i64.xor (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 2))))) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 3)))))\n          )\n        )\n      )\n\n      ;; A[2 + i] ^= ~A[3 + i] & A[4 + i];\n      (i64.store (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 2))))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 2)))))\n          (i64.and\n            (i64.xor (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 3))))) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 4)))))\n          )\n        )\n      )\n\n      ;; A[3 + i] ^= ~A[4 + i] & A0;\n      (i64.store (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 3))))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 3)))))\n          (i64.and\n            (i64.xor (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 4))))) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (local.get $A0)\n          )\n        )\n      )\n\n      ;; A[4 + i] ^= ~A0 & A1;\n      (i64.store (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 4))))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 4)))))\n          (i64.and\n            (i64.xor (local.get $A0) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (local.get $A1)\n          )\n        )\n      )\n\n      (local.set $i (i32.add (local.get $i) (i32.const 5)))\n      (br $loop)\n    )\n  )\n)\n\n(func $keccak_permute\n  (param $context_offset i32)\n\n  (local $rotation_consts i32)\n  (local $round_consts i32)\n  (local $round i32)\n\n  (local.set $round_consts (i32.add (local.get $context_offset) (i32.const 400)))\n  (local.set $rotation_consts (i32.add (local.get $context_offset) (i32.const 592)))\n\n  ;; for (round = 0; round < 24; round++)\n  (local.set $round (i32.const 0))\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (local.get $round) (i32.const 24))\n        (br $done)\n      )\n\n      ;; theta transform\n      (call $keccak_theta (local.get $context_offset))\n\n      ;; rho transform\n      (call $keccak_rho (local.get $context_offset) (local.get $rotation_consts))\n\n      ;; pi transform\n      (call $keccak_pi (local.get $context_offset))\n\n      ;; chi transform\n      (call $keccak_chi (local.get $context_offset))\n\n      ;; iota transform\n      ;; context_offset[0] ^= KECCAK_ROUND_CONSTANTS[round];\n      (i64.store (local.get $context_offset)\n        (i64.xor\n          (i64.load (local.get $context_offset))\n          (i64.load (i32.add (local.get $round_consts) (i32.mul (i32.const 8) (local.get $round))))\n        )\n      )\n\n      (local.set $round (i32.add (local.get $round) (i32.const 1)))\n      (br $loop)\n    )  \n  ) \n)\n\n(func $keccak_block\n  (param $input_offset i32)\n  (param $input_length i32) ;; ignored, we expect keccak256\n  (param $context_offset i32)\n\n  ;; read blocks in little-endian order and XOR against context_offset\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 0))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 0)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 0)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 8))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 8)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 8)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 16))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 16)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 16)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 24))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 24)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 24)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 32))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 32)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 32)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 40))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 40)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 40)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 48))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 48)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 48)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 56))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 56)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 56)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 64))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 64)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 64)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 72))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 72)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 72)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 80))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 80)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 80)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 88))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 88)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 88)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 96))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 96)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 96)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 104))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 104)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 104)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 112))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 112)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 112)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 120))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 120)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 120)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 128))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 128)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 128)))\n    )\n  )\n  \n  (call $keccak_permute (local.get $context_offset))\n)\n\n;;\n;; Initialise the context\n;;\n(func $keccak_init\n  (param $context_offset i32)\n  (local $round_consts i32)\n  (local $rotation_consts i32)\n\n  (call $keccak_reset (local.get $context_offset))\n\n  ;; insert the round constants (used by $KECCAK_IOTA)\n  (local.set $round_consts (i32.add (local.get $context_offset) (i32.const 400)))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 0)) (i64.const 0x0000000000000001))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 8)) (i64.const 0x0000000000008082))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 16)) (i64.const 0x800000000000808A))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 24)) (i64.const 0x8000000080008000))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 32)) (i64.const 0x000000000000808B))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 40)) (i64.const 0x0000000080000001))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 48)) (i64.const 0x8000000080008081))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 56)) (i64.const 0x8000000000008009))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 64)) (i64.const 0x000000000000008A))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 72)) (i64.const 0x0000000000000088))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 80)) (i64.const 0x0000000080008009))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 88)) (i64.const 0x000000008000000A))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 96)) (i64.const 0x000000008000808B))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 104)) (i64.const 0x800000000000008B))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 112)) (i64.const 0x8000000000008089))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 120)) (i64.const 0x8000000000008003))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 128)) (i64.const 0x8000000000008002))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 136)) (i64.const 0x8000000000000080))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 144)) (i64.const 0x000000000000800A))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 152)) (i64.const 0x800000008000000A))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 160)) (i64.const 0x8000000080008081))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 168)) (i64.const 0x8000000000008080))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 176)) (i64.const 0x0000000080000001))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 184)) (i64.const 0x8000000080008008))\n\n  ;; insert the rotation constants (used by $keccak_rho)\n  (local.set $rotation_consts (i32.add (local.get $context_offset) (i32.const 592)))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 0)) (i32.const 1))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 1)) (i32.const 62))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 2)) (i32.const 28))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 3)) (i32.const 27))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 4)) (i32.const 36))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 5)) (i32.const 44))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 6)) (i32.const 6))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 7)) (i32.const 55))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 8)) (i32.const 20))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 9)) (i32.const 3))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 10)) (i32.const 10))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 11)) (i32.const 43))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 12)) (i32.const 25))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 13)) (i32.const 39))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 14)) (i32.const 41))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 15)) (i32.const 45))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 16)) (i32.const 15))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 17)) (i32.const 21))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 18)) (i32.const 8))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 19)) (i32.const 18))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 20)) (i32.const 2))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 21)) (i32.const 61))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 22)) (i32.const 56))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 23)) (i32.const 14))\n)\n\n;;\n;; Reset the context\n;;\n(func $keccak_reset\n  (param $context_offset i32)\n\n  ;; clear out the context memory\n  (drop (call $memset (local.get $context_offset) (i32.const 0) (i32.const 400)))\n)\n\n;;\n;; Push input to the context\n;;\n(func $keccak_update\n  (param $context_offset i32)\n  (param $input_offset i32)\n  (param $input_length i32)\n\n  (local $residue_offset i32)\n  (local $residue_buffer i32)\n  (local $residue_index i32)\n  (local $tmp i32)\n\n  ;; this is where we store the pointer\n  (local.set $residue_offset (i32.add (local.get $context_offset) (i32.const 200)))\n  ;; this is where the buffer is\n  (local.set $residue_buffer (i32.add (local.get $context_offset) (i32.const 208)))\n\n  (local.set $residue_index (i32.load (local.get $residue_offset)))\n\n  ;; process residue from last block\n  (if (i32.ne (local.get $residue_index) (i32.const 0))\n    (then\n      ;; the space left in the residue buffer\n      (local.set $tmp (i32.sub (i32.const 136) (local.get $residue_index)))\n\n      ;; limit to what we have as an input\n      (if (i32.lt_u (local.get $input_length) (local.get $tmp))\n        (local.set $tmp (local.get $input_length))\n      )\n\n      ;; fill up the residue buffer\n      (drop (call $memcpy\n        (i32.add (local.get $residue_buffer) (local.get $residue_index))\n        (local.get $input_offset)\n        (local.get $tmp)\n      ))\n\n      (local.set $residue_index (i32.add (local.get $residue_index) (local.get $tmp)))\n\n      ;; block complete\n      (if (i32.eq (local.get $residue_index) (i32.const 136))\n        (call $keccak_block (local.get $input_offset) (i32.const 136) (local.get $context_offset))\n\n        (local.set $residue_index (i32.const 0))\n      )\n\n      (i32.store (local.get $residue_offset) (local.get $residue_index))\n\n      (local.set $input_length (i32.sub (local.get $input_length) (local.get $tmp)))\n    )\n  )\n\n  ;; while (input_length > block_size)\n  (block $done\n    (loop $loop\n      (if (i32.lt_u (local.get $input_length) (i32.const 136))\n        (br $done)\n      )\n\n      (call $keccak_block (local.get $input_offset) (i32.const 136) (local.get $context_offset))\n\n      (local.set $input_offset (i32.add (local.get $input_offset) (i32.const 136)))\n      (local.set $input_length (i32.sub (local.get $input_length) (i32.const 136)))\n      (br $loop)\n    )\n  )\n\n  ;; copy to the residue buffer\n  (if (i32.gt_u (local.get $input_length) (i32.const 0))\n    (then\n      (drop (call $memcpy\n        (i32.add (local.get $residue_buffer) (local.get $residue_index))\n        (local.get $input_offset)\n        (local.get $input_length)\n      ))\n\n      (local.set $residue_index (i32.add (local.get $residue_index) (local.get $input_length)))\n      (i32.store (local.get $residue_offset) (local.get $residue_index))\n    )\n  )\n)\n\n;;\n;; Finalise and return the hash\n;;\n;; The 256 bit hash is returned at the output offset.\n;;\n(func $keccak_finish\n  (param $context_offset i32)\n  (param $output_offset i32)\n\n  (local $residue_offset i32)\n  (local $residue_buffer i32)\n  (local $residue_index i32)\n  (local $tmp i32)\n\n  ;; this is where we store the pointer\n  (local.set $residue_offset (i32.add (local.get $context_offset) (i32.const 200)))\n  ;; this is where the buffer is\n  (local.set $residue_buffer (i32.add (local.get $context_offset) (i32.const 208)))\n\n  (local.set $residue_index (i32.load (local.get $residue_offset)))\n  (local.set $tmp (local.get $residue_index))\n\n  ;; clear the rest of the residue buffer\n  (drop (call $memset (i32.add (local.get $residue_buffer) (local.get $tmp)) (i32.const 0) (i32.sub (i32.const 136) (local.get $tmp))))\n\n  ;; ((char*)ctx->message)[ctx->rest] |= 0x01;\n  (local.set $tmp (i32.add (local.get $residue_buffer) (local.get $residue_index)))\n  (i32.store8 (local.get $tmp) (i32.or (i32.load8_u (local.get $tmp)) (i32.const 0x01)))\n\n  ;; ((char*)ctx->message)[block_size - 1] |= 0x80;\n  (local.set $tmp (i32.add (local.get $residue_buffer) (i32.const 135)))\n  (i32.store8 (local.get $tmp) (i32.or (i32.load8_u (local.get $tmp)) (i32.const 0x80)))\n\n  (call $keccak_block (local.get $residue_buffer) (i32.const 136) (local.get $context_offset))\n\n  ;; the first 32 bytes pointed at by $output_offset is the final hash\n  (i64.store (local.get $output_offset) (i64.load (local.get $context_offset)))\n  (i64.store (i32.add (local.get $output_offset) (i32.const 8)) (i64.load (i32.add (local.get $context_offset) (i32.const 8))))\n  (i64.store (i32.add (local.get $output_offset) (i32.const 16)) (i64.load (i32.add (local.get $context_offset) (i32.const 16))))\n  (i64.store (i32.add (local.get $output_offset) (i32.const 24)) (i64.load (i32.add (local.get $context_offset) (i32.const 24))))\n)\n\n;;\n;; Calculate the hash. Helper method incorporating the above three.\n;;\n(func $keccak\n  (param $context_offset i32)\n  (param $input_offset i32)\n  (param $input_length i32)\n  (param $output_offset i32)\n\n  (call $keccak_init (local.get $context_offset))\n  (call $keccak_update (local.get $context_offset) (local.get $input_offset) (local.get $input_length))\n  (call $keccak_finish (local.get $context_offset) (local.get $output_offset))\n)\n"
  },
  "memcpy": {
    "wast": ";;\n;; memcpy from ewasm-libc/ewasm-cleanup\n;;\n(func $memcpy\n  (param $dst i32)\n  (param $src i32)\n  (param $length i32)\n  (result i32)\n\n  (local $i i32)\n\n  (local.set $i (i32.const 0))\n\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (local.get $i) (local.get $length))\n        (br $done)\n      )\n\n      (i32.store8 (i32.add (local.get $dst) (local.get $i)) (i32.load8_u (i32.add (local.get $src) (local.get $i))))\n\n      (local.set $i (i32.add (local.get $i) (i32.const 1)))\n      (br $loop)\n    )\n  )\n\n  (return (local.get $dst))\n)\n"
  },
  "memset": {
    "wast": ";;\n;; memcpy from ewasm-libc/ewasm-cleanup\n;;\n(func $memset\n  (param $ptr i32)\n  (param $value i32)\n  (param $length i32)\n  (result i32)\n  (local $i i32)\n\n  (local.set $i (i32.const 0))\n\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (local.get $i) (local.get $length))\n        (br $done)\n      )\n\n      (i32.store8 (i32.add (local.get $ptr) (local.get $i)) (local.get $value))\n\n      (local.set $i (i32.add (local.get $i) (i32.const 1)))\n      (br $loop)\n    )\n  )\n  (local.get $ptr)\n)\n"
  },
  "memusegas": {
    "wast": "(func $memusegas\n  (param $offset i32)\n  (param $length i32)\n\n  (local $cost i64)\n  ;; the number of new words being allocated\n  (local $newWordCount i64)\n\n  (if (i32.eqz (local.get $length))\n    (then (return))\n  )\n\n  ;; const newMemoryWordCount = Math.ceil[[offset + length] / 32]\n  (local.set $newWordCount\n    (i64.div_u (i64.add (i64.const 31) (i64.add (i64.extend_i32_u (local.get $offset)) (i64.extend_i32_u (local.get $length))))\n               (i64.const 32)))\n\n  ;;if [runState.highestMem >= highestMem]  return\n  (if (i64.le_u (local.get $newWordCount) (global.get $wordCount))\n    (then (return))\n  )\n\n  ;; words * 3 + words ^2 / 512\n  (local.set $cost\n     (i64.add\n       (i64.mul (local.get $newWordCount) (i64.const 3))\n       (i64.div_u\n         (i64.mul (local.get $newWordCount)\n                  (local.get $newWordCount))\n         (i64.const 512))))\n\n  (call $useGas  (i64.sub (local.get $cost) (global.get $prevMemCost)))\n  (global.set $prevMemCost (local.get $cost))\n  (global.set $wordCount (local.get $newWordCount))\n\n  ;; grow actual memory\n  ;; the first 31704 bytes are guaranteed to be available\n  ;; adjust for 32 bytes  - the maximal size of MSTORE write\n  ;; TODO it should be memory.size * page_size\n  (local.set $offset (i32.add (local.get $length) (i32.add (local.get $offset) (global.get $memstart))))\n  (if (i32.gt_u (local.get $offset) (i32.mul (i32.const 65536) (memory.size)))\n    (then\n      (drop (memory.grow\n        (i32.div_u (i32.add (i32.const 65535) (i32.sub (local.get $offset) (memory.size))) (i32.const 65536))))\n    )\n  )\n)\n"
  },
  "mod_320": {
    "wast": "(func $mod_320\n  ;; dividend\n  (param $a i64)\n  (param $b i64)\n  (param $c i64)\n  (param $d i64)\n  (param $e i64)\n\n  ;; divisor\n  (param $a1 i64)\n  (param $b1 i64)\n  (param $c1 i64)\n  (param $d1 i64)\n  (param $e1 i64)\n\n  ;; stack pointer\n  (param $sp i32)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n  (local $eq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $maske i64)\n\n  (local $carry i32)\n  (local $temp i64)\n\n  (local.set $maske (i64.const 1))\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_320 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $e1))\n      (then\n        (local.set $a (i64.const 0))\n        (local.set $b (i64.const 0))\n        (local.set $c (i64.const 0))\n        (local.set $d (i64.const 0))\n        (local.set $e (i64.const 0))\n        (br $main)\n      )\n    )\n\n    (block $done\n      ;; align bits\n      (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (local.get $a1))) (call $gte_320\n                                                            (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $e1)\n                                                            (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $e)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (local.set $a1 (i64.add (i64.shl (local.get $a1) (i64.const 1)) (i64.shr_u (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shl (local.get $b1) (i64.const 1)) (i64.shr_u (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shl (local.get $c1) (i64.const 1)) (i64.shr_u (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.add (i64.shl (local.get $d1) (i64.const 1)) (i64.shr_u (local.get $e1) (i64.const 63))))\n        (local.set $e1 (i64.shl (local.get $e1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (local.set $maska (i64.add (i64.shl (local.get $maska) (i64.const 1)) (i64.shr_u (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shl (local.get $maskb) (i64.const 1)) (i64.shr_u (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shl (local.get $maskc) (i64.const 1)) (i64.shr_u (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.add (i64.shl (local.get $maskd) (i64.const 1)) (i64.shr_u (local.get $maske) (i64.const 63))))\n        (local.set $maske (i64.shl (local.get $maske) (i64.const 1)))\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_320 (local.get $maska) (local.get $maskb) (local.get $maskc) (local.get $maskd) (local.get $maske))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_320 (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $e) (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $e1))\n          (then\n            ;; dividend = dividend - divisor\n            (local.set $carry (i64.lt_u (local.get $e) (local.get $e1)))\n            (local.set $e     (i64.sub  (local.get $e) (local.get $e1)))\n\n            (local.set $temp  (i64.sub  (local.get $d) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $d)))\n            (local.set $d     (i64.sub  (local.get $temp) (local.get $d1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $d) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $c) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $c)))\n            (local.set $c     (i64.sub  (local.get $temp) (local.get $c1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $c) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $b) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $b)))\n            (local.set $b     (i64.sub  (local.get $temp) (local.get $b1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $b) (local.get $temp)) (local.get $carry)))\n\n            (local.set $a     (i64.sub  (i64.sub (local.get $a) (i64.extend_i32_u (local.get $carry))) (local.get $a1)))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (local.set $e1 (i64.add (i64.shr_u (local.get $e1) (i64.const 1)) (i64.shl (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.add (i64.shr_u (local.get $d1) (i64.const 1)) (i64.shl (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shr_u (local.get $c1) (i64.const 1)) (i64.shl (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shr_u (local.get $b1) (i64.const 1)) (i64.shl (local.get $a1) (i64.const 63))))\n        (local.set $a1 (i64.shr_u (local.get $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (local.set $maske (i64.add (i64.shr_u (local.get $maske) (i64.const 1)) (i64.shl (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.add (i64.shr_u (local.get $maskd) (i64.const 1)) (i64.shl (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shr_u (local.get $maskc) (i64.const 1)) (i64.shl (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shr_u (local.get $maskb) (i64.const 1)) (i64.shl (local.get $maska) (i64.const 63))))\n        (local.set $maska (i64.shr_u (local.get $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $b))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $c))\n  (i64.store (i32.add (local.get $sp) (i32.const 8))  (local.get $d))\n  (i64.store (local.get $sp)                          (local.get $e))\n)\n"
  },
  "mod_512": {
    "wast": ";; Modulo 0x06\n(func $mod_512\n  ;; dividend\n  (param $a i64)\n  (param $b i64)\n  (param $c i64)\n  (param $d i64)\n  (param $e i64)\n  (param $f i64)\n  (param $g i64)\n  (param $h i64)\n\n  ;; divisor\n  (param $a1 i64)\n  (param $b1 i64)\n  (param $c1 i64)\n  (param $d1 i64)\n  (param $e1 i64)\n  (param $f1 i64)\n  (param $g1 i64)\n  (param $h1 i64)\n\n  (param $sp i32)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $maske i64)\n  (local $maskf i64)\n  (local $maskg i64)\n  (local $maskh i64)\n\n  (local $carry i32)\n  (local $temp i64)\n\n  (local.set $maskh (i64.const 1))\n\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_512 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $e1) (local.get $f1) (local.get $g1) (local.get $h1))\n      (then\n        (local.set $e (i64.const 0))\n        (local.set $f (i64.const 0))\n        (local.set $g (i64.const 0))\n        (local.set $h (i64.const 0))\n        (br $main)\n      )\n    )\n\n    ;; align bits\n    (block $done\n      (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (local.get $a1)))\n          (call $gte_512 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $e1) (local.get $f1) (local.get $g1) (local.get $h1)\n                         (local.get $a)  (local.get $b)  (local.get $c)  (local.get $d)  (local.get $e)  (local.get $f)  (local.get $g)  (local.get $h)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (local.set $a1 (i64.add (i64.shl (local.get $a1) (i64.const 1)) (i64.shr_u (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shl (local.get $b1) (i64.const 1)) (i64.shr_u (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shl (local.get $c1) (i64.const 1)) (i64.shr_u (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.add (i64.shl (local.get $d1) (i64.const 1)) (i64.shr_u (local.get $e1) (i64.const 63))))\n        (local.set $e1 (i64.add (i64.shl (local.get $e1) (i64.const 1)) (i64.shr_u (local.get $f1) (i64.const 63))))\n        (local.set $f1 (i64.add (i64.shl (local.get $f1) (i64.const 1)) (i64.shr_u (local.get $g1) (i64.const 63))))\n        (local.set $g1 (i64.add (i64.shl (local.get $g1) (i64.const 1)) (i64.shr_u (local.get $h1) (i64.const 63))))\n        (local.set $h1 (i64.shl (local.get $h1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (local.set $maska (i64.add (i64.shl (local.get $maska) (i64.const 1)) (i64.shr_u (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shl (local.get $maskb) (i64.const 1)) (i64.shr_u (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shl (local.get $maskc) (i64.const 1)) (i64.shr_u (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.add (i64.shl (local.get $maskd) (i64.const 1)) (i64.shr_u (local.get $maske) (i64.const 63))))\n        (local.set $maske (i64.add (i64.shl (local.get $maske) (i64.const 1)) (i64.shr_u (local.get $maskf) (i64.const 63))))\n        (local.set $maskf (i64.add (i64.shl (local.get $maskf) (i64.const 1)) (i64.shr_u (local.get $maskg) (i64.const 63))))\n        (local.set $maskg (i64.add (i64.shl (local.get $maskg) (i64.const 1)) (i64.shr_u (local.get $maskh) (i64.const 63))))\n        (local.set $maskh (i64.shl (local.get $maskh) (i64.const 1)))\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_512 (local.get $maska) (local.get $maskb) (local.get $maskc) (local.get $maskd) (local.get $maske) (local.get $maskf) (local.get $maskg) (local.get $maskh))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_512\n          (local.get $a)  (local.get $b)  (local.get $c)  (local.get $d)  (local.get $e)  (local.get $f)  (local.get $g)  (local.get $h)\n          (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $e1) (local.get $f1) (local.get $g1) (local.get $h1))\n          (then\n            ;; dividend = dividend - divisor\n            (local.set $carry (i64.lt_u (local.get $h) (local.get $h1)))\n            (local.set $h     (i64.sub  (local.get $h) (local.get $h1)))\n\n            (local.set $temp  (i64.sub  (local.get $g) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $g)))\n            (local.set $g     (i64.sub  (local.get $temp) (local.get $g1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $g) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $f) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $f)))\n            (local.set $f     (i64.sub  (local.get $temp) (local.get $f1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $f) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $e) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $e)))\n            (local.set $e     (i64.sub  (local.get $temp) (local.get $e1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $e) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $d) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $d)))\n            (local.set $d     (i64.sub  (local.get $temp) (local.get $d1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $d) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $c) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $c)))\n            (local.set $c     (i64.sub  (local.get $temp) (local.get $c1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $c) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $b) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $b)))\n            (local.set $b     (i64.sub  (local.get $temp) (local.get $b1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $b) (local.get $temp)) (local.get $carry)))\n            (local.set $a     (i64.sub  (i64.sub (local.get $a) (i64.extend_i32_u (local.get $carry))) (local.get $a1)))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (local.set $h1 (i64.add (i64.shr_u (local.get $h1) (i64.const 1)) (i64.shl (local.get $g1) (i64.const 63))))\n        (local.set $g1 (i64.add (i64.shr_u (local.get $g1) (i64.const 1)) (i64.shl (local.get $f1) (i64.const 63))))\n        (local.set $f1 (i64.add (i64.shr_u (local.get $f1) (i64.const 1)) (i64.shl (local.get $e1) (i64.const 63))))\n        (local.set $e1 (i64.add (i64.shr_u (local.get $e1) (i64.const 1)) (i64.shl (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.add (i64.shr_u (local.get $d1) (i64.const 1)) (i64.shl (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shr_u (local.get $c1) (i64.const 1)) (i64.shl (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shr_u (local.get $b1) (i64.const 1)) (i64.shl (local.get $a1) (i64.const 63))))\n        (local.set $a1 (i64.shr_u (local.get $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (local.set $maskh (i64.add (i64.shr_u (local.get $maskh) (i64.const 1)) (i64.shl (local.get $maskg) (i64.const 63))))\n        (local.set $maskg (i64.add (i64.shr_u (local.get $maskg) (i64.const 1)) (i64.shl (local.get $maskf) (i64.const 63))))\n        (local.set $maskf (i64.add (i64.shr_u (local.get $maskf) (i64.const 1)) (i64.shl (local.get $maske) (i64.const 63))))\n        (local.set $maske (i64.add (i64.shr_u (local.get $maske) (i64.const 1)) (i64.shl (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.add (i64.shr_u (local.get $maskd) (i64.const 1)) (i64.shl (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shr_u (local.get $maskc) (i64.const 1)) (i64.shl (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shr_u (local.get $maskb) (i64.const 1)) (i64.shl (local.get $maska) (i64.const 63))))\n        (local.set $maska (i64.shr_u (local.get $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n\n  (i64.store (local.get $sp) (local.get $e))\n  (i64.store (i32.sub (local.get $sp) (i32.const 8)) (local.get $f))\n  (i64.store (i32.sub (local.get $sp) (i32.const 16)) (local.get $g))\n  (i64.store (i32.sub (local.get $sp) (i32.const 24)) (local.get $h))\n)\n"
  },
  "mul_256": {
    "wast": "(func $mul_256\n  ;;  a b c d e f g h\n  ;;* i j k l m n o p\n  ;;----------------\n  (param $a i64)\n  (param $c i64)\n  (param $e i64)\n  (param $g i64)\n\n  (param $i i64)\n  (param $k i64)\n  (param $m i64)\n  (param $o i64)\n\n  (param $sp i32)\n\n  (local $b i64)\n  (local $d i64)\n  (local $f i64)\n  (local $h i64)\n  (local $j i64)\n  (local $l i64)\n  (local $n i64)\n  (local $p i64)\n  (local $temp6 i64)\n  (local $temp5 i64)\n  (local $temp4 i64)\n  (local $temp3 i64)\n  (local $temp2 i64)\n  (local $temp1 i64)\n  (local $temp0 i64)\n\n  ;; split the ops\n  (local.set $b (i64.and (local.get $a) (i64.const 4294967295)))\n  (local.set $a (i64.shr_u (local.get $a) (i64.const 32))) \n\n  (local.set $d (i64.and (local.get $c) (i64.const 4294967295)))\n  (local.set $c (i64.shr_u (local.get $c) (i64.const 32))) \n\n  (local.set $f (i64.and (local.get $e) (i64.const 4294967295)))\n  (local.set $e (i64.shr_u (local.get $e) (i64.const 32)))\n\n  (local.set $h (i64.and (local.get $g) (i64.const 4294967295)))\n  (local.set $g (i64.shr_u (local.get $g) (i64.const 32)))\n\n  (local.set $j (i64.and (local.get $i) (i64.const 4294967295)))\n  (local.set $i (i64.shr_u (local.get $i) (i64.const 32))) \n\n  (local.set $l (i64.and (local.get $k) (i64.const 4294967295)))\n  (local.set $k (i64.shr_u (local.get $k) (i64.const 32))) \n\n  (local.set $n (i64.and (local.get $m) (i64.const 4294967295)))\n  (local.set $m (i64.shr_u (local.get $m) (i64.const 32)))\n\n  (local.set $p (i64.and (local.get $o) (i64.const 4294967295)))\n  (local.set $o (i64.shr_u (local.get $o) (i64.const 32)))\n  ;; first row multiplication \n  ;; p * h\n  (local.set $temp0 (i64.mul (local.get $p) (local.get $h)))\n  ;; p * g + carry\n  (local.set $temp1 (i64.add (i64.mul (local.get $p) (local.get $g)) (i64.shr_u (local.get $temp0) (i64.const 32))))\n  ;; p * f + carry\n  (local.set $temp2 (i64.add (i64.mul (local.get $p) (local.get $f)) (i64.shr_u (local.get $temp1) (i64.const 32))))\n  ;; p * e + carry\n  (local.set $temp3 (i64.add (i64.mul (local.get $p) (local.get $e)) (i64.shr_u (local.get $temp2) (i64.const 32))))\n  ;; p * d + carry\n  (local.set $temp4 (i64.add (i64.mul (local.get $p) (local.get $d)) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; p * c + carry\n  (local.set $temp5  (i64.add (i64.mul (local.get $p) (local.get $c)) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; p * b + carry\n  (local.set $temp6  (i64.add (i64.mul (local.get $p) (local.get $b)) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; p * a + carry\n  (local.set $a  (i64.add (i64.mul (local.get $p) (local.get $a)) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; second row\n  ;; o * h + $temp1 \"pg\"\n  (local.set $temp1 (i64.add (i64.mul (local.get $o) (local.get $h)) (i64.and (local.get $temp1) (i64.const 4294967295))))\n  ;; o * g + $temp2 \"pf\" + carry\n  (local.set $temp2 (i64.add (i64.add (i64.mul (local.get $o) (local.get $g)) (i64.and (local.get $temp2) (i64.const 4294967295))) (i64.shr_u (local.get $temp1) (i64.const 32))))\n  ;; o * f + $temp3 \"pe\" + carry\n  (local.set $temp3 (i64.add (i64.add (i64.mul (local.get $o) (local.get $f)) (i64.and (local.get $temp3) (i64.const 4294967295))) (i64.shr_u (local.get $temp2) (i64.const 32))))\n  ;; o * e + $temp4  + carry\n  (local.set $temp4 (i64.add (i64.add (i64.mul (local.get $o) (local.get $e)) (i64.and (local.get $temp4) (i64.const 4294967295))) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; o * d + $temp5  + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $o) (local.get $d)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; o * c + $temp6  + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $o) (local.get $c)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; o * b + $a  + carry\n  (local.set $a (i64.add (i64.add (i64.mul (local.get $o) (local.get $b)) (i64.and (local.get $a) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; third row - n\n  ;; n * h + $temp2 \n  (local.set $temp2 (i64.add (i64.mul (local.get $n) (local.get $h)) (i64.and (local.get $temp2) (i64.const 4294967295))))\n  ;; n * g + $temp3 + carry\n  (local.set $temp3 (i64.add (i64.add (i64.mul (local.get $n) (local.get $g)) (i64.and (local.get $temp3) (i64.const 4294967295))) (i64.shr_u (local.get $temp2) (i64.const 32))))\n  ;; n * f + $temp4 + carry\n  (local.set $temp4 (i64.add (i64.add (i64.mul (local.get $n) (local.get $f)) (i64.and (local.get $temp4) (i64.const 4294967295))) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; n * e + $temp5  + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $n) (local.get $e)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; n * d + $temp6  + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $n) (local.get $d)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; n * c + $a  + carry\n  (local.set $a (i64.add (i64.add (i64.mul (local.get $n) (local.get $c)) (i64.and (local.get $a) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n\n  ;; forth row \n  ;; m * h + $temp3\n  (local.set $temp3 (i64.add (i64.mul (local.get $m) (local.get $h)) (i64.and (local.get $temp3) (i64.const 4294967295))))\n  ;; m * g + $temp4 + carry\n  (local.set $temp4 (i64.add (i64.add (i64.mul (local.get $m) (local.get $g)) (i64.and (local.get $temp4) (i64.const 4294967295))) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; m * f + $temp5 + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $m) (local.get $f)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; m * e + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $m) (local.get $e)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; m * d + $a + carry\n  (local.set $a (i64.add (i64.add (i64.mul (local.get $m) (local.get $d)) (i64.and (local.get $a) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n\n  ;; fith row\n  ;; l * h + $temp4\n  (local.set $temp4 (i64.add (i64.mul (local.get $l) (local.get $h)) (i64.and (local.get $temp4) (i64.const 4294967295))))\n  ;; l * g + $temp5 + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $l) (local.get $g)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; l * f + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $l) (local.get $f)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; l * e + $a + carry\n  (local.set $a (i64.add (i64.add (i64.mul (local.get $l) (local.get $e)) (i64.and (local.get $a) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n\n  ;; sixth row \n  ;; k * h + $temp5\n  (local.set $temp5 (i64.add (i64.mul (local.get $k) (local.get $h)) (i64.and (local.get $temp5) (i64.const 4294967295))))\n  ;; k * g + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $k) (local.get $g)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; k * f + $a + carry\n  (local.set $a (i64.add (i64.add (i64.mul (local.get $k) (local.get $f)) (i64.and (local.get $a) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n\n  ;; seventh row\n  ;; j * h + $temp6\n  (local.set $temp6 (i64.add (i64.mul (local.get $j) (local.get $h)) (i64.and (local.get $temp6) (i64.const 4294967295))))\n  ;; j * g + $a + carry\n\n  ;; eigth row\n  ;; i * h + $a\n  (local.set $a (i64.add (i64.mul (local.get $i) (local.get $h)) (i64.and (i64.add (i64.add (i64.mul (local.get $j) (local.get $g)) (i64.and (local.get $a) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))) (i64.const 4294967295))))\n\n  ;; combine terms\n  (local.set $a (i64.or (i64.shl (local.get $a) (i64.const 32)) (i64.and (local.get $temp6) (i64.const 4294967295))))\n  (local.set $c (i64.or (i64.shl (local.get $temp5) (i64.const 32)) (i64.and (local.get $temp4) (i64.const 4294967295))))\n  (local.set $e (i64.or (i64.shl (local.get $temp3) (i64.const 32)) (i64.and (local.get $temp2) (i64.const 4294967295))))\n  (local.set $g (i64.or (i64.shl (local.get $temp1) (i64.const 32)) (i64.and (local.get $temp0) (i64.const 4294967295))))\n\n  ;; save stack \n  (i64.store (local.get $sp) (local.get $a))\n  (i64.store (i32.sub (local.get $sp) (i32.const 8)) (local.get $c))\n  (i64.store (i32.sub (local.get $sp) (i32.const 16)) (local.get $e))\n  (i64.store (i32.sub (local.get $sp) (i32.const 24)) (local.get $g))\n)\n"
  }
}
},{}],171:[function(require,module,exports){
module.exports={
  "LOG": {
    "wast": "(func $LOG\n  (param $number i32)\n\n  (local $offset i32)\n  (local $offset0 i64)\n  (local $offset1 i64)\n  (local $offset2 i64)\n  (local $offset3 i64)\n\n  (local $length i32)\n  (local $length0 i64)\n  (local $length1 i64)\n  (local $length2 i64)\n  (local $length3 i64)\n\n  (local.set $offset0 (i64.load          (global.get $sp)))\n  (local.set $offset1 (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $offset2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $offset3 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n\n  (local.set $length0 (i64.load (i32.sub (global.get $sp) (i32.const 32))))\n  (local.set $length1 (i64.load (i32.sub (global.get $sp) (i32.const 24))))\n  (local.set $length2 (i64.load (i32.sub (global.get $sp) (i32.const 16))))\n  (local.set $length3 (i64.load (i32.sub (global.get $sp) (i32.const  8))))\n\n  (local.set $offset\n             (call $check_overflow (local.get $offset0)\n                                   (local.get $offset1)\n                                   (local.get $offset2)\n                                   (local.get $offset3)))\n\n  (local.set $length\n             (call $check_overflow (local.get $length0)\n                                   (local.get $length1)\n                                   (local.get $length2)\n                                   (local.get $length3)))\n\n  (call $memusegas (local.get $offset) (local.get $length))\n\n  (if (i32.eq (local.get $number) (i32.const 0))\n    (then\n      (call $log\n             (local.get $offset)\n             (local.get $length)\n             (local.get $number)\n             (i32.const  0)\n             (i32.const  0)\n             (i32.const  0)\n             (i32.const  0))\n    )\n  )\n  (if (i32.eq (local.get $number) (i32.const 1))\n    (then\n    (call $log\n             (local.get $offset)\n             (local.get $length)\n             (local.get $number)\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  64)))\n             (i32.const  0)\n             (i32.const  0)\n             (i32.const  0))\n    )\n  )\n  (if (i32.eq (local.get $number) (i32.const 2))\n    (then\n    (call $log\n             (local.get $offset)\n             (local.get $length)\n             (local.get $number)\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  64)))\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  96)))\n             (i32.const  0)\n             (i32.const  0))\n    )\n  )\n  (if (i32.eq (local.get $number) (i32.const 3))\n    (then\n    (call $log\n             (local.get $offset)\n             (local.get $length)\n             (local.get $number)\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  64)))\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  96)))\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const 128)))\n             (i32.const  0))\n    )\n  )\n  (if (i32.eq (local.get $number) (i32.const 4))\n    (then\n    (call $log\n             (local.get $offset)\n             (local.get $length)\n             (local.get $number)\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  64)))\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const  96)))\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const 128)))\n             (call $bswap_m256 (i32.sub (global.get $sp) (i32.const 160))))\n    )\n  )\n)\n",
    "imports": "(import \"env\" \"ethereum_log\" (func $log (param i32 i32 i32 i32 i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"LOG\" (func $LOG))"
  },
  "CALLDATALOAD": {
    "wast": ";; stack:\n;;  0: dataOffset\n(func $CALLDATALOAD\n  (local $writeOffset i32)\n  (local $writeOffset0 i64)\n  (local $writeOffset1 i64)\n  (local $writeOffset2 i64)\n  (local $writeOffset3 i64)\n\n  (local.set $writeOffset0 (i64.load (i32.add (global.get $sp) (i32.const  0))))\n  (local.set $writeOffset1 (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $writeOffset2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $writeOffset3 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n\n  (i64.store (i32.add (global.get $sp) (i32.const  0)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.const 0))\n\n  (local.set $writeOffset\n             (call $check_overflow (local.get $writeOffset0)\n                                   (local.get $writeOffset1)\n                                   (local.get $writeOffset2)\n                                   (local.get $writeOffset3)))\n\n  (call $callDataCopy (global.get $sp) (local.get $writeOffset) (i32.const 32))\n  ;; swap top stack item\n  (drop (call $bswap_m256 (global.get $sp)))\n)\n",
    "imports": "(import \"env\" \"ethereum_callDataCopy\" (func $callDataCopy (param i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"CALLDATALOAD\" (func $CALLDATALOAD))"
  },
  "GAS": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $GAS   (i64.store (i32.add (global.get $sp) (i32.const 32)) (call $getGasLeft))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getGasLeft\" (func $getGasLeft  (result i64)))",
    "inline_imports": "(import \"ewasm\" \"GAS\" (func $GAS))"
  },
  "ADDRESS": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $ADDRESS   (call $getAddress(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getAddress\" (func $getAddress (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"ADDRESS\" (func $ADDRESS))"
  },
  "BALANCE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $BALANCE   (call $getExternalBalance(call $bswap_m256 (global.get $sp))(global.get $sp))(drop (call $bswap_m256 (global.get $sp))))",
    "imports": "(import \"env\" \"ethereum_getExternalBalance\" (func $getExternalBalance (param i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"BALANCE\" (func $BALANCE))"
  },
  "SELFBALANCE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $SELFBALANCE   (call $getBalance(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getBalance\" (func $getBalance (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"SELFBALANCE\" (func $SELFBALANCE))"
  },
  "CHAINID": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CHAINID   (call $getChainId(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getChainId\" (func $getChainId (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"CHAINID\" (func $CHAINID))"
  },
  "BASEFEE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $BASEFEE   (call $getBaseFee(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getBaseFee\" (func $getBaseFee (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"BASEFEE\" (func $BASEFEE))"
  },
  "ORIGIN": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $ORIGIN   (call $getTxOrigin(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getTxOrigin\" (func $getTxOrigin (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"ORIGIN\" (func $ORIGIN))"
  },
  "CALLER": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLER   (call $getCaller(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getCaller\" (func $getCaller (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"CALLER\" (func $CALLER))"
  },
  "CALLVALUE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLVALUE   (call $getCallValue(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getCallValue\" (func $getCallValue (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"CALLVALUE\" (func $CALLVALUE))"
  },
  "CALLDATASIZE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLDATASIZE   (i64.store (i32.add (global.get $sp) (i32.const 32)) (i64.extend_i32_u (call $getCallDataSize)))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getCallDataSize\" (func $getCallDataSize  (result i32)))",
    "inline_imports": "(import \"ewasm\" \"CALLDATASIZE\" (func $CALLDATASIZE))"
  },
  "CALLDATACOPY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLDATACOPY (local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $callDataCopy(local.get $offset0)(call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8))))(local.get $length0)))",
    "imports": "(import \"env\" \"ethereum_callDataCopy\" (func $callDataCopy (param i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"CALLDATACOPY\" (func $CALLDATACOPY))"
  },
  "CODESIZE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CODESIZE   (i64.store (i32.add (global.get $sp) (i32.const 32)) (i64.extend_i32_u (call $getCodeSize)))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getCodeSize\" (func $getCodeSize  (result i32)))",
    "inline_imports": "(import \"ewasm\" \"CODESIZE\" (func $CODESIZE))"
  },
  "CODECOPY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CODECOPY (local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $codeCopy(local.get $offset0)(call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8))))(local.get $length0)))",
    "imports": "(import \"env\" \"ethereum_codeCopy\" (func $codeCopy (param i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"CODECOPY\" (func $CODECOPY))"
  },
  "EXTCODESIZE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $EXTCODESIZE   (i64.store (global.get $sp) (i64.extend_i32_u (call $getExternalCodeSize(call $bswap_m256 (global.get $sp)))))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 8)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getExternalCodeSize\" (func $getExternalCodeSize (param i32) (result i32)))",
    "inline_imports": "(import \"ewasm\" \"EXTCODESIZE\" (func $EXTCODESIZE))"
  },
  "EXTCODEHASH": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $EXTCODEHASH   (call $getExternalCodeHash(call $bswap_m256 (global.get $sp))(global.get $sp))(drop (call $bswap_m256 (global.get $sp))))",
    "imports": "(import \"env\" \"ethereum_getExternalCodeHash\" (func $getExternalCodeHash (param i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"EXTCODEHASH\" (func $EXTCODEHASH))"
  },
  "EXTCODECOPY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $EXTCODECOPY (local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -96)))\n          (i64.load (i32.add (global.get $sp) (i32.const -88)))\n          (i64.load (i32.add (global.get $sp) (i32.const -80)))\n          (i64.load (i32.add (global.get $sp) (i32.const -72)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $externalCodeCopy(call $bswap_m256 (global.get $sp))(local.get $offset0)(call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40))))(local.get $length0)))",
    "imports": "(import \"env\" \"ethereum_externalCodeCopy\" (func $externalCodeCopy (param i32 i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"EXTCODECOPY\" (func $EXTCODECOPY))"
  },
  "GASPRICE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $GASPRICE   (call $getTxGasPrice(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getTxGasPrice\" (func $getTxGasPrice (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"GASPRICE\" (func $GASPRICE))"
  },
  "BLOCKHASH": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $BLOCKHASH   (call $getBlockHash(call $check_overflow_i64\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24))))(global.get $sp))(drop (call $bswap_m256 (global.get $sp))))",
    "imports": "(import \"env\" \"ethereum_getBlockHash\" (func $getBlockHash (param i64 i32) ))",
    "inline_imports": "(import \"ewasm\" \"BLOCKHASH\" (func $BLOCKHASH))"
  },
  "COINBASE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $COINBASE   (call $getBlockCoinbase(i32.add (global.get $sp) (i32.const 32)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const 32)))))",
    "imports": "(import \"env\" \"ethereum_getBlockCoinbase\" (func $getBlockCoinbase (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"COINBASE\" (func $COINBASE))"
  },
  "TIMESTAMP": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $TIMESTAMP   (i64.store (i32.add (global.get $sp) (i32.const 32)) (call $getBlockTimestamp))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getBlockTimestamp\" (func $getBlockTimestamp  (result i64)))",
    "inline_imports": "(import \"ewasm\" \"TIMESTAMP\" (func $TIMESTAMP))"
  },
  "NUMBER": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $NUMBER   (i64.store (i32.add (global.get $sp) (i32.const 32)) (call $getBlockNumber))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getBlockNumber\" (func $getBlockNumber  (result i64)))",
    "inline_imports": "(import \"ewasm\" \"NUMBER\" (func $NUMBER))"
  },
  "DIFFICULTY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $DIFFICULTY   (call $getBlockDifficulty(i32.add (global.get $sp) (i32.const 32))))",
    "imports": "(import \"env\" \"ethereum_getBlockDifficulty\" (func $getBlockDifficulty (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"DIFFICULTY\" (func $DIFFICULTY))"
  },
  "GASLIMIT": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $GASLIMIT   (i64.store (i32.add (global.get $sp) (i32.const 32)) (call $getBlockGasLimit))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getBlockGasLimit\" (func $getBlockGasLimit  (result i64)))",
    "inline_imports": "(import \"ewasm\" \"GASLIMIT\" (func $GASLIMIT))"
  },
  "CREATE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CREATE (local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $create(call $bswap_m256 (global.get $sp))(local.get $offset0)(local.get $length0)(i32.add (global.get $sp) (i32.const -64)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const -64)))))",
    "imports": "(import \"env\" \"ethereum_create\" (func $create (param i32 i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"CREATE\" (func $CREATE))"
  },
  "CREATE2": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CREATE2 (local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $create2(call $bswap_m256 (global.get $sp))(local.get $offset0)(local.get $length0)(call $bswap_m256 (i32.add (global.get $sp) (i32.const -96)))(i32.add (global.get $sp) (i32.const -96)))(drop (call $bswap_m256 (i32.add (global.get $sp) (i32.const -96)))))",
    "imports": "(import \"env\" \"ethereum_create2\" (func $create2 (param i32 i32 i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"CREATE2\" (func $CREATE2))"
  },
  "CALL": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALL (local $offset0 i32)(local $length0 i32)(local $offset1 i32)(local $length1 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -96)))\n          (i64.load (i32.add (global.get $sp) (i32.const -88)))\n          (i64.load (i32.add (global.get $sp) (i32.const -80)))\n          (i64.load (i32.add (global.get $sp) (i32.const -72)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -128)))\n          (i64.load (i32.add (global.get $sp) (i32.const -120)))\n          (i64.load (i32.add (global.get $sp) (i32.const -112)))\n          (i64.load (i32.add (global.get $sp) (i32.const -104)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0)))(local.set $offset1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -160)))\n          (i64.load (i32.add (global.get $sp) (i32.const -152)))\n          (i64.load (i32.add (global.get $sp) (i32.const -144)))\n          (i64.load (i32.add (global.get $sp) (i32.const -136)))))(local.set $length1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -192)))\n          (i64.load (i32.add (global.get $sp) (i32.const -184)))\n          (i64.load (i32.add (global.get $sp) (i32.const -176)))\n          (i64.load (i32.add (global.get $sp) (i32.const -168)))))\n    (call $memusegas (local.get $offset1) (local.get $length1))\n    (local.set $offset1 (i32.add (global.get $memstart) (local.get $offset1))) (i64.store (i32.add (global.get $sp) (i32.const -192)) (i64.extend_i32_u (i32.eqz (call $call(call $check_overflow_i64\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24))))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -32)))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -64)))(local.get $offset0)(local.get $length0)(local.get $offset1)(local.get $length1)))))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const -168)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -176)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -184)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_call\" (func $call (param i64 i32 i32 i32 i32 i32 i32) (result i32)))",
    "inline_imports": "(import \"ewasm\" \"CALL\" (func $CALL))"
  },
  "CALLCODE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $CALLCODE (local $offset0 i32)(local $length0 i32)(local $offset1 i32)(local $length1 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -96)))\n          (i64.load (i32.add (global.get $sp) (i32.const -88)))\n          (i64.load (i32.add (global.get $sp) (i32.const -80)))\n          (i64.load (i32.add (global.get $sp) (i32.const -72)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -128)))\n          (i64.load (i32.add (global.get $sp) (i32.const -120)))\n          (i64.load (i32.add (global.get $sp) (i32.const -112)))\n          (i64.load (i32.add (global.get $sp) (i32.const -104)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0)))(local.set $offset1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -160)))\n          (i64.load (i32.add (global.get $sp) (i32.const -152)))\n          (i64.load (i32.add (global.get $sp) (i32.const -144)))\n          (i64.load (i32.add (global.get $sp) (i32.const -136)))))(local.set $length1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -192)))\n          (i64.load (i32.add (global.get $sp) (i32.const -184)))\n          (i64.load (i32.add (global.get $sp) (i32.const -176)))\n          (i64.load (i32.add (global.get $sp) (i32.const -168)))))\n    (call $memusegas (local.get $offset1) (local.get $length1))\n    (local.set $offset1 (i32.add (global.get $memstart) (local.get $offset1))) (i64.store (i32.add (global.get $sp) (i32.const -192)) (i64.extend_i32_u (i32.eqz (call $callCode(call $check_overflow_i64\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24))))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -32)))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -64)))(local.get $offset0)(local.get $length0)(local.get $offset1)(local.get $length1)))))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const -168)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -176)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -184)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_callCode\" (func $callCode (param i64 i32 i32 i32 i32 i32 i32) (result i32)))",
    "inline_imports": "(import \"ewasm\" \"CALLCODE\" (func $CALLCODE))"
  },
  "DELEGATECALL": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $DELEGATECALL (local $offset0 i32)(local $length0 i32)(local $offset1 i32)(local $length1 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -96)))\n          (i64.load (i32.add (global.get $sp) (i32.const -88)))\n          (i64.load (i32.add (global.get $sp) (i32.const -80)))\n          (i64.load (i32.add (global.get $sp) (i32.const -72)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0)))(local.set $offset1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -128)))\n          (i64.load (i32.add (global.get $sp) (i32.const -120)))\n          (i64.load (i32.add (global.get $sp) (i32.const -112)))\n          (i64.load (i32.add (global.get $sp) (i32.const -104)))))(local.set $length1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -160)))\n          (i64.load (i32.add (global.get $sp) (i32.const -152)))\n          (i64.load (i32.add (global.get $sp) (i32.const -144)))\n          (i64.load (i32.add (global.get $sp) (i32.const -136)))))\n    (call $memusegas (local.get $offset1) (local.get $length1))\n    (local.set $offset1 (i32.add (global.get $memstart) (local.get $offset1))) (i64.store (i32.add (global.get $sp) (i32.const -160)) (i64.extend_i32_u (i32.eqz (call $callDelegate(call $check_overflow_i64\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24))))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -32)))(local.get $offset0)(local.get $length0)(local.get $offset1)(local.get $length1)))))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const -136)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -144)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -152)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_callDelegate\" (func $callDelegate (param i64 i32 i32 i32 i32 i32) (result i32)))",
    "inline_imports": "(import \"ewasm\" \"DELEGATECALL\" (func $DELEGATECALL))"
  },
  "STATICCALL": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $STATICCALL (local $offset0 i32)(local $length0 i32)(local $offset1 i32)(local $length1 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -96)))\n          (i64.load (i32.add (global.get $sp) (i32.const -88)))\n          (i64.load (i32.add (global.get $sp) (i32.const -80)))\n          (i64.load (i32.add (global.get $sp) (i32.const -72)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0)))(local.set $offset1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -128)))\n          (i64.load (i32.add (global.get $sp) (i32.const -120)))\n          (i64.load (i32.add (global.get $sp) (i32.const -112)))\n          (i64.load (i32.add (global.get $sp) (i32.const -104)))))(local.set $length1 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -160)))\n          (i64.load (i32.add (global.get $sp) (i32.const -152)))\n          (i64.load (i32.add (global.get $sp) (i32.const -144)))\n          (i64.load (i32.add (global.get $sp) (i32.const -136)))))\n    (call $memusegas (local.get $offset1) (local.get $length1))\n    (local.set $offset1 (i32.add (global.get $memstart) (local.get $offset1))) (i64.store (i32.add (global.get $sp) (i32.const -160)) (i64.extend_i32_u (i32.eqz (call $callStatic(call $check_overflow_i64\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24))))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -32)))(local.get $offset0)(local.get $length0)(local.get $offset1)(local.get $length1)))))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const -136)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -144)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const -152)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_callStatic\" (func $callStatic (param i64 i32 i32 i32 i32 i32) (result i32)))",
    "inline_imports": "(import \"ewasm\" \"STATICCALL\" (func $STATICCALL))"
  },
  "RETURNDATACOPY": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $RETURNDATACOPY (local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -64)))\n          (i64.load (i32.add (global.get $sp) (i32.const -56)))\n          (i64.load (i32.add (global.get $sp) (i32.const -48)))\n          (i64.load (i32.add (global.get $sp) (i32.const -40)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $returnDataCopy(local.get $offset0)(call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8))))(local.get $length0)))",
    "imports": "(import \"env\" \"ethereum_returnDataCopy\" (func $returnDataCopy (param i32 i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"RETURNDATACOPY\" (func $RETURNDATACOPY))"
  },
  "RETURNDATASIZE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $RETURNDATASIZE   (i64.store (i32.add (global.get $sp) (i32.const 32)) (i64.extend_i32_u (call $getReturnDataSize)))\n    ;; zero out mem\n    (i64.store (i32.add (global.get $sp) (i32.const 56)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 48)) (i64.const 0))\n    (i64.store (i32.add (global.get $sp) (i32.const 40)) (i64.const 0)))",
    "imports": "(import \"env\" \"ethereum_getReturnDataSize\" (func $getReturnDataSize  (result i32)))",
    "inline_imports": "(import \"ewasm\" \"RETURNDATASIZE\" (func $RETURNDATASIZE))"
  },
  "SSTORE": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $SSTORE   (call $storageStore(call $bswap_m256 (global.get $sp))(call $bswap_m256 (i32.add (global.get $sp) (i32.const -32)))))",
    "imports": "(import \"env\" \"ethereum_storageStore\" (func $storageStore (param i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"SSTORE\" (func $SSTORE))"
  },
  "SLOAD": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $SLOAD   (call $storageLoad(call $bswap_m256 (global.get $sp))(global.get $sp))(drop (call $bswap_m256 (global.get $sp))))",
    "imports": "(import \"env\" \"ethereum_storageLoad\" (func $storageLoad (param i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"SLOAD\" (func $SLOAD))"
  },
  "SELFDESTRUCT": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $SELFDESTRUCT   (call $selfDestruct(call $bswap_m256 (global.get $sp))))",
    "imports": "(import \"env\" \"ethereum_selfDestruct\" (func $selfDestruct (param i32) ))",
    "inline_imports": "(import \"ewasm\" \"SELFDESTRUCT\" (func $SELFDESTRUCT))"
  },
  "RETURN": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $RETURN (local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $finish(local.get $offset0)(local.get $length0)))",
    "imports": "(import \"env\" \"ethereum_finish\" (func $finish (param i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"RETURN\" (func $RETURN))"
  },
  "REVERT": {
    "wast": ";; generated by ./wasm/generateInterface.js\n(func $REVERT (local $offset0 i32)(local $length0 i32) (local.set $offset0 (call $check_overflow\n          (i64.load (global.get $sp))\n          (i64.load (i32.add (global.get $sp) (i32.const 8)))\n          (i64.load (i32.add (global.get $sp) (i32.const 16)))\n          (i64.load (i32.add (global.get $sp) (i32.const 24)))))(local.set $length0 (call $check_overflow\n          (i64.load (i32.add (global.get $sp) (i32.const -32)))\n          (i64.load (i32.add (global.get $sp) (i32.const -24)))\n          (i64.load (i32.add (global.get $sp) (i32.const -16)))\n          (i64.load (i32.add (global.get $sp) (i32.const -8)))))\n    (call $memusegas (local.get $offset0) (local.get $length0))\n    (local.set $offset0 (i32.add (global.get $memstart) (local.get $offset0))) (call $revert(local.get $offset0)(local.get $length0)))",
    "imports": "(import \"env\" \"ethereum_revert\" (func $revert (param i32 i32) ))",
    "inline_imports": "(import \"ewasm\" \"REVERT\" (func $REVERT))"
  },
  "PUSH": {
    "inline_imports": "(import \"ewasm\" \"PUSH\" (func $PUSH (param i64 i64 i64 i64) ))",
    "wast": "(func $PUSH\n  (param $a0 i64)\n  (param $a1 i64)\n  (param $a2 i64)\n  (param $a3 i64)\n  (local $sp i32)\n\n  ;; increament stack pointer\n  (local.set $sp (i32.add (global.get $sp) (i32.const 32)))\n\n  (i64.store (local.get $sp) (local.get $a3))\n  (i64.store (i32.add (local.get $sp) (i32.const 8)) (local.get $a2))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $a1))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $a0))\n)\n"
  },
  "MSTORE": {
    "inline_imports": "(import \"ewasm\" \"MSTORE\" (func $MSTORE ))",
    "wast": ";; stack:\n;;  0: word\n;; -1: offset\n(func $MSTORE\n  (local $sp i32)\n\n  (local $offset   i32)\n  \n  (local $offset0 i64)\n  (local $offset1 i64)\n  (local $offset2 i64)\n  (local $offset3 i64)\n\n  ;; load args from the stack\n  (local.set $offset0 (i64.load          (global.get $sp)))\n  (local.set $offset1 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $offset2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $offset3 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n\n  (local.set $offset \n             (call $check_overflow (local.get $offset0)\n                                   (local.get $offset1)\n                                   (local.get $offset2)\n                                   (local.get $offset3)))\n  ;; subtrace gas useage\n  (call $memusegas (local.get $offset) (i32.const 32))\n\n  ;; pop item from the stack\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  ;; swap top stack item\n  (drop (call $bswap_m256 (local.get $sp)))\n\n  (local.set $offset (i32.add (local.get $offset) (global.get $memstart)))\n  ;; store word to memory\n  (i64.store          (local.get $offset)                 (i64.load          (local.get $sp)))\n  (i64.store (i32.add (local.get $offset) (i32.const 8))  (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (i64.store (i32.add (local.get $offset) (i32.const 16)) (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (i64.store (i32.add (local.get $offset) (i32.const 24)) (i64.load (i32.add (local.get $sp) (i32.const 24))))\n)\n"
  },
  "MLOAD": {
    "inline_imports": "(import \"ewasm\" \"MLOAD\" (func $MLOAD ))",
    "wast": ";; stack:\n;;  0: offset\n(func $MLOAD\n  (local $offset i32)\n  (local $offset0 i64)\n  (local $offset1 i64)\n  (local $offset2 i64)\n  (local $offset3 i64)\n\n  ;; load args from the stack\n  (local.set $offset0 (i64.load          (global.get $sp)))\n  (local.set $offset1 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $offset2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $offset3 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n\n  (local.set $offset \n             (call $check_overflow (local.get $offset0)\n                                   (local.get $offset1)\n                                   (local.get $offset2)\n                                   (local.get $offset3)))\n  ;; subttract gas useage\n  (call $memusegas (local.get $offset) (i32.const  32))\n\n  ;; FIXME: how to deal with overflow?\n  (local.set $offset (i32.add (local.get $offset) (global.get $memstart)))\n\n  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.load (i32.add (local.get $offset) (i32.const 24))))\n  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.load (i32.add (local.get $offset) (i32.const 16))))\n  (i64.store (i32.add (global.get $sp) (i32.const  8)) (i64.load (i32.add (local.get $offset) (i32.const  8))))\n  (i64.store          (global.get $sp)                 (i64.load          (local.get $offset)))\n\n  ;; swap\n  (drop (call $bswap_m256 (global.get $sp)))\n)\n"
  },
  "DUP": {
    "inline_imports": "(import \"ewasm\" \"DUP\" (func $DUP (param i32) ))",
    "wast": "(func $DUP\n  (param $a0 i32)\n  (local $sp i32)\n\n  (local $sp_ref i32)\n  \n  (local.set $sp (i32.add (global.get $sp) (i32.const 32)))\n  (local.set $sp_ref (i32.sub (i32.sub (local.get $sp) (i32.const 8)) (i32.mul (local.get $a0) (i32.const 32))))\n  \n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.load (local.get $sp_ref)))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.load (i32.sub (local.get $sp_ref) (i32.const 8))))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (i64.load (i32.sub (local.get $sp_ref) (i32.const 16))))\n  (i64.store          (local.get $sp)                 (i64.load (i32.sub (local.get $sp_ref) (i32.const 24))))\n)\n"
  },
  "ISZERO": {
    "inline_imports": "(import \"ewasm\" \"ISZERO\" (func $ISZERO ))",
    "wast": "(func $ISZERO\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n\n  ;; load args from the stack\n  (local.set $a0 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $a1 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $a2 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $a3 (i64.load (global.get $sp)))\n\n  (i64.store (global.get $sp)\n    (i64.extend_i32_u\n      (call $iszero_256 (local.get $a0) (local.get $a1) (local.get $a2) (local.get $a3))\n    )\n  )\n\n  ;; zero out the rest of memory\n  (i64.store (i32.add (global.get $sp) (i32.const 8)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "LT": {
    "inline_imports": "(import \"ewasm\" \"LT\" (func $LT ))",
    "wast": "(func $LT\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n\n  (local.set $sp (global.get $sp))\n\n  ;; load args from the stack\n  (local.set $a0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $a2 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $a3 (i64.load (local.get $sp)))\n\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 32)))\n\n  (local.set $b0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $b2 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $b3 (i64.load (local.get $sp)))\n\n  (i64.store (local.get $sp) (i64.extend_i32_u\n    (i32.or  (i64.lt_u (local.get $a0) (local.get $b0)) ;; a0 < b0\n    (i32.and (i64.eq   (local.get $a0) (local.get $b0)) ;; a0 == b0\n    (i32.or  (i64.lt_u (local.get $a1) (local.get $b1)) ;; a1 < b1\n    (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n    (i32.or  (i64.lt_u (local.get $a2) (local.get $b2)) ;; a2 < b2\n    (i32.and (i64.eq   (local.get $a2) (local.get $b2)) ;; a2 == b2\n             (i64.lt_u (local.get $a3) (local.get $b3)))))))))) ;; a3 < b3\n\n  ;; zero  out the rest of the stack item\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "GT": {
    "inline_imports": "(import \"ewasm\" \"GT\" (func $GT ))",
    "wast": "(func $GT\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n\n  (local.set $sp (global.get $sp))\n\n  ;; load args from the stack\n  (local.set $a0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $a2 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $a3 (i64.load (local.get $sp)))\n\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 32)))\n\n  (local.set $b0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $b2 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $b3 (i64.load (local.get $sp)))\n\n  (i64.store (local.get $sp) (i64.extend_i32_u\n    (i32.or (i64.gt_u (local.get $a0) (local.get $b0)) ;; a0 > b0\n    (i32.and (i64.eq   (local.get $a0) (local.get $b0)) ;; a0 == a1\n    (i32.or  (i64.gt_u (local.get $a1) (local.get $b1)) ;; a1 > b1\n    (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n    (i32.or  (i64.gt_u (local.get $a2) (local.get $b2)) ;; a2 > b2\n    (i32.and (i64.eq   (local.get $a2) (local.get $b2)) ;; a2 == b2\n             (i64.gt_u (local.get $a3) (local.get $b3)))))))))) ;; a3 > b3\n\n  ;; zero  out the rest of the stack item\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "SLT": {
    "inline_imports": "(import \"ewasm\" \"SLT\" (func $SLT ))",
    "wast": "(func $SLT\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n\n  ;; load args from the stack\n  (local.set $a0 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $a1 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $a2 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $a3 (i64.load (global.get $sp)))\n\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (local.set $b0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $b2 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $b3 (i64.load (local.get $sp)))\n\n  (i64.store (local.get $sp) (i64.extend_i32_u\n    (i32.or  (i64.lt_s (local.get $a0) (local.get $b0)) ;; a0 < b0\n    (i32.and (i64.eq   (local.get $a0) (local.get $b0)) ;; a0 == b0\n    (i32.or  (i64.lt_u (local.get $a1) (local.get $b1)) ;; a1 < b1\n    (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n    (i32.or  (i64.lt_u (local.get $a2) (local.get $b2)) ;; a2 < b2\n    (i32.and (i64.eq   (local.get $a2) (local.get $b2)) ;; a2 == b2\n             (i64.lt_u (local.get $a3) (local.get $b3)))))))))) ;; a3 < b3\n\n  ;; zero  out the rest of the stack item\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "SHR": {
    "inline_imports": "(import \"ewasm\" \"SHR\" (func $SHR ))",
    "wast": "(func $SHR\n    (local $sp i32)\n    (local $x1 i64)\n    (local $x2 i64)\n    (local $x3 i64)\n    (local $x4 i64)\n    (local $y1 i64)\n    (local $y2 i64)\n    (local $y3 i64)\n    (local $y4 i64)\n\n    (local $z1 i64)\n    (local $z2 i64)\n    (local $z3 i64)\n    (local $z4 i64)\n    (local $t i64)\n\n    ;; load args from the stack\n    (local.set $x1 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n    (local.set $x2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n    (local.set $x3 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n    (local.set $x4 (i64.load (global.get $sp)))\n\n    (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n    (local.set $y1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n    (local.set $y2 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n    (local.set $y3 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n    (local.set $y4 (i64.load (local.get $sp)))\n\n    (block\n        (if (i32.and (i64.eqz (local.get $x1)) (i64.eqz (local.get $x2))) (then\n            (if (i64.eqz (local.get $x3)) (then\n                (if (i64.eqz (local.get $x4))\n                    (then\n                        (local.set $z1 (local.get $y1))\n                        (local.set $z2 (local.get $y2))\n                        (local.set $z3 (local.get $y3))\n                        (local.set $z4 (local.get $y4))\n                    )\n                    (else\n                        (if (i64.lt_u (local.get $x4) (i64.const 256)) (then\n                            (if (i64.ge_u (local.get $x4) (i64.const 128)) (then\n                                (local.set $y4 (local.get $y2))\n                                (local.set $y3 (local.get $y1))\n                                (local.set $y2 (i64.const 0))\n                                (local.set $y1 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 128)))\n                            ))\n                            (if (i64.ge_u (local.get $x4) (i64.const 64)) (then\n                                (local.set $y4 (local.get $y3))\n                                (local.set $y3 (local.get $y2))\n                                (local.set $y2 (local.get $y1))\n                                (local.set $y1 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 64)))\n                            ))\n                            (nop)\n                            (block\n                                (local.set $z4 (call $shr_single (local.get $y4) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (block\n                                (local.set $z3 (call $shr_single (local.get $y3) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (local.set $z4 (i64.or (local.get $z4) (local.get $t)))\n                            (block\n                                (local.set $z2 (call $shr_single (local.get $y2) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (local.set $z3 (i64.or (local.get $z3) (local.get $t)))\n                            (block\n                                (local.set $z1 (call $shr_single (local.get $y1) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (local.set $z2 (i64.or (local.get $z2) (local.get $t)))\n                        ))\n                    )\n                )\n            ))\n        ))\n\n    )\n    (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $z1))\n    (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $z2))\n    (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $z3))\n    (i64.store          (local.get $sp)                 (local.get $z4))\n)\n\n(func $shr_single\n    (param $a i64)\n    (param $amount i64)\n    (result i64)\n    (local $x i64)\n    (local $y i64)\n    (block\n        (local.set $y (i64.shl (local.get $a) (i64.sub (i64.const 64) (local.get $amount))))\n        (local.set $x (i64.shr_u (local.get $a) (local.get $amount)))\n\n    )\n    (global.set $global_ (local.get $y))\n    (local.get $x)\n)\n"
  },
  "EQ": {
    "inline_imports": "(import \"ewasm\" \"EQ\" (func $EQ ))",
    "wast": "(func $EQ\n  (local $sp i32)\n\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n  (i64.store (local.get $sp)\n    (i64.extend_i32_u\n      (i32.and (i64.eq   (i64.load (i32.add (local.get $sp) (i32.const 56))) (i64.load (i32.add (local.get $sp) (i32.const 24))))\n      (i32.and (i64.eq   (i64.load (i32.add (local.get $sp) (i32.const 48))) (i64.load (i32.add (local.get $sp) (i32.const 16))))\n      (i32.and (i64.eq   (i64.load (i32.add (local.get $sp) (i32.const 40))) (i64.load (i32.add (local.get $sp) (i32.const  8))))\n               (i64.eq   (i64.load (i32.add (local.get $sp) (i32.const 32))) (i64.load          (local.get $sp))))))))\n\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (i64.const 0))\n)\n"
  },
  "ADD": {
    "inline_imports": "(import \"ewasm\" \"ADD\" (func $ADD ))",
    "wast": "(func $ADD\n  (local $sp i32)\n\n  (local $a i64)\n  (local $c i64)\n  (local $d i64)\n  (local $carry i64)\n\n  (local.set $sp (global.get $sp))\n\n  ;; d c b a\n  ;; pop the stack\n  (local.set $a (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $c (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $d (i64.load (local.get $sp)))\n  ;; decement the stack pointer\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 8)))\n\n  ;; d\n  (local.set $carry (i64.add (local.get $d) (i64.load (i32.sub (local.get $sp) (i32.const 24)))))\n  ;; save d  to mem\n  (i64.store (i32.sub (local.get $sp) (i32.const 24)) (local.get $carry))\n  ;; check  for overflow\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $carry) (local.get $d))))\n\n  ;; c use $d as reg\n  (local.set $d     (i64.add (i64.load (i32.sub (local.get $sp) (i32.const 16))) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $d) (local.get $carry))))\n  (local.set $d     (i64.add (local.get $c) (local.get $d)))\n  ;; store the result\n  (i64.store (i32.sub (local.get $sp) (i32.const 16)) (local.get $d))\n  ;; check overflow\n  (local.set $carry (i64.or (i64.extend_i32_u  (i64.lt_u (local.get $d) (local.get $c))) (local.get $carry)))\n\n  ;; b\n  ;; add carry\n  (local.set $d     (i64.add (i64.load (i32.sub (local.get $sp) (i32.const 8))) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $d) (local.get $carry))))\n\n  ;; use reg c\n  (local.set $c (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $d (i64.add (local.get $c) (local.get $d)))\n  (i64.store (i32.sub (local.get $sp) (i32.const 8)) (local.get $d))\n  ;; a\n  (i64.store (local.get $sp)\n             (i64.add        ;; add a\n               (local.get $a)\n               (i64.add\n                 (i64.load (local.get $sp))  ;; load the operand\n                 (i64.or  ;; carry\n                   (i64.extend_i32_u (i64.lt_u (local.get $d) (local.get $c)))\n                   (local.get $carry)))))\n)\n"
  },
  "SUB": {
    "inline_imports": "(import \"ewasm\" \"SUB\" (func $SUB ))",
    "wast": "(func $SUB\n  (local $sp i32)\n\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  (local $carry i64)\n  (local $temp i64)\n\n  (local.set $a (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $b (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $c (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $d (i64.load          (global.get $sp)))\n  ;; decement the stack pointer\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c1 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (local.set $d1 (i64.load          (local.get $sp)))\n\n  ;; a * 64^3 + b*64^2 + c*64 + d\n  ;; d\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $d) (local.get $d1))))\n  (local.set $d (i64.sub (local.get $d) (local.get $d1)))\n\n  ;; c\n  (local.set $temp (i64.sub (local.get $c) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.gt_u (local.get $temp) (local.get $c))))\n  (local.set $c (i64.sub (local.get $temp) (local.get $c1)))\n  (local.set $carry (i64.or (i64.extend_i32_u (i64.gt_u (local.get $c) (local.get $temp))) (local.get $carry)))\n\n  ;; b\n  (local.set $temp (i64.sub (local.get $b) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.gt_u (local.get $temp) (local.get $b))))\n  (local.set $b (i64.sub (local.get $temp) (local.get $b1)))\n\n  ;; a\n  (local.set $a (i64.sub (i64.sub (local.get $a) (i64.or (i64.extend_i32_u (i64.gt_u (local.get $b) (local.get $temp))) (local.get $carry))) (local.get $a1)))\n\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $a))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $b))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $c))\n  (i64.store          (local.get $sp)                 (local.get $d))\n)\n"
  },
  "SWAP": {
    "inline_imports": "(import \"ewasm\" \"SWAP\" (func $SWAP (param i32) ))",
    "wast": "(func $SWAP\n  (param $a0 i32)\n  (local $sp_ref i32)\n\n  (local $topa i64)\n  (local $topb i64)\n  (local $topc i64)\n  (local $topd i64)\n  \n  (local.set $sp_ref (i32.sub (i32.add  (global.get $sp) (i32.const 24)) (i32.mul (i32.add (local.get $a0) (i32.const 1)) (i32.const 32))))\n\n  (local.set $topa (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $topb (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $topc (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $topd (i64.load          (global.get $sp)))\n  \n  ;; replace the top element\n  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.load (local.get $sp_ref)))\n  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.load (i32.sub (local.get $sp_ref) (i32.const 8))))\n  (i64.store (i32.add (global.get $sp) (i32.const  8)) (i64.load (i32.sub (local.get $sp_ref) (i32.const 16))))\n  (i64.store          (global.get $sp)                 (i64.load (i32.sub (local.get $sp_ref) (i32.const 24))))\n\n  ;; store the old top element\n  (i64.store (local.get $sp_ref)                          (local.get $topa))\n  (i64.store (i32.sub (local.get $sp_ref) (i32.const 8))  (local.get $topb))\n  (i64.store (i32.sub (local.get $sp_ref) (i32.const 16)) (local.get $topc))\n  (i64.store (i32.sub (local.get $sp_ref) (i32.const 24)) (local.get $topd))\n)\n"
  },
  "check_overflow": {
    "inline_imports": "(import \"ewasm\" \"check_overflow\" (func $check_overflow (param i64 i64 i64 i64)  (result i32) ))",
    "wast": "(func $check_overflow\n  (param $a i64)\n  (param $b i64)\n  (param $c i64)\n  (param $d i64)\n  (result i32)\n\n  (local $MAX_INT i32)\n  (local.set $MAX_INT (i32.const -1))\n\n  (if\n    (i32.and\n      (i32.and\n        (i64.eqz  (local.get $d))\n        (i64.eqz  (local.get $c)))\n      (i32.and\n        (i64.eqz  (local.get $b))\n        (i64.lt_u (local.get $a) (i64.extend_i32_u (local.get $MAX_INT)))))\n     (return (i32.wrap_i64 (local.get $a))))\n\n     (return (local.get $MAX_INT))\n)\n"
  },
  "ADDMOD": {
    "wast": ";; stack:\n;;  0: A\n;; -1: B\n;; -2: MOD\n(func $ADDMOD\n  (local $sp i32)\n\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  (local $moda i64)\n  (local $modb i64)\n  (local $modc i64)\n  (local $modd i64)\n\n  (local $carry i64)\n\n  (local.set $sp (global.get $sp))\n\n  ;; load args from the stack\n  (local.set $a (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $d (i64.load (local.get $sp)))\n\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 32)))\n\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c1 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $d1 (i64.load (local.get $sp)))\n\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 32)))\n\n  (local.set $moda (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $modb (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $modc (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $modd (i64.load (local.get $sp)))\n\n  ;; a * 64^3 + b*64^2 + c*64 + d\n  ;; d\n  (local.set $d     (i64.add (local.get $d1) (local.get $d)))\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $d) (local.get $d1))))\n  ;; c\n  (local.set $c     (i64.add (local.get $c) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $c) (local.get $carry))))\n  (local.set $c     (i64.add (local.get $c1) (local.get $c)))\n  (local.set $carry (i64.or (i64.extend_i32_u  (i64.lt_u (local.get $c) (local.get $c1))) (local.get $carry)))\n  ;; b\n  (local.set $b     (i64.add (local.get $b) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $b) (local.get $carry))))\n  (local.set $b     (i64.add (local.get $b1) (local.get $b)))\n  (local.set $carry (i64.or (i64.extend_i32_u  (i64.lt_u (local.get $b) (local.get $b1))) (local.get $carry)))\n  ;; a\n  (local.set $a     (i64.add (local.get $a) (local.get $carry)))\n  (local.set $carry (i64.extend_i32_u (i64.lt_u (local.get $a) (local.get $carry))))\n  (local.set $a     (i64.add (local.get $a1) (local.get $a)))\n  (local.set $carry (i64.or (i64.extend_i32_u  (i64.lt_u (local.get $a) (local.get $a1))) (local.get $carry)))\n\n  (call $mod_320\n        (local.get $carry) (local.get $a)    (local.get $b)    (local.get $c)    (local.get $d)\n        (i64.const 0)      (local.get $moda) (local.get $modb) (local.get $modc) (local.get $modd) (local.get $sp))\n)\n"
  },
  "AND": {
    "wast": "(func $AND\n  (i64.store (i32.sub (global.get $sp) (i32.const 8))  (i64.and (i64.load (i32.sub (global.get $sp) (i32.const 8)))  (i64.load (i32.add (global.get $sp) (i32.const 24)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 16)) (i64.and (i64.load (i32.sub (global.get $sp) (i32.const 16))) (i64.load (i32.add (global.get $sp) (i32.const 16)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 24)) (i64.and (i64.load (i32.sub (global.get $sp) (i32.const 24))) (i64.load (i32.add (global.get $sp) (i32.const 8)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 32)) (i64.and (i64.load (i32.sub (global.get $sp) (i32.const 32))) (i64.load (global.get $sp))))\n)\n"
  },
  "BYTE": {
    "wast": ";; stack:\n;;  0: offset\n;; -1: value\n(func $BYTE\n    (local $sp i32)\n\n    (local $x1 i64)\n    (local $x2 i64)\n    (local $x3 i64)\n    (local $x4 i64)\n    (local $y1 i64)\n    (local $y2 i64)\n    (local $y3 i64)\n    (local $y4 i64)\n\n    (local $r1 i64)\n    (local $r2 i64)\n    (local $r3 i64)\n    (local $r4 i64)\n    (local $component i64)\n    (local $condition i64)\n\n    ;; load args from the stack\n    (local.set $x1 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n    (local.set $x2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n    (local.set $x3 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n    (local.set $x4 (i64.load (global.get $sp)))\n\n    (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n    (local.set $y1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n    (local.set $y2 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n    (local.set $y3 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n    (local.set $y4 (i64.load (local.get $sp)))\n\n    (block\n        (if (i64.eqz (i64.or (i64.or (local.get $x1) (local.get $x2)) (local.get $x3))) (then\n            (nop)\n            (block\n                (local.set $condition (i64.div_u (local.get $x4) (i64.const 8)))\n                (if (i64.eq (local.get $condition) (i64.const 0)) (then\n                    (local.set $component (local.get $y1))\n                )(else\n                    (if (i64.eq (local.get $condition) (i64.const 1)) (then\n                        (local.set $component (local.get $y2))\n                    )(else\n                        (if (i64.eq (local.get $condition) (i64.const 2)) (then\n                            (local.set $component (local.get $y3))\n                        )(else\n                            (if (i64.eq (local.get $condition) (i64.const 3)) (then\n                                (local.set $component (local.get $y4))\n                            ))\n                        ))\n                    ))\n                ))\n\n            )\n            (local.set $x4 (i64.mul (i64.rem_u (local.get $x4) (i64.const 8)) (i64.const 8)))\n            (local.set $r4 (i64.shr_u (local.get $component) (i64.sub (i64.const 56) (local.get $x4))))\n            (local.set $r4 (i64.and (i64.const 255) (local.get $r4)))\n        ))\n\n    )\n    (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $r1))\n    (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $r2))\n    (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $r3))\n    (i64.store          (local.get $sp)                 (local.get $r4))\n)\n"
  },
  "DIV": {
    "wast": "(func $DIV\n  (local $sp i32)\n  ;; dividend\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  ;; divisor\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $carry i32)\n  (local $temp  i64)\n  (local $temp2  i64)\n\n  (local.set $sp (global.get $sp))\n  (local.set $maskd (i64.const 1))\n\n  ;; load args from the stack\n  (local.set $a (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $d (i64.load (local.get $sp)))\n\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 32)))\n\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c1 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $d1 (i64.load (local.get $sp)))\n\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n      (br $main)\n    )\n\n    ;; align bits\n    (block $done\n      (loop $loop\n        ;; align bits;\n        (if\n          ;; check to make sure we are not overflowing\n          (i32.or (i64.eqz (i64.clz (local.get $a1)))\n          ;;  divisor < dividend\n          (call $gte_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $a) (local.get $b) (local.get $c) (local.get $d)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (local.set $a1 (i64.add (i64.shl (local.get $a1) (i64.const 1)) (i64.shr_u (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shl (local.get $b1) (i64.const 1)) (i64.shr_u (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shl (local.get $c1) (i64.const 1)) (i64.shr_u (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.shl (local.get $d1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (local.set $maska (i64.add (i64.shl (local.get $maska) (i64.const 1)) (i64.shr_u (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shl (local.get $maskb) (i64.const 1)) (i64.shr_u (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shl (local.get $maskc) (i64.const 1)) (i64.shr_u (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.shl (local.get $maskd) (i64.const 1)))\n\n        (br $loop)\n      )\n    )\n\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_256 (local.get $maska) (local.get $maskb) (local.get $maskc) (local.get $maskd))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_256 (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n          (then\n            ;; dividend = dividend - divisor\n            (local.set $carry (i64.lt_u (local.get $d) (local.get $d1)))\n            (local.set $d     (i64.sub  (local.get $d) (local.get $d1)))\n            (local.set $temp  (i64.sub  (local.get $c) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $c)))\n            (local.set $c     (i64.sub  (local.get $temp) (local.get $c1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $c) (local.get $temp)) (local.get $carry)))\n            (local.set $temp  (i64.sub  (local.get $b) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $b)))\n            (local.set $b     (i64.sub  (local.get $temp) (local.get $b1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $b) (local.get $temp)) (local.get $carry)))\n            (local.set $a     (i64.sub  (i64.sub (local.get $a) (i64.extend_i32_u (local.get $carry))) (local.get $a1)))\n\n            ;; result = result + mask\n            (local.set $dq   (i64.add (local.get $maskd) (local.get $dq)))\n            (local.set $temp (i64.extend_i32_u (i64.lt_u (local.get $dq) (local.get $maskd))))\n            (local.set $cq   (i64.add (local.get $cq) (local.get $temp)))\n            (local.set $temp (i64.extend_i32_u (i64.lt_u (local.get $cq) (local.get $temp))))\n            (local.set $cq   (i64.add (local.get $maskc) (local.get $cq)))\n            (local.set $temp (i64.or (i64.extend_i32_u  (i64.lt_u (local.get $cq) (local.get $maskc))) (local.get $temp)))\n            (local.set $bq   (i64.add (local.get $bq) (local.get $temp)))\n            (local.set $temp (i64.extend_i32_u (i64.lt_u (local.get $bq) (local.get $temp))))\n            (local.set $bq   (i64.add (local.get $maskb) (local.get $bq)))\n            (local.set $aq   (i64.add (local.get $maska) (i64.add (local.get $aq) (i64.or (i64.extend_i32_u (i64.lt_u (local.get $bq) (local.get $maskb))) (local.get $temp)))))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (local.set $d1 (i64.add (i64.shr_u (local.get $d1) (i64.const 1)) (i64.shl (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shr_u (local.get $c1) (i64.const 1)) (i64.shl (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shr_u (local.get $b1) (i64.const 1)) (i64.shl (local.get $a1) (i64.const 63))))\n        (local.set $a1 (i64.shr_u (local.get $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (local.set $maskd (i64.add (i64.shr_u (local.get $maskd) (i64.const 1)) (i64.shl (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shr_u (local.get $maskc) (i64.const 1)) (i64.shl (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shr_u (local.get $maskb) (i64.const 1)) (i64.shl (local.get $maska) (i64.const 63))))\n        (local.set $maska (i64.shr_u (local.get $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $aq))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $bq))\n  (i64.store (i32.add (local.get $sp) (i32.const 8))  (local.get $cq))\n  (i64.store (local.get $sp) (local.get $dq))\n)\n"
  },
  "EXP": {
    "wast": "(func $EXP\n  (local $sp i32)\n\n  ;; base\n  (local $base0 i64)\n  (local $base1 i64)\n  (local $base2 i64)\n  (local $base3 i64)\n\n  ;; exp\n  (local $exp0 i64)\n  (local $exp1 i64)\n  (local $exp2 i64)\n  (local $exp3 i64)\n\n  (local $r0 i64)\n  (local $r1 i64)\n  (local $r2 i64)\n  (local $r3 i64)\n\n  (local $gasCounter i32)\n  (local.set $sp (global.get $sp))\n\n  ;; load args from the stack\n  (local.set $base0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $base1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $base2 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (local.set $base3 (i64.load          (local.get $sp)))\n\n  (local.set $sp (i32.sub (local.get $sp) (i32.const 32)))\n\n  (local.set $exp0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $exp1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $exp2 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (local.set $exp3 (i64.load          (local.get $sp)))\n\n  ;; let result = new BN[1]\n  (local.set $r3 (i64.const 1))\n\n  (block $done\n    (loop $loop\n       ;; while [exp > 0] {\n      (if (call $iszero_256 (local.get $exp0) (local.get $exp1) (local.get $exp2) (local.get $exp3))\n        (br $done)\n      )\n\n      ;; if[exp.modn[2] === 1]\n      ;; is odd?\n      (if (i64.eqz (i64.ctz (local.get $exp3)))\n\n        ;; result = result.mul[base].mod[TWO_POW256]\n        ;; r = r * a\n        (then\n          (call $mul_256 (local.get $r0) (local.get $r1) (local.get $r2) (local.get $r3) (local.get $base0) (local.get $base1) (local.get $base2) (local.get $base3) (i32.add (local.get $sp) (i32.const 24)))\n          (local.set $r0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n          (local.set $r1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n          (local.set $r2 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n          (local.set $r3 (i64.load          (local.get $sp)))\n        )\n      )\n      ;; exp = exp.shrn 1\n      (local.set $exp3 (i64.add (i64.shr_u (local.get $exp3) (i64.const 1)) (i64.shl (local.get $exp2) (i64.const 63))))\n      (local.set $exp2 (i64.add (i64.shr_u (local.get $exp2) (i64.const 1)) (i64.shl (local.get $exp1) (i64.const 63))))\n      (local.set $exp1 (i64.add (i64.shr_u (local.get $exp1) (i64.const 1)) (i64.shl (local.get $exp0) (i64.const 63))))\n      (local.set $exp0 (i64.shr_u (local.get $exp0) (i64.const 1)))\n\n      ;; base = base.mulr[baser].modr[TWO_POW256]\n      (call $mul_256 (local.get $base0) (local.get $base1) (local.get $base2) (local.get $base3) (local.get $base0) (local.get $base1) (local.get $base2) (local.get $base3) (i32.add (local.get $sp) (i32.const 24)))\n      (local.set $base0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n      (local.set $base1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n      (local.set $base2 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n      (local.set $base3 (i64.load          (local.get $sp)))\n\n      (local.set $gasCounter (i32.add (local.get $gasCounter) (i32.const 1)))\n      (br $loop)\n    )\n  )\n\n  ;; use gas\n  ;; Log256[Exponent] * 10\n  (call $useGas\n    (i64.extend_i32_u\n      (i32.mul\n        (i32.const 10)\n        (i32.div_u\n          (i32.add (local.get $gasCounter) (i32.const 7))\n          (i32.const 8)))))\n\n  ;; decement the stack pointer\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $r0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $r1))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $r2))\n  (i64.store          (local.get $sp)                 (local.get $r3))\n)\n"
  },
  "MOD": {
    "wast": "(func $MOD\n  (local $sp i32)\n\n  ;; dividend\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  ;; divisor\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $carry i32)\n  (local $temp i64)\n\n  (local.set $maskd (i64.const 1))\n\n  ;; load args from the stack\n  (local.set $a (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $b (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $c (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $d (i64.load          (global.get $sp)))\n  ;; decement the stack pointer\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c1 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (local.set $d1 (i64.load          (local.get $sp)))\n\n\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n      (then\n        (local.set $a (i64.const 0))\n        (local.set $b (i64.const 0))\n        (local.set $c (i64.const 0))\n        (local.set $d (i64.const 0))\n        (br $main)\n      )\n    )\n\n    ;; align bits\n    (block $done\n        (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (local.get $a1))) (call $gte_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $a) (local.get $b) (local.get $c) (local.get $d)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (local.set $a1 (i64.add (i64.shl (local.get $a1) (i64.const 1)) (i64.shr_u (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shl (local.get $b1) (i64.const 1)) (i64.shr_u (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shl (local.get $c1) (i64.const 1)) (i64.shr_u (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.shl (local.get $d1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (local.set $maska (i64.add (i64.shl (local.get $maska) (i64.const 1)) (i64.shr_u (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shl (local.get $maskb) (i64.const 1)) (i64.shr_u (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shl (local.get $maskc) (i64.const 1)) (i64.shr_u (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.shl (local.get $maskd) (i64.const 1)))\n\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_256 (local.get $maska) (local.get $maskb) (local.get $maskc) (local.get $maskd))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_256 (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n          (then\n            ;; dividend = dividend - divisor\n            (local.set $carry (i64.lt_u (local.get $d) (local.get $d1)))\n            (local.set $d     (i64.sub  (local.get $d) (local.get $d1)))\n            (local.set $temp  (i64.sub  (local.get $c) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $c)))\n            (local.set $c     (i64.sub  (local.get $temp) (local.get $c1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $c) (local.get $temp)) (local.get $carry)))\n            (local.set $temp  (i64.sub  (local.get $b) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $b)))\n            (local.set $b     (i64.sub  (local.get $temp) (local.get $b1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $b) (local.get $temp)) (local.get $carry)))\n            (local.set $a     (i64.sub  (i64.sub (local.get $a) (i64.extend_i32_u (local.get $carry))) (local.get $a1)))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (local.set $d1 (i64.add (i64.shr_u (local.get $d1) (i64.const 1)) (i64.shl (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shr_u (local.get $c1) (i64.const 1)) (i64.shl (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shr_u (local.get $b1) (i64.const 1)) (i64.shl (local.get $a1) (i64.const 63))))\n        (local.set $a1 (i64.shr_u (local.get $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (local.set $maskd (i64.add (i64.shr_u (local.get $maskd) (i64.const 1)) (i64.shl (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shr_u (local.get $maskc) (i64.const 1)) (i64.shl (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shr_u (local.get $maskb) (i64.const 1)) (i64.shl (local.get $maska) (i64.const 63))))\n        (local.set $maska (i64.shr_u (local.get $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $a))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $b))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $c))\n  (i64.store          (local.get $sp)                 (local.get $d))\n)\n"
  },
  "MSIZE": {
    "wast": "(func $MSIZE\n  (local $sp i32)\n\n  ;; there's no input item for us to overwrite\n  (local.set $sp (i32.add (global.get $sp) (i32.const 32)))\n\n  (i64.store (i32.add (local.get $sp) (i32.const 0)) \n             (i64.mul (global.get $wordCount) (i64.const 32)))\n  (i64.store (i32.add (local.get $sp) (i32.const 8)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "MSTORE8": {
    "wast": ";; stack:\n;;  0: offset\n;; -1: word\n(func $MSTORE8\n  (local $sp i32)\n\n  (local $offset i32)\n\n  (local $offset0 i64)\n  (local $offset1 i64)\n  (local $offset2 i64)\n  (local $offset3 i64)\n\n  ;; load args from the stack\n  (local.set $offset0 (i64.load          (global.get $sp)))\n  (local.set $offset1 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $offset2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $offset3 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n\n  (local.set $offset \n             (call $check_overflow (local.get $offset0)\n                                   (local.get $offset1)\n                                   (local.get $offset2)\n                                   (local.get $offset3)))\n\n  (call $memusegas (local.get $offset) (i32.const 1))\n\n  ;; pop stack\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n  (local.set $offset (i32.add (local.get $offset) (global.get $memstart)))\n  (i32.store8 (i32.add (local.get $offset) (i32.const 0)) (i32.load (local.get $sp)))\n)\n"
  },
  "MUL": {
    "wast": "(func $MUL\n  (call $mul_256\n        (i64.load (i32.add (global.get $sp) (i32.const 24)))\n        (i64.load (i32.add (global.get $sp) (i32.const 16)))\n        (i64.load (i32.add (global.get $sp) (i32.const  8)))\n        (i64.load          (global.get $sp))\n        (i64.load (i32.sub (global.get $sp) (i32.const  8)))\n        (i64.load (i32.sub (global.get $sp) (i32.const 16)))\n        (i64.load (i32.sub (global.get $sp) (i32.const 24)))\n        (i64.load (i32.sub (global.get $sp) (i32.const 32)))\n        (i32.sub (global.get $sp) (i32.const 8))\n  )\n)\n"
  },
  "MULMOD": {
    "wast": "(func $MULMOD\n  (local $sp i32)\n\n  (local $a i64)\n  (local $c i64)\n  (local $e i64)\n  (local $g i64)\n  (local $i i64)\n  (local $k i64)\n  (local $m i64)\n  (local $o i64)\n  (local $b i64)\n  (local $d i64)\n  (local $f i64)\n  (local $h i64)\n  (local $j i64)\n  (local $l i64)\n  (local $n i64)\n  (local $p i64)\n  (local $temp7 i64)\n  (local $temp6 i64)\n  (local $temp5 i64)\n  (local $temp4 i64)\n  (local $temp3 i64)\n  (local $temp2 i64)\n  (local $temp1 i64)\n  (local $temp0 i64)\n  (local $rowCarry i64)\n\n  (local $moda i64)\n  (local $modb i64)\n  (local $modc i64)\n  (local $modd i64)\n\n  ;; pop two items of the stack\n  (local.set $a (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $c (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $e (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $g (i64.load          (global.get $sp)))\n  (local.set $i (i64.load (i32.sub (global.get $sp) (i32.const  8))))\n  (local.set $k (i64.load (i32.sub (global.get $sp) (i32.const 16))))\n  (local.set $m (i64.load (i32.sub (global.get $sp) (i32.const 24))))\n  (local.set $o (i64.load (i32.sub (global.get $sp) (i32.const 32))))\n\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 64)))\n\n  ;; MUL\n  ;;  a b c d e f g h\n  ;;* i j k l m n o p\n  ;;----------------\n\n  ;; split the ops\n  (local.set $b (i64.and (local.get $a) (i64.const 4294967295)))\n  (local.set $a (i64.shr_u (local.get $a) (i64.const 32))) \n\n  (local.set $d (i64.and (local.get $c) (i64.const 4294967295)))\n  (local.set $c (i64.shr_u (local.get $c) (i64.const 32))) \n\n  (local.set $f (i64.and (local.get $e) (i64.const 4294967295)))\n  (local.set $e (i64.shr_u (local.get $e) (i64.const 32)))\n\n  (local.set $h (i64.and (local.get $g) (i64.const 4294967295)))\n  (local.set $g (i64.shr_u (local.get $g) (i64.const 32)))\n\n  (local.set $j (i64.and (local.get $i) (i64.const 4294967295)))\n  (local.set $i (i64.shr_u (local.get $i) (i64.const 32))) \n\n  (local.set $l (i64.and (local.get $k) (i64.const 4294967295)))\n  (local.set $k (i64.shr_u (local.get $k) (i64.const 32))) \n\n  (local.set $n (i64.and (local.get $m) (i64.const 4294967295)))\n  (local.set $m (i64.shr_u (local.get $m) (i64.const 32)))\n\n  (local.set $p (i64.and (local.get $o) (i64.const 4294967295)))\n  (local.set $o (i64.shr_u (local.get $o) (i64.const 32)))\n\n   ;; first row multiplication \n  ;; p * h\n  (local.set $temp0 (i64.mul (local.get $p) (local.get $h)))\n  ;; p * g + carry\n  (local.set $temp1 (i64.add (i64.mul (local.get $p) (local.get $g)) (i64.shr_u (local.get $temp0) (i64.const 32))))\n  ;; p * f + carry\n  (local.set $temp2 (i64.add (i64.mul (local.get $p) (local.get $f)) (i64.shr_u (local.get $temp1) (i64.const 32))))\n  ;; p * e + carry\n  (local.set $temp3 (i64.add (i64.mul (local.get $p) (local.get $e)) (i64.shr_u (local.get $temp2) (i64.const 32))))\n  ;; p * d + carry\n  (local.set $temp4 (i64.add (i64.mul (local.get $p) (local.get $d)) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; p * c + carry\n  (local.set $temp5 (i64.add (i64.mul (local.get $p) (local.get $c)) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; p * b + carry\n  (local.set $temp6 (i64.add (i64.mul (local.get $p) (local.get $b)) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; p * a + carry\n  (local.set $temp7 (i64.add (i64.mul (local.get $p) (local.get $a)) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  (local.set $rowCarry (i64.shr_u (local.get $temp7) (i64.const 32)))\n\n  ;; second row\n  ;; o * h + $temp1 \n  (local.set $temp1 (i64.add (i64.mul (local.get $o) (local.get $h)) (i64.and (local.get $temp1) (i64.const 4294967295))))\n  ;; o * g + $temp2 + carry\n  (local.set $temp2 (i64.add (i64.add (i64.mul (local.get $o) (local.get $g)) (i64.and (local.get $temp2) (i64.const 4294967295))) (i64.shr_u (local.get $temp1) (i64.const 32))))\n  ;; o * f + $temp3 + carry\n  (local.set $temp3 (i64.add (i64.add (i64.mul (local.get $o) (local.get $f)) (i64.and (local.get $temp3) (i64.const 4294967295))) (i64.shr_u (local.get $temp2) (i64.const 32))))\n  ;; o * e + $temp4 + carry\n  (local.set $temp4 (i64.add (i64.add (i64.mul (local.get $o) (local.get $e)) (i64.and (local.get $temp4) (i64.const 4294967295))) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; o * d + $temp5 + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $o) (local.get $d)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; o * c + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $o) (local.get $c)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; o * b + $temp7 + carry\n  (local.set $temp7 (i64.add (i64.add (i64.mul (local.get $o) (local.get $b)) (i64.and (local.get $temp7) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; o * a + carry + rowCarry\n  (local.set $p (i64.add (i64.add (i64.mul (local.get $o) (local.get $a)) (i64.shr_u (local.get $temp7) (i64.const 32))) (local.get $rowCarry)))\n  (local.set $rowCarry (i64.shr_u (local.get $p) (i64.const 32)))\n\n  ;; third row - n\n  ;; n * h + $temp2 \n  (local.set $temp2 (i64.add (i64.mul (local.get $n) (local.get $h)) (i64.and (local.get $temp2) (i64.const 4294967295))))\n  ;; n * g + $temp3  carry\n  (local.set $temp3 (i64.add (i64.add (i64.mul (local.get $n) (local.get $g)) (i64.and (local.get $temp3) (i64.const 4294967295))) (i64.shr_u (local.get $temp2) (i64.const 32))))\n  ;; n * f + $temp4) + carry\n  (local.set $temp4 (i64.add (i64.add (i64.mul (local.get $n) (local.get $f)) (i64.and (local.get $temp4) (i64.const 4294967295))) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; n * e + $temp5 + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $n) (local.get $e)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; n * d + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $n) (local.get $d)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; n * c + $temp7 + carry\n  (local.set $temp7 (i64.add (i64.add (i64.mul (local.get $n) (local.get $c)) (i64.and (local.get $temp7) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; n * b + $p + carry\n  (local.set $p     (i64.add (i64.add (i64.mul (local.get $n) (local.get $b)) (i64.and (local.get $p)     (i64.const 4294967295))) (i64.shr_u (local.get $temp7) (i64.const 32))))\n  ;; n * a + carry\n  (local.set $o (i64.add (i64.add (i64.mul (local.get $n) (local.get $a)) (i64.shr_u (local.get $p) (i64.const 32))) (local.get $rowCarry)))\n  (local.set $rowCarry (i64.shr_u (local.get $o) (i64.const 32)))\n\n  ;; forth row \n  ;; m * h + $temp3\n  (local.set $temp3 (i64.add (i64.mul (local.get $m) (local.get $h)) (i64.and (local.get $temp3) (i64.const 4294967295))))\n  ;; m * g + $temp4 + carry\n  (local.set $temp4 (i64.add (i64.add (i64.mul (local.get $m) (local.get $g)) (i64.and (local.get $temp4) (i64.const 4294967295))) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; m * f + $temp5 + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $m) (local.get $f)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; m * e + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $m) (local.get $e)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; m * d + $temp7 + carry\n  (local.set $temp7 (i64.add (i64.add (i64.mul (local.get $m) (local.get $d)) (i64.and (local.get $temp7) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; m * c + $p + carry\n  (local.set $p     (i64.add (i64.add (i64.mul (local.get $m) (local.get $c)) (i64.and (local.get $p)     (i64.const 4294967295))) (i64.shr_u (local.get $temp7) (i64.const 32))))\n  ;; m * b + $o + carry\n  (local.set $o     (i64.add (i64.add (i64.mul (local.get $m) (local.get $b)) (i64.and (local.get $o)     (i64.const 4294967295))) (i64.shr_u (local.get $p)     (i64.const 32))))\n  ;; m * a + carry + rowCarry\n  (local.set $n     (i64.add (i64.add (i64.mul (local.get $m) (local.get $a)) (i64.shr_u (local.get $o) (i64.const 32))) (local.get $rowCarry)))\n  (local.set $rowCarry (i64.shr_u (local.get $n) (i64.const 32)))\n\n  ;; fith row\n  ;; l * h + $temp4\n  (local.set $temp4 (i64.add (i64.mul (local.get $l) (local.get $h)) (i64.and (local.get $temp4) (i64.const 4294967295))))\n  ;; l * g + $temp5 + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $l) (local.get $g)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; l * f + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $l) (local.get $f)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; l * e + $temp7 + carry\n  (local.set $temp7 (i64.add (i64.add (i64.mul (local.get $l) (local.get $e)) (i64.and (local.get $temp7) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; l * d + $p + carry\n  (local.set $p     (i64.add (i64.add (i64.mul (local.get $l) (local.get $d)) (i64.and (local.get $p)     (i64.const 4294967295))) (i64.shr_u (local.get $temp7) (i64.const 32))))\n  ;; l * c + $o + carry\n  (local.set $o     (i64.add (i64.add (i64.mul (local.get $l) (local.get $c)) (i64.and (local.get $o)     (i64.const 4294967295))) (i64.shr_u (local.get $p)     (i64.const 32))))\n  ;; l * b + $n + carry\n  (local.set $n     (i64.add (i64.add (i64.mul (local.get $l) (local.get $b)) (i64.and (local.get $n)     (i64.const 4294967295))) (i64.shr_u (local.get $o)     (i64.const 32))))\n  ;; l * a + carry + rowCarry\n  (local.set $m     (i64.add (i64.add (i64.mul (local.get $l) (local.get $a)) (i64.shr_u (local.get $n) (i64.const 32))) (local.get $rowCarry)))\n  (local.set $rowCarry (i64.shr_u (local.get $m) (i64.const 32)))\n\n  ;; sixth row \n  ;; k * h + $temp5\n  (local.set $temp5 (i64.add (i64.mul (local.get $k) (local.get $h)) (i64.and (local.get $temp5) (i64.const 4294967295))))\n  ;; k * g + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $k) (local.get $g)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; k * f + $temp7 + carry\n  (local.set $temp7 (i64.add (i64.add (i64.mul (local.get $k) (local.get $f)) (i64.and (local.get $temp7) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; k * e + $p + carry\n  (local.set $p     (i64.add (i64.add (i64.mul (local.get $k) (local.get $e)) (i64.and (local.get $p)     (i64.const 4294967295))) (i64.shr_u (local.get $temp7) (i64.const 32))))\n  ;; k * d + $o + carry\n  (local.set $o     (i64.add (i64.add (i64.mul (local.get $k) (local.get $d)) (i64.and (local.get $o)     (i64.const 4294967295))) (i64.shr_u (local.get $p)     (i64.const 32))))\n  ;; k * c + $n + carry\n  (local.set $n     (i64.add (i64.add (i64.mul (local.get $k) (local.get $c)) (i64.and (local.get $n)     (i64.const 4294967295))) (i64.shr_u (local.get $o)     (i64.const 32))))\n  ;; k * b + $m + carry\n  (local.set $m     (i64.add (i64.add (i64.mul (local.get $k) (local.get $b)) (i64.and (local.get $m)     (i64.const 4294967295))) (i64.shr_u (local.get $n)     (i64.const 32))))\n  ;; k * a + carry\n  (local.set $l     (i64.add (i64.add (i64.mul (local.get $k) (local.get $a)) (i64.shr_u (local.get $m) (i64.const 32))) (local.get $rowCarry)))\n  (local.set $rowCarry (i64.shr_u (local.get $l) (i64.const 32)))\n\n  ;; seventh row\n  ;; j * h + $temp6\n  (local.set $temp6 (i64.add (i64.mul (local.get $j) (local.get $h)) (i64.and (local.get $temp6) (i64.const 4294967295))))\n  ;; j * g + $temp7 + carry\n  (local.set $temp7 (i64.add (i64.add (i64.mul (local.get $j) (local.get $g)) (i64.and (local.get $temp7) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; j * f + $p +carry\n  (local.set $p     (i64.add (i64.add (i64.mul (local.get $j) (local.get $f)) (i64.and (local.get $p)     (i64.const 4294967295))) (i64.shr_u (local.get $temp7) (i64.const 32))))\n  ;; j * e + $o + carry\n  (local.set $o     (i64.add (i64.add (i64.mul (local.get $j) (local.get $e)) (i64.and (local.get $o)     (i64.const 4294967295))) (i64.shr_u (local.get $p)     (i64.const 32))))\n  ;; j * d + $n + carry\n  (local.set $n     (i64.add (i64.add (i64.mul (local.get $j) (local.get $d)) (i64.and (local.get $n)     (i64.const 4294967295))) (i64.shr_u (local.get $o)     (i64.const 32))))\n  ;; j * c + $m + carry\n  (local.set $m     (i64.add (i64.add (i64.mul (local.get $j) (local.get $c)) (i64.and (local.get $m)     (i64.const 4294967295))) (i64.shr_u (local.get $n)     (i64.const 32))))\n  ;; j * b + $l + carry\n  (local.set $l     (i64.add (i64.add (i64.mul (local.get $j) (local.get $b)) (i64.and (local.get $l)     (i64.const 4294967295))) (i64.shr_u (local.get $m)     (i64.const 32))))\n  ;; j * a + carry\n  (local.set $k     (i64.add (i64.add (i64.mul (local.get $j) (local.get $a)) (i64.shr_u (local.get $l) (i64.const 32))) (local.get $rowCarry)))\n  (local.set $rowCarry (i64.shr_u (local.get $k) (i64.const 32)))\n\n  ;; eigth row\n  ;; i * h + $temp7 \n  (local.set $temp7 (i64.add (i64.mul (local.get $i) (local.get $h)) (i64.and (local.get $temp7) (i64.const 4294967295))))\n  ;; i * g + $p \n  (local.set $p     (i64.add (i64.add (i64.mul (local.get $i) (local.get $g)) (i64.and (local.get $p)     (i64.const 4294967295))) (i64.shr_u (local.get $temp7) (i64.const 32))))\n  ;; i * f + $o + carry\n  (local.set $o     (i64.add (i64.add (i64.mul (local.get $i) (local.get $f)) (i64.and (local.get $o)     (i64.const 4294967295))) (i64.shr_u (local.get $p)     (i64.const 32))))\n  ;; i * e + $n + carry\n  (local.set $n     (i64.add (i64.add (i64.mul (local.get $i) (local.get $e)) (i64.and (local.get $n)     (i64.const 4294967295))) (i64.shr_u (local.get $o)     (i64.const 32))))\n  ;; i * d + $m + carry\n  (local.set $m     (i64.add (i64.add (i64.mul (local.get $i) (local.get $d)) (i64.and (local.get $m)     (i64.const 4294967295))) (i64.shr_u (local.get $n)     (i64.const 32))))\n  ;; i * c + $l + carry\n  (local.set $l     (i64.add (i64.add (i64.mul (local.get $i) (local.get $c)) (i64.and (local.get $l)     (i64.const 4294967295))) (i64.shr_u (local.get $m)     (i64.const 32))))\n  ;; i * b + $k + carry\n  (local.set $k     (i64.add (i64.add (i64.mul (local.get $i) (local.get $b)) (i64.and (local.get $k)     (i64.const 4294967295))) (i64.shr_u (local.get $l)     (i64.const 32))))\n  ;; i * a + carry\n  (local.set $j     (i64.add (i64.add (i64.mul (local.get $i) (local.get $a)) (i64.shr_u (local.get $k) (i64.const 32))) (local.get $rowCarry)))\n\n  ;; combine terms\n  (local.set $a (local.get $j))\n  (local.set $b (i64.or (i64.shl (local.get $k)     (i64.const 32)) (i64.and (local.get $l)     (i64.const 4294967295))))\n  (local.set $c (i64.or (i64.shl (local.get $m)     (i64.const 32)) (i64.and (local.get $n)     (i64.const 4294967295))))\n  (local.set $d (i64.or (i64.shl (local.get $o)     (i64.const 32)) (i64.and (local.get $p)     (i64.const 4294967295))))\n  (local.set $e (i64.or (i64.shl (local.get $temp7) (i64.const 32)) (i64.and (local.get $temp6) (i64.const 4294967295))))\n  (local.set $f (i64.or (i64.shl (local.get $temp5) (i64.const 32)) (i64.and (local.get $temp4) (i64.const 4294967295))))\n  (local.set $g (i64.or (i64.shl (local.get $temp3) (i64.const 32)) (i64.and (local.get $temp2) (i64.const 4294967295))))\n  (local.set $h (i64.or (i64.shl (local.get $temp1) (i64.const 32)) (i64.and (local.get $temp0) (i64.const 4294967295))))\n\n  ;; pop the MOD argmunet off the stack\n  (local.set $moda (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $modb (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $modc (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (local.set $modd (i64.load          (local.get $sp)))\n\n  (call $mod_512\n         (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $e) (local.get $f) (local.get $g) (local.get $h) \n         (i64.const 0)  (i64.const 0) (i64.const 0)  (i64.const 0)  (local.get $moda) (local.get $modb) (local.get $modc) (local.get $modd) (i32.add (local.get $sp) (i32.const 24))\n  )\n)\n"
  },
  "NOT": {
    "wast": "(func $NOT\n  ;; FIXME: consider using 0xffffffffffffffff instead of -1?\n  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.xor (i64.load (i32.add (global.get $sp) (i32.const 24))) (i64.const -1)))\n  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.xor (i64.load (i32.add (global.get $sp) (i32.const 16))) (i64.const -1)))\n  (i64.store (i32.add (global.get $sp) (i32.const  8)) (i64.xor (i64.load (i32.add (global.get $sp) (i32.const  8))) (i64.const -1)))\n  (i64.store (i32.add (global.get $sp) (i32.const  0)) (i64.xor (i64.load (i32.add (global.get $sp) (i32.const  0))) (i64.const -1)))\n)\n"
  },
  "OR": {
    "wast": "(func $OR\n  (i64.store (i32.sub (global.get $sp) (i32.const  8)) (i64.or (i64.load (i32.sub (global.get $sp) (i32.const  8))) (i64.load (i32.add (global.get $sp) (i32.const 24)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 16)) (i64.or (i64.load (i32.sub (global.get $sp) (i32.const 16))) (i64.load (i32.add (global.get $sp) (i32.const 16)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 24)) (i64.or (i64.load (i32.sub (global.get $sp) (i32.const 24))) (i64.load (i32.add (global.get $sp) (i32.const  8)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 32)) (i64.or (i64.load (i32.sub (global.get $sp) (i32.const 32))) (i64.load          (global.get $sp))))\n)\n"
  },
  "PC": {
    "wast": "(func $PC\n  (param $pc i32)\n  (local $sp i32)\n\n  ;; add one to the stack\n  (local.set $sp (i32.add (global.get $sp) (i32.const 32)))\n  (i64.store (local.get $sp) (i64.extend_i32_u (local.get $pc)))\n\n  ;; zero out rest of stack\n  (i64.store (i32.add (local.get $sp) (i32.const 8)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "SAR": {
    "wast": "(func $SAR\n    (local $sp i32)\n    (local $x1 i64)\n    (local $x2 i64)\n    (local $x3 i64)\n    (local $x4 i64)\n    (local $y1 i64)\n    (local $y2 i64)\n    (local $y3 i64)\n    (local $y4 i64)\n\n    (local $z1 i64)\n    (local $z2 i64)\n    (local $z3 i64)\n    (local $z4 i64)\n\n    ;; load args from the stack\n    (local.set $x1 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n    (local.set $x2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n    (local.set $x3 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n    (local.set $x4 (i64.load (global.get $sp)))\n\n    (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n    (local.set $y1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n    (local.set $y2 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n    (local.set $y3 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n    (local.set $y4 (i64.load (local.get $sp)))\n\n    (block $label_sar_internal\n        (if (i64.gt_u (i64.clz (local.get $y1)) (i64.const 0)) (then\n            (block\n                (local.set $z1 (call $shr_ (local.get $x1) (local.get $x2) (local.get $x3) (local.get $x4) (local.get $y1) (local.get $y2) (local.get $y3) (local.get $y4)))\n                (local.set $z2 (global.get $global_))\n                (local.set $z3 (global.get $global__1))\n                (local.set $z4 (global.get $global__2))\n\n            )\n            (br $label_sar_internal)\n        ))\n        (if (call $gte_256x256_64 (local.get $x1) (local.get $x2) (local.get $x3) (local.get $x4) (i64.const 0) (i64.const 0) (i64.const 0) (i64.const 256)) (then\n            (local.set $z1 (i64.const 18446744073709551615))\n            (local.set $z2 (i64.const 18446744073709551615))\n            (local.set $z3 (i64.const 18446744073709551615))\n            (local.set $z4 (i64.const 18446744073709551615))\n        ))\n        (if (call $lt_256x256_64 (local.get $x1) (local.get $x2) (local.get $x3) (local.get $x4) (i64.const 0) (i64.const 0) (i64.const 0) (i64.const 256)) (then\n            (block\n                (local.set $y1 (call $shr_ (i64.const 0) (i64.const 0) (i64.const 0) (local.get $x4) (local.get $y1) (local.get $y2) (local.get $y3) (local.get $y4)))\n                (local.set $y2 (global.get $global_))\n                (local.set $y3 (global.get $global__1))\n                (local.set $y4 (global.get $global__2))\n\n            )\n            (block\n                (local.set $z1 (call $shl_ (i64.const 0) (i64.const 0) (i64.const 0) (i64.sub (i64.const 256) (local.get $x4)) (i64.const 18446744073709551615) (i64.const 18446744073709551615) (i64.const 18446744073709551615) (i64.const 18446744073709551615)))\n                (local.set $z2 (global.get $global_))\n                (local.set $z3 (global.get $global__1))\n                (local.set $z4 (global.get $global__2))\n\n            )\n            (block\n                (local.set $z1 (call $or_ (local.get $y1) (local.get $y2) (local.get $y3) (local.get $y4) (local.get $z1) (local.get $z2) (local.get $z3) (local.get $z4)))\n                (local.set $z2 (global.get $global_))\n                (local.set $z3 (global.get $global__1))\n                (local.set $z4 (global.get $global__2))\n\n            )\n        ))\n\n    )\n    (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $z1))\n    (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $z2))\n    (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $z3))\n    (i64.store          (local.get $sp)                 (local.get $z4))\n)\n\n(func $lt_256x256_64\n    (param $x1 i64)\n    (param $x2 i64)\n    (param $x3 i64)\n    (param $x4 i64)\n    (param $y1 i64)\n    (param $y2 i64)\n    (param $y3 i64)\n    (param $y4 i64)\n    (result i32)\n    (local $z i32)\n    (local $condition_106 i32)\n    (local $condition_107 i32)\n    (local $condition_108 i32)\n    (block\n        (block\n            (local.set $condition_106 (call $cmp (local.get $x1) (local.get $y1)))\n            (if (i32.eq (local.get $condition_106) (i32.const 0)) (then\n                (block\n                    (local.set $condition_107 (call $cmp (local.get $x2) (local.get $y2)))\n                    (if (i32.eq (local.get $condition_107) (i32.const 0)) (then\n                        (block\n                            (local.set $condition_108 (call $cmp (local.get $x3) (local.get $y3)))\n                            (if (i32.eq (local.get $condition_108) (i32.const 0)) (then\n                                (local.set $z (i64.lt_u (local.get $x4) (local.get $y4)))\n                            )(else\n                                (if (i32.eq (local.get $condition_108) (i32.const 1)) (then\n                                    (local.set $z (i32.const 0))\n                                )(else\n                                    (local.set $z (i32.const 1))\n                                ))\n                            ))\n\n                        )\n                    )(else\n                        (if (i32.eq (local.get $condition_107) (i32.const 1)) (then\n                            (local.set $z (i32.const 0))\n                        )(else\n                            (local.set $z (i32.const 1))\n                        ))\n                    ))\n\n                )\n            )(else\n                (if (i32.eq (local.get $condition_106) (i32.const 1)) (then\n                    (local.set $z (i32.const 0))\n                )(else\n                    (local.set $z (i32.const 1))\n                ))\n            ))\n\n        )\n\n    )\n    (local.get $z)\n)\n\n(func $gte_256x256_64\n    (param $x1 i64)\n    (param $x2 i64)\n    (param $x3 i64)\n    (param $x4 i64)\n    (param $y1 i64)\n    (param $y2 i64)\n    (param $y3 i64)\n    (param $y4 i64)\n    (result i32)\n    (local $z i32)\n    (block\n        (local.set $z (i32.eqz (call $lt_256x256_64 (local.get $x1) (local.get $x2) (local.get $x3) (local.get $x4) (local.get $y1) (local.get $y2) (local.get $y3) (local.get $y4))))\n\n    )\n    (local.get $z)\n)\n\n\n(func $or_\n    (param $x1 i64)\n    (param $x2 i64)\n    (param $x3 i64)\n    (param $x4 i64)\n    (param $y1 i64)\n    (param $y2 i64)\n    (param $y3 i64)\n    (param $y4 i64)\n    (result i64)\n    (local $r1 i64)\n    (local $r2 i64)\n    (local $r3 i64)\n    (local $r4 i64)\n    (block\n        (local.set $r1 (i64.or (local.get $x1) (local.get $y1)))\n        (local.set $r2 (i64.or (local.get $x2) (local.get $y2)))\n        (local.set $r3 (i64.or (local.get $x3) (local.get $y3)))\n        (local.set $r4 (i64.or (local.get $x4) (local.get $y4)))\n\n    )\n    (global.set $global_ (local.get $r2))\n    (global.set $global__1 (local.get $r3))\n    (global.set $global__2 (local.get $r4))\n    (local.get $r1)\n)\n\n\n(func $cmp\n    (param $a i64)\n    (param $b i64)\n    (result i32)\n    (local $r i32)\n    (block\n        (local.set $r (select (i32.const 4294967295) (i64.ne (local.get $a) (local.get $b)) (i64.lt_u (local.get $a) (local.get $b))))\n\n    )\n    (local.get $r)\n)\n\n\n(func $shr_single_\n    (param $a i64)\n    (param $amount i64)\n    (result i64)\n    (local $x i64)\n    (local $y i64)\n    (block\n        (local.set $y (i64.shl (local.get $a) (i64.sub (i64.const 64) (local.get $amount))))\n        (local.set $x (i64.shr_u (local.get $a) (local.get $amount)))\n\n    )\n    (global.set $global_ (local.get $y))\n    (local.get $x)\n)\n\n(func $shr_\n    (param $x1 i64)\n    (param $x2 i64)\n    (param $x3 i64)\n    (param $x4 i64)\n    (param $y1 i64)\n    (param $y2 i64)\n    (param $y3 i64)\n    (param $y4 i64)\n    (result i64)\n    (local $z1 i64)\n    (local $z2 i64)\n    (local $z3 i64)\n    (local $z4 i64)\n    (local $t i64)\n    (block\n        (if (i32.and (i64.eqz (local.get $x1)) (i64.eqz (local.get $x2))) (then\n            (if (i64.eqz (local.get $x3)) (then\n                (if (i64.eqz (local.get $x4))\n                    (then\n                        (local.set $z1 (local.get $y1))\n                        (local.set $z2 (local.get $y2))\n                        (local.set $z3 (local.get $y3))\n                        (local.set $z4 (local.get $y4))\n                    )\n                    (else\n                        (if (i64.lt_u (local.get $x4) (i64.const 256)) (then\n                            (if (i64.ge_u (local.get $x4) (i64.const 128)) (then\n                                (local.set $y4 (local.get $y2))\n                                (local.set $y3 (local.get $y1))\n                                (local.set $y2 (i64.const 0))\n                                (local.set $y1 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 128)))\n                            ))\n                            (if (i64.ge_u (local.get $x4) (i64.const 64)) (then\n                                (local.set $y4 (local.get $y3))\n                                (local.set $y3 (local.get $y2))\n                                (local.set $y2 (local.get $y1))\n                                (local.set $y1 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 64)))\n                            ))\n                            (nop)\n                            (block\n                                (local.set $z4 (call $shr_single_ (local.get $y4) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (block\n                                (local.set $z3 (call $shr_single_ (local.get $y3) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (local.set $z4 (i64.or (local.get $z4) (local.get $t)))\n                            (block\n                                (local.set $z2 (call $shr_single_ (local.get $y2) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (local.set $z3 (i64.or (local.get $z3) (local.get $t)))\n                            (block\n                                (local.set $z1 (call $shr_single_ (local.get $y1) (local.get $x4)))\n                                (local.set $t (global.get $global_))\n\n                            )\n                            (local.set $z2 (i64.or (local.get $z2) (local.get $t)))\n                        ))\n                    )\n                )\n            ))\n        ))\n\n    )\n    (global.set $global_ (local.get $z2))\n    (global.set $global__1 (local.get $z3))\n    (global.set $global__2 (local.get $z4))\n    (local.get $z1)\n)\n\n\n(func $shl_single_\n    (param $a i64)\n    (param $amount i64)\n    (result i64)\n    (local $x i64)\n    (local $y i64)\n    (block\n        (local.set $x (i64.shr_u (local.get $a) (i64.sub (i64.const 64) (local.get $amount))))\n        (local.set $y (i64.shl (local.get $a) (local.get $amount)))\n\n    )\n    (global.set $global_ (local.get $y))\n    (local.get $x)\n)\n\n(func $shl_\n    (param $x1 i64)\n    (param $x2 i64)\n    (param $x3 i64)\n    (param $x4 i64)\n    (param $y1 i64)\n    (param $y2 i64)\n    (param $y3 i64)\n    (param $y4 i64)\n    (result i64)\n    (local $z1 i64)\n    (local $z2 i64)\n    (local $z3 i64)\n    (local $z4 i64)\n    (local $t i64)\n    (local $r i64)\n    (block\n        (if (i32.and (i64.eqz (local.get $x1)) (i64.eqz (local.get $x2))) (then\n            (if (i64.eqz (local.get $x3)) (then\n                (if (i64.eqz (local.get $x4))\n                    (then\n                        (local.set $z1 (local.get $y1))\n                        (local.set $z2 (local.get $y2))\n                        (local.set $z3 (local.get $y3))\n                        (local.set $z4 (local.get $y4))\n                    )\n                    (else\n                        (if (i64.lt_u (local.get $x4) (i64.const 256)) (then\n                            (if (i64.ge_u (local.get $x4) (i64.const 128)) (then\n                                (local.set $y1 (local.get $y3))\n                                (local.set $y2 (local.get $y4))\n                                (local.set $y3 (i64.const 0))\n                                (local.set $y4 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 128)))\n                            ))\n                            (if (i64.ge_u (local.get $x4) (i64.const 64)) (then\n                                (local.set $y1 (local.get $y2))\n                                (local.set $y2 (local.get $y3))\n                                (local.set $y3 (local.get $y4))\n                                (local.set $y4 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 64)))\n                            ))\n                            (nop)\n                            (block\n                                (local.set $t (call $shl_single_ (local.get $y4) (local.get $x4)))\n                                (local.set $z4 (global.get $global_))\n\n                            )\n                            (block\n                                (local.set $r (call $shl_single_ (local.get $y3) (local.get $x4)))\n                                (local.set $z3 (global.get $global_))\n\n                            )\n                            (local.set $z3 (i64.or (local.get $z3) (local.get $t)))\n                            (block\n                                (local.set $t (call $shl_single_ (local.get $y2) (local.get $x4)))\n                                (local.set $z2 (global.get $global_))\n\n                            )\n                            (local.set $z2 (i64.or (local.get $z2) (local.get $r)))\n                            (block\n                                (local.set $r (call $shl_single_ (local.get $y1) (local.get $x4)))\n                                (local.set $z1 (global.get $global_))\n\n                            )\n                            (local.set $z1 (i64.or (local.get $z1) (local.get $t)))\n                        ))\n                    )\n                )\n            ))\n        ))\n\n    )\n    (global.set $global_ (local.get $z2))\n    (global.set $global__1 (local.get $z3))\n    (global.set $global__2 (local.get $z4))\n    (local.get $z1)\n)\n"
  },
  "SDIV": {
    "wast": "(func $SDIV\n  (local $sp i32)\n\n  ;; dividend\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  ;; divisor\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $carry i32)\n  (local $temp  i64)\n  (local $temp2 i64)\n  (local $sign i32)\n\n  (local.set $maskd (i64.const 1))\n\n  ;; load args from the stack\n  (local.set $a (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $b (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $c (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $d (i64.load (global.get $sp)))\n\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c1 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $d1 (i64.load (local.get $sp)))\n\n  ;; get the resulting sign\n  (local.set $sign (i32.wrap_i64 (i64.shr_u (i64.xor (local.get $a1) (local.get $a)) (i64.const 63))))\n\n  ;; convert to unsigned value\n  (if (i64.eqz (i64.clz (local.get $a)))\n    (then\n      (local.set $a (i64.xor (local.get $a) (i64.const -1)))\n      (local.set $b (i64.xor (local.get $b) (i64.const -1)))\n      (local.set $c (i64.xor (local.get $c) (i64.const -1)))\n      (local.set $d (i64.xor (local.get $d) (i64.const -1)))\n\n      ;; a = a + 1\n      (local.set $d (i64.add (local.get $d) (i64.const 1)))\n      (local.set $carry (i64.eqz (local.get $d)))\n      (local.set $c (i64.add (local.get $c) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $c)) (local.get $carry)))\n      (local.set $b (i64.add (local.get $b) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $b)) (local.get $carry)))\n      (local.set $a (i64.add (local.get $a) (i64.extend_i32_u (local.get $carry))))\n    )\n  )\n  (if (i64.eqz (i64.clz (local.get $a1)))\n    (then\n      (local.set $a1 (i64.xor (local.get $a1) (i64.const -1)))\n      (local.set $b1 (i64.xor (local.get $b1) (i64.const -1)))\n      (local.set $c1 (i64.xor (local.get $c1) (i64.const -1)))\n      (local.set $d1 (i64.xor (local.get $d1) (i64.const -1)))\n\n      (local.set $d1 (i64.add (local.get $d1) (i64.const 1)))\n      (local.set $carry (i64.eqz (local.get $d1)))\n      (local.set $c1 (i64.add (local.get $c1) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $c1)) (local.get $carry)))\n      (local.set $b1 (i64.add (local.get $b1) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $b1)) (local.get $carry)))\n      (local.set $a1 (i64.add (local.get $a1) (i64.extend_i32_u (local.get $carry))))\n    )\n  )\n\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n      (br $main)\n    )\n\n    ;; align bits\n    (block $done\n      (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (local.get $a1))) (call $gte_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $a) (local.get $b) (local.get $c) (local.get $d)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (local.set $a1 (i64.add (i64.shl (local.get $a1) (i64.const 1)) (i64.shr_u (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shl (local.get $b1) (i64.const 1)) (i64.shr_u (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shl (local.get $c1) (i64.const 1)) (i64.shr_u (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.shl (local.get $d1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (local.set $maska (i64.add (i64.shl (local.get $maska) (i64.const 1)) (i64.shr_u (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shl (local.get $maskb) (i64.const 1)) (i64.shr_u (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shl (local.get $maskc) (i64.const 1)) (i64.shr_u (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.shl (local.get $maskd) (i64.const 1)))\n\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_256 (local.get $maska) (local.get $maskb) (local.get $maskc) (local.get $maskd))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_256 (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n          (then\n            ;; dividend = dividend - divisor\n            (local.set $carry (i64.lt_u (local.get $d) (local.get $d1)))\n            (local.set $d     (i64.sub  (local.get $d) (local.get $d1)))\n            (local.set $temp  (i64.sub  (local.get $c) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $c)))\n            (local.set $c     (i64.sub  (local.get $temp) (local.get $c1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $c) (local.get $temp)) (local.get $carry)))\n            (local.set $temp  (i64.sub  (local.get $b) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $b)))\n            (local.set $b     (i64.sub  (local.get $temp) (local.get $b1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $b) (local.get $temp)) (local.get $carry)))\n            (local.set $a     (i64.sub  (i64.sub (local.get $a) (i64.extend_i32_u (local.get $carry))) (local.get $a1)))\n\n            ;; result = result + mask\n            (local.set $dq    (i64.add  (local.get $maskd) (local.get $dq)))\n            (local.set $carry (i64.lt_u (local.get $dq) (local.get $maskd)))\n            (local.set $temp  (i64.add  (local.get $cq) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.lt_u (local.get $temp) (local.get $cq)))\n            (local.set $cq    (i64.add  (local.get $maskc) (local.get $temp)))\n            (local.set $carry (i32.or   (i64.lt_u (local.get $cq) (local.get $maskc)) (local.get $carry)))\n            (local.set $temp  (i64.add  (local.get $bq) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.lt_u (local.get $temp) (local.get $bq)))\n            (local.set $bq    (i64.add  (local.get $maskb) (local.get $temp)))\n            (local.set $carry (i32.or   (i64.lt_u (local.get $bq) (local.get $maskb)) (local.get $carry)))\n            (local.set $aq    (i64.add  (local.get $maska) (i64.add (local.get $aq) (i64.extend_i32_u (local.get $carry)))))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (local.set $d1 (i64.add (i64.shr_u (local.get $d1) (i64.const 1)) (i64.shl (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shr_u (local.get $c1) (i64.const 1)) (i64.shl (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shr_u (local.get $b1) (i64.const 1)) (i64.shl (local.get $a1) (i64.const 63))))\n        (local.set $a1 (i64.shr_u (local.get $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (local.set $maskd (i64.add (i64.shr_u (local.get $maskd) (i64.const 1)) (i64.shl (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shr_u (local.get $maskc) (i64.const 1)) (i64.shl (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shr_u (local.get $maskb) (i64.const 1)) (i64.shl (local.get $maska) (i64.const 63))))\n        (local.set $maska (i64.shr_u (local.get $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n\n  ;; convert to signed\n  (if (local.get $sign)\n    (then\n      (local.set $aq (i64.xor (local.get $aq) (i64.const -1)))\n      (local.set $bq (i64.xor (local.get $bq) (i64.const -1)))\n      (local.set $cq (i64.xor (local.get $cq) (i64.const -1)))\n      (local.set $dq (i64.xor (local.get $dq) (i64.const -1)))\n\n      (local.set $dq (i64.add (local.get $dq) (i64.const 1)))\n      (local.set $cq (i64.add (local.get $cq) (i64.extend_i32_u (i64.eqz (local.get $dq)))))\n      (local.set $bq (i64.add (local.get $bq) (i64.extend_i32_u (i64.eqz (local.get $cq)))))\n      (local.set $aq (i64.add (local.get $aq) (i64.extend_i32_u (i64.eqz (local.get $bq)))))\n    )\n  )\n\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $aq))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $bq))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $cq))\n  (i64.store          (local.get $sp)                 (local.get $dq))\n)\n"
  },
  "SGT": {
    "wast": "(func $SGT\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n\n  ;; load args from the stack\n  (local.set $a0 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $a1 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $a2 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $a3 (i64.load (global.get $sp)))\n\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (local.set $b0 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $b2 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n  (local.set $b3 (i64.load (local.get $sp)))\n\n  (i64.store (local.get $sp) (i64.extend_i32_u\n    (i32.or  (i64.gt_s (local.get $a0) (local.get $b0)) ;; a0 > b0\n    (i32.and (i64.eq   (local.get $a0) (local.get $b0)) ;; a0 == a1\n    (i32.or  (i64.gt_u (local.get $a1) (local.get $b1)) ;; a1 > b1\n    (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n    (i32.or  (i64.gt_u (local.get $a2) (local.get $b2)) ;; a2 > b2\n    (i32.and (i64.eq   (local.get $a2) (local.get $b2)) ;; a2 == b2\n             (i64.gt_u (local.get $a3) (local.get $b3)))))))))) ;; a3 > b3\n\n  ;; zero  out the rest of the stack item\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (i64.const 0))\n)\n"
  },
  "SHA3": {
    "wast": "(func $SHA3\n  (local $dataOffset i32)\n  (local $dataOffset0 i64)\n  (local $dataOffset1 i64)\n  (local $dataOffset2 i64)\n  (local $dataOffset3 i64)\n\n  (local $length i32)\n  (local $length0 i64)\n  (local $length1 i64)\n  (local $length2 i64)\n  (local $length3 i64)\n\n  (local $contextOffset i32)\n  (local $outputOffset i32)\n\n  (local.set $length0 (i64.load (i32.sub (global.get $sp) (i32.const 32))))\n  (local.set $length1 (i64.load (i32.sub (global.get $sp) (i32.const 24))))\n  (local.set $length2 (i64.load (i32.sub (global.get $sp) (i32.const 16))))\n  (local.set $length3 (i64.load (i32.sub (global.get $sp) (i32.const 8))))\n\n  (local.set $dataOffset0 (i64.load (i32.add (global.get $sp) (i32.const 0))))\n  (local.set $dataOffset1 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n  (local.set $dataOffset2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $dataOffset3 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n\n  (local.set $length\n             (call $check_overflow (local.get $length0)\n                                   (local.get $length1)\n                                   (local.get $length2)\n                                   (local.get $length3)))\n  (local.set $dataOffset\n             (call $check_overflow (local.get $dataOffset0)\n                                   (local.get $dataOffset1)\n                                   (local.get $dataOffset2)\n                                   (local.get $dataOffset3)))\n\n  ;; charge copy fee ceil(words/32) * 6\n  (call $useGas (i64.extend_i32_u (i32.mul (i32.div_u (i32.add (local.get $length) (i32.const 31)) (i32.const 32)) (i32.const 6))))\n  (call $memusegas (local.get $dataOffset) (local.get $length))\n\n  (local.set $dataOffset (i32.add (global.get $memstart) (local.get $dataOffset)))\n\n  (local.set $contextOffset (i32.const 32808))\n  (local.set $outputOffset (i32.sub (global.get $sp) (i32.const 32)))\n\n  (call $keccak (local.get $contextOffset) (local.get $dataOffset) (local.get $length) (local.get $outputOffset))\n\n  (drop (call $bswap_m256 (local.get $outputOffset)))\n)\n"
  },
  "SHL": {
    "wast": "(func $SHL\n    (local $sp i32)\n    (local $x1 i64)\n    (local $x2 i64)\n    (local $x3 i64)\n    (local $x4 i64)\n    (local $y1 i64)\n    (local $y2 i64)\n    (local $y3 i64)\n    (local $y4 i64)\n\n    (local $z1 i64)\n    (local $z2 i64)\n    (local $z3 i64)\n    (local $z4 i64)\n    (local $t i64)\n    (local $r i64)\n\n    ;; load args from the stack\n    (local.set $x1 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n    (local.set $x2 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n    (local.set $x3 (i64.load (i32.add (global.get $sp) (i32.const 8))))\n    (local.set $x4 (i64.load (global.get $sp)))\n\n    (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n    (local.set $y1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n    (local.set $y2 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n    (local.set $y3 (i64.load (i32.add (local.get $sp) (i32.const 8))))\n    (local.set $y4 (i64.load (local.get $sp)))\n\n    (block\n        (if (i32.and (i64.eqz (local.get $x1)) (i64.eqz (local.get $x2))) (then\n            (if (i64.eqz (local.get $x3)) (then\n                (if (i64.eqz (local.get $x4))\n                    (then\n                        (local.set $z1 (local.get $y1))\n                        (local.set $z2 (local.get $y2))\n                        (local.set $z3 (local.get $y3))\n                        (local.set $z4 (local.get $y4))\n                    )\n                    (else\n                        (if (i64.lt_u (local.get $x4) (i64.const 256)) (then\n                            (if (i64.ge_u (local.get $x4) (i64.const 128)) (then\n                                (local.set $y1 (local.get $y3))\n                                (local.set $y2 (local.get $y4))\n                                (local.set $y3 (i64.const 0))\n                                (local.set $y4 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 128)))\n                            ))\n                            (if (i64.ge_u (local.get $x4) (i64.const 64)) (then\n                                (local.set $y1 (local.get $y2))\n                                (local.set $y2 (local.get $y3))\n                                (local.set $y3 (local.get $y4))\n                                (local.set $y4 (i64.const 0))\n                                (local.set $x4 (i64.sub (local.get $x4) (i64.const 64)))\n                            ))\n                            (nop)\n                            (block\n                                (local.set $t (call $shl_single (local.get $y4) (local.get $x4)))\n                                (local.set $z4 (global.get $global_))\n\n                            )\n                            (block\n                                (local.set $r (call $shl_single (local.get $y3) (local.get $x4)))\n                                (local.set $z3 (global.get $global_))\n\n                            )\n                            (local.set $z3 (i64.or (local.get $z3) (local.get $t)))\n                            (block\n                                (local.set $t (call $shl_single (local.get $y2) (local.get $x4)))\n                                (local.set $z2 (global.get $global_))\n\n                            )\n                            (local.set $z2 (i64.or (local.get $z2) (local.get $r)))\n                            (block\n                                (local.set $r (call $shl_single (local.get $y1) (local.get $x4)))\n                                (local.set $z1 (global.get $global_))\n\n                            )\n                            (local.set $z1 (i64.or (local.get $z1) (local.get $t)))\n                        ))\n                    )\n                )\n            ))\n        ))\n\n    )\n    (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $z1))\n    (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $z2))\n    (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $z3))\n    (i64.store          (local.get $sp)                 (local.get $z4))\n)\n\n(func $shl_single\n    (param $a i64)\n    (param $amount i64)\n    (result i64)\n    (local $x i64)\n    (local $y i64)\n    (block\n        (local.set $x (i64.shr_u (local.get $a) (i64.sub (i64.const 64) (local.get $amount))))\n        (local.set $y (i64.shl (local.get $a) (local.get $amount)))\n\n    )\n    (global.set $global_ (local.get $y))\n    (local.get $x)\n)\n"
  },
  "SIGNEXTEND": {
    "wast": "(func $SIGNEXTEND\n  (local $sp i32)\n\n  (local $a0 i64)\n  (local $a1 i64)\n  (local $a2 i64)\n  (local $a3 i64)\n\n  (local $b0 i64)\n  (local $b1 i64)\n  (local $b2 i64)\n  (local $b3 i64)\n  (local $sign i64)\n  (local $t i32)\n  (local $end i32)\n\n  (local.set $a0 (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $a1 (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $a2 (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $a3 (i64.load          (global.get $sp)))\n\n  (local.set $end (global.get $sp))\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (if (i32.and\n        (i32.and\n          (i32.and\n            (i64.lt_u (local.get $a3) (i64.const 32))\n            (i64.eqz (local.get $a2)))\n          (i64.eqz (local.get $a1)))\n        (i64.eqz (local.get $a0)))\n    (then\n      (local.set $t (i32.add (i32.wrap_i64 (local.get $a3)) (local.get $sp)))\n      (local.set $sign (i64.shr_s (i64.load8_s (local.get $t)) (i64.const 8)))\n      (local.set $t (i32.add (local.get $t) (i32.const 1)))\n      (block $done\n        (loop $loop\n          (if (i32.lt_u (local.get $end) (local.get $t))\n            (br $done)\n          )\n          (i64.store (local.get $t) (local.get $sign))\n          (local.set $t (i32.add (local.get $t) (i32.const 8)))\n          (br $loop)\n        )\n      )\n    )\n  )\n)\n\n"
  },
  "SMOD": {
    "wast": "(func $SMOD\n  (local $sp i32)\n  ;; dividend\n  (local $a i64)\n  (local $b i64)\n  (local $c i64)\n  (local $d i64)\n\n  ;; divisor\n  (local $a1 i64)\n  (local $b1 i64)\n  (local $c1 i64)\n  (local $d1 i64)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $carry i32)\n  (local $sign i32)\n  (local $temp  i64)\n  (local $temp2  i64)\n\n  ;; load args from the stack\n  (local.set $a (i64.load (i32.add (global.get $sp) (i32.const 24))))\n  (local.set $b (i64.load (i32.add (global.get $sp) (i32.const 16))))\n  (local.set $c (i64.load (i32.add (global.get $sp) (i32.const  8))))\n  (local.set $d (i64.load          (global.get $sp)))\n  ;; decement the stack pointer\n  (local.set $sp (i32.sub (global.get $sp) (i32.const 32)))\n\n  (local.set $a1 (i64.load (i32.add (local.get $sp) (i32.const 24))))\n  (local.set $b1 (i64.load (i32.add (local.get $sp) (i32.const 16))))\n  (local.set $c1 (i64.load (i32.add (local.get $sp) (i32.const  8))))\n  (local.set $d1 (i64.load          (local.get $sp)))\n\n  (local.set $maskd (i64.const 1))\n  (local.set $sign (i32.wrap_i64 (i64.shr_u (local.get $d) (i64.const 63))))\n\n  ;; convert to unsigned value\n  (if (i64.eqz (i64.clz (local.get $a)))\n    (then\n      (local.set $a (i64.xor (local.get $a) (i64.const -1)))\n      (local.set $b (i64.xor (local.get $b) (i64.const -1)))\n      (local.set $c (i64.xor (local.get $c) (i64.const -1)))\n      (local.set $d (i64.xor (local.get $d) (i64.const -1)))\n\n      ;; a = a + 1\n      (local.set $d (i64.add (local.get $d) (i64.const 1)))\n      (local.set $carry (i64.eqz (local.get $d)))\n      (local.set $c (i64.add (local.get $c) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $c)) (local.get $carry)))\n      (local.set $b (i64.add (local.get $b) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $b)) (local.get $carry)))\n      (local.set $a (i64.add (local.get $a) (i64.extend_i32_u (local.get $carry))))\n    )\n  )\n\n  (if (i64.eqz (i64.clz (local.get $a1)))\n    (then\n      (local.set $a1 (i64.xor (local.get $a1) (i64.const -1)))\n      (local.set $b1 (i64.xor (local.get $b1) (i64.const -1)))\n      (local.set $c1 (i64.xor (local.get $c1) (i64.const -1)))\n      (local.set $d1 (i64.xor (local.get $d1) (i64.const -1)))\n\n      (local.set $d1 (i64.add (local.get $d1) (i64.const 1)))\n      (local.set $carry (i64.eqz (local.get $d1)))\n      (local.set $c1 (i64.add (local.get $c1) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $c1)) (local.get $carry)))\n      (local.set $b1 (i64.add (local.get $b1) (i64.extend_i32_u (local.get $carry))))\n      (local.set $carry (i32.and (i64.eqz (local.get $b1)) (local.get $carry)))\n      (local.set $a1 (i64.add (local.get $a1) (i64.extend_i32_u (local.get $carry))))\n    )\n  )\n\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n      (then\n        (local.set $a (i64.const 0))\n        (local.set $b (i64.const 0))\n        (local.set $c (i64.const 0))\n        (local.set $d (i64.const 0))\n        (br $main)\n      )\n    )\n\n    ;; align bits\n    (block $done\n      (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (local.get $a1))) (call $gte_256 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $a) (local.get $b) (local.get $c) (local.get $d)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (local.set $a1 (i64.add (i64.shl (local.get $a1) (i64.const 1)) (i64.shr_u (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shl (local.get $b1) (i64.const 1)) (i64.shr_u (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shl (local.get $c1) (i64.const 1)) (i64.shr_u (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.shl (local.get $d1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (local.set $maska (i64.add (i64.shl (local.get $maska) (i64.const 1)) (i64.shr_u (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shl (local.get $maskb) (i64.const 1)) (i64.shr_u (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shl (local.get $maskc) (i64.const 1)) (i64.shr_u (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.shl (local.get $maskd) (i64.const 1)))\n\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_256 (local.get $maska) (local.get $maskb) (local.get $maskc) (local.get $maskd))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_256 (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1))\n          (then\n            ;; dividend = dividend - divisor\n            (local.set $carry (i64.lt_u (local.get $d) (local.get $d1)))\n            (local.set $d     (i64.sub  (local.get $d) (local.get $d1)))\n            (local.set $temp  (i64.sub  (local.get $c) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $c)))\n            (local.set $c     (i64.sub  (local.get $temp) (local.get $c1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $c) (local.get $temp)) (local.get $carry)))\n            (local.set $temp  (i64.sub  (local.get $b) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $b)))\n            (local.set $b     (i64.sub  (local.get $temp) (local.get $b1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $b) (local.get $temp)) (local.get $carry)))\n            (local.set $a     (i64.sub  (i64.sub (local.get $a) (i64.extend_i32_u (local.get $carry))) (local.get $a1)))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (local.set $d1 (i64.add (i64.shr_u (local.get $d1) (i64.const 1)) (i64.shl (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shr_u (local.get $c1) (i64.const 1)) (i64.shl (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shr_u (local.get $b1) (i64.const 1)) (i64.shl (local.get $a1) (i64.const 63))))\n        (local.set $a1 (i64.shr_u (local.get $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (local.set $maskd (i64.add (i64.shr_u (local.get $maskd) (i64.const 1)) (i64.shl (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shr_u (local.get $maskc) (i64.const 1)) (i64.shl (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shr_u (local.get $maskb) (i64.const 1)) (i64.shl (local.get $maska) (i64.const 63))))\n        (local.set $maska (i64.shr_u (local.get $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  )\n\n  ;; convert to signed\n  (if (local.get $sign)\n    (then\n      (local.set $a (i64.xor (local.get $a) (i64.const -1)))\n      (local.set $b (i64.xor (local.get $b) (i64.const -1)))\n      (local.set $c (i64.xor (local.get $c) (i64.const -1)))\n      (local.set $d (i64.xor (local.get $d) (i64.const -1)))\n\n      (local.set $d (i64.add (local.get $d) (i64.const 1)))\n      (local.set $c (i64.add (local.get $c) (i64.extend_i32_u (i64.eqz (local.get $d)))))\n      (local.set $b (i64.add (local.get $b) (i64.extend_i32_u (i64.eqz (local.get $c)))))\n      (local.set $a (i64.add (local.get $a) (i64.extend_i32_u (i64.eqz (local.get $b)))))\n    )\n  )\n\n  ;; save the stack\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $a))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $b))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (local.get $c))\n  (i64.store          (local.get $sp)                 (local.get $d))\n) ;; end for SMOD\n"
  },
  "XOR": {
    "wast": "(func $XOR\n  (i64.store (i32.sub (global.get $sp) (i32.const  8)) (i64.xor (i64.load (i32.sub (global.get $sp) (i32.const  8))) (i64.load (i32.add (global.get $sp) (i32.const 24)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 16)) (i64.xor (i64.load (i32.sub (global.get $sp) (i32.const 16))) (i64.load (i32.add (global.get $sp) (i32.const 16)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 24)) (i64.xor (i64.load (i32.sub (global.get $sp) (i32.const 24))) (i64.load (i32.add (global.get $sp) (i32.const  8)))))\n  (i64.store (i32.sub (global.get $sp) (i32.const 32)) (i64.xor (i64.load (i32.sub (global.get $sp) (i32.const 32))) (i64.load (i32.add (global.get $sp) (i32.const  0)))))\n)\n"
  },
  "bswap_i32": {
    "wast": "(func $bswap_i32\n  (param $int i32)\n  (result i32)\n\n  (i32.or\n    (i32.or\n      (i32.and (i32.shr_u (local.get $int) (i32.const 24)) (i32.const 0xff)) ;; 7 -> 0\n      (i32.and (i32.shr_u (local.get $int) (i32.const 8)) (i32.const 0xff00))) ;; 6 -> 1\n    (i32.or\n      (i32.and (i32.shl (local.get $int) (i32.const 8)) (i32.const 0xff0000)) ;; 5 -> 2\n      (i32.and (i32.shl (local.get $int) (i32.const 24)) (i32.const 0xff000000)))) ;; 4 -> 3\n)\n"
  },
  "bswap_i64": {
    "wast": "(func $bswap_i64\n  (param $int i64)\n  (result i64)\n\n  (i64.or\n    (i64.or\n      (i64.or\n        (i64.and (i64.shr_u (local.get $int) (i64.const 56)) (i64.const 0xff)) ;; 7 -> 0\n        (i64.and (i64.shr_u (local.get $int) (i64.const 40)) (i64.const 0xff00))) ;; 6 -> 1\n      (i64.or\n        (i64.and (i64.shr_u (local.get $int) (i64.const 24)) (i64.const 0xff0000)) ;; 5 -> 2\n        (i64.and (i64.shr_u (local.get $int) (i64.const  8)) (i64.const 0xff000000)))) ;; 4 -> 3\n    (i64.or\n      (i64.or\n        (i64.and (i64.shl (local.get $int) (i64.const 8))   (i64.const 0xff00000000)) ;; 3 -> 4\n        (i64.and (i64.shl (local.get $int) (i64.const 24))   (i64.const 0xff0000000000))) ;; 2 -> 5\n      (i64.or\n        (i64.and (i64.shl (local.get $int) (i64.const 40))   (i64.const 0xff000000000000)) ;; 1 -> 6\n        (i64.and (i64.shl (local.get $int) (i64.const 56))   (i64.const 0xff00000000000000))))) ;; 0 -> 7\n)\n"
  },
  "bswap_m128": {
    "wast": "(func $bswap_m128\n  (param $sp i32)\n  (result i32)\n  (local $temp i64)\n\n  (local.set $temp (call $bswap_i64 (i64.load (local.get $sp))))\n  (i64.store (local.get $sp) (call $bswap_i64 (i64.load (i32.add (local.get $sp) (i32.const 8)))))\n  (i64.store (i32.add (local.get $sp) (i32.const 8)) (local.get $temp))\n  (local.get $sp)\n)\n"
  },
  "bswap_m160": {
    "wast": "(func $bswap_m160\n  (param $sp i32)\n  (result i32)\n  (local $temp i64)\n\n  (local.set $temp (call $bswap_i64 (i64.load (local.get $sp))))\n  (i64.store (local.get $sp) (call $bswap_i64 (i64.load (i32.add (local.get $sp) (i32.const 12)))))\n  (i64.store (i32.add (local.get $sp) (i32.const 12)) (local.get $temp))\n\n  (i32.store (i32.add (local.get $sp) (i32.const 8)) (call $bswap_i32 (i32.load (i32.add (local.get $sp) (i32.const 8)))))\n  (local.get $sp)\n)\n"
  },
  "bswap_m256": {
    "wast": "(func $bswap_m256\n  (param $sp i32)\n  (result i32)\n  (local $temp i64)\n\n  (local.set $temp (call $bswap_i64 (i64.load (local.get $sp))))\n  (i64.store (local.get $sp) (call $bswap_i64 (i64.load (i32.add (local.get $sp) (i32.const 24)))))\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $temp))\n\n  (local.set $temp (call $bswap_i64 (i64.load (i32.add (local.get $sp) (i32.const 8)))))\n  (i64.store (i32.add (local.get $sp) (i32.const  8)) (call $bswap_i64 (i64.load (i32.add (local.get $sp) (i32.const 16)))))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $temp))\n  (local.get $sp)\n)\n"
  },
  "callback": {
    "wast": "(func $callback\n  (call $main)\n)\n"
  },
  "callback_128": {
    "wast": "(func $callback_128\n  (param $result i32)\n\n  (drop (call $bswap_m128 (global.get $sp)))\n  (call $main)\n)\n"
  },
  "callback_160": {
    "wast": "(func $callback_160\n  (param $result i32)\n\n  (drop (call $bswap_m160 (global.get $sp)))\n  (call $main)\n)\n"
  },
  "callback_256": {
    "wast": "(func $callback_256\n  (param $result i32)\n\n  (drop (call $bswap_m256 (global.get $sp)))\n  (call $main)\n)\n"
  },
  "callback_32": {
    "wast": "(func $callback_32\n  (param $result i32)\n\n  (i64.store (global.get $sp) (i64.extend_i32_u (local.get $result)))\n  ;; zero out mem\n  (i64.store (i32.add (global.get $sp) (i32.const 24)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const 16)) (i64.const 0))\n  (i64.store (i32.add (global.get $sp) (i32.const 8)) (i64.const 0))\n\n  (call $main)\n)\n"
  },
  "check_overflow_i64": {
    "wast": "(func $check_overflow_i64\n  (param $a i64)\n  (param $b i64)\n  (param $c i64)\n  (param $d i64)\n  (result i64)\n\n  (if\n    (i32.and \n      (i32.and \n        (i64.eqz  (local.get $d))\n        (i64.eqz  (local.get $c)))\n      (i64.eqz  (local.get $b)))\n    (return (local.get $a)))\n\n    (return (i64.const 0xffffffffffffffff))\n)\n"
  },
  "gte_256": {
    "wast": ";; is a less than or equal to b // a >= b\n(func $gte_256\n  (param $a0 i64)\n  (param $a1 i64)\n  (param $a2 i64)\n  (param $a3 i64)\n\n  (param $b0 i64)\n  (param $b1 i64)\n  (param $b2 i64)\n  (param $b3 i64)\n\n  (result i32)\n\n  ;; a0 > b0 || [a0 == b0 && [a1 > b1 || [a1 == b1 && [a2 > b2 || [a2 == b2 && a3 >= b3 ]]]]\n  (i32.or  (i64.gt_u (local.get $a0) (local.get $b0)) ;; a0 > b0\n  (i32.and (i64.eq   (local.get $a0) (local.get $b0))\n  (i32.or  (i64.gt_u (local.get $a1) (local.get $b1)) ;; a1 > b1\n  (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n  (i32.or  (i64.gt_u (local.get $a2) (local.get $b2)) ;; a2 > b2\n  (i32.and (i64.eq   (local.get $a2) (local.get $b2))\n           (i64.ge_u (local.get $a3) (local.get $b3))))))))\n)\n"
  },
  "gte_320": {
    "wast": "(func $gte_320\n  (param $a0 i64)\n  (param $a1 i64)\n  (param $a2 i64)\n  (param $a3 i64)\n  (param $a4 i64)\n\n  (param $b0 i64)\n  (param $b1 i64)\n  (param $b2 i64)\n  (param $b3 i64)\n  (param $b4 i64)\n\n  (result i32)\n\n  ;; a0 > b0 || [a0 == b0 && [a1 > b1 || [a1 == b1 && [a2 > b2 || [a2 == b2 && a3 >= b3 ]]]]\n  (i32.or  (i64.gt_u (local.get $a0) (local.get $b0)) ;; a0 > b0\n  (i32.and (i64.eq   (local.get $a0) (local.get $b0))\n  (i32.or  (i64.gt_u (local.get $a1) (local.get $b1)) ;; a1 > b1\n  (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n  (i32.or  (i64.gt_u (local.get $a2) (local.get $b2)) ;; a2 > b2\n  (i32.and (i64.eq   (local.get $a2) (local.get $b2))\n  (i32.or  (i64.gt_u (local.get $a3) (local.get $b3)) ;; a2 > b2\n  (i32.and (i64.eq   (local.get $a3) (local.get $b3))\n           (i64.ge_u (local.get $a4) (local.get $b4))))))))))\n)\n"
  },
  "gte_512": {
    "wast": "(func $gte_512\n  (param $a0 i64)\n  (param $a1 i64)\n  (param $a2 i64)\n  (param $a3 i64)\n  (param $a4 i64)\n  (param $a5 i64)\n  (param $a6 i64)\n  (param $a7 i64)\n\n  (param $b0 i64)\n  (param $b1 i64)\n  (param $b2 i64)\n  (param $b3 i64)\n  (param $b4 i64)\n  (param $b5 i64)\n  (param $b6 i64)\n  (param $b7 i64)\n\n  (result i32)\n\n  ;; a0 > b0 || [a0 == b0 && [a1 > b1 || [a1 == b1 && [a2 > b2 || [a2 == b2 && a3 >= b3 ]]]]\n  (i32.or  (i64.gt_u (local.get $a0) (local.get $b0)) ;; a0 > b0\n  (i32.and (i64.eq   (local.get $a0) (local.get $b0))\n  (i32.or  (i64.gt_u (local.get $a1) (local.get $b1)) ;; a1 > b1\n  (i32.and (i64.eq   (local.get $a1) (local.get $b1)) ;; a1 == b1\n  (i32.or  (i64.gt_u (local.get $a2) (local.get $b2)) ;; a2 > b2\n  (i32.and (i64.eq   (local.get $a2) (local.get $b2))\n  (i32.or  (i64.gt_u (local.get $a3) (local.get $b3)) ;; a3 > b3\n  (i32.and (i64.eq   (local.get $a3) (local.get $b3))\n  (i32.or  (i64.gt_u (local.get $a4) (local.get $b4)) ;; a4 > b4\n  (i32.and (i64.eq   (local.get $a4) (local.get $b4))\n  (i32.or  (i64.gt_u (local.get $a5) (local.get $b5)) ;; a5 > b5\n  (i32.and (i64.eq   (local.get $a5) (local.get $b5))\n  (i32.or  (i64.gt_u (local.get $a6) (local.get $b6)) ;; a6 > b6\n  (i32.and (i64.eq   (local.get $a6) (local.get $b6))\n           (i64.ge_u (local.get $a7) (local.get $b7))))))))))))))))\n)\n"
  },
  "iszero_256": {
    "wast": "(func $iszero_256\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (result i32)\n\n  (i64.eqz (i64.or (i64.or (i64.or (local.get 0) (local.get 1)) (local.get 2)) (local.get 3))) \n)\n"
  },
  "iszero_320": {
    "wast": "(func $iszero_320\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (result i32)\n\n  (i64.eqz (i64.or (i64.or (i64.or (i64.or (local.get 0) (local.get 1)) (local.get 2)) (local.get 3)) (local.get 4)))\n)\n"
  },
  "iszero_512": {
    "wast": "(func $iszero_512\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (param i64)\n  (result i32)\n  (i64.eqz (i64.or (i64.or (i64.or (i64.or (i64.or (i64.or (i64.or (local.get 0) (local.get 1)) (local.get 2)) (local.get 3)) (local.get 4)) (local.get 5)) (local.get 6)) (local.get 7)))\n)\n"
  },
  "keccak": {
    "wast": ";;\n;; Copied from https://github.com/axic/keccak-wasm (has more comments)\n;;\n\n(func $keccak_theta\n  (param $context_offset i32)\n\n  (local $C0 i64)\n  (local $C1 i64)\n  (local $C2 i64)\n  (local $C3 i64)\n  (local $C4 i64)\n  (local $D0 i64)\n  (local $D1 i64)\n  (local $D2 i64)\n  (local $D3 i64)\n  (local $D4 i64)\n\n  ;; C[x] = A[x] ^ A[x + 5] ^ A[x + 10] ^ A[x + 15] ^ A[x + 20];\n  (local.set $C0\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 0)))\n      (i64.xor\n        (i64.load (i32.add (local.get $context_offset) (i32.const 40)))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.const 80)))\n          (i64.xor\n            (i64.load (i32.add (local.get $context_offset) (i32.const 120)))\n            (i64.load (i32.add (local.get $context_offset) (i32.const 160)))\n          )\n        )\n      )\n    )\n  )\n\n  (local.set $C1\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 8)))\n      (i64.xor\n        (i64.load (i32.add (local.get $context_offset) (i32.const 48)))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.const 88)))\n          (i64.xor\n            (i64.load (i32.add (local.get $context_offset) (i32.const 128)))\n            (i64.load (i32.add (local.get $context_offset) (i32.const 168)))\n          )\n        )\n      )\n    )\n  )\n\n  (local.set $C2\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 16)))\n      (i64.xor\n        (i64.load (i32.add (local.get $context_offset) (i32.const 56)))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.const 96)))\n          (i64.xor\n            (i64.load (i32.add (local.get $context_offset) (i32.const 136)))\n            (i64.load (i32.add (local.get $context_offset) (i32.const 176)))\n          )\n        )\n      )\n    )\n  )\n\n  (local.set $C3\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 24)))\n      (i64.xor\n        (i64.load (i32.add (local.get $context_offset) (i32.const 64)))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.const 104)))\n          (i64.xor\n            (i64.load (i32.add (local.get $context_offset) (i32.const 144)))\n            (i64.load (i32.add (local.get $context_offset) (i32.const 184)))\n          )\n        )\n      )\n    )\n  )\n\n  (local.set $C4\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 32)))\n      (i64.xor\n        (i64.load (i32.add (local.get $context_offset) (i32.const 72)))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.const 112)))\n          (i64.xor\n            (i64.load (i32.add (local.get $context_offset) (i32.const 152)))\n            (i64.load (i32.add (local.get $context_offset) (i32.const 192)))\n          )\n        )\n      )\n    )\n  )\n\n  ;; D[0] = ROTL64(C[1], 1) ^ C[4];\n  (local.set $D0\n    (i64.xor\n      (local.get $C4)\n      (i64.rotl\n        (local.get $C1)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; D[1] = ROTL64(C[2], 1) ^ C[0];\n  (local.set $D1\n    (i64.xor\n      (local.get $C0)\n      (i64.rotl\n        (local.get $C2)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; D[2] = ROTL64(C[3], 1) ^ C[1];\n  (local.set $D2\n    (i64.xor\n      (local.get $C1)\n      (i64.rotl\n        (local.get $C3)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; D[3] = ROTL64(C[4], 1) ^ C[2];\n  (local.set $D3\n    (i64.xor\n      (local.get $C2)\n      (i64.rotl\n        (local.get $C4)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; D[4] = ROTL64(C[0], 1) ^ C[3];\n  (local.set $D4\n    (i64.xor\n      (local.get $C3)\n      (i64.rotl\n        (local.get $C0)\n        (i64.const 1)\n      )\n    )\n  )\n\n  ;; A[x]      ^= D[x];\n  ;; A[x + 5]  ^= D[x];\n  ;; A[x + 10] ^= D[x];\n  ;; A[x + 15] ^= D[x];\n  ;; A[x + 20] ^= D[x];\n  \n  ;; x = 0\n  (i64.store (i32.add (local.get $context_offset) (i32.const 0))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 0)))\n      (local.get $D0)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 40))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 40)))\n      (local.get $D0)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 80))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 80)))\n      (local.get $D0)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 120))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 120)))\n      (local.get $D0)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 160))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 160)))\n      (local.get $D0)\n    )\n  )\n\n  ;; x = 1\n  (i64.store (i32.add (local.get $context_offset) (i32.const 8))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 8)))\n      (local.get $D1)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 48))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 48)))\n      (local.get $D1)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 88))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 88)))\n      (local.get $D1)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 128))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 128)))\n      (local.get $D1)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 168))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 168)))\n      (local.get $D1)\n    )\n  )\n\n  ;; x = 2\n  (i64.store (i32.add (local.get $context_offset) (i32.const 16))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 16)))\n      (local.get $D2)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 56))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 56)))\n      (local.get $D2)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 96))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 96)))\n      (local.get $D2)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 136))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 136)))\n      (local.get $D2)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 176))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 176)))\n      (local.get $D2)\n    )\n  )\n\n  ;; x = 3\n  (i64.store (i32.add (local.get $context_offset) (i32.const 24))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 24)))\n      (local.get $D3)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 64))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 64)))\n      (local.get $D3)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 104))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 104)))\n      (local.get $D3)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 144))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 144)))\n      (local.get $D3)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 184))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 184)))\n      (local.get $D3)\n    )\n  )\n\n  ;; x = 4\n  (i64.store (i32.add (local.get $context_offset) (i32.const 32))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 32)))\n      (local.get $D4)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 72))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 72)))\n      (local.get $D4)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 112))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 112)))\n      (local.get $D4)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 152))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 152)))\n      (local.get $D4)\n    )\n  )\n\n  (i64.store (i32.add (local.get $context_offset) (i32.const 192))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 192)))\n      (local.get $D4)\n    )\n  )\n)\n\n(func $keccak_rho\n  (param $context_offset i32)\n  (param $rotation_consts i32)\n\n  ;;(local $tmp i32)\n\n  ;; state[ 1] = ROTL64(state[ 1],  1);\n  ;;(local.set $tmp (i32.add (local.get $context_offset) (i32.const 1)))\n  ;;(i64.store (local.get $tmp) (i64.rotl (i64.load (local.get $context_offset)) (i64.const 1)))\n\n  ;;(local.set $tmp (i32.add (local.get $context_offset) (i32.const 2)))\n  ;;(i64.store (local.get $tmp) (i64.rotl (i64.load (local.get $context_offset)) (i64.const 62)))\n\n  (local $tmp i32)\n  (local $i i32)\n\n  ;; for (i = 0; i <= 24; i++)\n  (local.set $i (i32.const 0))\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (local.get $i) (i32.const 24))\n        (br $done)\n      )\n\n      (local.set $tmp (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (i32.const 1) (local.get $i)))))\n\n      (i64.store (local.get $tmp) (i64.rotl (i64.load (local.get $tmp)) (i64.load8_u (i32.add (local.get $rotation_consts) (local.get $i)))))\n\n      (local.set $i (i32.add (local.get $i) (i32.const 1)))\n      (br $loop)\n    )\n  )\n)\n\n(func $keccak_pi\n  (param $context_offset i32)\n\n  (local $A1 i64)\n  (local.set $A1 (i64.load (i32.add (local.get $context_offset) (i32.const 8))))\n\n  ;; Swap non-overlapping fields, i.e. $A1 = $A6, etc.\n  ;; NOTE: $A0 is untouched\n  (i64.store (i32.add (local.get $context_offset) (i32.const 8)) (i64.load (i32.add (local.get $context_offset) (i32.const 48))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 48)) (i64.load (i32.add (local.get $context_offset) (i32.const 72))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 72)) (i64.load (i32.add (local.get $context_offset) (i32.const 176))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 176)) (i64.load (i32.add (local.get $context_offset) (i32.const 112))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 112)) (i64.load (i32.add (local.get $context_offset) (i32.const 160))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 160)) (i64.load (i32.add (local.get $context_offset) (i32.const 16))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 16)) (i64.load (i32.add (local.get $context_offset) (i32.const 96))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 96)) (i64.load (i32.add (local.get $context_offset) (i32.const 104))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 104)) (i64.load (i32.add (local.get $context_offset) (i32.const 152))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 152)) (i64.load (i32.add (local.get $context_offset) (i32.const 184))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 184)) (i64.load (i32.add (local.get $context_offset) (i32.const 120))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 120)) (i64.load (i32.add (local.get $context_offset) (i32.const 32))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 32)) (i64.load (i32.add (local.get $context_offset) (i32.const 192))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 192)) (i64.load (i32.add (local.get $context_offset) (i32.const 168))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 168)) (i64.load (i32.add (local.get $context_offset) (i32.const 64))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 64)) (i64.load (i32.add (local.get $context_offset) (i32.const 128))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 128)) (i64.load (i32.add (local.get $context_offset) (i32.const 40))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 40)) (i64.load (i32.add (local.get $context_offset) (i32.const 24))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 24)) (i64.load (i32.add (local.get $context_offset) (i32.const 144))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 144)) (i64.load (i32.add (local.get $context_offset) (i32.const 136))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 136)) (i64.load (i32.add (local.get $context_offset) (i32.const 88))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 88)) (i64.load (i32.add (local.get $context_offset) (i32.const 56))))\n  (i64.store (i32.add (local.get $context_offset) (i32.const 56)) (i64.load (i32.add (local.get $context_offset) (i32.const 80))))\n\n  ;; Place the previously saved overlapping field\n  (i64.store (i32.add (local.get $context_offset) (i32.const 80)) (local.get $A1))\n)\n\n(func $keccak_chi\n  (param $context_offset i32)\n\n  (local $A0 i64)\n  (local $A1 i64)\n  (local $i i32)\n\n  ;; for (round = 0; round < 25; i += 5)\n  (local.set $i (i32.const 0))\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (local.get $i) (i32.const 25))\n        (br $done)\n      )\n\n      (local.set $A0 (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (local.get $i)))))\n      (local.set $A1 (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 1))))))\n\n      ;; A[0 + i] ^= ~A1 & A[2 + i];\n      (i64.store (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (local.get $i)))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (local.get $i))))\n          (i64.and\n            (i64.xor (local.get $A1) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 2)))))\n          )\n        )\n      )\n\n      ;; A[1 + i] ^= ~A[2 + i] & A[3 + i];\n      (i64.store (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 1))))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 1)))))\n          (i64.and\n            (i64.xor (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 2))))) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 3)))))\n          )\n        )\n      )\n\n      ;; A[2 + i] ^= ~A[3 + i] & A[4 + i];\n      (i64.store (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 2))))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 2)))))\n          (i64.and\n            (i64.xor (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 3))))) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 4)))))\n          )\n        )\n      )\n\n      ;; A[3 + i] ^= ~A[4 + i] & A0;\n      (i64.store (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 3))))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 3)))))\n          (i64.and\n            (i64.xor (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 4))))) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (local.get $A0)\n          )\n        )\n      )\n\n      ;; A[4 + i] ^= ~A0 & A1;\n      (i64.store (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 4))))\n        (i64.xor\n          (i64.load (i32.add (local.get $context_offset) (i32.mul (i32.const 8) (i32.add (local.get $i) (i32.const 4)))))\n          (i64.and\n            (i64.xor (local.get $A0) (i64.const 0xFFFFFFFFFFFFFFFF)) ;; bitwise not\n            (local.get $A1)\n          )\n        )\n      )\n\n      (local.set $i (i32.add (local.get $i) (i32.const 5)))\n      (br $loop)\n    )\n  )\n)\n\n(func $keccak_permute\n  (param $context_offset i32)\n\n  (local $rotation_consts i32)\n  (local $round_consts i32)\n  (local $round i32)\n\n  (local.set $round_consts (i32.add (local.get $context_offset) (i32.const 400)))\n  (local.set $rotation_consts (i32.add (local.get $context_offset) (i32.const 592)))\n\n  ;; for (round = 0; round < 24; round++)\n  (local.set $round (i32.const 0))\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (local.get $round) (i32.const 24))\n        (br $done)\n      )\n\n      ;; theta transform\n      (call $keccak_theta (local.get $context_offset))\n\n      ;; rho transform\n      (call $keccak_rho (local.get $context_offset) (local.get $rotation_consts))\n\n      ;; pi transform\n      (call $keccak_pi (local.get $context_offset))\n\n      ;; chi transform\n      (call $keccak_chi (local.get $context_offset))\n\n      ;; iota transform\n      ;; context_offset[0] ^= KECCAK_ROUND_CONSTANTS[round];\n      (i64.store (local.get $context_offset)\n        (i64.xor\n          (i64.load (local.get $context_offset))\n          (i64.load (i32.add (local.get $round_consts) (i32.mul (i32.const 8) (local.get $round))))\n        )\n      )\n\n      (local.set $round (i32.add (local.get $round) (i32.const 1)))\n      (br $loop)\n    )  \n  ) \n)\n\n(func $keccak_block\n  (param $input_offset i32)\n  (param $input_length i32) ;; ignored, we expect keccak256\n  (param $context_offset i32)\n\n  ;; read blocks in little-endian order and XOR against context_offset\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 0))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 0)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 0)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 8))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 8)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 8)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 16))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 16)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 16)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 24))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 24)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 24)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 32))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 32)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 32)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 40))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 40)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 40)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 48))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 48)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 48)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 56))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 56)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 56)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 64))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 64)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 64)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 72))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 72)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 72)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 80))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 80)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 80)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 88))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 88)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 88)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 96))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 96)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 96)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 104))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 104)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 104)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 112))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 112)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 112)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 120))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 120)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 120)))\n    )\n  )\n\n  (i64.store\n    (i32.add (local.get $context_offset) (i32.const 128))\n    (i64.xor\n      (i64.load (i32.add (local.get $context_offset) (i32.const 128)))\n      (i64.load (i32.add (local.get $input_offset) (i32.const 128)))\n    )\n  )\n  \n  (call $keccak_permute (local.get $context_offset))\n)\n\n;;\n;; Initialise the context\n;;\n(func $keccak_init\n  (param $context_offset i32)\n  (local $round_consts i32)\n  (local $rotation_consts i32)\n\n  (call $keccak_reset (local.get $context_offset))\n\n  ;; insert the round constants (used by $KECCAK_IOTA)\n  (local.set $round_consts (i32.add (local.get $context_offset) (i32.const 400)))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 0)) (i64.const 0x0000000000000001))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 8)) (i64.const 0x0000000000008082))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 16)) (i64.const 0x800000000000808A))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 24)) (i64.const 0x8000000080008000))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 32)) (i64.const 0x000000000000808B))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 40)) (i64.const 0x0000000080000001))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 48)) (i64.const 0x8000000080008081))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 56)) (i64.const 0x8000000000008009))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 64)) (i64.const 0x000000000000008A))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 72)) (i64.const 0x0000000000000088))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 80)) (i64.const 0x0000000080008009))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 88)) (i64.const 0x000000008000000A))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 96)) (i64.const 0x000000008000808B))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 104)) (i64.const 0x800000000000008B))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 112)) (i64.const 0x8000000000008089))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 120)) (i64.const 0x8000000000008003))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 128)) (i64.const 0x8000000000008002))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 136)) (i64.const 0x8000000000000080))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 144)) (i64.const 0x000000000000800A))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 152)) (i64.const 0x800000008000000A))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 160)) (i64.const 0x8000000080008081))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 168)) (i64.const 0x8000000000008080))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 176)) (i64.const 0x0000000080000001))\n  (i64.store (i32.add (local.get $round_consts) (i32.const 184)) (i64.const 0x8000000080008008))\n\n  ;; insert the rotation constants (used by $keccak_rho)\n  (local.set $rotation_consts (i32.add (local.get $context_offset) (i32.const 592)))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 0)) (i32.const 1))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 1)) (i32.const 62))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 2)) (i32.const 28))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 3)) (i32.const 27))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 4)) (i32.const 36))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 5)) (i32.const 44))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 6)) (i32.const 6))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 7)) (i32.const 55))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 8)) (i32.const 20))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 9)) (i32.const 3))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 10)) (i32.const 10))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 11)) (i32.const 43))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 12)) (i32.const 25))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 13)) (i32.const 39))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 14)) (i32.const 41))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 15)) (i32.const 45))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 16)) (i32.const 15))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 17)) (i32.const 21))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 18)) (i32.const 8))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 19)) (i32.const 18))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 20)) (i32.const 2))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 21)) (i32.const 61))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 22)) (i32.const 56))\n  (i32.store8 (i32.add (local.get $rotation_consts) (i32.const 23)) (i32.const 14))\n)\n\n;;\n;; Reset the context\n;;\n(func $keccak_reset\n  (param $context_offset i32)\n\n  ;; clear out the context memory\n  (drop (call $memset (local.get $context_offset) (i32.const 0) (i32.const 400)))\n)\n\n;;\n;; Push input to the context\n;;\n(func $keccak_update\n  (param $context_offset i32)\n  (param $input_offset i32)\n  (param $input_length i32)\n\n  (local $residue_offset i32)\n  (local $residue_buffer i32)\n  (local $residue_index i32)\n  (local $tmp i32)\n\n  ;; this is where we store the pointer\n  (local.set $residue_offset (i32.add (local.get $context_offset) (i32.const 200)))\n  ;; this is where the buffer is\n  (local.set $residue_buffer (i32.add (local.get $context_offset) (i32.const 208)))\n\n  (local.set $residue_index (i32.load (local.get $residue_offset)))\n\n  ;; process residue from last block\n  (if (i32.ne (local.get $residue_index) (i32.const 0))\n    (then\n      ;; the space left in the residue buffer\n      (local.set $tmp (i32.sub (i32.const 136) (local.get $residue_index)))\n\n      ;; limit to what we have as an input\n      (if (i32.lt_u (local.get $input_length) (local.get $tmp))\n        (local.set $tmp (local.get $input_length))\n      )\n\n      ;; fill up the residue buffer\n      (drop (call $memcpy\n        (i32.add (local.get $residue_buffer) (local.get $residue_index))\n        (local.get $input_offset)\n        (local.get $tmp)\n      ))\n\n      (local.set $residue_index (i32.add (local.get $residue_index) (local.get $tmp)))\n\n      ;; block complete\n      (if (i32.eq (local.get $residue_index) (i32.const 136))\n        (call $keccak_block (local.get $input_offset) (i32.const 136) (local.get $context_offset))\n\n        (local.set $residue_index (i32.const 0))\n      )\n\n      (i32.store (local.get $residue_offset) (local.get $residue_index))\n\n      (local.set $input_length (i32.sub (local.get $input_length) (local.get $tmp)))\n    )\n  )\n\n  ;; while (input_length > block_size)\n  (block $done\n    (loop $loop\n      (if (i32.lt_u (local.get $input_length) (i32.const 136))\n        (br $done)\n      )\n\n      (call $keccak_block (local.get $input_offset) (i32.const 136) (local.get $context_offset))\n\n      (local.set $input_offset (i32.add (local.get $input_offset) (i32.const 136)))\n      (local.set $input_length (i32.sub (local.get $input_length) (i32.const 136)))\n      (br $loop)\n    )\n  )\n\n  ;; copy to the residue buffer\n  (if (i32.gt_u (local.get $input_length) (i32.const 0))\n    (then\n      (drop (call $memcpy\n        (i32.add (local.get $residue_buffer) (local.get $residue_index))\n        (local.get $input_offset)\n        (local.get $input_length)\n      ))\n\n      (local.set $residue_index (i32.add (local.get $residue_index) (local.get $input_length)))\n      (i32.store (local.get $residue_offset) (local.get $residue_index))\n    )\n  )\n)\n\n;;\n;; Finalise and return the hash\n;;\n;; The 256 bit hash is returned at the output offset.\n;;\n(func $keccak_finish\n  (param $context_offset i32)\n  (param $output_offset i32)\n\n  (local $residue_offset i32)\n  (local $residue_buffer i32)\n  (local $residue_index i32)\n  (local $tmp i32)\n\n  ;; this is where we store the pointer\n  (local.set $residue_offset (i32.add (local.get $context_offset) (i32.const 200)))\n  ;; this is where the buffer is\n  (local.set $residue_buffer (i32.add (local.get $context_offset) (i32.const 208)))\n\n  (local.set $residue_index (i32.load (local.get $residue_offset)))\n  (local.set $tmp (local.get $residue_index))\n\n  ;; clear the rest of the residue buffer\n  (drop (call $memset (i32.add (local.get $residue_buffer) (local.get $tmp)) (i32.const 0) (i32.sub (i32.const 136) (local.get $tmp))))\n\n  ;; ((char*)ctx->message)[ctx->rest] |= 0x01;\n  (local.set $tmp (i32.add (local.get $residue_buffer) (local.get $residue_index)))\n  (i32.store8 (local.get $tmp) (i32.or (i32.load8_u (local.get $tmp)) (i32.const 0x01)))\n\n  ;; ((char*)ctx->message)[block_size - 1] |= 0x80;\n  (local.set $tmp (i32.add (local.get $residue_buffer) (i32.const 135)))\n  (i32.store8 (local.get $tmp) (i32.or (i32.load8_u (local.get $tmp)) (i32.const 0x80)))\n\n  (call $keccak_block (local.get $residue_buffer) (i32.const 136) (local.get $context_offset))\n\n  ;; the first 32 bytes pointed at by $output_offset is the final hash\n  (i64.store (local.get $output_offset) (i64.load (local.get $context_offset)))\n  (i64.store (i32.add (local.get $output_offset) (i32.const 8)) (i64.load (i32.add (local.get $context_offset) (i32.const 8))))\n  (i64.store (i32.add (local.get $output_offset) (i32.const 16)) (i64.load (i32.add (local.get $context_offset) (i32.const 16))))\n  (i64.store (i32.add (local.get $output_offset) (i32.const 24)) (i64.load (i32.add (local.get $context_offset) (i32.const 24))))\n)\n\n;;\n;; Calculate the hash. Helper method incorporating the above three.\n;;\n(func $keccak\n  (param $context_offset i32)\n  (param $input_offset i32)\n  (param $input_length i32)\n  (param $output_offset i32)\n\n  (call $keccak_init (local.get $context_offset))\n  (call $keccak_update (local.get $context_offset) (local.get $input_offset) (local.get $input_length))\n  (call $keccak_finish (local.get $context_offset) (local.get $output_offset))\n)\n"
  },
  "memcpy": {
    "wast": ";;\n;; memcpy from ewasm-libc/ewasm-cleanup\n;;\n(func $memcpy\n  (param $dst i32)\n  (param $src i32)\n  (param $length i32)\n  (result i32)\n\n  (local $i i32)\n\n  (local.set $i (i32.const 0))\n\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (local.get $i) (local.get $length))\n        (br $done)\n      )\n\n      (i32.store8 (i32.add (local.get $dst) (local.get $i)) (i32.load8_u (i32.add (local.get $src) (local.get $i))))\n\n      (local.set $i (i32.add (local.get $i) (i32.const 1)))\n      (br $loop)\n    )\n  )\n\n  (return (local.get $dst))\n)\n"
  },
  "memset": {
    "wast": ";;\n;; memcpy from ewasm-libc/ewasm-cleanup\n;;\n(func $memset\n  (param $ptr i32)\n  (param $value i32)\n  (param $length i32)\n  (result i32)\n  (local $i i32)\n\n  (local.set $i (i32.const 0))\n\n  (block $done\n    (loop $loop\n      (if (i32.ge_u (local.get $i) (local.get $length))\n        (br $done)\n      )\n\n      (i32.store8 (i32.add (local.get $ptr) (local.get $i)) (local.get $value))\n\n      (local.set $i (i32.add (local.get $i) (i32.const 1)))\n      (br $loop)\n    )\n  )\n  (local.get $ptr)\n)\n"
  },
  "memusegas": {
    "wast": "(func $memusegas\n  (param $offset i32)\n  (param $length i32)\n\n  (local $cost i64)\n  ;; the number of new words being allocated\n  (local $newWordCount i64)\n\n  (if (i32.eqz (local.get $length))\n    (then (return))\n  )\n\n  ;; const newMemoryWordCount = Math.ceil[[offset + length] / 32]\n  (local.set $newWordCount\n    (i64.div_u (i64.add (i64.const 31) (i64.add (i64.extend_i32_u (local.get $offset)) (i64.extend_i32_u (local.get $length))))\n               (i64.const 32)))\n\n  ;;if [runState.highestMem >= highestMem]  return\n  (if (i64.le_u (local.get $newWordCount) (global.get $wordCount))\n    (then (return))\n  )\n\n  ;; words * 3 + words ^2 / 512\n  (local.set $cost\n     (i64.add\n       (i64.mul (local.get $newWordCount) (i64.const 3))\n       (i64.div_u\n         (i64.mul (local.get $newWordCount)\n                  (local.get $newWordCount))\n         (i64.const 512))))\n\n  (call $useGas  (i64.sub (local.get $cost) (global.get $prevMemCost)))\n  (global.set $prevMemCost (local.get $cost))\n  (global.set $wordCount (local.get $newWordCount))\n\n  ;; grow actual memory\n  ;; the first 31704 bytes are guaranteed to be available\n  ;; adjust for 32 bytes  - the maximal size of MSTORE write\n  ;; TODO it should be memory.size * page_size\n  (local.set $offset (i32.add (local.get $length) (i32.add (local.get $offset) (global.get $memstart))))\n  (if (i32.gt_u (local.get $offset) (i32.mul (i32.const 65536) (memory.size)))\n    (then\n      (drop (memory.grow\n        (i32.div_u (i32.add (i32.const 65535) (i32.sub (local.get $offset) (memory.size))) (i32.const 65536))))\n    )\n  )\n)\n"
  },
  "mod_320": {
    "wast": "(func $mod_320\n  ;; dividend\n  (param $a i64)\n  (param $b i64)\n  (param $c i64)\n  (param $d i64)\n  (param $e i64)\n\n  ;; divisor\n  (param $a1 i64)\n  (param $b1 i64)\n  (param $c1 i64)\n  (param $d1 i64)\n  (param $e1 i64)\n\n  ;; stack pointer\n  (param $sp i32)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n  (local $eq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $maske i64)\n\n  (local $carry i32)\n  (local $temp i64)\n\n  (local.set $maske (i64.const 1))\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_320 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $e1))\n      (then\n        (local.set $a (i64.const 0))\n        (local.set $b (i64.const 0))\n        (local.set $c (i64.const 0))\n        (local.set $d (i64.const 0))\n        (local.set $e (i64.const 0))\n        (br $main)\n      )\n    )\n\n    (block $done\n      ;; align bits\n      (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (local.get $a1))) (call $gte_320\n                                                            (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $e1)\n                                                            (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $e)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (local.set $a1 (i64.add (i64.shl (local.get $a1) (i64.const 1)) (i64.shr_u (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shl (local.get $b1) (i64.const 1)) (i64.shr_u (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shl (local.get $c1) (i64.const 1)) (i64.shr_u (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.add (i64.shl (local.get $d1) (i64.const 1)) (i64.shr_u (local.get $e1) (i64.const 63))))\n        (local.set $e1 (i64.shl (local.get $e1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (local.set $maska (i64.add (i64.shl (local.get $maska) (i64.const 1)) (i64.shr_u (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shl (local.get $maskb) (i64.const 1)) (i64.shr_u (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shl (local.get $maskc) (i64.const 1)) (i64.shr_u (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.add (i64.shl (local.get $maskd) (i64.const 1)) (i64.shr_u (local.get $maske) (i64.const 63))))\n        (local.set $maske (i64.shl (local.get $maske) (i64.const 1)))\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_320 (local.get $maska) (local.get $maskb) (local.get $maskc) (local.get $maskd) (local.get $maske))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_320 (local.get $a) (local.get $b) (local.get $c) (local.get $d) (local.get $e) (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $e1))\n          (then\n            ;; dividend = dividend - divisor\n            (local.set $carry (i64.lt_u (local.get $e) (local.get $e1)))\n            (local.set $e     (i64.sub  (local.get $e) (local.get $e1)))\n\n            (local.set $temp  (i64.sub  (local.get $d) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $d)))\n            (local.set $d     (i64.sub  (local.get $temp) (local.get $d1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $d) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $c) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $c)))\n            (local.set $c     (i64.sub  (local.get $temp) (local.get $c1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $c) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $b) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $b)))\n            (local.set $b     (i64.sub  (local.get $temp) (local.get $b1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $b) (local.get $temp)) (local.get $carry)))\n\n            (local.set $a     (i64.sub  (i64.sub (local.get $a) (i64.extend_i32_u (local.get $carry))) (local.get $a1)))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (local.set $e1 (i64.add (i64.shr_u (local.get $e1) (i64.const 1)) (i64.shl (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.add (i64.shr_u (local.get $d1) (i64.const 1)) (i64.shl (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shr_u (local.get $c1) (i64.const 1)) (i64.shl (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shr_u (local.get $b1) (i64.const 1)) (i64.shl (local.get $a1) (i64.const 63))))\n        (local.set $a1 (i64.shr_u (local.get $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (local.set $maske (i64.add (i64.shr_u (local.get $maske) (i64.const 1)) (i64.shl (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.add (i64.shr_u (local.get $maskd) (i64.const 1)) (i64.shl (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shr_u (local.get $maskc) (i64.const 1)) (i64.shl (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shr_u (local.get $maskb) (i64.const 1)) (i64.shl (local.get $maska) (i64.const 63))))\n        (local.set $maska (i64.shr_u (local.get $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n  (i64.store (i32.add (local.get $sp) (i32.const 24)) (local.get $b))\n  (i64.store (i32.add (local.get $sp) (i32.const 16)) (local.get $c))\n  (i64.store (i32.add (local.get $sp) (i32.const 8))  (local.get $d))\n  (i64.store (local.get $sp)                          (local.get $e))\n)\n"
  },
  "mod_512": {
    "wast": ";; Modulo 0x06\n(func $mod_512\n  ;; dividend\n  (param $a i64)\n  (param $b i64)\n  (param $c i64)\n  (param $d i64)\n  (param $e i64)\n  (param $f i64)\n  (param $g i64)\n  (param $h i64)\n\n  ;; divisor\n  (param $a1 i64)\n  (param $b1 i64)\n  (param $c1 i64)\n  (param $d1 i64)\n  (param $e1 i64)\n  (param $f1 i64)\n  (param $g1 i64)\n  (param $h1 i64)\n\n  (param $sp i32)\n\n  ;; quotient\n  (local $aq i64)\n  (local $bq i64)\n  (local $cq i64)\n  (local $dq i64)\n\n  ;; mask\n  (local $maska i64)\n  (local $maskb i64)\n  (local $maskc i64)\n  (local $maskd i64)\n  (local $maske i64)\n  (local $maskf i64)\n  (local $maskg i64)\n  (local $maskh i64)\n\n  (local $carry i32)\n  (local $temp i64)\n\n  (local.set $maskh (i64.const 1))\n\n  (block $main\n    ;; check div by 0\n    (if (call $iszero_512 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $e1) (local.get $f1) (local.get $g1) (local.get $h1))\n      (then\n        (local.set $e (i64.const 0))\n        (local.set $f (i64.const 0))\n        (local.set $g (i64.const 0))\n        (local.set $h (i64.const 0))\n        (br $main)\n      )\n    )\n\n    ;; align bits\n    (block $done\n      (loop $loop\n        ;; align bits;\n        (if (i32.or (i64.eqz (i64.clz (local.get $a1)))\n          (call $gte_512 (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $e1) (local.get $f1) (local.get $g1) (local.get $h1)\n                         (local.get $a)  (local.get $b)  (local.get $c)  (local.get $d)  (local.get $e)  (local.get $f)  (local.get $g)  (local.get $h)))\n          (br $done)\n        )\n\n        ;; divisor = divisor << 1\n        (local.set $a1 (i64.add (i64.shl (local.get $a1) (i64.const 1)) (i64.shr_u (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shl (local.get $b1) (i64.const 1)) (i64.shr_u (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shl (local.get $c1) (i64.const 1)) (i64.shr_u (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.add (i64.shl (local.get $d1) (i64.const 1)) (i64.shr_u (local.get $e1) (i64.const 63))))\n        (local.set $e1 (i64.add (i64.shl (local.get $e1) (i64.const 1)) (i64.shr_u (local.get $f1) (i64.const 63))))\n        (local.set $f1 (i64.add (i64.shl (local.get $f1) (i64.const 1)) (i64.shr_u (local.get $g1) (i64.const 63))))\n        (local.set $g1 (i64.add (i64.shl (local.get $g1) (i64.const 1)) (i64.shr_u (local.get $h1) (i64.const 63))))\n        (local.set $h1 (i64.shl (local.get $h1) (i64.const 1)))\n\n        ;; mask = mask << 1\n        (local.set $maska (i64.add (i64.shl (local.get $maska) (i64.const 1)) (i64.shr_u (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shl (local.get $maskb) (i64.const 1)) (i64.shr_u (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shl (local.get $maskc) (i64.const 1)) (i64.shr_u (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.add (i64.shl (local.get $maskd) (i64.const 1)) (i64.shr_u (local.get $maske) (i64.const 63))))\n        (local.set $maske (i64.add (i64.shl (local.get $maske) (i64.const 1)) (i64.shr_u (local.get $maskf) (i64.const 63))))\n        (local.set $maskf (i64.add (i64.shl (local.get $maskf) (i64.const 1)) (i64.shr_u (local.get $maskg) (i64.const 63))))\n        (local.set $maskg (i64.add (i64.shl (local.get $maskg) (i64.const 1)) (i64.shr_u (local.get $maskh) (i64.const 63))))\n        (local.set $maskh (i64.shl (local.get $maskh) (i64.const 1)))\n        (br $loop)\n      )\n    )\n\n    (block $done\n      (loop $loop\n        ;; loop while mask != 0\n        (if (call $iszero_512 (local.get $maska) (local.get $maskb) (local.get $maskc) (local.get $maskd) (local.get $maske) (local.get $maskf) (local.get $maskg) (local.get $maskh))\n          (br $done)\n        )\n        ;; if dividend >= divisor\n        (if (call $gte_512\n          (local.get $a)  (local.get $b)  (local.get $c)  (local.get $d)  (local.get $e)  (local.get $f)  (local.get $g)  (local.get $h)\n          (local.get $a1) (local.get $b1) (local.get $c1) (local.get $d1) (local.get $e1) (local.get $f1) (local.get $g1) (local.get $h1))\n          (then\n            ;; dividend = dividend - divisor\n            (local.set $carry (i64.lt_u (local.get $h) (local.get $h1)))\n            (local.set $h     (i64.sub  (local.get $h) (local.get $h1)))\n\n            (local.set $temp  (i64.sub  (local.get $g) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $g)))\n            (local.set $g     (i64.sub  (local.get $temp) (local.get $g1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $g) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $f) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $f)))\n            (local.set $f     (i64.sub  (local.get $temp) (local.get $f1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $f) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $e) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $e)))\n            (local.set $e     (i64.sub  (local.get $temp) (local.get $e1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $e) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $d) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $d)))\n            (local.set $d     (i64.sub  (local.get $temp) (local.get $d1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $d) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $c) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $c)))\n            (local.set $c     (i64.sub  (local.get $temp) (local.get $c1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $c) (local.get $temp)) (local.get $carry)))\n\n            (local.set $temp  (i64.sub  (local.get $b) (i64.extend_i32_u (local.get $carry))))\n            (local.set $carry (i64.gt_u (local.get $temp) (local.get $b)))\n            (local.set $b     (i64.sub  (local.get $temp) (local.get $b1)))\n            (local.set $carry (i32.or   (i64.gt_u (local.get $b) (local.get $temp)) (local.get $carry)))\n            (local.set $a     (i64.sub  (i64.sub (local.get $a) (i64.extend_i32_u (local.get $carry))) (local.get $a1)))\n          )\n        )\n        ;; divisor = divisor >> 1\n        (local.set $h1 (i64.add (i64.shr_u (local.get $h1) (i64.const 1)) (i64.shl (local.get $g1) (i64.const 63))))\n        (local.set $g1 (i64.add (i64.shr_u (local.get $g1) (i64.const 1)) (i64.shl (local.get $f1) (i64.const 63))))\n        (local.set $f1 (i64.add (i64.shr_u (local.get $f1) (i64.const 1)) (i64.shl (local.get $e1) (i64.const 63))))\n        (local.set $e1 (i64.add (i64.shr_u (local.get $e1) (i64.const 1)) (i64.shl (local.get $d1) (i64.const 63))))\n        (local.set $d1 (i64.add (i64.shr_u (local.get $d1) (i64.const 1)) (i64.shl (local.get $c1) (i64.const 63))))\n        (local.set $c1 (i64.add (i64.shr_u (local.get $c1) (i64.const 1)) (i64.shl (local.get $b1) (i64.const 63))))\n        (local.set $b1 (i64.add (i64.shr_u (local.get $b1) (i64.const 1)) (i64.shl (local.get $a1) (i64.const 63))))\n        (local.set $a1 (i64.shr_u (local.get $a1) (i64.const 1)))\n\n        ;; mask = mask >> 1\n        (local.set $maskh (i64.add (i64.shr_u (local.get $maskh) (i64.const 1)) (i64.shl (local.get $maskg) (i64.const 63))))\n        (local.set $maskg (i64.add (i64.shr_u (local.get $maskg) (i64.const 1)) (i64.shl (local.get $maskf) (i64.const 63))))\n        (local.set $maskf (i64.add (i64.shr_u (local.get $maskf) (i64.const 1)) (i64.shl (local.get $maske) (i64.const 63))))\n        (local.set $maske (i64.add (i64.shr_u (local.get $maske) (i64.const 1)) (i64.shl (local.get $maskd) (i64.const 63))))\n        (local.set $maskd (i64.add (i64.shr_u (local.get $maskd) (i64.const 1)) (i64.shl (local.get $maskc) (i64.const 63))))\n        (local.set $maskc (i64.add (i64.shr_u (local.get $maskc) (i64.const 1)) (i64.shl (local.get $maskb) (i64.const 63))))\n        (local.set $maskb (i64.add (i64.shr_u (local.get $maskb) (i64.const 1)) (i64.shl (local.get $maska) (i64.const 63))))\n        (local.set $maska (i64.shr_u (local.get $maska) (i64.const 1)))\n        (br $loop)\n      )\n    )\n  );; end of main\n\n  (i64.store (local.get $sp) (local.get $e))\n  (i64.store (i32.sub (local.get $sp) (i32.const 8)) (local.get $f))\n  (i64.store (i32.sub (local.get $sp) (i32.const 16)) (local.get $g))\n  (i64.store (i32.sub (local.get $sp) (i32.const 24)) (local.get $h))\n)\n"
  },
  "mul_256": {
    "wast": "(func $mul_256\n  ;;  a b c d e f g h\n  ;;* i j k l m n o p\n  ;;----------------\n  (param $a i64)\n  (param $c i64)\n  (param $e i64)\n  (param $g i64)\n\n  (param $i i64)\n  (param $k i64)\n  (param $m i64)\n  (param $o i64)\n\n  (param $sp i32)\n\n  (local $b i64)\n  (local $d i64)\n  (local $f i64)\n  (local $h i64)\n  (local $j i64)\n  (local $l i64)\n  (local $n i64)\n  (local $p i64)\n  (local $temp6 i64)\n  (local $temp5 i64)\n  (local $temp4 i64)\n  (local $temp3 i64)\n  (local $temp2 i64)\n  (local $temp1 i64)\n  (local $temp0 i64)\n\n  ;; split the ops\n  (local.set $b (i64.and (local.get $a) (i64.const 4294967295)))\n  (local.set $a (i64.shr_u (local.get $a) (i64.const 32))) \n\n  (local.set $d (i64.and (local.get $c) (i64.const 4294967295)))\n  (local.set $c (i64.shr_u (local.get $c) (i64.const 32))) \n\n  (local.set $f (i64.and (local.get $e) (i64.const 4294967295)))\n  (local.set $e (i64.shr_u (local.get $e) (i64.const 32)))\n\n  (local.set $h (i64.and (local.get $g) (i64.const 4294967295)))\n  (local.set $g (i64.shr_u (local.get $g) (i64.const 32)))\n\n  (local.set $j (i64.and (local.get $i) (i64.const 4294967295)))\n  (local.set $i (i64.shr_u (local.get $i) (i64.const 32))) \n\n  (local.set $l (i64.and (local.get $k) (i64.const 4294967295)))\n  (local.set $k (i64.shr_u (local.get $k) (i64.const 32))) \n\n  (local.set $n (i64.and (local.get $m) (i64.const 4294967295)))\n  (local.set $m (i64.shr_u (local.get $m) (i64.const 32)))\n\n  (local.set $p (i64.and (local.get $o) (i64.const 4294967295)))\n  (local.set $o (i64.shr_u (local.get $o) (i64.const 32)))\n  ;; first row multiplication \n  ;; p * h\n  (local.set $temp0 (i64.mul (local.get $p) (local.get $h)))\n  ;; p * g + carry\n  (local.set $temp1 (i64.add (i64.mul (local.get $p) (local.get $g)) (i64.shr_u (local.get $temp0) (i64.const 32))))\n  ;; p * f + carry\n  (local.set $temp2 (i64.add (i64.mul (local.get $p) (local.get $f)) (i64.shr_u (local.get $temp1) (i64.const 32))))\n  ;; p * e + carry\n  (local.set $temp3 (i64.add (i64.mul (local.get $p) (local.get $e)) (i64.shr_u (local.get $temp2) (i64.const 32))))\n  ;; p * d + carry\n  (local.set $temp4 (i64.add (i64.mul (local.get $p) (local.get $d)) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; p * c + carry\n  (local.set $temp5  (i64.add (i64.mul (local.get $p) (local.get $c)) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; p * b + carry\n  (local.set $temp6  (i64.add (i64.mul (local.get $p) (local.get $b)) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; p * a + carry\n  (local.set $a  (i64.add (i64.mul (local.get $p) (local.get $a)) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; second row\n  ;; o * h + $temp1 \"pg\"\n  (local.set $temp1 (i64.add (i64.mul (local.get $o) (local.get $h)) (i64.and (local.get $temp1) (i64.const 4294967295))))\n  ;; o * g + $temp2 \"pf\" + carry\n  (local.set $temp2 (i64.add (i64.add (i64.mul (local.get $o) (local.get $g)) (i64.and (local.get $temp2) (i64.const 4294967295))) (i64.shr_u (local.get $temp1) (i64.const 32))))\n  ;; o * f + $temp3 \"pe\" + carry\n  (local.set $temp3 (i64.add (i64.add (i64.mul (local.get $o) (local.get $f)) (i64.and (local.get $temp3) (i64.const 4294967295))) (i64.shr_u (local.get $temp2) (i64.const 32))))\n  ;; o * e + $temp4  + carry\n  (local.set $temp4 (i64.add (i64.add (i64.mul (local.get $o) (local.get $e)) (i64.and (local.get $temp4) (i64.const 4294967295))) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; o * d + $temp5  + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $o) (local.get $d)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; o * c + $temp6  + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $o) (local.get $c)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; o * b + $a  + carry\n  (local.set $a (i64.add (i64.add (i64.mul (local.get $o) (local.get $b)) (i64.and (local.get $a) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n  ;; third row - n\n  ;; n * h + $temp2 \n  (local.set $temp2 (i64.add (i64.mul (local.get $n) (local.get $h)) (i64.and (local.get $temp2) (i64.const 4294967295))))\n  ;; n * g + $temp3 + carry\n  (local.set $temp3 (i64.add (i64.add (i64.mul (local.get $n) (local.get $g)) (i64.and (local.get $temp3) (i64.const 4294967295))) (i64.shr_u (local.get $temp2) (i64.const 32))))\n  ;; n * f + $temp4 + carry\n  (local.set $temp4 (i64.add (i64.add (i64.mul (local.get $n) (local.get $f)) (i64.and (local.get $temp4) (i64.const 4294967295))) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; n * e + $temp5  + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $n) (local.get $e)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; n * d + $temp6  + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $n) (local.get $d)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; n * c + $a  + carry\n  (local.set $a (i64.add (i64.add (i64.mul (local.get $n) (local.get $c)) (i64.and (local.get $a) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n\n  ;; forth row \n  ;; m * h + $temp3\n  (local.set $temp3 (i64.add (i64.mul (local.get $m) (local.get $h)) (i64.and (local.get $temp3) (i64.const 4294967295))))\n  ;; m * g + $temp4 + carry\n  (local.set $temp4 (i64.add (i64.add (i64.mul (local.get $m) (local.get $g)) (i64.and (local.get $temp4) (i64.const 4294967295))) (i64.shr_u (local.get $temp3) (i64.const 32))))\n  ;; m * f + $temp5 + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $m) (local.get $f)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; m * e + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $m) (local.get $e)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; m * d + $a + carry\n  (local.set $a (i64.add (i64.add (i64.mul (local.get $m) (local.get $d)) (i64.and (local.get $a) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n\n  ;; fith row\n  ;; l * h + $temp4\n  (local.set $temp4 (i64.add (i64.mul (local.get $l) (local.get $h)) (i64.and (local.get $temp4) (i64.const 4294967295))))\n  ;; l * g + $temp5 + carry\n  (local.set $temp5 (i64.add (i64.add (i64.mul (local.get $l) (local.get $g)) (i64.and (local.get $temp5) (i64.const 4294967295))) (i64.shr_u (local.get $temp4) (i64.const 32))))\n  ;; l * f + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $l) (local.get $f)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; l * e + $a + carry\n  (local.set $a (i64.add (i64.add (i64.mul (local.get $l) (local.get $e)) (i64.and (local.get $a) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n\n  ;; sixth row \n  ;; k * h + $temp5\n  (local.set $temp5 (i64.add (i64.mul (local.get $k) (local.get $h)) (i64.and (local.get $temp5) (i64.const 4294967295))))\n  ;; k * g + $temp6 + carry\n  (local.set $temp6 (i64.add (i64.add (i64.mul (local.get $k) (local.get $g)) (i64.and (local.get $temp6) (i64.const 4294967295))) (i64.shr_u (local.get $temp5) (i64.const 32))))\n  ;; k * f + $a + carry\n  (local.set $a (i64.add (i64.add (i64.mul (local.get $k) (local.get $f)) (i64.and (local.get $a) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))))\n\n  ;; seventh row\n  ;; j * h + $temp6\n  (local.set $temp6 (i64.add (i64.mul (local.get $j) (local.get $h)) (i64.and (local.get $temp6) (i64.const 4294967295))))\n  ;; j * g + $a + carry\n\n  ;; eigth row\n  ;; i * h + $a\n  (local.set $a (i64.add (i64.mul (local.get $i) (local.get $h)) (i64.and (i64.add (i64.add (i64.mul (local.get $j) (local.get $g)) (i64.and (local.get $a) (i64.const 4294967295))) (i64.shr_u (local.get $temp6) (i64.const 32))) (i64.const 4294967295))))\n\n  ;; combine terms\n  (local.set $a (i64.or (i64.shl (local.get $a) (i64.const 32)) (i64.and (local.get $temp6) (i64.const 4294967295))))\n  (local.set $c (i64.or (i64.shl (local.get $temp5) (i64.const 32)) (i64.and (local.get $temp4) (i64.const 4294967295))))\n  (local.set $e (i64.or (i64.shl (local.get $temp3) (i64.const 32)) (i64.and (local.get $temp2) (i64.const 4294967295))))\n  (local.set $g (i64.or (i64.shl (local.get $temp1) (i64.const 32)) (i64.and (local.get $temp0) (i64.const 4294967295))))\n\n  ;; save stack \n  (i64.store (local.get $sp) (local.get $a))\n  (i64.store (i32.sub (local.get $sp) (i32.const 8)) (local.get $c))\n  (i64.store (i32.sub (local.get $sp) (i32.const 16)) (local.get $e))\n  (i64.store (i32.sub (local.get $sp) (i32.const 24)) (local.get $g))\n)\n"
  }
}
},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjbGllbnQuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9hc3NlcnQvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYXNzZXJ0L25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Fzc2VydC9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2JhcnJhY2tzL2FwcGx5LWhvb2suanMiLCJub2RlX21vZHVsZXMvYmFycmFja3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JlbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nob28vaHRtbC5qcyIsIm5vZGVfbW9kdWxlcy9jaG9vL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kb2N1bWVudC1yZWFkeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kb2N1bWVudC1yZWFkeS9ub2RlX21vZHVsZXMvZ2xvYmFsL2RvY3VtZW50LmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZ2xvYmFsL2RvY3VtZW50LmpzIiwibm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCJub2RlX21vZHVsZXMvaGFzaC1tYXRjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oeXBlcnNjcmlwdC1hdHRyaWJ1dGUtdG8tcHJvcGVydHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaHlwZXJ4L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pbnNlcnQtY3NzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbW9ycGhkb20vZGlzdC9tb3JwaGRvbS5qcyIsIm5vZGVfbW9kdWxlcy9uYW5vYXNzZXJ0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25hbm9yYWYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vbi1sb2FkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhdGhuYW1lLW1hdGNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3NoZWV0LXJvdXRlci9oYXNoLmpzIiwibm9kZV9tb2R1bGVzL3NoZWV0LXJvdXRlci9oaXN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL3NoZWV0LXJvdXRlci9ocmVmLmpzIiwibm9kZV9tb2R1bGVzL3NoZWV0LXJvdXRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvd2F5ZmFyZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2F5ZmFyZXIvdHJpZS5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJub2RlX21vZHVsZXMveHRlbmQvbXV0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy95by15by9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy95by15by91cGRhdGUtZXZlbnRzLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL0BhcmstdXMvZXZtMndhc20vaW5kZXguanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2Jyb3JhbmQvaW5kZXguanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvY2lwaGVyLWJhc2UvaW5kZXguanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvY3JlYXRlLWhhc2gvYnJvd3Nlci5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2Jhc2UuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2Vkd2FyZHMuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2N1cnZlL2luZGV4LmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9tb250LmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9jdXJ2ZS9zaG9ydC5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvY3VydmVzLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9pbmRleC5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvZWMva2V5LmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lYy9zaWduYXR1cmUuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL2luZGV4LmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy9lZGRzYS9rZXkuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvZWxsaXB0aWMvbGliL2VsbGlwdGljL2VkZHNhL3NpZ25hdHVyZS5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9saWIvZWxsaXB0aWMvcHJlY29tcHV0ZWQvc2VjcDI1NmsxLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2VsbGlwdGljL2xpYi9lbGxpcHRpYy91dGlscy5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9lbGxpcHRpYy9wYWNrYWdlLmpzb24iLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2hhc2gtdXRpbHMuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvcmFuZG9tLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azEuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW5kZXguanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxLWFkYXB0ZXIuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxLWxpYi9kZXIuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxLWxpYi9pbmRleC5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9ldGhqcy11dGlsL2xpYi9pbmRleC5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9oYXNoLWJhc2UvaW5kZXguanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvaGFzaC1iYXNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZXJyb3JzLWJyb3dzZXIuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvaGFzaC1iYXNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2hhc2gtYmFzZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2hhc2gtYmFzZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2hhc2gtYmFzZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9oYXNoLWJhc2Uvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9oYXNoLWJhc2Uvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvci5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9oYXNoLWJhc2Uvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdC5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9oYXNoLWJhc2Uvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2hhc2gtYmFzZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvaGFzaC1iYXNlL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZnJvbS1icm93c2VyLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2hhc2gtYmFzZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2hhc2gtYmFzZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2hhc2gtYmFzZS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2NvbW1vbi5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL2htYWMuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9yaXBlbWQuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMS5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8yMjQuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMjU2LmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzM4NC5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS81MTIuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvY29tbW9uLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvdXRpbHMuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvaG1hYy1kcmJnL2xpYi9obWFjLWRyYmcuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvaXMtaGV4LXByZWZpeGVkL3NyYy9pbmRleC5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9rZWNjYWsvanMuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMva2VjY2FrL2xpYi9hcGkvaW5kZXguanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMva2VjY2FrL2xpYi9hcGkva2VjY2FrLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2tlY2Nhay9saWIvYXBpL3NoYWtlLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL2tlY2Nhay9saWIva2VjY2FrLXN0YXRlLXVucm9sbC5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9rZWNjYWsvbGliL2tlY2Nhay5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9rZWNjYWsvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMva2VjY2FrL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMva2VjY2FrL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMva2VjY2FrL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3IuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMva2VjY2FrL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9tZDUuanMvaW5kZXguanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvbWluaW1hbGlzdGljLWFzc2VydC9pbmRleC5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9taW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzL2xpYi91dGlscy5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9yYW5kb21ieXRlcy9icm93c2VyLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL3JpcGVtZDE2MC9pbmRleC5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9ybHAvZGlzdC5icm93c2VyL2luZGV4LmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL3JscC9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9lbGxpcHRpYy5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2VsbGlwdGljLmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvaW5kZXguanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvc2hhLmpzL2hhc2guanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvc2hhLmpzL2luZGV4LmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTEuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTIyNC5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMjU2LmpzIiwiLi4vZXZtMndhc20tanMvbm9kZV9tb2R1bGVzL3NoYS5qcy9zaGEzODQuanMiLCIuLi9ldm0yd2FzbS1qcy9ub2RlX21vZHVsZXMvc2hhLmpzL3NoYTUxMi5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy9zdHJpcC1oZXgtcHJlZml4L3NyYy9pbmRleC5qcyIsIi4uL2V2bTJ3YXNtLWpzL25vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwiLi4vZXZtMndhc20tanMvb3Bjb2Rlcy5qcyIsIi4uL2V2bTJ3YXNtLWpzL3dhc20vd2FzdC1hc3luYy5qc29uIiwiLi4vZXZtMndhc20tanMvd2FzbS93YXN0Lmpzb24iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3dkRBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzEvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2U0E7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOXhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdDNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcHVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNoWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25tQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ25tQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeHJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJjb25zdCBjaG9vID0gcmVxdWlyZSgnY2hvbycpXG5jb25zdCBodG1sID0gcmVxdWlyZSgnY2hvby9odG1sJylcbmNvbnN0IHNmID0gMFxuY29uc3QgZXZtMndhc20gPSByZXF1aXJlKCdAYXJrLXVzL2V2bTJ3YXNtJylcbmNvbnN0IGFwcCA9IGNob28oKVxuXG4vLyBhZGQgZ2xvYmFsIGNzc1xuOygocmVxdWlyZSgnaW5zZXJ0LWNzcycpKFwiY29kZSB7XFxuICB3aGl0ZS1zcGFjZTogcHJlO1xcbiAgaGVpZ2h0OiA5NSU7XFxufVxcblxcbm1haW4sXFxuZGl2LFxcbmh0bWwsIFxcbmJvZHkge1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxufVxcblxcbmRpdiB7XFxuICBmbG9hdDogbGVmdDtcXG4gIHdpZHRoOiA1MCU7XFxufVxcblxcbm1haW4ge1xcbiAgaGVpZ2h0OiA4NSU7IFxcbn1cXG5cXG50ZXh0YXJlYSB7XFxuICB3aWR0aDogOTAlO1xcbiAgaGVpZ2h0OiA4MCU7XFxufVwiKSB8fCB0cnVlKSAmJiBcIl80YmJmOGRkMlwiKVxuXG5jb25zdCBzY3JvbGwgPSAoKHJlcXVpcmUoJ2luc2VydC1jc3MnKShcIi5fNzQ0NzliZDYge1xcbiAgICBvdmVyZmxvdzogc2Nyb2xsO1xcbiAgfVwiKSB8fCB0cnVlKSAmJiBcIl83NDQ3OWJkNlwiKVxuXG5jb25zdCBkZW1vRVZNY29kZSA9ICcweDYwNjA2MDQwNTI2MDAwMzU3YzAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5MDA0ODA2Mzc3MTYwMkY3MTQ2MDM3NTc2MDM1NTY1YjAwNWI2MDU0NjAwNDgwODAzNTkwNjAyMDAxOTA5MTkwODAzNTkwNjAyMDAxOTA5MTkwNTA1MDYwNkE1NjViNjA0MDUxODA4MjgxNTI2MDIwMDE5MTUwNTA2MDQwNTE4MDkxMDM5MGYzNWI2MDAwODE4MzAxOTA1MDgwNTA1YjkyOTE1MDUwNTYnXG5jb25zdCBkZW1vV2FzdENvZGUgPSBjb21waWxlRVZNKGRlbW9FVk1jb2RlLCB0cnVlLCB0cnVlKVxuXG5hcHAubW9kZWwoe1xuICBzdGF0ZToge1xuICAgIGV2bUNvZGU6IGRlbW9FVk1jb2RlLFxuICAgIHdhc3RDb2RlOiBkZW1vV2FzdENvZGUsXG4gICAgaW5saW5lT3BzOiB0cnVlLFxuICAgIHBwcmludDogdHJ1ZVxuICB9LFxuICByZWR1Y2Vyczoge1xuICAgIGNvbXBpbGU6IChkYXRhLCBzdGF0ZSkgPT4gKHtcbiAgICAgIGV2bUNvZGU6IGRhdGEsXG4gICAgICB3YXN0Q29kZTogY29tcGlsZUVWTShkYXRhLCBzdGF0ZS5pbmxpbmVPcHMsIHN0YXRlLnBwcmludClcbiAgICB9KSxcbiAgICB0b2dnbGU6IChkYXRhLCBzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlID0ge31cbiAgICAgIHVwZGF0ZVtkYXRhXSA9ICFzdGF0ZVtkYXRhXVxuICAgICAgcmV0dXJuIHVwZGF0ZVxuICAgIH1cbiAgfVxufSlcblxuY29uc3QgaGVhZGVyID0gaHRtbGBcbiAgPGhlYWRlcj5cbiAgICA8aDE+RVZNIDIgRVdBU008L2gxPlxuICA8L2hlYWRlcj5gXG5cbmNvbnN0IGZvb3RlciA9IGh0bWxgXG4gIDxmb290ZXI+XG4gICB0cmFuc2NvbXBpbGVzIEVWTSBieXRlY29kZSB0byA8YSBocmVmPSdodHRwczovL2dpdGh1Yi5jb20vZXdhc20vZGVzaWduJz5ld2FzbTwvYT4gd2l0aCA8YSBocmVmPSdodHRwczovL2dpdGh1Yi5jb20vZXdhc20vZXZtMndhc20vJz5ldm0yd2FzbTwvYT4gfCA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL2V3YXNtL2V2bTJ3YXNtLWZyb250ZW5kXCI+c291cmNlPC9hPiB8IDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZXdhc20vZXZtMndhc20tZnJvbnRlbmQvaXNzdWVzXCI+aXNzdWVzPC9hPlxuICA8L2Zvb3Rlcj5gXG5cbmNvbnN0IGNsaXBib2FyZENvcHkgPSAodGV4dCkgPT4ge1xuICBpZiAobmF2aWdhdG9yLmNsaXBib2FyZCkge1xuICAgICAgcmV0dXJuIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpO1xuICB9XG4gIGNvbnN0IGF1eCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgYXV4LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHRleHQpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGF1eCk7XG4gIGF1eC5zZWxlY3QoKTtcbiAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJjb3B5XCIpO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGF1eCk7XG59XG5cbmNvbnN0IG1haW5WaWV3ID0gKHN0YXRlLCBwcmV2LCBzZW5kKSA9PiBodG1sIGBcbiAgPG1haW4+XG4gICAgPGRpdj5cbiAgICAgIDx0ZXh0YXJlYSBpZD1cImV2bWNvZGVcIiBvbmNoYW5nZT0keyhlKSA9PiBzZW5kKCdjb21waWxlJywgZS50YXJnZXQudmFsdWUpfT4ke3N0YXRlLmV2bUNvZGV9PC90ZXh0YXJlYT5cbiAgICAgIDxicj5cbiAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPSR7c3RhdGUuaW5saW5lT3BzfSBvbmNoYW5nZT0keyhlKSA9PiB7XG4gICAgICAgIHNlbmQoJ3RvZ2dsZScsICdpbmxpbmVPcHMnKVxuICAgICAgICBzZW5kKCdjb21waWxlJywgc3RhdGUuZXZtQ29kZSlcbiAgICAgIH19IC8+aW5saW5lIEVWTSBvcGNvZGVzXG4gICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD0ke3N0YXRlLnBwcmludH0gb25jaGFuZ2U9JHsoZSkgPT4ge1xuICAgICAgICBzZW5kKCd0b2dnbGUnLCAncHByaW50JylcbiAgICAgICAgc2VuZCgnY29tcGlsZScsIHN0YXRlLmV2bUNvZGUpXG4gICAgICB9fSAvPnByZXR0eSBwcmludFxuICAgIDwvZGl2PlxuICAgIDxoMz5Db3B5IHRoZSB3YXN0IHNvdXJjZTwvaDI+XG4gICAgPGgzPkdvIHRvIHRoZSB3YXQyd2FzbSB0b29sLCBwYXN0ZSB0aGUgd2FzdCBzb3VyY2UuIENsaWNrIG9uIGRvd25sb2FkIGFuZCBnZXQgdGhlIC53YXNtIGZpbGU8L2gyPlxuICAgIDxidXR0b24gb25jbGljaz0keygpID0+IGNsaXBib2FyZENvcHkoc3RhdGUud2FzdENvZGUpfT5jb3B5IHdhc3Q8L2J1dHRvbj5cbiAgICA8YSBocmVmPVwiaHR0cHM6Ly93ZWJhc3NlbWJseS5naXRodWIuaW8vd2FidC9kZW1vL3dhdDJ3YXNtL1wiIHRhcmdldD1cIl9ibGFua1wiPmdvIHRvIHdhdDJ3YXNtPC9hPlxuICAgIDxkaXYgY2xhc3M9JHtzY3JvbGx9PlxuICAgICAgPGNvZGU+JHtzdGF0ZS53YXN0Q29kZX08L2NvZGU+XG4gICAgPC9kaXY+XG4gIDwvbWFpbj5gXG5cblxuYXBwLnJvdXRlcigocm91dGUpID0+IFtcbiAgcm91dGUoJy8nLCBtYWluVmlldylcbl0pXG5cbnNldFRpbWVvdXQoKCkgPT4ge1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImV2bWNvZGVcIikudmFsdWUgPSBkZW1vRVZNY29kZTtcbn0sIDEwMDApO1xuXG5jb25zdCB0cmVlID0gYXBwLnN0YXJ0KClcbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaGVhZGVyKVxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0cmVlKVxuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb290ZXIpXG5cbmZ1bmN0aW9uIGNvbXBpbGVFVk0gKGV2bSwgaW5saW5lT3BzLCBwcHJpbnQpIHtcbiAgY29uc29sZS5sb2coZXZtKTtcbiAgaWYgKGV2bS5zdWJzdHJpbmcoMCwgMikgPT0gXCIweFwiKSB7XG4gICAgZXZtID0gZXZtLnN1YnN0cmluZygyKTtcbiAgfVxuICBjb25zdCBzb3VyY2UgPSBldm0yd2FzbS5ldm0yd2FzdChuZXcgQnVmZmVyKGV2bSwgJ2hleCcpLCB7XG4gICAgaW5saW5lT3BzOiBpbmxpbmVPcHMsXG4gICAgcHByaW50OiBwcHJpbnRcbiAgfSlcbiAgLy8gY29uc29sZS5sb2coc291cmNlKVxuICByZXR1cm4gc291cmNlO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0QXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBjb21wYXJlIGFuZCBpc0J1ZmZlciB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuLy8gb3JpZ2luYWwgbm90aWNlOlxuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgaWYgKGdsb2JhbC5CdWZmZXIgJiYgdHlwZW9mIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgfVxuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKTtcbn1cblxuLy8gYmFzZWQgb24gbm9kZSBhc3NlcnQsIG9yaWdpbmFsIG5vdGljZTpcbi8vIE5COiBUaGUgVVJMIHRvIHRoZSBDb21tb25KUyBzcGVjIGlzIGtlcHQganVzdCBmb3IgdHJhZGl0aW9uLlxuLy8gICAgIG5vZGUtYXNzZXJ0IGhhcyBldm9sdmVkIGEgbG90IHNpbmNlIHRoZW4sIGJvdGggaW4gQVBJIGFuZCBiZWhhdmlvci5cblxuLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9vKCkge30ubmFtZSA9PT0gJ2Zvbyc7XG59KCkpO1xuZnVuY3Rpb24gcFRvU3RyaW5nIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuZnVuY3Rpb24gaXNWaWV3KGFycmJ1Zikge1xuICBpZiAoaXNCdWZmZXIoYXJyYnVmKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYnVmKTtcbiAgfVxuICBpZiAoIWFycmJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYnVmIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYXJyYnVmLmJ1ZmZlciAmJiBhcnJidWYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG52YXIgcmVnZXggPSAvXFxzKmZ1bmN0aW9uXFxzKyhbXlxcKFxcc10qKVxccyovO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9ibG9iL2FkZWVlZWM4YmZjYzYwNjhiMTg3ZDdkOWZiM2Q1YmIxZDNhMzA4OTkvaW1wbGVtZW50YXRpb24uanNcbmZ1bmN0aW9uIGdldE5hbWUoZnVuYykge1xuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihmdW5jKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzKSB7XG4gICAgcmV0dXJuIGZ1bmMubmFtZTtcbiAgfVxuICB2YXIgc3RyID0gZnVuYy50b1N0cmluZygpO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gZ2V0TmFtZShzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBpbnNwZWN0KHNvbWV0aGluZykge1xuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzIHx8ICF1dGlsLmlzRnVuY3Rpb24oc29tZXRoaW5nKSkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qoc29tZXRoaW5nKTtcbiAgfVxuICB2YXIgcmF3bmFtZSA9IGdldE5hbWUoc29tZXRoaW5nKTtcbiAgdmFyIG5hbWUgPSByYXduYW1lID8gJzogJyArIHJhd25hbWUgOiAnJztcbiAgcmV0dXJuICdbRnVuY3Rpb24nICsgIG5hbWUgKyAnXSc7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5hY3R1YWwpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmV4cGVjdGVkKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwU3RyaWN0RXF1YWwnLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgJiYgaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYWN0dWFsLCBleHBlY3RlZCkgPT09IDA7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKChhY3R1YWwgPT09IG51bGwgfHwgdHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIHN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0eXBlZCBhcnJheXMsIHdyYXAgdGhlaXIgdW5kZXJseWluZ1xuICAvLyBBcnJheUJ1ZmZlcnMgaW4gYSBCdWZmZXIgZWFjaCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAvLyBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGUgYXJyYXlzIHRvIGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBjaGVja2VkIGJ5XG4gIC8vIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKGFrYSBwVG9TdHJpbmcpLiBOZXZlciBwZXJmb3JtIGJpbmFyeVxuICAvLyBjb21wYXJpc29ucyBmb3IgRmxvYXQqQXJyYXlzLCB0aG91Z2gsIHNpbmNlIGUuZy4gKzAgPT09IC0wIGJ1dCB0aGVpclxuICAvLyBiaXQgcGF0dGVybnMgYXJlIG5vdCBpZGVudGljYWwuXG4gIH0gZWxzZSBpZiAoaXNWaWV3KGFjdHVhbCkgJiYgaXNWaWV3KGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgIHBUb1N0cmluZyhhY3R1YWwpID09PSBwVG9TdHJpbmcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgIShhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkpIHtcbiAgICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhY3R1YWwuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShleHBlY3RlZC5idWZmZXIpKSA9PT0gMDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgIT09IGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBtZW1vcyA9IG1lbW9zIHx8IHthY3R1YWw6IFtdLCBleHBlY3RlZDogW119O1xuXG4gICAgdmFyIGFjdHVhbEluZGV4ID0gbWVtb3MuYWN0dWFsLmluZGV4T2YoYWN0dWFsKTtcbiAgICBpZiAoYWN0dWFsSW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoYWN0dWFsSW5kZXggPT09IG1lbW9zLmV4cGVjdGVkLmluZGV4T2YoZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLmFjdHVhbC5wdXNoKGFjdHVhbCk7XG4gICAgbWVtb3MuZXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG5cbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKHV0aWwuaXNQcmltaXRpdmUoYSkgfHwgdXRpbC5pc1ByaW1pdGl2ZShiKSlcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgaWYgKHN0cmljdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSk7XG4gIHZhciBiSXNBcmdzID0gaXNBcmd1bWVudHMoYik7XG4gIGlmICgoYUlzQXJncyAmJiAhYklzQXJncykgfHwgKCFhSXNBcmdzICYmIGJJc0FyZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFJc0FyZ3MpIHtcbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIsIHN0cmljdCk7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKTtcbiAgdmFyIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgdmFyIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT09IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwU3RyaWN0RXF1YWwnLCBub3REZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59XG5cblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElnbm9yZS4gIFRoZSBpbnN0YW5jZW9mIGNoZWNrIGRvZXNuJ3Qgd29yayBmb3IgYXJyb3cgZnVuY3Rpb25zLlxuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIF90cnlCbG9jayhibG9jaykge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgYmxvY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJsb2NrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICBhY3R1YWwgPSBfdHJ5QmxvY2soYmxvY2spO1xuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgdmFyIHVzZXJQcm92aWRlZE1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZyc7XG4gIHZhciBpc1Vud2FudGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIHV0aWwuaXNFcnJvcihhY3R1YWwpO1xuICB2YXIgaXNVbmV4cGVjdGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIGFjdHVhbCAmJiAhZXhwZWN0ZWQ7XG5cbiAgaWYgKChpc1Vud2FudGVkRXhjZXB0aW9uICYmXG4gICAgICB1c2VyUHJvdmlkZWRNZXNzYWdlICYmXG4gICAgICBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHxcbiAgICAgIGlzVW5leHBlY3RlZEV4Y2VwdGlvbikge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyh0cnVlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MoZmFsc2UsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cbi8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5mdW5jdGlvbiBzdHJpY3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09Jywgc3RyaWN0KTtcbn1cbmFzc2VydC5zdHJpY3QgPSBvYmplY3RBc3NpZ24oc3RyaWN0LCBhc3NlcnQsIHtcbiAgZXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcbiAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxuICBub3RFcXVhbDogYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLFxuICBub3REZWVwRXF1YWw6IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWxcbn0pO1xuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYXBwbHlIb29rXG5cbi8vIGFwcGx5IGFyZ3VtZW50cyBvbnRvIGFuIGFycmF5IG9mIGZ1bmN0aW9ucywgdXNlZnVsIGZvciBob29rc1xuLy8gKGFyciwgYW55PywgYW55PywgYW55PywgYW55PywgYW55PykgLT4gbnVsbFxuZnVuY3Rpb24gYXBwbHlIb29rIChhcnIsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgYXJyLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgZm4oYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSlcbiAgfSlcbn1cbiIsImNvbnN0IG11dGF0ZSA9IHJlcXVpcmUoJ3h0ZW5kL211dGFibGUnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuXG5jb25zdCBhcHBseUhvb2sgPSByZXF1aXJlKCcuL2FwcGx5LWhvb2snKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRpc3BhdGNoZXJcblxuLy8gaW5pdGlhbGl6ZSBhIG5ldyBiYXJyYWNrcyBpbnN0YW5jZVxuLy8gb2JqIC0+IG9ialxuZnVuY3Rpb24gZGlzcGF0Y2hlciAoaG9va3MpIHtcbiAgaG9va3MgPSBob29rcyB8fCB7fVxuICBhc3NlcnQuZXF1YWwodHlwZW9mIGhvb2tzLCAnb2JqZWN0JywgJ2JhcnJhY2tzOiBob29rcyBzaG91bGQgYmUgdW5kZWZpbmVkIG9yIGFuIG9iamVjdCcpXG5cbiAgY29uc3Qgb25TdGF0ZUNoYW5nZUhvb2tzID0gW11cbiAgY29uc3Qgb25BY3Rpb25Ib29rcyA9IFtdXG4gIGNvbnN0IG9uRXJyb3JIb29rcyA9IFtdXG5cbiAgY29uc3Qgc3Vic2NyaXB0aW9uV3JhcHMgPSBbXVxuICBjb25zdCBpbml0aWFsU3RhdGVXcmFwcyA9IFtdXG4gIGNvbnN0IHJlZHVjZXJXcmFwcyA9IFtdXG4gIGNvbnN0IGVmZmVjdFdyYXBzID0gW11cblxuICB1c2UoaG9va3MpXG5cbiAgdmFyIHJlZHVjZXJzQ2FsbGVkID0gZmFsc2VcbiAgdmFyIGVmZmVjdHNDYWxsZWQgPSBmYWxzZVxuICB2YXIgc3RhdGVDYWxsZWQgPSBmYWxzZVxuICB2YXIgc3Vic0NhbGxlZCA9IGZhbHNlXG5cbiAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHN0YXJ0Ll9zdWJzY3JpcHRpb25zID0ge31cbiAgY29uc3QgcmVkdWNlcnMgPSBzdGFydC5fcmVkdWNlcnMgPSB7fVxuICBjb25zdCBlZmZlY3RzID0gc3RhcnQuX2VmZmVjdHMgPSB7fVxuICBjb25zdCBtb2RlbHMgPSBzdGFydC5fbW9kZWxzID0gW11cbiAgdmFyIF9zdGF0ZSA9IHt9XG5cbiAgc3RhcnQubW9kZWwgPSBzZXRNb2RlbFxuICBzdGFydC5zdGF0ZSA9IGdldFN0YXRlXG4gIHN0YXJ0LnN0YXJ0ID0gc3RhcnRcbiAgc3RhcnQudXNlID0gdXNlXG4gIHJldHVybiBzdGFydFxuXG4gIC8vIHB1c2ggYW4gb2JqZWN0IG9mIGhvb2tzIG9udG8gYW4gYXJyYXlcbiAgLy8gb2JqIC0+IG51bGxcbiAgZnVuY3Rpb24gdXNlIChob29rcykge1xuICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgaG9va3MsICdvYmplY3QnLCAnYmFycmFja3MudXNlOiBob29rcyBzaG91bGQgYmUgYW4gb2JqZWN0JylcbiAgICBhc3NlcnQub2soIWhvb2tzLm9uRXJyb3IgfHwgdHlwZW9mIGhvb2tzLm9uRXJyb3IgPT09ICdmdW5jdGlvbicsICdiYXJyYWNrcy51c2U6IG9uRXJyb3Igc2hvdWxkIGJlIHVuZGVmaW5lZCBvciBhIGZ1bmN0aW9uJylcbiAgICBhc3NlcnQub2soIWhvb2tzLm9uQWN0aW9uIHx8IHR5cGVvZiBob29rcy5vbkFjdGlvbiA9PT0gJ2Z1bmN0aW9uJywgJ2JhcnJhY2tzLnVzZTogb25BY3Rpb24gc2hvdWxkIGJlIHVuZGVmaW5lZCBvciBhIGZ1bmN0aW9uJylcbiAgICBhc3NlcnQub2soIWhvb2tzLm9uU3RhdGVDaGFuZ2UgfHwgdHlwZW9mIGhvb2tzLm9uU3RhdGVDaGFuZ2UgPT09ICdmdW5jdGlvbicsICdiYXJyYWNrcy51c2U6IG9uU3RhdGVDaGFuZ2Ugc2hvdWxkIGJlIHVuZGVmaW5lZCBvciBhIGZ1bmN0aW9uJylcblxuICAgIGlmIChob29rcy5vblN0YXRlQ2hhbmdlKSBvblN0YXRlQ2hhbmdlSG9va3MucHVzaChob29rcy5vblN0YXRlQ2hhbmdlKVxuICAgIGlmIChob29rcy5vbkVycm9yKSBvbkVycm9ySG9va3MucHVzaCh3cmFwT25FcnJvcihob29rcy5vbkVycm9yKSlcbiAgICBpZiAoaG9va3Mub25BY3Rpb24pIG9uQWN0aW9uSG9va3MucHVzaChob29rcy5vbkFjdGlvbilcbiAgICBpZiAoaG9va3Mud3JhcFN1YnNjcmlwdGlvbnMpIHN1YnNjcmlwdGlvbldyYXBzLnB1c2goaG9va3Mud3JhcFN1YnNjcmlwdGlvbnMpXG4gICAgaWYgKGhvb2tzLndyYXBJbml0aWFsU3RhdGUpIGluaXRpYWxTdGF0ZVdyYXBzLnB1c2goaG9va3Mud3JhcEluaXRpYWxTdGF0ZSlcbiAgICBpZiAoaG9va3Mud3JhcFJlZHVjZXJzKSByZWR1Y2VyV3JhcHMucHVzaChob29rcy53cmFwUmVkdWNlcnMpXG4gICAgaWYgKGhvb2tzLndyYXBFZmZlY3RzKSBlZmZlY3RXcmFwcy5wdXNoKGhvb2tzLndyYXBFZmZlY3RzKVxuICB9XG5cbiAgLy8gcHVzaCBhIG1vZGVsIHRvIGJlIGluaXRpYXRlZFxuICAvLyBvYmogLT4gbnVsbFxuICBmdW5jdGlvbiBzZXRNb2RlbCAobW9kZWwpIHtcbiAgICBhc3NlcnQuZXF1YWwodHlwZW9mIG1vZGVsLCAnb2JqZWN0JywgJ2JhcnJhY2tzLnN0b3JlLm1vZGVsOiBtb2RlbCBzaG91bGQgYmUgYW4gb2JqZWN0JylcbiAgICBtb2RlbHMucHVzaChtb2RlbClcbiAgfVxuXG4gIC8vIGdldCB0aGUgY3VycmVudCBzdGF0ZSBmcm9tIHRoZSBzdG9yZVxuICAvLyBvYmo/IC0+IG9ialxuICBmdW5jdGlvbiBnZXRTdGF0ZSAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG4gICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBvcHRzLCAnb2JqZWN0JywgJ2JhcnJhY2tzLnN0b3JlLnN0YXRlOiBvcHRzIHNob3VsZCBiZSBhbiBvYmplY3QnKVxuXG4gICAgY29uc3Qgc3RhdGUgPSBvcHRzLnN0YXRlXG4gICAgaWYgKCFvcHRzLnN0YXRlICYmIG9wdHMuZnJlZXplID09PSBmYWxzZSkgcmV0dXJuIHh0ZW5kKF9zdGF0ZSlcbiAgICBlbHNlIGlmICghb3B0cy5zdGF0ZSkgcmV0dXJuIE9iamVjdC5mcmVlemUoeHRlbmQoX3N0YXRlKSlcbiAgICBhc3NlcnQuZXF1YWwodHlwZW9mIHN0YXRlLCAnb2JqZWN0JywgJ2JhcnJhY2tzLnN0b3JlLnN0YXRlOiBzdGF0ZSBzaG91bGQgYmUgYW4gb2JqZWN0JylcblxuICAgIGNvbnN0IG5hbWVzcGFjZXMgPSBbXVxuICAgIGNvbnN0IG5ld1N0YXRlID0ge31cblxuICAgIC8vIGFwcGx5IGFsbCBmaWVsZHMgZnJvbSB0aGUgbW9kZWwsIGFuZCBuYW1lc3BhY2VkIGZpZWxkcyBmcm9tIHRoZSBwYXNzZWRcbiAgICAvLyBpbiBzdGF0ZVxuICAgIG1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgY29uc3QgbnMgPSBtb2RlbC5uYW1lc3BhY2VcbiAgICAgIG5hbWVzcGFjZXMucHVzaChucylcbiAgICAgIGNvbnN0IG1vZGVsU3RhdGUgPSBtb2RlbC5zdGF0ZSB8fCB7fVxuICAgICAgaWYgKG5zKSB7XG4gICAgICAgIG5ld1N0YXRlW25zXSA9IG5ld1N0YXRlW25zXSB8fCB7fVxuICAgICAgICBhcHBseShucywgbW9kZWxTdGF0ZSwgbmV3U3RhdGUpXG4gICAgICAgIG5ld1N0YXRlW25zXSA9IHh0ZW5kKG5ld1N0YXRlW25zXSwgc3RhdGVbbnNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXV0YXRlKG5ld1N0YXRlLCBtb2RlbFN0YXRlKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBub3cgYXBwbHkgYWxsIGZpZWxkcyB0aGF0IHdlcmVuJ3QgbmFtZXNwYWNlZCBmcm9tIHRoZSBwYXNzZWQgaW4gc3RhdGVcbiAgICBPYmplY3Qua2V5cyhzdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAobmFtZXNwYWNlcy5pbmRleE9mKGtleSkgIT09IC0xKSByZXR1cm5cbiAgICAgIG5ld1N0YXRlW2tleV0gPSBzdGF0ZVtrZXldXG4gICAgfSlcblxuICAgIGNvbnN0IHRtcFN0YXRlID0geHRlbmQoX3N0YXRlLCB4dGVuZChzdGF0ZSwgbmV3U3RhdGUpKVxuICAgIGNvbnN0IHdyYXBwZWRTdGF0ZSA9IHdyYXBIb29rKHRtcFN0YXRlLCBpbml0aWFsU3RhdGVXcmFwcylcblxuICAgIHJldHVybiAob3B0cy5mcmVlemUgPT09IGZhbHNlKVxuICAgICAgPyB3cmFwcGVkU3RhdGVcbiAgICAgIDogT2JqZWN0LmZyZWV6ZSh3cmFwcGVkU3RhdGUpXG4gIH1cblxuICAvLyBpbml0aWFsaXplIHRoZSBzdG9yZSBob29rcywgZ2V0IHRoZSBzZW5kKCkgZnVuY3Rpb25cbiAgLy8gb2JqPyAtPiBmblxuICBmdW5jdGlvbiBzdGFydCAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG4gICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBvcHRzLCAnb2JqZWN0JywgJ2JhcnJhY2tzLnN0b3JlLnN0YXJ0OiBvcHRzIHNob3VsZCBiZSB1bmRlZmluZWQgb3IgYW4gb2JqZWN0JylcblxuICAgIC8vIHJlZ2lzdGVyIHZhbHVlcyBmcm9tIHRoZSBtb2RlbHNcbiAgICBtb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgIGNvbnN0IG5zID0gbW9kZWwubmFtZXNwYWNlXG4gICAgICBpZiAoIXN0YXRlQ2FsbGVkICYmIG1vZGVsLnN0YXRlICYmIG9wdHMuc3RhdGUgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsU3RhdGUgPSBtb2RlbC5zdGF0ZSB8fCB7fVxuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICBfc3RhdGVbbnNdID0gX3N0YXRlW25zXSB8fCB7fVxuICAgICAgICAgIGFwcGx5KG5zLCBtb2RlbFN0YXRlLCBfc3RhdGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXV0YXRlKF9zdGF0ZSwgbW9kZWxTdGF0ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFyZWR1Y2Vyc0NhbGxlZCAmJiBtb2RlbC5yZWR1Y2VycyAmJiBvcHRzLnJlZHVjZXJzICE9PSBmYWxzZSkge1xuICAgICAgICBhcHBseShucywgbW9kZWwucmVkdWNlcnMsIHJlZHVjZXJzLCBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcEhvb2soY2IsIHJlZHVjZXJXcmFwcylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGlmICghZWZmZWN0c0NhbGxlZCAmJiBtb2RlbC5lZmZlY3RzICYmIG9wdHMuZWZmZWN0cyAhPT0gZmFsc2UpIHtcbiAgICAgICAgYXBwbHkobnMsIG1vZGVsLmVmZmVjdHMsIGVmZmVjdHMsIGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgIHJldHVybiB3cmFwSG9vayhjYiwgZWZmZWN0V3JhcHMpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBpZiAoIXN1YnNDYWxsZWQgJiYgbW9kZWwuc3Vic2NyaXB0aW9ucyAmJiBvcHRzLnN1YnNjcmlwdGlvbnMgIT09IGZhbHNlKSB7XG4gICAgICAgIGFwcGx5KG5zLCBtb2RlbC5zdWJzY3JpcHRpb25zLCBzdWJzY3JpcHRpb25zLCBmdW5jdGlvbiAoY2IsIGtleSkge1xuICAgICAgICAgIGNvbnN0IHNlbmQgPSBjcmVhdGVTZW5kKCdzdWJzY3JpcHRpb246ICcgKyAobnMgPyBucyArICc6JyArIGtleSA6IGtleSkpXG4gICAgICAgICAgY2IgPSB3cmFwSG9vayhjYiwgc3Vic2NyaXB0aW9uV3JhcHMpXG4gICAgICAgICAgY2Ioc2VuZCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgYXBwbHlIb29rKG9uRXJyb3JIb29rcywgZXJyLCBfc3RhdGUsIGNyZWF0ZVNlbmQpXG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm4gY2JcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gdGhlIHN0YXRlIHdyYXAgaXMgc3BlY2lhbCBiZWNhdXNlIHdlIHdhbnQgdG8gb3BlcmF0ZSBvbiB0aGUgZnVsbFxuICAgIC8vIHN0YXRlIHJhdGhlciB0aGFuIGluZHZpZHVhbCBjaHVua3MsIHNvIHdlIGFwcGx5IGl0IG91dHNpZGUgdGhlIGxvb3BcbiAgICBpZiAoIXN0YXRlQ2FsbGVkICYmIG9wdHMuc3RhdGUgIT09IGZhbHNlKSB7XG4gICAgICBfc3RhdGUgPSB3cmFwSG9vayhfc3RhdGUsIGluaXRpYWxTdGF0ZVdyYXBzKVxuICAgIH1cblxuICAgIGlmICghb3B0cy5ub1N1YnNjcmlwdGlvbnMpIHN1YnNDYWxsZWQgPSB0cnVlXG4gICAgaWYgKCFvcHRzLm5vUmVkdWNlcnMpIHJlZHVjZXJzQ2FsbGVkID0gdHJ1ZVxuICAgIGlmICghb3B0cy5ub0VmZmVjdHMpIGVmZmVjdHNDYWxsZWQgPSB0cnVlXG4gICAgaWYgKCFvcHRzLm5vU3RhdGUpIHN0YXRlQ2FsbGVkID0gdHJ1ZVxuXG4gICAgaWYgKCFvbkVycm9ySG9va3MubGVuZ3RoKSBvbkVycm9ySG9va3MucHVzaCh3cmFwT25FcnJvcihkZWZhdWx0T25FcnJvcikpXG5cbiAgICByZXR1cm4gY3JlYXRlU2VuZFxuXG4gICAgLy8gY2FsbCBhbiBhY3Rpb24gZnJvbSBhIHZpZXdcbiAgICAvLyAoc3RyLCBib29sPykgLT4gKHN0ciwgYW55PywgZm4/KSAtPiBudWxsXG4gICAgZnVuY3Rpb24gY3JlYXRlU2VuZCAoc2VsZk5hbWUsIGNhbGxPbkVycm9yKSB7XG4gICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIHNlbGZOYW1lLCAnc3RyaW5nJywgJ2JhcnJhY2tzLnN0b3JlLnN0YXJ0LmNyZWF0ZVNlbmQ6IHNlbGZOYW1lIHNob3VsZCBiZSBhIHN0cmluZycpXG4gICAgICBhc3NlcnQub2soIWNhbGxPbkVycm9yIHx8IHR5cGVvZiBjYWxsT25FcnJvciA9PT0gJ2Jvb2xlYW4nLCAnYmFycmFja3Muc3RvcmUuc3RhcnQuc2VuZDogY2FsbE9uRXJyb3Igc2hvdWxkIGJlIHVuZGVmaW5lZCBvciBhIGJvb2xlYW4nKVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2VuZCAobmFtZSwgZGF0YSwgY2IpIHtcbiAgICAgICAgaWYgKCFjYiAmJiAhY2FsbE9uRXJyb3IpIHtcbiAgICAgICAgICBjYiA9IGRhdGFcbiAgICAgICAgICBkYXRhID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSAodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGRhdGEpXG5cbiAgICAgICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBuYW1lLCAnc3RyaW5nJywgJ2JhcnJhY2tzLnN0b3JlLnN0YXJ0LnNlbmQ6IG5hbWUgc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgICAgICAgYXNzZXJ0Lm9rKCFjYiB8fCB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicsICdiYXJyYWNrcy5zdG9yZS5zdGFydC5zZW5kOiBjYiBzaG91bGQgYmUgYSBmdW5jdGlvbicpXG5cbiAgICAgICAgY29uc3QgZG9uZSA9IGNhbGxPbkVycm9yID8gb25FcnJvckNhbGxiYWNrIDogY2JcbiAgICAgICAgX3NlbmQobmFtZSwgZGF0YSwgc2VsZk5hbWUsIGRvbmUpXG5cbiAgICAgICAgZnVuY3Rpb24gb25FcnJvckNhbGxiYWNrIChlcnIpIHtcbiAgICAgICAgICBlcnIgPSBlcnIgfHwgbnVsbFxuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGFwcGx5SG9vayhvbkVycm9ySG9va3MsIGVyciwgX3N0YXRlLCBmdW5jdGlvbiBjcmVhdGVTZW5kIChzZWxmTmFtZSkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gc2VuZCAobmFtZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgbmFtZSwgJ3N0cmluZycsICdiYXJyYWNrcy5zdG9yZS5zdGFydC5zZW5kOiBuYW1lIHNob3VsZCBiZSBhIHN0cmluZycpXG4gICAgICAgICAgICAgICAgZGF0YSA9ICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogZGF0YSlcbiAgICAgICAgICAgICAgICBfc2VuZChuYW1lLCBkYXRhLCBzZWxmTmFtZSwgZG9uZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxsIGFuIGFjdGlvblxuICAgIC8vIChzdHIsIHN0ciwgYW55LCBmbikgLT4gbnVsbFxuICAgIGZ1bmN0aW9uIF9zZW5kIChuYW1lLCBkYXRhLCBjYWxsZXIsIGNiKSB7XG4gICAgICBhc3NlcnQuZXF1YWwodHlwZW9mIG5hbWUsICdzdHJpbmcnLCAnYmFycmFja3MuX3NlbmQ6IG5hbWUgc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgY2FsbGVyLCAnc3RyaW5nJywgJ2JhcnJhY2tzLl9zZW5kOiBjYWxsZXIgc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgY2IsICdmdW5jdGlvbicsICdiYXJyYWNrcy5fc2VuZDogY2Igc2hvdWxkIGJlIGEgZnVuY3Rpb24nKVxuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlZHVjZXJzQ2FsbGVkID0gZmFsc2VcbiAgICAgICAgdmFyIGVmZmVjdHNDYWxsZWQgPSBmYWxzZVxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHh0ZW5kKF9zdGF0ZSlcblxuICAgICAgICBpZiAob25BY3Rpb25Ib29rcy5sZW5ndGgpIHtcbiAgICAgICAgICBhcHBseUhvb2sob25BY3Rpb25Ib29rcywgZGF0YSwgX3N0YXRlLCBuYW1lLCBjYWxsZXIsIGNyZWF0ZVNlbmQpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZGF0ZSBpZiBhIG5hbWVzcGFjZSBleGlzdHMuIE5hbWVzcGFjZXMgYXJlIGRlbGltaXRlZCBieSAnOicuXG4gICAgICAgIHZhciBhY3Rpb25OYW1lID0gbmFtZVxuICAgICAgICBpZiAoLzovLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICBjb25zdCBhcnIgPSBuYW1lLnNwbGl0KCc6JylcbiAgICAgICAgICB2YXIgbnMgPSBhcnIuc2hpZnQoKVxuICAgICAgICAgIGFjdGlvbk5hbWUgPSBhcnIuam9pbignOicpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBfcmVkdWNlcnMgPSBucyA/IHJlZHVjZXJzW25zXSA6IHJlZHVjZXJzXG4gICAgICAgIGlmIChfcmVkdWNlcnMgJiYgX3JlZHVjZXJzW2FjdGlvbk5hbWVdKSB7XG4gICAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICBjb25zdCByZWR1Y2VkU3RhdGUgPSBfcmVkdWNlcnNbYWN0aW9uTmFtZV0oZGF0YSwgX3N0YXRlW25zXSlcbiAgICAgICAgICAgIG5ld1N0YXRlW25zXSA9IHh0ZW5kKF9zdGF0ZVtuc10sIHJlZHVjZWRTdGF0ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXV0YXRlKG5ld1N0YXRlLCByZWR1Y2Vyc1thY3Rpb25OYW1lXShkYXRhLCBfc3RhdGUpKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZWR1Y2Vyc0NhbGxlZCA9IHRydWVcbiAgICAgICAgICBpZiAob25TdGF0ZUNoYW5nZUhvb2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgYXBwbHlIb29rKG9uU3RhdGVDaGFuZ2VIb29rcywgZGF0YSwgbmV3U3RhdGUsIF9zdGF0ZSwgYWN0aW9uTmFtZSwgY3JlYXRlU2VuZClcbiAgICAgICAgICB9XG4gICAgICAgICAgX3N0YXRlID0gbmV3U3RhdGVcbiAgICAgICAgICBjYihudWxsLCBuZXdTdGF0ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IF9lZmZlY3RzID0gbnMgPyBlZmZlY3RzW25zXSA6IGVmZmVjdHNcbiAgICAgICAgaWYgKCFyZWR1Y2Vyc0NhbGxlZCAmJiBfZWZmZWN0cyAmJiBfZWZmZWN0c1thY3Rpb25OYW1lXSkge1xuICAgICAgICAgIGNvbnN0IHNlbmQgPSBjcmVhdGVTZW5kKCdlZmZlY3Q6ICcgKyBuYW1lKVxuICAgICAgICAgIGlmIChucykgX2VmZmVjdHNbYWN0aW9uTmFtZV0oZGF0YSwgX3N0YXRlW25zXSwgc2VuZCwgY2IpXG4gICAgICAgICAgZWxzZSBfZWZmZWN0c1thY3Rpb25OYW1lXShkYXRhLCBfc3RhdGUsIHNlbmQsIGNiKVxuICAgICAgICAgIGVmZmVjdHNDYWxsZWQgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlZHVjZXJzQ2FsbGVkICYmICFlZmZlY3RzQ2FsbGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBhY3Rpb24gJyArIGFjdGlvbk5hbWUpXG4gICAgICAgIH1cbiAgICAgIH0sIDApXG4gICAgfVxuICB9XG59XG5cbi8vIGNvbXBvc2UgYW4gb2JqZWN0IGNvbmRpdGlvbmFsbHlcbi8vIG9wdGlvbmFsbHkgY29udGFpbnMgYSBuYW1lc3BhY2Vcbi8vIHdoaWNoIGlzIHVzZWQgdG8gbmVzdCBwcm9wZXJ0aWVzLlxuLy8gKHN0ciwgb2JqLCBvYmosIGZuPykgLT4gbnVsbFxuZnVuY3Rpb24gYXBwbHkgKG5zLCBzb3VyY2UsIHRhcmdldCwgd3JhcCkge1xuICBpZiAobnMgJiYgIXRhcmdldFtuc10pIHRhcmdldFtuc10gPSB7fVxuICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGNvbnN0IGNiID0gd3JhcCA/IHdyYXAoc291cmNlW2tleV0sIGtleSkgOiBzb3VyY2Vba2V5XVxuICAgIGlmIChucykgdGFyZ2V0W25zXVtrZXldID0gY2JcbiAgICBlbHNlIHRhcmdldFtrZXldID0gY2JcbiAgfSlcbn1cblxuLy8gaGFuZGxlIGVycm9ycyBhbGwgdGhlIHdheSBhdCB0aGUgdG9wIG9mIHRoZSB0cmFjZVxuLy8gZXJyPyAtPiBudWxsXG5mdW5jdGlvbiBkZWZhdWx0T25FcnJvciAoZXJyKSB7XG4gIHRocm93IGVyclxufVxuXG5mdW5jdGlvbiB3cmFwT25FcnJvciAob25FcnJvcikge1xuICByZXR1cm4gZnVuY3Rpb24gb25FcnJvcldyYXAgKGVyciwgc3RhdGUsIGNyZWF0ZVNlbmQpIHtcbiAgICBpZiAoZXJyKSBvbkVycm9yKGVyciwgc3RhdGUsIGNyZWF0ZVNlbmQpXG4gIH1cbn1cblxuLy8gdGFrZSBhIGFwcGx5IGFuIGFycmF5IG9mIHRyYW5zZm9ybXMgb250byBhIHZhbHVlLiBUaGUgbmV3IHZhbHVlXG4vLyBtdXN0IGJlIHJldHVybmVkIHN5bmNocm9ub3VzbHkgZnJvbSB0aGUgdHJhbnNmb3JtXG4vLyAoYW55LCBbZm5dKSAtPiBhbnlcbmZ1bmN0aW9uIHdyYXBIb29rICh2YWx1ZSwgdHJhbnNmb3Jtcykge1xuICB0cmFuc2Zvcm1zLmZvckVhY2goZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgIHZhbHVlID0gdHJhbnNmb3JtKHZhbHVlKVxuICB9KVxuICByZXR1cm4gdmFsdWVcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnZ2xvYmFsL2RvY3VtZW50JylcbnZhciBoeXBlcnggPSByZXF1aXJlKCdoeXBlcngnKVxudmFyIG9ubG9hZCA9IHJlcXVpcmUoJ29uLWxvYWQnKVxuXG52YXIgU1ZHTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXG52YXIgWExJTktOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJ1xuXG52YXIgQk9PTF9QUk9QUyA9IHtcbiAgYXV0b2ZvY3VzOiAxLFxuICBjaGVja2VkOiAxLFxuICBkZWZhdWx0Y2hlY2tlZDogMSxcbiAgZGlzYWJsZWQ6IDEsXG4gIGZvcm1ub3ZhbGlkYXRlOiAxLFxuICBpbmRldGVybWluYXRlOiAxLFxuICByZWFkb25seTogMSxcbiAgcmVxdWlyZWQ6IDEsXG4gIHNlbGVjdGVkOiAxLFxuICB3aWxsdmFsaWRhdGU6IDFcbn1cbnZhciBDT01NRU5UX1RBRyA9ICchLS0nXG52YXIgU1ZHX1RBR1MgPSBbXG4gICdzdmcnLFxuICAnYWx0R2x5cGgnLCAnYWx0R2x5cGhEZWYnLCAnYWx0R2x5cGhJdGVtJywgJ2FuaW1hdGUnLCAnYW5pbWF0ZUNvbG9yJyxcbiAgJ2FuaW1hdGVNb3Rpb24nLCAnYW5pbWF0ZVRyYW5zZm9ybScsICdjaXJjbGUnLCAnY2xpcFBhdGgnLCAnY29sb3ItcHJvZmlsZScsXG4gICdjdXJzb3InLCAnZGVmcycsICdkZXNjJywgJ2VsbGlwc2UnLCAnZmVCbGVuZCcsICdmZUNvbG9yTWF0cml4JyxcbiAgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLCAnZmVDb21wb3NpdGUnLCAnZmVDb252b2x2ZU1hdHJpeCcsICdmZURpZmZ1c2VMaWdodGluZycsXG4gICdmZURpc3BsYWNlbWVudE1hcCcsICdmZURpc3RhbnRMaWdodCcsICdmZUZsb29kJywgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsXG4gICdmZUZ1bmNHJywgJ2ZlRnVuY1InLCAnZmVHYXVzc2lhbkJsdXInLCAnZmVJbWFnZScsICdmZU1lcmdlJywgJ2ZlTWVyZ2VOb2RlJyxcbiAgJ2ZlTW9ycGhvbG9neScsICdmZU9mZnNldCcsICdmZVBvaW50TGlnaHQnLCAnZmVTcGVjdWxhckxpZ2h0aW5nJyxcbiAgJ2ZlU3BvdExpZ2h0JywgJ2ZlVGlsZScsICdmZVR1cmJ1bGVuY2UnLCAnZmlsdGVyJywgJ2ZvbnQnLCAnZm9udC1mYWNlJyxcbiAgJ2ZvbnQtZmFjZS1mb3JtYXQnLCAnZm9udC1mYWNlLW5hbWUnLCAnZm9udC1mYWNlLXNyYycsICdmb250LWZhY2UtdXJpJyxcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZycsICdnbHlwaCcsICdnbHlwaFJlZicsICdoa2VybicsICdpbWFnZScsICdsaW5lJyxcbiAgJ2xpbmVhckdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21pc3NpbmctZ2x5cGgnLCAnbXBhdGgnLFxuICAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsXG4gICdzZXQnLCAnc3RvcCcsICdzd2l0Y2gnLCAnc3ltYm9sJywgJ3RleHQnLCAndGV4dFBhdGgnLCAndGl0bGUnLCAndHJlZicsXG4gICd0c3BhbicsICd1c2UnLCAndmlldycsICd2a2Vybidcbl1cblxuZnVuY3Rpb24gYmVsQ3JlYXRlRWxlbWVudCAodGFnLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIGVsXG5cbiAgLy8gSWYgYW4gc3ZnIHRhZywgaXQgbmVlZHMgYSBuYW1lc3BhY2VcbiAgaWYgKFNWR19UQUdTLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICBwcm9wcy5uYW1lc3BhY2UgPSBTVkdOU1xuICB9XG5cbiAgLy8gSWYgd2UgYXJlIHVzaW5nIGEgbmFtZXNwYWNlXG4gIHZhciBucyA9IGZhbHNlXG4gIGlmIChwcm9wcy5uYW1lc3BhY2UpIHtcbiAgICBucyA9IHByb3BzLm5hbWVzcGFjZVxuICAgIGRlbGV0ZSBwcm9wcy5uYW1lc3BhY2VcbiAgfVxuXG4gIC8vIENyZWF0ZSB0aGUgZWxlbWVudFxuICBpZiAobnMpIHtcbiAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhucywgdGFnKVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gQ09NTUVOVF9UQUcpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudChwcm9wcy5jb21tZW50KVxuICB9IGVsc2Uge1xuICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpXG4gIH1cblxuICAvLyBJZiBhZGRpbmcgb25sb2FkIGV2ZW50c1xuICBpZiAocHJvcHMub25sb2FkIHx8IHByb3BzLm9udW5sb2FkKSB7XG4gICAgdmFyIGxvYWQgPSBwcm9wcy5vbmxvYWQgfHwgZnVuY3Rpb24gKCkge31cbiAgICB2YXIgdW5sb2FkID0gcHJvcHMub251bmxvYWQgfHwgZnVuY3Rpb24gKCkge31cbiAgICBvbmxvYWQoZWwsIGZ1bmN0aW9uIGJlbE9ubG9hZCAoKSB7XG4gICAgICBsb2FkKGVsKVxuICAgIH0sIGZ1bmN0aW9uIGJlbE9udW5sb2FkICgpIHtcbiAgICAgIHVubG9hZChlbClcbiAgICB9LFxuICAgIC8vIFdlIGhhdmUgdG8gdXNlIG5vbi1zdGFuZGFyZCBgY2FsbGVyYCB0byBmaW5kIHdobyBpbnZva2VzIGBiZWxDcmVhdGVFbGVtZW50YFxuICAgIGJlbENyZWF0ZUVsZW1lbnQuY2FsbGVyLmNhbGxlci5jYWxsZXIpXG4gICAgZGVsZXRlIHByb3BzLm9ubG9hZFxuICAgIGRlbGV0ZSBwcm9wcy5vbnVubG9hZFxuICB9XG5cbiAgLy8gQ3JlYXRlIHRoZSBwcm9wZXJ0aWVzXG4gIGZvciAodmFyIHAgaW4gcHJvcHMpIHtcbiAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgIHZhciBrZXkgPSBwLnRvTG93ZXJDYXNlKClcbiAgICAgIHZhciB2YWwgPSBwcm9wc1twXVxuICAgICAgLy8gTm9ybWFsaXplIGNsYXNzTmFtZVxuICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzbmFtZScpIHtcbiAgICAgICAga2V5ID0gJ2NsYXNzJ1xuICAgICAgICBwID0gJ2NsYXNzJ1xuICAgICAgfVxuICAgICAgLy8gVGhlIGZvciBhdHRyaWJ1dGUgZ2V0cyB0cmFuc2Zvcm1lZCB0byBodG1sRm9yLCBidXQgd2UganVzdCBzZXQgYXMgZm9yXG4gICAgICBpZiAocCA9PT0gJ2h0bWxGb3InKSB7XG4gICAgICAgIHAgPSAnZm9yJ1xuICAgICAgfVxuICAgICAgLy8gSWYgYSBwcm9wZXJ0eSBpcyBib29sZWFuLCBzZXQgaXRzZWxmIHRvIHRoZSBrZXlcbiAgICAgIGlmIChCT09MX1BST1BTW2tleV0pIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gJ3RydWUnKSB2YWwgPSBrZXlcbiAgICAgICAgZWxzZSBpZiAodmFsID09PSAnZmFsc2UnKSBjb250aW51ZVxuICAgICAgfVxuICAgICAgLy8gSWYgYSBwcm9wZXJ0eSBwcmVmZXJzIGJlaW5nIHNldCBkaXJlY3RseSB2cyBzZXRBdHRyaWJ1dGVcbiAgICAgIGlmIChrZXkuc2xpY2UoMCwgMikgPT09ICdvbicpIHtcbiAgICAgICAgZWxbcF0gPSB2YWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgIGlmIChwID09PSAneGxpbms6aHJlZicpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKFhMSU5LTlMsIHAsIHZhbClcbiAgICAgICAgICB9IGVsc2UgaWYgKC9eeG1sbnMoJHw6KS9pLnRlc3QocCkpIHtcbiAgICAgICAgICAgIC8vIHNraXAgeG1sbnMgZGVmaW5pdGlvbnNcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgcCwgdmFsKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUocCwgdmFsKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKGNoaWxkcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHMpKSByZXR1cm5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBjaGlsZHNbaV1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgIGFwcGVuZENoaWxkKG5vZGUpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgdHlwZW9mIG5vZGUgPT09ICdib29sZWFuJyB8fFxuICAgICAgICB0eXBlb2Ygbm9kZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICBub2RlIGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICBub2RlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnRvU3RyaW5nKClcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZWwubGFzdENoaWxkICYmIGVsLmxhc3RDaGlsZC5ub2RlTmFtZSA9PT0gJyN0ZXh0Jykge1xuICAgICAgICAgIGVsLmxhc3RDaGlsZC5ub2RlVmFsdWUgKz0gbm9kZVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUpXG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQobm9kZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXBwZW5kQ2hpbGQoY2hpbGRyZW4pXG5cbiAgcmV0dXJuIGVsXG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwZXJ4KGJlbENyZWF0ZUVsZW1lbnQsIHtjb21tZW50czogdHJ1ZX0pXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHNcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBiZWxDcmVhdGVFbGVtZW50XG4iLCIiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCd5by15bycpXG4iLCJjb25zdCBoaXN0b3J5ID0gcmVxdWlyZSgnc2hlZXQtcm91dGVyL2hpc3RvcnknKVxuY29uc3Qgc2hlZXRSb3V0ZXIgPSByZXF1aXJlKCdzaGVldC1yb3V0ZXInKVxuY29uc3QgZG9jdW1lbnQgPSByZXF1aXJlKCdnbG9iYWwvZG9jdW1lbnQnKVxuY29uc3Qgb25SZWFkeSA9IHJlcXVpcmUoJ2RvY3VtZW50LXJlYWR5JylcbmNvbnN0IGhyZWYgPSByZXF1aXJlKCdzaGVldC1yb3V0ZXIvaHJlZicpXG5jb25zdCBoYXNoID0gcmVxdWlyZSgnc2hlZXQtcm91dGVyL2hhc2gnKVxuY29uc3QgaGFzaE1hdGNoID0gcmVxdWlyZSgnaGFzaC1tYXRjaCcpXG5jb25zdCBiYXJyYWNrcyA9IHJlcXVpcmUoJ2JhcnJhY2tzJylcbmNvbnN0IG5hbm9yYWYgPSByZXF1aXJlKCduYW5vcmFmJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbmNvbnN0IHlvID0gcmVxdWlyZSgneW8teW8nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNob29cblxuLy8gZnJhbWV3b3JrIGZvciBjcmVhdGluZyBzdHVyZHkgd2ViIGFwcGxpY2F0aW9uc1xuLy8gbnVsbCAtPiBmblxuZnVuY3Rpb24gY2hvbyAob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIGNvbnN0IF9zdG9yZSA9IHN0YXJ0Ll9zdG9yZSA9IGJhcnJhY2tzKClcbiAgdmFyIF9yb3V0ZXIgPSBzdGFydC5fcm91dGVyID0gbnVsbFxuICB2YXIgX2RlZmF1bHRSb3V0ZSA9IG51bGxcbiAgdmFyIF9yb290Tm9kZSA9IG51bGxcbiAgdmFyIF9yb3V0ZXMgPSBudWxsXG4gIHZhciBfZnJhbWUgPSBudWxsXG5cbiAgX3N0b3JlLnVzZSh7IG9uU3RhdGVDaGFuZ2U6IHJlbmRlciB9KVxuICBfc3RvcmUudXNlKG9wdHMpXG5cbiAgc3RhcnQudG9TdHJpbmcgPSB0b1N0cmluZ1xuICBzdGFydC5yb3V0ZXIgPSByb3V0ZXJcbiAgc3RhcnQubW9kZWwgPSBtb2RlbFxuICBzdGFydC5zdGFydCA9IHN0YXJ0XG4gIHN0YXJ0LnVzZSA9IHVzZVxuXG4gIHJldHVybiBzdGFydFxuXG4gIC8vIHJlbmRlciB0aGUgYXBwbGljYXRpb24gdG8gYSBzdHJpbmdcbiAgLy8gKHN0ciwgb2JqKSAtPiBzdHJcbiAgZnVuY3Rpb24gdG9TdHJpbmcgKHJvdXRlLCBzZXJ2ZXJTdGF0ZSkge1xuICAgIHNlcnZlclN0YXRlID0gc2VydmVyU3RhdGUgfHwge31cbiAgICBhc3NlcnQuZXF1YWwodHlwZW9mIHJvdXRlLCAnc3RyaW5nJywgJ2Nob28uYXBwLnRvU3RyaW5nOiByb3V0ZSBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICBhc3NlcnQuZXF1YWwodHlwZW9mIHNlcnZlclN0YXRlLCAnb2JqZWN0JywgJ2Nob28uYXBwLnRvU3RyaW5nOiBzZXJ2ZXJTdGF0ZSBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgX3N0b3JlLnN0YXJ0KHsgc3Vic2NyaXB0aW9uczogZmFsc2UsIHJlZHVjZXJzOiBmYWxzZSwgZWZmZWN0czogZmFsc2UgfSlcblxuICAgIGNvbnN0IHN0YXRlID0gX3N0b3JlLnN0YXRlKHsgc3RhdGU6IHNlcnZlclN0YXRlIH0pXG4gICAgY29uc3Qgcm91dGVyID0gY3JlYXRlUm91dGVyKF9kZWZhdWx0Um91dGUsIF9yb3V0ZXMsIGNyZWF0ZVNlbmQpXG4gICAgY29uc3QgdHJlZSA9IHJvdXRlcihyb3V0ZSwgc3RhdGUpXG4gICAgcmV0dXJuIHRyZWUub3V0ZXJIVE1MIHx8IHRyZWUudG9TdHJpbmcoKVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU2VuZCAoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2VuZCAoKSB7XG4gICAgICAgIGFzc2VydC5vayhmYWxzZSwgJ2Nob286IHNlbmQoKSBjYW5ub3QgYmUgY2FsbGVkIGZyb20gTm9kZScpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gc3RhcnQgdGhlIGFwcGxpY2F0aW9uXG4gIC8vIChzdHI/LCBvYmo/KSAtPiBET01Ob2RlXG4gIGZ1bmN0aW9uIHN0YXJ0IChzZWxlY3Rvciwgc3RhcnRPcHRzKSB7XG4gICAgaWYgKCFzdGFydE9wdHMgJiYgdHlwZW9mIHNlbGVjdG9yICE9PSAnc3RyaW5nJykge1xuICAgICAgc3RhcnRPcHRzID0gc2VsZWN0b3JcbiAgICAgIHNlbGVjdG9yID0gbnVsbFxuICAgIH1cbiAgICBzdGFydE9wdHMgPSBzdGFydE9wdHMgfHwge31cblxuICAgIF9zdG9yZS5tb2RlbChhcHBJbml0KHN0YXJ0T3B0cykpXG4gICAgY29uc3QgY3JlYXRlU2VuZCA9IF9zdG9yZS5zdGFydChzdGFydE9wdHMpXG4gICAgX3JvdXRlciA9IHN0YXJ0Ll9yb3V0ZXIgPSBjcmVhdGVSb3V0ZXIoX2RlZmF1bHRSb3V0ZSwgX3JvdXRlcywgY3JlYXRlU2VuZClcbiAgICBjb25zdCBzdGF0ZSA9IF9zdG9yZS5zdGF0ZSh7c3RhdGU6IHt9fSlcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIGNvbnN0IHRyZWUgPSBfcm91dGVyKHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lLCBzdGF0ZSlcbiAgICAgIF9yb290Tm9kZSA9IHRyZWVcbiAgICAgIHJldHVybiB0cmVlXG4gICAgfSBlbHNlIHtcbiAgICAgIG9uUmVhZHkoZnVuY3Rpb24gb25SZWFkeSAoKSB7XG4gICAgICAgIGNvbnN0IG9sZFRyZWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICAgICAgICBhc3NlcnQub2sob2xkVHJlZSwgJ2NvdWxkIG5vdCBxdWVyeSBzZWxlY3RvcjogJyArIHNlbGVjdG9yKVxuICAgICAgICBjb25zdCBuZXdUcmVlID0gX3JvdXRlcihzdGF0ZS5sb2NhdGlvbi5wYXRobmFtZSwgc3RhdGUpXG4gICAgICAgIF9yb290Tm9kZSA9IHlvLnVwZGF0ZShvbGRUcmVlLCBuZXdUcmVlKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyB1cGRhdGUgdGhlIERPTSBhZnRlciBldmVyeSBzdGF0ZSBtdXRhdGlvblxuICAvLyAob2JqLCBvYmosIG9iaiwgc3RyLCBmbikgLT4gbnVsbFxuICBmdW5jdGlvbiByZW5kZXIgKGRhdGEsIHN0YXRlLCBwcmV2LCBuYW1lLCBjcmVhdGVTZW5kKSB7XG4gICAgaWYgKCFfZnJhbWUpIHtcbiAgICAgIF9mcmFtZSA9IG5hbm9yYWYoZnVuY3Rpb24gKHN0YXRlLCBwcmV2KSB7XG4gICAgICAgIGNvbnN0IG5ld1RyZWUgPSBfcm91dGVyKHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lLCBzdGF0ZSwgcHJldilcbiAgICAgICAgX3Jvb3ROb2RlID0geW8udXBkYXRlKF9yb290Tm9kZSwgbmV3VHJlZSlcbiAgICAgIH0pXG4gICAgfVxuICAgIF9mcmFtZShzdGF0ZSwgcHJldilcbiAgfVxuXG4gIC8vIHJlZ2lzdGVyIGFsbCByb3V0ZXMgb24gdGhlIHJvdXRlclxuICAvLyAoc3RyPywgW2ZufFtmbl1dKSAtPiBvYmpcbiAgZnVuY3Rpb24gcm91dGVyIChkZWZhdWx0Um91dGUsIHJvdXRlcykge1xuICAgIF9kZWZhdWx0Um91dGUgPSBkZWZhdWx0Um91dGVcbiAgICBfcm91dGVzID0gcm91dGVzXG4gIH1cblxuICAvLyBjcmVhdGUgYSBuZXcgbW9kZWxcbiAgLy8gKHN0cj8sIG9iaikgLT4gbnVsbFxuICBmdW5jdGlvbiBtb2RlbCAobW9kZWwpIHtcbiAgICBfc3RvcmUubW9kZWwobW9kZWwpXG4gIH1cblxuICAvLyByZWdpc3RlciBhIHBsdWdpblxuICAvLyAob2JqKSAtPiBudWxsXG4gIGZ1bmN0aW9uIHVzZSAoaG9va3MpIHtcbiAgICBhc3NlcnQuZXF1YWwodHlwZW9mIGhvb2tzLCAnb2JqZWN0JywgJ2Nob28udXNlOiBob29rcyBzaG91bGQgYmUgYW4gb2JqZWN0JylcbiAgICBfc3RvcmUudXNlKGhvb2tzKVxuICB9XG5cbiAgLy8gY3JlYXRlIGEgbmV3IHJvdXRlciB3aXRoIGEgY3VzdG9tIGBjcmVhdGVSb3V0ZSgpYCBmdW5jdGlvblxuICAvLyAoc3RyPywgb2JqLCBmbj8pIC0+IG51bGxcbiAgZnVuY3Rpb24gY3JlYXRlUm91dGVyIChkZWZhdWx0Um91dGUsIHJvdXRlcywgY3JlYXRlU2VuZCkge1xuICAgIHZhciBwcmV2ID0geyBwYXJhbXM6IHt9IH1cbiAgICByZXR1cm4gc2hlZXRSb3V0ZXIoZGVmYXVsdFJvdXRlLCByb3V0ZXMsIGNyZWF0ZVJvdXRlKVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91dGUgKHJvdXRlRm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAocm91dGUsIGlubGluZSwgY2hpbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbmxpbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpbmxpbmUgPSB3cmFwKGlubGluZSwgcm91dGUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvdXRlRm4ocm91dGUsIGlubGluZSwgY2hpbGQpXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXAgKGNoaWxkLCByb3V0ZSkge1xuICAgICAgICBjb25zdCBzZW5kID0gY3JlYXRlU2VuZCgndmlldzogJyArIHJvdXRlLCB0cnVlKVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2hvb1dyYXAgKHBhcmFtcywgc3RhdGUpIHtcbiAgICAgICAgICBjb25zdCBud1ByZXYgPSBwcmV2XG4gICAgICAgICAgY29uc3QgbndTdGF0ZSA9IHByZXYgPSB4dGVuZChzdGF0ZSwgeyBwYXJhbXM6IHBhcmFtcyB9KVxuICAgICAgICAgIGlmIChvcHRzLmZyZWV6ZSAhPT0gZmFsc2UpIE9iamVjdC5mcmVlemUobndTdGF0ZSlcbiAgICAgICAgICByZXR1cm4gY2hpbGQobndTdGF0ZSwgbndQcmV2LCBzZW5kKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIGluaXRpYWwgYXBwbGljYXRpb24gc3RhdGUgbW9kZWxcbi8vIG9iaiAtPiBvYmpcbmZ1bmN0aW9uIGFwcEluaXQgKG9wdHMpIHtcbiAgY29uc3QgbG9jID0gZG9jdW1lbnQubG9jYXRpb25cbiAgY29uc3Qgc3RhdGUgPSB7IHBhdGhuYW1lOiAob3B0cy5oYXNoKSA/IGhhc2hNYXRjaChsb2MuaGFzaCkgOiBsb2MuaHJlZiB9XG4gIGNvbnN0IHJlZHVjZXJzID0ge1xuICAgIHNldExvY2F0aW9uOiBmdW5jdGlvbiBzZXRMb2NhdGlvbiAoZGF0YSwgc3RhdGUpIHtcbiAgICAgIHJldHVybiB7IHBhdGhuYW1lOiBkYXRhLmxvY2F0aW9uLnJlcGxhY2UoLyMuKi8sICcnKSB9XG4gICAgfVxuICB9XG4gIC8vIGlmIGhhc2ggcm91dGluZyBleHBsaWNpdGx5IGVuYWJsZWQsIHN1YnNjcmliZSB0byBpdFxuICBjb25zdCBzdWJzID0ge31cbiAgaWYgKG9wdHMuaGFzaCA9PT0gdHJ1ZSkge1xuICAgIHB1c2hMb2NhdGlvblN1YihmdW5jdGlvbiAobmF2aWdhdGUpIHtcbiAgICAgIGhhc2goZnVuY3Rpb24gKGZyYWdtZW50KSB7XG4gICAgICAgIG5hdmlnYXRlKGhhc2hNYXRjaChmcmFnbWVudCkpXG4gICAgICB9KVxuICAgIH0sICdoYW5kbGVIYXNoJywgc3VicylcbiAgfSBlbHNlIHtcbiAgICBpZiAob3B0cy5oaXN0b3J5ICE9PSBmYWxzZSkgcHVzaExvY2F0aW9uU3ViKGhpc3RvcnksICdoYW5kbGVIaXN0b3J5Jywgc3VicylcbiAgICBpZiAob3B0cy5ocmVmICE9PSBmYWxzZSkgcHVzaExvY2F0aW9uU3ViKGhyZWYsICdoYW5kbGVIcmVmJywgc3VicylcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZXNwYWNlOiAnbG9jYXRpb24nLFxuICAgIHN1YnNjcmlwdGlvbnM6IHN1YnMsXG4gICAgcmVkdWNlcnM6IHJlZHVjZXJzLFxuICAgIHN0YXRlOiBzdGF0ZVxuICB9XG5cbiAgLy8gY3JlYXRlIGEgbmV3IHN1YnNjcmlwdGlvbiB0aGF0IG1vZGlmaWVzXG4gIC8vICdhcHA6bG9jYXRpb24nIGFuZCBwdXNoIGl0IHRvIGJlIGxvYWRlZFxuICAvLyAoZm4sIG9iaikgLT4gbnVsbFxuICBmdW5jdGlvbiBwdXNoTG9jYXRpb25TdWIgKGNiLCBrZXksIG1vZGVsKSB7XG4gICAgbW9kZWxba2V5XSA9IGZ1bmN0aW9uIChzZW5kLCBkb25lKSB7XG4gICAgICBjYihmdW5jdGlvbiBuYXZpZ2F0ZSAocGF0aG5hbWUpIHtcbiAgICAgICAgc2VuZCgnbG9jYXRpb246c2V0TG9jYXRpb24nLCB7IGxvY2F0aW9uOiBwYXRobmFtZSB9LCBkb25lKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCdnbG9iYWwvZG9jdW1lbnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIgPyByZWFkeSA6IG5vb3BcblxuZnVuY3Rpb24gcmVhZHkgKGNhbGxiYWNrKSB7XG4gIHZhciBzdGF0ZSA9IGRvY3VtZW50LnJlYWR5U3RhdGVcbiAgaWYgKHN0YXRlID09PSAnY29tcGxldGUnIHx8IHN0YXRlID09PSAnaW50ZXJhY3RpdmUnKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIDApXG4gIH1cblxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gb25Mb2FkICgpIHtcbiAgICBjYWxsYmFjaygpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cbiIsInZhciB0b3BMZXZlbCA9IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDpcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9XG52YXIgbWluRG9jID0gcmVxdWlyZSgnbWluLWRvY3VtZW50Jyk7XG5cbnZhciBkb2NjeTtcblxuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkb2NjeSA9IGRvY3VtZW50O1xufSBlbHNlIHtcbiAgICBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J107XG5cbiAgICBpZiAoIWRvY2N5KSB7XG4gICAgICAgIGRvY2N5ID0gdG9wTGV2ZWxbJ19fR0xPQkFMX0RPQ1VNRU5UX0NBQ0hFQDQnXSA9IG1pbkRvYztcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG9jY3k7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJ2YXIgdG9wTGV2ZWwgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fVxudmFyIG1pbkRvYyA9IHJlcXVpcmUoJ21pbi1kb2N1bWVudCcpO1xuXG52YXIgZG9jY3k7XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZG9jY3kgPSBkb2N1bWVudDtcbn0gZWxzZSB7XG4gICAgZG9jY3kgPSB0b3BMZXZlbFsnX19HTE9CQUxfRE9DVU1FTlRfQ0FDSEVANCddO1xuXG4gICAgaWYgKCFkb2NjeSkge1xuICAgICAgICBkb2NjeSA9IHRvcExldmVsWydfX0dMT0JBTF9ET0NVTUVOVF9DQUNIRUA0J10gPSBtaW5Eb2M7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRvY2N5O1xuIiwidmFyIHdpbjtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW4gPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW4gPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICB3aW4gPSBzZWxmO1xufSBlbHNlIHtcbiAgICB3aW4gPSB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3aW47XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc2hNYXRjaCAoaGFzaCwgcHJlZml4KSB7XG4gIHZhciBwcmUgPSBwcmVmaXggfHwgJy8nO1xuICBpZiAoaGFzaC5sZW5ndGggPT09IDApIHJldHVybiBwcmU7XG4gIGhhc2ggPSBoYXNoLnJlcGxhY2UoJyMnLCAnJyk7XG4gIGhhc2ggPSBoYXNoLnJlcGxhY2UoL1xcLyQvLCAnJylcbiAgaWYgKGhhc2guaW5kZXhPZignLycpICE9IDApIGhhc2ggPSAnLycgKyBoYXNoO1xuICBpZiAocHJlID09ICcvJykgcmV0dXJuIGhhc2g7XG4gIGVsc2UgcmV0dXJuIGhhc2gucmVwbGFjZShwcmUsICcnKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYXR0cmlidXRlVG9Qcm9wZXJ0eVxuXG52YXIgdHJhbnNmb3JtID0ge1xuICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcbiAgJ2Zvcic6ICdodG1sRm9yJyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2J1xufVxuXG5mdW5jdGlvbiBhdHRyaWJ1dGVUb1Byb3BlcnR5IChoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGFnTmFtZSwgYXR0cnMsIGNoaWxkcmVuKSB7XG4gICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xuICAgICAgaWYgKGF0dHIgaW4gdHJhbnNmb3JtKSB7XG4gICAgICAgIGF0dHJzW3RyYW5zZm9ybVthdHRyXV0gPSBhdHRyc1thdHRyXVxuICAgICAgICBkZWxldGUgYXR0cnNbYXR0cl1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGgodGFnTmFtZSwgYXR0cnMsIGNoaWxkcmVuKVxuICB9XG59XG4iLCJ2YXIgYXR0clRvUHJvcCA9IHJlcXVpcmUoJ2h5cGVyc2NyaXB0LWF0dHJpYnV0ZS10by1wcm9wZXJ0eScpXG5cbnZhciBWQVIgPSAwLCBURVhUID0gMSwgT1BFTiA9IDIsIENMT1NFID0gMywgQVRUUiA9IDRcbnZhciBBVFRSX0tFWSA9IDUsIEFUVFJfS0VZX1cgPSA2XG52YXIgQVRUUl9WQUxVRV9XID0gNywgQVRUUl9WQUxVRSA9IDhcbnZhciBBVFRSX1ZBTFVFX1NRID0gOSwgQVRUUl9WQUxVRV9EUSA9IDEwXG52YXIgQVRUUl9FUSA9IDExLCBBVFRSX0JSRUFLID0gMTJcbnZhciBDT01NRU5UID0gMTNcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICB2YXIgY29uY2F0ID0gb3B0cy5jb25jYXQgfHwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gU3RyaW5nKGEpICsgU3RyaW5nKGIpXG4gIH1cbiAgaWYgKG9wdHMuYXR0clRvUHJvcCAhPT0gZmFsc2UpIHtcbiAgICBoID0gYXR0clRvUHJvcChoKVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChzdHJpbmdzKSB7XG4gICAgdmFyIHN0YXRlID0gVEVYVCwgcmVnID0gJydcbiAgICB2YXIgYXJnbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgIHZhciBwYXJ0cyA9IFtdXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpIDwgYXJnbGVuIC0gMSkge1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2krMV1cbiAgICAgICAgdmFyIHAgPSBwYXJzZShzdHJpbmdzW2ldKVxuICAgICAgICB2YXIgeHN0YXRlID0gc3RhdGVcbiAgICAgICAgaWYgKHhzdGF0ZSA9PT0gQVRUUl9WQUxVRV9EUSkgeHN0YXRlID0gQVRUUl9WQUxVRVxuICAgICAgICBpZiAoeHN0YXRlID09PSBBVFRSX1ZBTFVFX1NRKSB4c3RhdGUgPSBBVFRSX1ZBTFVFXG4gICAgICAgIGlmICh4c3RhdGUgPT09IEFUVFJfVkFMVUVfVykgeHN0YXRlID0gQVRUUl9WQUxVRVxuICAgICAgICBpZiAoeHN0YXRlID09PSBBVFRSKSB4c3RhdGUgPSBBVFRSX0tFWVxuICAgICAgICBpZiAoeHN0YXRlID09PSBPUEVOKSB7XG4gICAgICAgICAgaWYgKHJlZyA9PT0gJy8nKSB7XG4gICAgICAgICAgICBwLnB1c2goWyBPUEVOLCAnLycsIGFyZyBdKVxuICAgICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcC5wdXNoKFsgT1BFTiwgYXJnIF0pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHhzdGF0ZSA9PT0gQ09NTUVOVCAmJiBvcHRzLmNvbW1lbnRzKSB7XG4gICAgICAgICAgcmVnICs9IFN0cmluZyhhcmcpXG4gICAgICAgIH0gZWxzZSBpZiAoeHN0YXRlICE9PSBDT01NRU5UKSB7XG4gICAgICAgICAgcC5wdXNoKFsgVkFSLCB4c3RhdGUsIGFyZyBdKVxuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2guYXBwbHkocGFydHMsIHApXG4gICAgICB9IGVsc2UgcGFydHMucHVzaC5hcHBseShwYXJ0cywgcGFyc2Uoc3RyaW5nc1tpXSkpXG4gICAgfVxuXG4gICAgdmFyIHRyZWUgPSBbbnVsbCx7fSxbXV1cbiAgICB2YXIgc3RhY2sgPSBbW3RyZWUsLTFdXVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXIgPSBzdGFja1tzdGFjay5sZW5ndGgtMV1bMF1cbiAgICAgIHZhciBwID0gcGFydHNbaV0sIHMgPSBwWzBdXG4gICAgICBpZiAocyA9PT0gT1BFTiAmJiAvXlxcLy8udGVzdChwWzFdKSkge1xuICAgICAgICB2YXIgaXggPSBzdGFja1tzdGFjay5sZW5ndGgtMV1bMV1cbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aC0xXVswXVsyXVtpeF0gPSBoKFxuICAgICAgICAgICAgY3VyWzBdLCBjdXJbMV0sIGN1clsyXS5sZW5ndGggPyBjdXJbMl0gOiB1bmRlZmluZWRcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocyA9PT0gT1BFTikge1xuICAgICAgICB2YXIgYyA9IFtwWzFdLHt9LFtdXVxuICAgICAgICBjdXJbMl0ucHVzaChjKVxuICAgICAgICBzdGFjay5wdXNoKFtjLGN1clsyXS5sZW5ndGgtMV0pXG4gICAgICB9IGVsc2UgaWYgKHMgPT09IEFUVFJfS0VZIHx8IChzID09PSBWQVIgJiYgcFsxXSA9PT0gQVRUUl9LRVkpKSB7XG4gICAgICAgIHZhciBrZXkgPSAnJ1xuICAgICAgICB2YXIgY29weUtleVxuICAgICAgICBmb3IgKDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBhcnRzW2ldWzBdID09PSBBVFRSX0tFWSkge1xuICAgICAgICAgICAga2V5ID0gY29uY2F0KGtleSwgcGFydHNbaV1bMV0pXG4gICAgICAgICAgfSBlbHNlIGlmIChwYXJ0c1tpXVswXSA9PT0gVkFSICYmIHBhcnRzW2ldWzFdID09PSBBVFRSX0tFWSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0c1tpXVsyXSA9PT0gJ29iamVjdCcgJiYgIWtleSkge1xuICAgICAgICAgICAgICBmb3IgKGNvcHlLZXkgaW4gcGFydHNbaV1bMl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHNbaV1bMl0uaGFzT3duUHJvcGVydHkoY29weUtleSkgJiYgIWN1clsxXVtjb3B5S2V5XSkge1xuICAgICAgICAgICAgICAgICAgY3VyWzFdW2NvcHlLZXldID0gcGFydHNbaV1bMl1bY29weUtleV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGtleSA9IGNvbmNhdChrZXksIHBhcnRzW2ldWzJdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0c1tpXVswXSA9PT0gQVRUUl9FUSkgaSsrXG4gICAgICAgIHZhciBqID0gaVxuICAgICAgICBmb3IgKDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHBhcnRzW2ldWzBdID09PSBBVFRSX1ZBTFVFIHx8IHBhcnRzW2ldWzBdID09PSBBVFRSX0tFWSkge1xuICAgICAgICAgICAgaWYgKCFjdXJbMV1ba2V5XSkgY3VyWzFdW2tleV0gPSBzdHJmbihwYXJ0c1tpXVsxXSlcbiAgICAgICAgICAgIGVsc2UgcGFydHNbaV1bMV09PT1cIlwiIHx8IChjdXJbMV1ba2V5XSA9IGNvbmNhdChjdXJbMV1ba2V5XSwgcGFydHNbaV1bMV0pKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzW2ldWzBdID09PSBWQVJcbiAgICAgICAgICAmJiAocGFydHNbaV1bMV0gPT09IEFUVFJfVkFMVUUgfHwgcGFydHNbaV1bMV0gPT09IEFUVFJfS0VZKSkge1xuICAgICAgICAgICAgaWYgKCFjdXJbMV1ba2V5XSkgY3VyWzFdW2tleV0gPSBzdHJmbihwYXJ0c1tpXVsyXSlcbiAgICAgICAgICAgIGVsc2UgcGFydHNbaV1bMl09PT1cIlwiIHx8IChjdXJbMV1ba2V5XSA9IGNvbmNhdChjdXJbMV1ba2V5XSwgcGFydHNbaV1bMl0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGtleS5sZW5ndGggJiYgIWN1clsxXVtrZXldICYmIGkgPT09IGpcbiAgICAgICAgICAgICYmIChwYXJ0c1tpXVswXSA9PT0gQ0xPU0UgfHwgcGFydHNbaV1bMF0gPT09IEFUVFJfQlJFQUspKSB7XG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjYm9vbGVhbi1hdHRyaWJ1dGVzXG4gICAgICAgICAgICAgIC8vIGVtcHR5IHN0cmluZyBpcyBmYWxzeSwgbm90IHdlbGwgYmVoYXZlZCB2YWx1ZSBpbiBicm93c2VyXG4gICAgICAgICAgICAgIGN1clsxXVtrZXldID0ga2V5LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJ0c1tpXVswXSA9PT0gQ0xPU0UpIHtcbiAgICAgICAgICAgICAgaS0tXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzID09PSBBVFRSX0tFWSkge1xuICAgICAgICBjdXJbMV1bcFsxXV0gPSB0cnVlXG4gICAgICB9IGVsc2UgaWYgKHMgPT09IFZBUiAmJiBwWzFdID09PSBBVFRSX0tFWSkge1xuICAgICAgICBjdXJbMV1bcFsyXV0gPSB0cnVlXG4gICAgICB9IGVsc2UgaWYgKHMgPT09IENMT1NFKSB7XG4gICAgICAgIGlmIChzZWxmQ2xvc2luZyhjdXJbMF0pICYmIHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBpeCA9IHN0YWNrW3N0YWNrLmxlbmd0aC0xXVsxXVxuICAgICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoLTFdWzBdWzJdW2l4XSA9IGgoXG4gICAgICAgICAgICBjdXJbMF0sIGN1clsxXSwgY3VyWzJdLmxlbmd0aCA/IGN1clsyXSA6IHVuZGVmaW5lZFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzID09PSBWQVIgJiYgcFsxXSA9PT0gVEVYVCkge1xuICAgICAgICBpZiAocFsyXSA9PT0gdW5kZWZpbmVkIHx8IHBbMl0gPT09IG51bGwpIHBbMl0gPSAnJ1xuICAgICAgICBlbHNlIGlmICghcFsyXSkgcFsyXSA9IGNvbmNhdCgnJywgcFsyXSlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocFsyXVswXSkpIHtcbiAgICAgICAgICBjdXJbMl0ucHVzaC5hcHBseShjdXJbMl0sIHBbMl0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VyWzJdLnB1c2gocFsyXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzID09PSBURVhUKSB7XG4gICAgICAgIGN1clsyXS5wdXNoKHBbMV0pXG4gICAgICB9IGVsc2UgaWYgKHMgPT09IEFUVFJfRVEgfHwgcyA9PT0gQVRUUl9CUkVBSykge1xuICAgICAgICAvLyBuby1vcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmhhbmRsZWQ6ICcgKyBzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmVlWzJdLmxlbmd0aCA+IDEgJiYgL15cXHMqJC8udGVzdCh0cmVlWzJdWzBdKSkge1xuICAgICAgdHJlZVsyXS5zaGlmdCgpXG4gICAgfVxuXG4gICAgaWYgKHRyZWVbMl0ubGVuZ3RoID4gMlxuICAgIHx8ICh0cmVlWzJdLmxlbmd0aCA9PT0gMiAmJiAvXFxTLy50ZXN0KHRyZWVbMl1bMV0pKSkge1xuICAgICAgaWYgKG9wdHMuY3JlYXRlRnJhZ21lbnQpIHJldHVybiBvcHRzLmNyZWF0ZUZyYWdtZW50KHRyZWVbMl0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdtdWx0aXBsZSByb290IGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBpbiBhbiBlbmNsb3NpbmcgdGFnJ1xuICAgICAgKVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlWzJdWzBdKSAmJiB0eXBlb2YgdHJlZVsyXVswXVswXSA9PT0gJ3N0cmluZydcbiAgICAmJiBBcnJheS5pc0FycmF5KHRyZWVbMl1bMF1bMl0pKSB7XG4gICAgICB0cmVlWzJdWzBdID0gaCh0cmVlWzJdWzBdWzBdLCB0cmVlWzJdWzBdWzFdLCB0cmVlWzJdWzBdWzJdKVxuICAgIH1cbiAgICByZXR1cm4gdHJlZVsyXVswXVxuXG4gICAgZnVuY3Rpb24gcGFyc2UgKHN0cikge1xuICAgICAgdmFyIHJlcyA9IFtdXG4gICAgICBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUVfVykgc3RhdGUgPSBBVFRSXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSlcbiAgICAgICAgaWYgKHN0YXRlID09PSBURVhUICYmIGMgPT09ICc8Jykge1xuICAgICAgICAgIGlmIChyZWcubGVuZ3RoKSByZXMucHVzaChbVEVYVCwgcmVnXSlcbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gT1BFTlxuICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICc+JyAmJiAhcXVvdChzdGF0ZSkgJiYgc3RhdGUgIT09IENPTU1FTlQpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IE9QRU4gJiYgcmVnLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzLnB1c2goW09QRU4scmVnXSlcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX0tFWSkge1xuICAgICAgICAgICAgcmVzLnB1c2goW0FUVFJfS0VZLHJlZ10pXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRSAmJiByZWcubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWddKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXMucHVzaChbQ0xPU0VdKVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBURVhUXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IENPTU1FTlQgJiYgLy0kLy50ZXN0KHJlZykgJiYgYyA9PT0gJy0nKSB7XG4gICAgICAgICAgaWYgKG9wdHMuY29tbWVudHMpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX1ZBTFVFLHJlZy5zdWJzdHIoMCwgcmVnLmxlbmd0aCAtIDEpXSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IFRFWFRcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gT1BFTiAmJiAvXiEtLSQvLnRlc3QocmVnKSkge1xuICAgICAgICAgIGlmIChvcHRzLmNvbW1lbnRzKSB7XG4gICAgICAgICAgICByZXMucHVzaChbT1BFTiwgcmVnXSxbQVRUUl9LRVksJ2NvbW1lbnQnXSxbQVRUUl9FUV0pXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZyA9IGNcbiAgICAgICAgICBzdGF0ZSA9IENPTU1FTlRcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gVEVYVCB8fCBzdGF0ZSA9PT0gQ09NTUVOVCkge1xuICAgICAgICAgIHJlZyArPSBjXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IE9QRU4gJiYgYyA9PT0gJy8nICYmIHJlZy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBuby1vcCwgc2VsZiBjbG9zaW5nIHRhZyB3aXRob3V0IGEgc3BhY2UgPGJyLz5cbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gT1BFTiAmJiAvXFxzLy50ZXN0KGMpKSB7XG4gICAgICAgICAgaWYgKHJlZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKFtPUEVOLCByZWddKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gQVRUUlxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBPUEVOKSB7XG4gICAgICAgICAgcmVnICs9IGNcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUiAmJiAvW15cXHNcIic9L10vLnRlc3QoYykpIHtcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJfS0VZXG4gICAgICAgICAgcmVnID0gY1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSICYmIC9cXHMvLnRlc3QoYykpIHtcbiAgICAgICAgICBpZiAocmVnLmxlbmd0aCkgcmVzLnB1c2goW0FUVFJfS0VZLHJlZ10pXG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfQlJFQUtdKVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX0tFWSAmJiAvXFxzLy50ZXN0KGMpKSB7XG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfS0VZLHJlZ10pXG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJfS0VZX1dcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9LRVkgJiYgYyA9PT0gJz0nKSB7XG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfS0VZLHJlZ10sW0FUVFJfRVFdKVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBBVFRSX1ZBTFVFX1dcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgICByZWcgKz0gY1xuICAgICAgICB9IGVsc2UgaWYgKChzdGF0ZSA9PT0gQVRUUl9LRVlfVyB8fCBzdGF0ZSA9PT0gQVRUUikgJiYgYyA9PT0gJz0nKSB7XG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfRVFdKVxuICAgICAgICAgIHN0YXRlID0gQVRUUl9WQUxVRV9XXG4gICAgICAgIH0gZWxzZSBpZiAoKHN0YXRlID09PSBBVFRSX0tFWV9XIHx8IHN0YXRlID09PSBBVFRSKSAmJiAhL1xccy8udGVzdChjKSkge1xuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX0JSRUFLXSlcbiAgICAgICAgICBpZiAoL1tcXHctXS8udGVzdChjKSkge1xuICAgICAgICAgICAgcmVnICs9IGNcbiAgICAgICAgICAgIHN0YXRlID0gQVRUUl9LRVlcbiAgICAgICAgICB9IGVsc2Ugc3RhdGUgPSBBVFRSXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUVfVyAmJiBjID09PSAnXCInKSB7XG4gICAgICAgICAgc3RhdGUgPSBBVFRSX1ZBTFVFX0RRXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUVfVyAmJiBjID09PSBcIidcIikge1xuICAgICAgICAgIHN0YXRlID0gQVRUUl9WQUxVRV9TUVxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX0RRICYmIGMgPT09ICdcIicpIHtcbiAgICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWddLFtBVFRSX0JSRUFLXSlcbiAgICAgICAgICByZWcgPSAnJ1xuICAgICAgICAgIHN0YXRlID0gQVRUUlxuICAgICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX1NRICYmIGMgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgcmVzLnB1c2goW0FUVFJfVkFMVUUscmVnXSxbQVRUUl9CUkVBS10pXG4gICAgICAgICAgcmVnID0gJydcbiAgICAgICAgICBzdGF0ZSA9IEFUVFJcbiAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRV9XICYmICEvXFxzLy50ZXN0KGMpKSB7XG4gICAgICAgICAgc3RhdGUgPSBBVFRSX1ZBTFVFXG4gICAgICAgICAgaS0tXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUUgJiYgL1xccy8udGVzdChjKSkge1xuICAgICAgICAgIHJlcy5wdXNoKFtBVFRSX1ZBTFVFLHJlZ10sW0FUVFJfQlJFQUtdKVxuICAgICAgICAgIHJlZyA9ICcnXG4gICAgICAgICAgc3RhdGUgPSBBVFRSXG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUUgfHwgc3RhdGUgPT09IEFUVFJfVkFMVUVfU1FcbiAgICAgICAgfHwgc3RhdGUgPT09IEFUVFJfVkFMVUVfRFEpIHtcbiAgICAgICAgICByZWcgKz0gY1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgPT09IFRFWFQgJiYgcmVnLmxlbmd0aCkge1xuICAgICAgICByZXMucHVzaChbVEVYVCxyZWddKVxuICAgICAgICByZWcgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9WQUxVRSAmJiByZWcubGVuZ3RoKSB7XG4gICAgICAgIHJlcy5wdXNoKFtBVFRSX1ZBTFVFLHJlZ10pXG4gICAgICAgIHJlZyA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBBVFRSX1ZBTFVFX0RRICYmIHJlZy5sZW5ndGgpIHtcbiAgICAgICAgcmVzLnB1c2goW0FUVFJfVkFMVUUscmVnXSlcbiAgICAgICAgcmVnID0gJydcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IEFUVFJfVkFMVUVfU1EgJiYgcmVnLmxlbmd0aCkge1xuICAgICAgICByZXMucHVzaChbQVRUUl9WQUxVRSxyZWddKVxuICAgICAgICByZWcgPSAnJ1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQVRUUl9LRVkpIHtcbiAgICAgICAgcmVzLnB1c2goW0FUVFJfS0VZLHJlZ10pXG4gICAgICAgIHJlZyA9ICcnXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyZm4gKHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicpIHJldHVybiB4XG4gICAgZWxzZSBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKSByZXR1cm4geFxuICAgIGVsc2UgaWYgKHggJiYgdHlwZW9mIHggPT09ICdvYmplY3QnKSByZXR1cm4geFxuICAgIGVsc2UgaWYgKHggPT09IG51bGwgfHwgeCA9PT0gdW5kZWZpbmVkKSByZXR1cm4geFxuICAgIGVsc2UgcmV0dXJuIGNvbmNhdCgnJywgeClcbiAgfVxufVxuXG5mdW5jdGlvbiBxdW90IChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUgPT09IEFUVFJfVkFMVUVfU1EgfHwgc3RhdGUgPT09IEFUVFJfVkFMVUVfRFFcbn1cblxudmFyIGNsb3NlUkUgPSBSZWdFeHAoJ14oJyArIFtcbiAgJ2FyZWEnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2JyJywgJ2NvbCcsICdjb21tYW5kJywgJ2VtYmVkJyxcbiAgJ2ZyYW1lJywgJ2hyJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2tleWdlbicsICdsaW5rJywgJ21ldGEnLCAncGFyYW0nLFxuICAnc291cmNlJywgJ3RyYWNrJywgJ3dicicsICchLS0nLFxuICAvLyBTVkcgVEFHU1xuICAnYW5pbWF0ZScsICdhbmltYXRlVHJhbnNmb3JtJywgJ2NpcmNsZScsICdjdXJzb3InLCAnZGVzYycsICdlbGxpcHNlJyxcbiAgJ2ZlQmxlbmQnLCAnZmVDb2xvck1hdHJpeCcsICdmZUNvbXBvc2l0ZScsXG4gICdmZUNvbnZvbHZlTWF0cml4JywgJ2ZlRGlmZnVzZUxpZ2h0aW5nJywgJ2ZlRGlzcGxhY2VtZW50TWFwJyxcbiAgJ2ZlRGlzdGFudExpZ2h0JywgJ2ZlRmxvb2QnLCAnZmVGdW5jQScsICdmZUZ1bmNCJywgJ2ZlRnVuY0cnLCAnZmVGdW5jUicsXG4gICdmZUdhdXNzaWFuQmx1cicsICdmZUltYWdlJywgJ2ZlTWVyZ2VOb2RlJywgJ2ZlTW9ycGhvbG9neScsXG4gICdmZU9mZnNldCcsICdmZVBvaW50TGlnaHQnLCAnZmVTcGVjdWxhckxpZ2h0aW5nJywgJ2ZlU3BvdExpZ2h0JywgJ2ZlVGlsZScsXG4gICdmZVR1cmJ1bGVuY2UnLCAnZm9udC1mYWNlLWZvcm1hdCcsICdmb250LWZhY2UtbmFtZScsICdmb250LWZhY2UtdXJpJyxcbiAgJ2dseXBoJywgJ2dseXBoUmVmJywgJ2hrZXJuJywgJ2ltYWdlJywgJ2xpbmUnLCAnbWlzc2luZy1nbHlwaCcsICdtcGF0aCcsXG4gICdwYXRoJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmVjdCcsICdzZXQnLCAnc3RvcCcsICd0cmVmJywgJ3VzZScsICd2aWV3JyxcbiAgJ3ZrZXJuJ1xuXS5qb2luKCd8JykgKyAnKSg/OltcXC4jXVthLXpBLVowLTlcXHUwMDdGLVxcdUZGRkZfOi1dKykqJCcpXG5mdW5jdGlvbiBzZWxmQ2xvc2luZyAodGFnKSB7IHJldHVybiBjbG9zZVJFLnRlc3QodGFnKSB9XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwidmFyIGNvbnRhaW5lcnMgPSBbXTsgLy8gd2lsbCBzdG9yZSBjb250YWluZXIgSFRNTEVsZW1lbnQgcmVmZXJlbmNlc1xudmFyIHN0eWxlRWxlbWVudHMgPSBbXTsgLy8gd2lsbCBzdG9yZSB7cHJlcGVuZDogSFRNTEVsZW1lbnQsIGFwcGVuZDogSFRNTEVsZW1lbnR9XG5cbmZ1bmN0aW9uIGluc2VydENzcyhjc3MsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBwb3NpdGlvbiA9IG9wdGlvbnMucHJlcGVuZCA9PT0gdHJ1ZSA/ICdwcmVwZW5kJyA6ICdhcHBlbmQnO1xuICAgIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb250YWluZXIgOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoZWFkJyk7XG4gICAgdmFyIGNvbnRhaW5lcklkID0gY29udGFpbmVycy5pbmRleE9mKGNvbnRhaW5lcik7XG5cbiAgICAvLyBmaXJzdCB0aW1lIHdlIHNlZSB0aGlzIGNvbnRhaW5lciwgY3JlYXRlIHRoZSBuZWNlc3NhcnkgZW50cmllc1xuICAgIGlmIChjb250YWluZXJJZCA9PT0gLTEpIHtcbiAgICAgICAgY29udGFpbmVySWQgPSBjb250YWluZXJzLnB1c2goY29udGFpbmVyKSAtIDE7XG4gICAgICAgIHN0eWxlRWxlbWVudHNbY29udGFpbmVySWRdID0ge307XG4gICAgfVxuXG4gICAgLy8gdHJ5IHRvIGdldCB0aGUgY29ycmVwb25kaW5nIGNvbnRhaW5lciArIHBvc2l0aW9uIHN0eWxlRWxlbWVudCwgY3JlYXRlIGl0IG90aGVyd2lzZVxuICAgIHZhciBzdHlsZUVsZW1lbnQ7XG5cbiAgICBpZiAoc3R5bGVFbGVtZW50c1tjb250YWluZXJJZF0gIT09IHVuZGVmaW5lZCAmJiBzdHlsZUVsZW1lbnRzW2NvbnRhaW5lcklkXVtwb3NpdGlvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHlsZUVsZW1lbnQgPSBzdHlsZUVsZW1lbnRzW2NvbnRhaW5lcklkXVtwb3NpdGlvbl07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVFbGVtZW50ID0gc3R5bGVFbGVtZW50c1tjb250YWluZXJJZF1bcG9zaXRpb25dID0gY3JlYXRlU3R5bGVFbGVtZW50KCk7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAncHJlcGVuZCcpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBjb250YWluZXIuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN0cmlwIHBvdGVudGlhbCBVVEYtOCBCT00gaWYgY3NzIHdhcyByZWFkIGZyb20gYSBmaWxlXG4gICAgaWYgKGNzcy5jaGFyQ29kZUF0KDApID09PSAweEZFRkYpIHsgY3NzID0gY3NzLnN1YnN0cigxLCBjc3MubGVuZ3RoKTsgfVxuXG4gICAgLy8gYWN0dWFsbHkgYWRkIHRoZSBzdHlsZXNoZWV0XG4gICAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgKz0gY3NzXG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVFbGVtZW50LnRleHRDb250ZW50ICs9IGNzcztcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVFbGVtZW50O1xufTtcblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KCkge1xuICAgIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKTtcbiAgICByZXR1cm4gc3R5bGVFbGVtZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydENzcztcbm1vZHVsZS5leHBvcnRzLmluc2VydENzcyA9IGluc2VydENzcztcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG5mdW5jdGlvbiBtb3JwaEF0dHJzKGZyb21Ob2RlLCB0b05vZGUpIHtcbiAgICB2YXIgdG9Ob2RlQXR0cnMgPSB0b05vZGUuYXR0cmlidXRlcztcbiAgICB2YXIgYXR0cjtcbiAgICB2YXIgYXR0ck5hbWU7XG4gICAgdmFyIGF0dHJOYW1lc3BhY2VVUkk7XG4gICAgdmFyIGF0dHJWYWx1ZTtcbiAgICB2YXIgZnJvbVZhbHVlO1xuXG4gICAgLy8gZG9jdW1lbnQtZnJhZ21lbnRzIGRvbnQgaGF2ZSBhdHRyaWJ1dGVzIHNvIGxldHMgbm90IGRvIGFueXRoaW5nXG4gICAgaWYgKHRvTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSB8fCBmcm9tTm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBhdHRyaWJ1dGVzIG9uIG9yaWdpbmFsIERPTSBlbGVtZW50XG4gICAgZm9yICh2YXIgaSA9IHRvTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGF0dHIgPSB0b05vZGVBdHRyc1tpXTtcbiAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICAgIGF0dHJOYW1lc3BhY2VVUkkgPSBhdHRyLm5hbWVzcGFjZVVSSTtcbiAgICAgICAgYXR0clZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgICAgICBpZiAoYXR0ck5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLmxvY2FsTmFtZSB8fCBhdHRyTmFtZTtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZU5TKGF0dHJOYW1lc3BhY2VVUkksIGF0dHJOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGZyb21WYWx1ZSAhPT0gYXR0clZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIucHJlZml4ID09PSAneG1sbnMnKXtcbiAgICAgICAgICAgICAgICAgICAgYXR0ck5hbWUgPSBhdHRyLm5hbWU7IC8vIEl0J3Mgbm90IGFsbG93ZWQgdG8gc2V0IGFuIGF0dHJpYnV0ZSB3aXRoIHRoZSBYTUxOUyBuYW1lc3BhY2Ugd2l0aG91dCBzcGVjaWZ5aW5nIHRoZSBgeG1sbnNgIHByZWZpeFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21WYWx1ZSA9IGZyb21Ob2RlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChmcm9tVmFsdWUgIT09IGF0dHJWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGZyb21Ob2RlLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXh0cmEgYXR0cmlidXRlcyBmb3VuZCBvbiB0aGUgb3JpZ2luYWwgRE9NIGVsZW1lbnQgdGhhdFxuICAgIC8vIHdlcmVuJ3QgZm91bmQgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgIHZhciBmcm9tTm9kZUF0dHJzID0gZnJvbU5vZGUuYXR0cmlidXRlcztcblxuICAgIGZvciAodmFyIGQgPSBmcm9tTm9kZUF0dHJzLmxlbmd0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGF0dHIgPSBmcm9tTm9kZUF0dHJzW2RdO1xuICAgICAgICBhdHRyTmFtZSA9IGF0dHIubmFtZTtcbiAgICAgICAgYXR0ck5hbWVzcGFjZVVSSSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuXG4gICAgICAgIGlmIChhdHRyTmFtZXNwYWNlVVJJKSB7XG4gICAgICAgICAgICBhdHRyTmFtZSA9IGF0dHIubG9jYWxOYW1lIHx8IGF0dHJOYW1lO1xuXG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmcm9tTm9kZS5yZW1vdmVBdHRyaWJ1dGVOUyhhdHRyTmFtZXNwYWNlVVJJLCBhdHRyTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRvTm9kZS5oYXNBdHRyaWJ1dGUoYXR0ck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZnJvbU5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIHJhbmdlOyAvLyBDcmVhdGUgYSByYW5nZSBvYmplY3QgZm9yIGVmZmljZW50bHkgcmVuZGVyaW5nIHN0cmluZ3MgdG8gZWxlbWVudHMuXG52YXIgTlNfWEhUTUwgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG5cbnZhciBkb2MgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogZG9jdW1lbnQ7XG52YXIgSEFTX1RFTVBMQVRFX1NVUFBPUlQgPSAhIWRvYyAmJiAnY29udGVudCcgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG52YXIgSEFTX1JBTkdFX1NVUFBPUlQgPSAhIWRvYyAmJiBkb2MuY3JlYXRlUmFuZ2UgJiYgJ2NyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCcgaW4gZG9jLmNyZWF0ZVJhbmdlKCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IGRvYy5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIHRlbXBsYXRlLmlubmVySFRNTCA9IHN0cjtcbiAgICByZXR1cm4gdGVtcGxhdGUuY29udGVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21SYW5nZShzdHIpIHtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoZG9jLmJvZHkpO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudCA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHIpO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudEZyb21XcmFwKHN0cikge1xuICAgIHZhciBmcmFnbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KCdib2R5Jyk7XG4gICAgZnJhZ21lbnQuaW5uZXJIVE1MID0gc3RyO1xuICAgIHJldHVybiBmcmFnbWVudC5jaGlsZE5vZGVzWzBdO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgYWJvdXQgdGhlIHNhbWVcbiAqIHZhciBodG1sID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzdHIsICd0ZXh0L2h0bWwnKTtcbiAqIHJldHVybiBodG1sLmJvZHkuZmlyc3RDaGlsZDtcbiAqXG4gKiBAbWV0aG9kIHRvRWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICovXG5mdW5jdGlvbiB0b0VsZW1lbnQoc3RyKSB7XG4gICAgc3RyID0gc3RyLnRyaW0oKTtcbiAgICBpZiAoSEFTX1RFTVBMQVRFX1NVUFBPUlQpIHtcbiAgICAgIC8vIGF2b2lkIHJlc3RyaWN0aW9ucyBvbiBjb250ZW50IGZvciB0aGluZ3MgbGlrZSBgPHRyPjx0aD5IaTwvdGg+PC90cj5gIHdoaWNoXG4gICAgICAvLyBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgZG9lc24ndCBzdXBwb3J0XG4gICAgICAvLyA8dGVtcGxhdGU+IHN1cHBvcnQgbm90IGF2YWlsYWJsZSBpbiBJRVxuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVRlbXBsYXRlKHN0cik7XG4gICAgfSBlbHNlIGlmIChIQVNfUkFOR0VfU1VQUE9SVCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVJhbmdlKHN0cik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUZyYWdtZW50RnJvbVdyYXAoc3RyKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdHdvIG5vZGUncyBuYW1lcyBhcmUgdGhlIHNhbWUuXG4gKlxuICogTk9URTogV2UgZG9uJ3QgYm90aGVyIGNoZWNraW5nIGBuYW1lc3BhY2VVUklgIGJlY2F1c2UgeW91IHdpbGwgbmV2ZXIgZmluZCB0d28gSFRNTCBlbGVtZW50cyB3aXRoIHRoZSBzYW1lXG4gKiAgICAgICBub2RlTmFtZSBhbmQgZGlmZmVyZW50IG5hbWVzcGFjZSBVUklzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiIFRoZSB0YXJnZXQgZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU5vZGVOYW1lcyhmcm9tRWwsIHRvRWwpIHtcbiAgICB2YXIgZnJvbU5vZGVOYW1lID0gZnJvbUVsLm5vZGVOYW1lO1xuICAgIHZhciB0b05vZGVOYW1lID0gdG9FbC5ub2RlTmFtZTtcbiAgICB2YXIgZnJvbUNvZGVTdGFydCwgdG9Db2RlU3RhcnQ7XG5cbiAgICBpZiAoZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZyb21Db2RlU3RhcnQgPSBmcm9tTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcbiAgICB0b0NvZGVTdGFydCA9IHRvTm9kZU5hbWUuY2hhckNvZGVBdCgwKTtcblxuICAgIC8vIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIHZpcnR1YWwgRE9NIG5vZGUgb3IgU1ZHIG5vZGUgdGhlbiB3ZSBtYXlcbiAgICAvLyBuZWVkIHRvIG5vcm1hbGl6ZSB0aGUgdGFnIG5hbWUgYmVmb3JlIGNvbXBhcmluZy4gTm9ybWFsIEhUTUwgZWxlbWVudHMgdGhhdCBhcmVcbiAgICAvLyBpbiB0aGUgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJcbiAgICAvLyBhcmUgY29udmVydGVkIHRvIHVwcGVyIGNhc2VcbiAgICBpZiAoZnJvbUNvZGVTdGFydCA8PSA5MCAmJiB0b0NvZGVTdGFydCA+PSA5NykgeyAvLyBmcm9tIGlzIHVwcGVyIGFuZCB0byBpcyBsb3dlclxuICAgICAgICByZXR1cm4gZnJvbU5vZGVOYW1lID09PSB0b05vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmICh0b0NvZGVTdGFydCA8PSA5MCAmJiBmcm9tQ29kZVN0YXJ0ID49IDk3KSB7IC8vIHRvIGlzIHVwcGVyIGFuZCBmcm9tIGlzIGxvd2VyXG4gICAgICAgIHJldHVybiB0b05vZGVOYW1lID09PSBmcm9tTm9kZU5hbWUudG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlbGVtZW50LCBvcHRpb25hbGx5IHdpdGggYSBrbm93biBuYW1lc3BhY2UgVVJJLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBlbGVtZW50IG5hbWUsIGUuZy4gJ2Rpdicgb3IgJ3N2ZydcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZXNwYWNlVVJJXSB0aGUgZWxlbWVudCdzIG5hbWVzcGFjZSBVUkksIGkuZS4gdGhlIHZhbHVlIG9mXG4gKiBpdHMgYHhtbG5zYCBhdHRyaWJ1dGUgb3IgaXRzIGluZmVycmVkIG5hbWVzcGFjZS5cbiAqXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZSwgbmFtZXNwYWNlVVJJKSB7XG4gICAgcmV0dXJuICFuYW1lc3BhY2VVUkkgfHwgbmFtZXNwYWNlVVJJID09PSBOU19YSFRNTCA/XG4gICAgICAgIGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpIDpcbiAgICAgICAgZG9jLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIG5hbWUpO1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgY2hpbGRyZW4gb2Ygb25lIERPTSBlbGVtZW50IHRvIGFub3RoZXIgRE9NIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gbW92ZUNoaWxkcmVuKGZyb21FbCwgdG9FbCkge1xuICAgIHZhciBjdXJDaGlsZCA9IGZyb21FbC5maXJzdENoaWxkO1xuICAgIHdoaWxlIChjdXJDaGlsZCkge1xuICAgICAgICB2YXIgbmV4dENoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgIHRvRWwuYXBwZW5kQ2hpbGQoY3VyQ2hpbGQpO1xuICAgICAgICBjdXJDaGlsZCA9IG5leHRDaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHRvRWw7XG59XG5cbmZ1bmN0aW9uIHN5bmNCb29sZWFuQXR0clByb3AoZnJvbUVsLCB0b0VsLCBuYW1lKSB7XG4gICAgaWYgKGZyb21FbFtuYW1lXSAhPT0gdG9FbFtuYW1lXSkge1xuICAgICAgICBmcm9tRWxbbmFtZV0gPSB0b0VsW25hbWVdO1xuICAgICAgICBpZiAoZnJvbUVsW25hbWVdKSB7XG4gICAgICAgICAgICBmcm9tRWwuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBzcGVjaWFsRWxIYW5kbGVycyA9IHtcbiAgICBPUFRJT046IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGZyb21FbC5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudE5hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgcGFyZW50TmFtZSA9IHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudE5hbWUgPT09ICdTRUxFQ1QnICYmICFwYXJlbnROb2RlLmhhc0F0dHJpYnV0ZSgnbXVsdGlwbGUnKSkge1xuICAgICAgICAgICAgICAgIGlmIChmcm9tRWwuaGFzQXR0cmlidXRlKCdzZWxlY3RlZCcpICYmICF0b0VsLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIE1TIEVkZ2UgYnVnIHdoZXJlIHRoZSAnc2VsZWN0ZWQnIGF0dHJpYnV0ZSBjYW4gb25seSBiZVxuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmVkIGlmIHNldCB0byBhIG5vbi1lbXB0eSB2YWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTIwODc2NzkvXG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5zZXRBdHRyaWJ1dGUoJ3NlbGVjdGVkJywgJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGZyb21FbC5yZW1vdmVBdHRyaWJ1dGUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gcmVzZXQgc2VsZWN0IGVsZW1lbnQncyBzZWxlY3RlZEluZGV4IHRvIC0xLCBvdGhlcndpc2Ugc2V0dGluZ1xuICAgICAgICAgICAgICAgIC8vIGZyb21FbC5zZWxlY3RlZCB1c2luZyB0aGUgc3luY0Jvb2xlYW5BdHRyUHJvcCBiZWxvdyBoYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSBjb3JyZWN0IHNlbGVjdGVkSW5kZXggd2lsbCBiZSBzZXQgaW4gdGhlIFNFTEVDVCBzcGVjaWFsIGhhbmRsZXIgYmVsb3cuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdzZWxlY3RlZCcpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhlIFwidmFsdWVcIiBhdHRyaWJ1dGUgaXMgc3BlY2lhbCBmb3IgdGhlIDxpbnB1dD4gZWxlbWVudCBzaW5jZSBpdCBzZXRzXG4gICAgICogdGhlIGluaXRpYWwgdmFsdWUuIENoYW5naW5nIHRoZSBcInZhbHVlXCIgYXR0cmlidXRlIHdpdGhvdXQgY2hhbmdpbmcgdGhlXG4gICAgICogXCJ2YWx1ZVwiIHByb3BlcnR5IHdpbGwgaGF2ZSBubyBlZmZlY3Qgc2luY2UgaXQgaXMgb25seSB1c2VkIHRvIHRoZSBzZXQgdGhlXG4gICAgICogaW5pdGlhbCB2YWx1ZS4gIFNpbWlsYXIgZm9yIHRoZSBcImNoZWNrZWRcIiBhdHRyaWJ1dGUsIGFuZCBcImRpc2FibGVkXCIuXG4gICAgICovXG4gICAgSU5QVVQ6IGZ1bmN0aW9uKGZyb21FbCwgdG9FbCkge1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJQcm9wKGZyb21FbCwgdG9FbCwgJ2NoZWNrZWQnKTtcbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyUHJvcChmcm9tRWwsIHRvRWwsICdkaXNhYmxlZCcpO1xuXG4gICAgICAgIGlmIChmcm9tRWwudmFsdWUgIT09IHRvRWwudmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IHRvRWwudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRvRWwuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICBmcm9tRWwucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIFRFWFRBUkVBOiBmdW5jdGlvbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gdG9FbC52YWx1ZTtcbiAgICAgICAgaWYgKGZyb21FbC52YWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGZyb21FbC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpcnN0Q2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIE5lZWRlZCBmb3IgSUUuIEFwcGFyZW50bHkgSUUgc2V0cyB0aGUgcGxhY2Vob2xkZXIgYXMgdGhlXG4gICAgICAgICAgICAvLyBub2RlIHZhbHVlIGFuZCB2aXNlIHZlcnNhLiBUaGlzIGlnbm9yZXMgYW4gZW1wdHkgdXBkYXRlLlxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChvbGRWYWx1ZSA9PSBuZXdWYWx1ZSB8fCAoIW5ld1ZhbHVlICYmIG9sZFZhbHVlID09IGZyb21FbC5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFNFTEVDVDogZnVuY3Rpb24oZnJvbUVsLCB0b0VsKSB7XG4gICAgICAgIGlmICghdG9FbC5oYXNBdHRyaWJ1dGUoJ211bHRpcGxlJykpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGxvb3AgdGhyb3VnaCBjaGlsZHJlbiBvZiBmcm9tRWwsIG5vdCB0b0VsIHNpbmNlIG5vZGVzIGNhbiBiZSBtb3ZlZFxuICAgICAgICAgICAgLy8gZnJvbSB0b0VsIHRvIGZyb21FbCBkaXJlY3RseSB3aGVuIG1vcnBoaW5nLlxuICAgICAgICAgICAgLy8gQXQgdGhlIHRpbWUgdGhpcyBzcGVjaWFsIGhhbmRsZXIgaXMgaW52b2tlZCwgYWxsIGNoaWxkcmVuIGhhdmUgYWxyZWFkeSBiZWVuIG1vcnBoZWRcbiAgICAgICAgICAgIC8vIGFuZCBhcHBlbmRlZCB0byAvIHJlbW92ZWQgZnJvbSBmcm9tRWwsIHNvIHVzaW5nIGZyb21FbCBoZXJlIGlzIHNhZmUgYW5kIGNvcnJlY3QuXG4gICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBmcm9tRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBvcHRncm91cDtcbiAgICAgICAgICAgIHZhciBub2RlTmFtZTtcbiAgICAgICAgICAgIHdoaWxlKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgbm9kZU5hbWUgPSBjdXJDaGlsZC5ub2RlTmFtZSAmJiBjdXJDaGlsZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PT0gJ09QVEdST1VQJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IGN1ckNoaWxkO1xuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IG9wdGdyb3VwLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnT1BUSU9OJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmhhc0F0dHJpYnV0ZSgnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gY3VyQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VyQ2hpbGQgJiYgb3B0Z3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gb3B0Z3JvdXAubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRncm91cCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZyb21FbC5zZWxlY3RlZEluZGV4ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUkMSA9IDExO1xudmFyIFRFWFRfTk9ERSA9IDM7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXROb2RlS2V5KG5vZGUpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICAgIHJldHVybiAobm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykpIHx8IG5vZGUuaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ycGhkb21GYWN0b3J5KG1vcnBoQXR0cnMpIHtcblxuICAgIHJldHVybiBmdW5jdGlvbiBtb3JwaGRvbShmcm9tTm9kZSwgdG9Ob2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0b05vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoZnJvbU5vZGUubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQnIHx8IGZyb21Ob2RlLm5vZGVOYW1lID09PSAnSFRNTCcgfHwgZnJvbU5vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAgICAgICAgIHZhciB0b05vZGVIdG1sID0gdG9Ob2RlO1xuICAgICAgICAgICAgICAgIHRvTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdodG1sJyk7XG4gICAgICAgICAgICAgICAgdG9Ob2RlLmlubmVySFRNTCA9IHRvTm9kZUh0bWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvTm9kZSA9IHRvRWxlbWVudCh0b05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdldE5vZGVLZXkgPSBvcHRpb25zLmdldE5vZGVLZXkgfHwgZGVmYXVsdEdldE5vZGVLZXk7XG4gICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlQWRkZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uTm9kZUFkZGVkID0gb3B0aW9ucy5vbk5vZGVBZGRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVFbFVwZGF0ZWQgPSBvcHRpb25zLm9uQmVmb3JlRWxVcGRhdGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbkVsVXBkYXRlZCA9IG9wdGlvbnMub25FbFVwZGF0ZWQgfHwgbm9vcDtcbiAgICAgICAgdmFyIG9uQmVmb3JlTm9kZURpc2NhcmRlZCA9IG9wdGlvbnMub25CZWZvcmVOb2RlRGlzY2FyZGVkIHx8IG5vb3A7XG4gICAgICAgIHZhciBvbk5vZGVEaXNjYXJkZWQgPSBvcHRpb25zLm9uTm9kZURpc2NhcmRlZCB8fCBub29wO1xuICAgICAgICB2YXIgb25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCA9IG9wdGlvbnMub25CZWZvcmVFbENoaWxkcmVuVXBkYXRlZCB8fCBub29wO1xuICAgICAgICB2YXIgY2hpbGRyZW5Pbmx5ID0gb3B0aW9ucy5jaGlsZHJlbk9ubHkgPT09IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBvYmplY3QgaXMgdXNlZCBhcyBhIGxvb2t1cCB0byBxdWlja2x5IGZpbmQgYWxsIGtleWVkIGVsZW1lbnRzIGluIHRoZSBvcmlnaW5hbCBET00gdHJlZS5cbiAgICAgICAgdmFyIGZyb21Ob2Rlc0xvb2t1cCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHZhciBrZXllZFJlbW92YWxMaXN0ID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gYWRkS2V5ZWRSZW1vdmFsKGtleSkge1xuICAgICAgICAgICAga2V5ZWRSZW1vdmFsTGlzdC5wdXNoKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB3YWxrRGlzY2FyZGVkQ2hpbGROb2Rlcyhub2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwS2V5ZWROb2RlcyAmJiAoa2V5ID0gZ2V0Tm9kZUtleShjdXJDaGlsZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgc2tpcHBpbmcga2V5ZWQgbm9kZXMgdGhlbiB3ZSBhZGQgdGhlIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYSBsaXN0IHNvIHRoYXQgaXQgY2FuIGJlIGhhbmRsZWQgYXQgdGhlIHZlcnkgZW5kLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJlcG9ydCB0aGUgbm9kZSBhcyBkaXNjYXJkZWQgaWYgaXQgaXMgbm90IGtleWVkLiBXZSBkbyB0aGlzIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0IHRoZSBlbmQgd2UgbG9vcCB0aHJvdWdoIGFsbCBrZXllZCBlbGVtZW50cyB0aGF0IHdlcmUgdW5tYXRjaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiBkaXNjYXJkIHRoZW0gaW4gb25lIGZpbmFsIHBhc3MuXG4gICAgICAgICAgICAgICAgICAgICAgICBvbk5vZGVEaXNjYXJkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoaWxkLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxrRGlzY2FyZGVkQ2hpbGROb2RlcyhjdXJDaGlsZCwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyQ2hpbGQgPSBjdXJDaGlsZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIERPTSBub2RlIG91dCBvZiB0aGUgb3JpZ2luYWwgRE9NXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gICAgICAgICAqIEBwYXJhbSAge05vZGV9IHBhcmVudE5vZGUgVGhlIG5vZGVzIHBhcmVudFxuICAgICAgICAgKiBAcGFyYW0gIHtCb29sZWFufSBza2lwS2V5ZWROb2RlcyBJZiB0cnVlIHRoZW4gZWxlbWVudHMgd2l0aCBrZXlzIHdpbGwgYmUgc2tpcHBlZCBhbmQgbm90IGRpc2NhcmRlZC5cbiAgICAgICAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlLCBwYXJlbnROb2RlLCBza2lwS2V5ZWROb2Rlcykge1xuICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZURpc2NhcmRlZChub2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKG5vZGUpO1xuICAgICAgICAgICAgd2Fsa0Rpc2NhcmRlZENoaWxkTm9kZXMobm9kZSwgc2tpcEtleWVkTm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLy8gVHJlZVdhbGtlciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKHJvb3QpIHtcbiAgICAgICAgLy8gICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcbiAgICAgICAgLy8gICAgICAgICByb290LFxuICAgICAgICAvLyAgICAgICAgIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UKTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIHZhciBlbDtcbiAgICAgICAgLy8gICAgIHdoaWxlKChlbCA9IHRyZWVXYWxrZXIubmV4dE5vZGUoKSkpIHtcbiAgICAgICAgLy8gICAgICAgICB2YXIga2V5ID0gZ2V0Tm9kZUtleShlbCk7XG4gICAgICAgIC8vICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAvLyAgICAgICAgICAgICBmcm9tTm9kZXNMb29rdXBba2V5XSA9IGVsO1xuICAgICAgICAvLyAgICAgICAgIH1cbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIC8vIE5vZGVJdGVyYXRvciBpbXBsZW1lbnRhdGlvbiBpcyBubyBmYXN0ZXIsIGJ1dCBrZWVwaW5nIHRoaXMgYXJvdW5kIGluIGNhc2UgdGhpcyBjaGFuZ2VzIGluIHRoZSBmdXR1cmVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gZnVuY3Rpb24gaW5kZXhUcmVlKG5vZGUpIHtcbiAgICAgICAgLy8gICAgIHZhciBub2RlSXRlcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVOb2RlSXRlcmF0b3Iobm9kZSwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQpO1xuICAgICAgICAvLyAgICAgdmFyIGVsO1xuICAgICAgICAvLyAgICAgd2hpbGUoKGVsID0gbm9kZUl0ZXJhdG9yLm5leHROb2RlKCkpKSB7XG4gICAgICAgIC8vICAgICAgICAgdmFyIGtleSA9IGdldE5vZGVLZXkoZWwpO1xuICAgICAgICAvLyAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBlbDtcbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICBmdW5jdGlvbiBpbmRleFRyZWUobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFJDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyQ2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1ckNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbU5vZGVzTG9va3VwW2tleV0gPSBjdXJDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdhbGsgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhUcmVlKGN1ckNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICBjdXJDaGlsZCA9IGN1ckNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4VHJlZShmcm9tTm9kZSk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTm9kZUFkZGVkKGVsKSB7XG4gICAgICAgICAgICBvbk5vZGVBZGRlZChlbCk7XG5cbiAgICAgICAgICAgIHZhciBjdXJDaGlsZCA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY3VyQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBjdXJDaGlsZC5uZXh0U2libGluZztcblxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBnZXROb2RlS2V5KGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bm1hdGNoZWRGcm9tRWwgPSBmcm9tTm9kZXNMb29rdXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZmluZCBhIGR1cGxpY2F0ZSAjaWQgbm9kZSBpbiBjYWNoZSwgcmVwbGFjZSBgZWxgIHdpdGggY2FjaGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG1vcnBoIGl0IHRvIHRoZSBjaGlsZCBub2RlLlxuICAgICAgICAgICAgICAgICAgICBpZiAodW5tYXRjaGVkRnJvbUVsICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyQ2hpbGQsIHVubWF0Y2hlZEZyb21FbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckNoaWxkLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHVubWF0Y2hlZEZyb21FbCwgY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9ycGhFbCh1bm1hdGNoZWRGcm9tRWwsIGN1ckNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGwgZm9yIGN1ckNoaWxkIGFuZCBpdCdzIGNoaWxkcmVuIHRvIHNlZSBpZiB3ZSBmaW5kIHNvbWV0aGluZyBpblxuICAgICAgICAgICAgICAgICAgLy8gZnJvbU5vZGVzTG9va3VwXG4gICAgICAgICAgICAgICAgICBoYW5kbGVOb2RlQWRkZWQoY3VyQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1ckNoaWxkID0gbmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgcHJvY2Vzc2VkIGFsbCBvZiB0aGUgXCJ0byBub2Rlc1wiLiBJZiBjdXJGcm9tTm9kZUNoaWxkIGlzXG4gICAgICAgICAgICAvLyBub24tbnVsbCB0aGVuIHdlIHN0aWxsIGhhdmUgc29tZSBmcm9tIG5vZGVzIGxlZnQgb3ZlciB0aGF0IG5lZWRcbiAgICAgICAgICAgIC8vIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgaWYgKChjdXJGcm9tTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyRnJvbU5vZGVDaGlsZCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIGFkZEtleWVkUmVtb3ZhbChjdXJGcm9tTm9kZUtleSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHN0aWxsIGEgY2hhbmNlIHRoZXkgd2lsbCBiZSBtYXRjaGVkIHVwIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbW9ycGhFbChmcm9tRWwsIHRvRWwsIGNoaWxkcmVuT25seSkge1xuICAgICAgICAgICAgdmFyIHRvRWxLZXkgPSBnZXROb2RlS2V5KHRvRWwpO1xuXG4gICAgICAgICAgICBpZiAodG9FbEtleSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGFuIGVsZW1lbnQgd2l0aCBhbiBJRCBpcyBiZWluZyBtb3JwaGVkIHRoZW4gaXQgd2lsbCBiZSBpbiB0aGUgZmluYWxcbiAgICAgICAgICAgICAgICAvLyBET00gc28gY2xlYXIgaXQgb3V0IG9mIHRoZSBzYXZlZCBlbGVtZW50cyBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgZGVsZXRlIGZyb21Ob2Rlc0xvb2t1cFt0b0VsS2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25hbFxuICAgICAgICAgICAgICAgIGlmIChvbkJlZm9yZUVsVXBkYXRlZChmcm9tRWwsIHRvRWwpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGF0dHJpYnV0ZXMgb24gb3JpZ2luYWwgRE9NIGVsZW1lbnQgZmlyc3RcbiAgICAgICAgICAgICAgICBtb3JwaEF0dHJzKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW9uYWxcbiAgICAgICAgICAgICAgICBvbkVsVXBkYXRlZChmcm9tRWwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlRWxDaGlsZHJlblVwZGF0ZWQoZnJvbUVsLCB0b0VsKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZyb21FbC5ub2RlTmFtZSAhPT0gJ1RFWFRBUkVBJykge1xuICAgICAgICAgICAgICBtb3JwaENoaWxkcmVuKGZyb21FbCwgdG9FbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzcGVjaWFsRWxIYW5kbGVycy5URVhUQVJFQShmcm9tRWwsIHRvRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbW9ycGhDaGlsZHJlbihmcm9tRWwsIHRvRWwpIHtcbiAgICAgICAgICAgIHZhciBjdXJUb05vZGVDaGlsZCA9IHRvRWwuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbUVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB2YXIgY3VyVG9Ob2RlS2V5O1xuICAgICAgICAgICAgdmFyIGN1ckZyb21Ob2RlS2V5O1xuXG4gICAgICAgICAgICB2YXIgZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgdmFyIHRvTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdGcm9tRWw7XG5cbiAgICAgICAgICAgIC8vIHdhbGsgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICBvdXRlcjogd2hpbGUgKGN1clRvTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdG9OZXh0U2libGluZyA9IGN1clRvTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIGN1clRvTm9kZUtleSA9IGdldE5vZGVLZXkoY3VyVG9Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgLy8gd2FsayB0aGUgZnJvbU5vZGUgY2hpbGRyZW4gYWxsIHRoZSB3YXkgdGhyb3VnaFxuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJGcm9tTm9kZUNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21OZXh0U2libGluZyA9IGN1ckZyb21Ob2RlQ2hpbGQubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmlzU2FtZU5vZGUgJiYgY3VyVG9Ob2RlQ2hpbGQuaXNTYW1lTm9kZShjdXJGcm9tTm9kZUNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSB0b05leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVLZXkgPSBnZXROb2RlS2V5KGN1ckZyb21Ob2RlQ2hpbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJGcm9tTm9kZVR5cGUgPSBjdXJGcm9tTm9kZUNoaWxkLm5vZGVUeXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgaWYgdGhlIGN1ckZyb21Ob2RlQ2hpbGQgZG9lc250IGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJUb05vZGVDaGlsZFxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNDb21wYXRpYmxlID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZVR5cGUgPT09IGN1clRvTm9kZUNoaWxkLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBCb3RoIG5vZGVzIGJlaW5nIGNvbXBhcmVkIGFyZSBFbGVtZW50IG5vZGVzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgbm9kZSBoYXMgYSBrZXkgc28gd2Ugd2FudCB0byBtYXRjaCBpdCB1cCB3aXRoIHRoZSBjb3JyZWN0IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJUb05vZGVLZXkgIT09IGN1ckZyb21Ob2RlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCBET00gdHJlZSBkb2VzIG5vdCBoYXZlIGEgbWF0Y2hpbmcga2V5IHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBjaGVjayBvdXIgbG9va3VwIHRvIHNlZSBpZiB0aGVyZSBpcyBhIG1hdGNoaW5nIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBET00gdHJlZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tTmV4dFNpYmxpbmcgPT09IG1hdGNoaW5nRnJvbUVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3Igc2luZ2xlIGVsZW1lbnQgcmVtb3ZhbHMuIFRvIGF2b2lkIHJlbW92aW5nIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBET00gbm9kZSBvdXQgb2YgdGhlIHRyZWUgKHNpbmNlIHRoYXQgY2FuIGJyZWFrIENTUyB0cmFuc2l0aW9ucywgZXRjLiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHdpbGwgaW5zdGVhZCBkaXNjYXJkIHRoZSBjdXJyZW50IG5vZGUgYW5kIHdhaXQgdW50aWwgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlcmF0aW9uIHRvIHByb3Blcmx5IG1hdGNoIHVwIHRoZSBrZXllZCB0YXJnZXQgZWxlbWVudCB3aXRoIGl0cyBtYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IGluIHRoZSBvcmlnaW5hbCB0cmVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbWF0Y2hpbmcga2V5ZWQgZWxlbWVudCBzb21ld2hlcmUgaW4gdGhlIG9yaWdpbmFsIERPTSB0cmVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMZXQncyBtb3ZlIHRoZSBvcmlnaW5hbCBET00gbm9kZSBpbnRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBtb3JwaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdC5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSB1c2UgaW5zZXJ0QmVmb3JlIGluc3RlYWQgb2YgcmVwbGFjZUNoaWxkIGJlY2F1c2Ugd2Ugd2FudCB0byBnbyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBgcmVtb3ZlTm9kZSgpYCBmdW5jdGlvbiBmb3IgdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBkaXNjYXJkZWQgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgbGlmZWN5Y2xlIGhvb2tzIGFyZSBjb3JyZWN0bHkgaW52b2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tRWwuaW5zZXJ0QmVmb3JlKG1hdGNoaW5nRnJvbUVsLCBjdXJGcm9tTm9kZUNoaWxkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmcm9tTmV4dFNpYmxpbmcgPSBjdXJGcm9tTm9kZUNoaWxkLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJGcm9tTm9kZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhlIG5vZGUgaXMga2V5ZWQgaXQgbWlnaHQgYmUgbWF0Y2hlZCB1cCBsYXRlciBzbyB3ZSBkZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGFjdHVhbCByZW1vdmFsIHRvIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRLZXllZFJlbW92YWwoY3VyRnJvbU5vZGVLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogd2Ugc2tpcCBuZXN0ZWQga2V5ZWQgbm9kZXMgZnJvbSBiZWluZyByZW1vdmVkIHNpbmNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBzdGlsbCBhIGNoYW5jZSB0aGV5IHdpbGwgYmUgbWF0Y2hlZCB1cCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjdXJGcm9tTm9kZUNoaWxkLCBmcm9tRWwsIHRydWUgLyogc2tpcCBrZXllZCBub2RlcyAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gbWF0Y2hpbmdGcm9tRWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm9kZXMgYXJlIG5vdCBjb21wYXRpYmxlIHNpbmNlIHRoZSBcInRvXCIgbm9kZSBoYXMgYSBrZXkgYW5kIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm8gbWF0Y2hpbmcga2V5ZWQgbm9kZSBpbiB0aGUgc291cmNlIHRyZWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9yaWdpbmFsIGhhcyBhIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbXBhdGlibGUgPSBpc0NvbXBhdGlibGUgIT09IGZhbHNlICYmIGNvbXBhcmVOb2RlTmFtZXMoY3VyRnJvbU5vZGVDaGlsZCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgY29tcGF0aWJsZSBET00gZWxlbWVudHMgc28gdHJhbnNmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IFwiZnJvbVwiIG5vZGUgdG8gbWF0Y2ggdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFyZ2V0IERPTSBub2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNT1JQSFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3JwaEVsKGN1ckZyb21Ob2RlQ2hpbGQsIGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyRnJvbU5vZGVUeXBlID09PSBURVhUX05PREUgfHwgY3VyRnJvbU5vZGVUeXBlID09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJvdGggbm9kZXMgYmVpbmcgY29tcGFyZWQgYXJlIFRleHQgb3IgQ29tbWVudCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29tcGF0aWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2ltcGx5IHVwZGF0ZSBub2RlVmFsdWUgb24gdGhlIG9yaWdpbmFsIG5vZGUgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgdGhlIHRleHQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVDaGlsZC5ub2RlVmFsdWUgIT09IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkLm5vZGVWYWx1ZSA9IGN1clRvTm9kZUNoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgYm90aCB0aGUgXCJ0b1wiIGNoaWxkIGFuZCB0aGUgXCJmcm9tXCIgY2hpbGQgc2luY2Ugd2UgZm91bmQgYSBtYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBlbHNlIHRvIGRvIGFzIHdlIGFscmVhZHkgcmVjdXJzaXZlbHkgY2FsbGVkIG1vcnBoQ2hpbGRyZW4gYWJvdmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckZyb21Ob2RlQ2hpbGQgPSBmcm9tTmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNvbXBhdGlibGUgbWF0Y2ggc28gcmVtb3ZlIHRoZSBvbGQgbm9kZSBmcm9tIHRoZSBET00gYW5kIGNvbnRpbnVlIHRyeWluZyB0byBmaW5kIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2ggaW4gdGhlIG9yaWdpbmFsIERPTS4gSG93ZXZlciwgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSBmcm9tIG5vZGUgaXMgbm90IGtleWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIGl0IGlzIHBvc3NpYmxlIHRoYXQgYSBrZXllZCBub2RlIG1pZ2h0IG1hdGNoIHVwIHdpdGggYSBub2RlIHNvbWV3aGVyZSBlbHNlIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB0YXJnZXQgdHJlZSBhbmQgd2UgZG9uJ3Qgd2FudCB0byBkaXNjYXJkIGl0IGp1c3QgeWV0IHNpbmNlIGl0IHN0aWxsIG1pZ2h0IGZpbmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBob21lIGluIHRoZSBmaW5hbCBET00gdHJlZS4gQWZ0ZXIgZXZlcnl0aGluZyBpcyBkb25lIHdlIHdpbGwgcmVtb3ZlIGFueSBrZXllZCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGRpZG4ndCBmaW5kIGEgaG9tZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyRnJvbU5vZGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBub2RlIGlzIGtleWVkIGl0IG1pZ2h0IGJlIG1hdGNoZWQgdXAgbGF0ZXIgc28gd2UgZGVmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBhY3R1YWwgcmVtb3ZhbCB0byBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkS2V5ZWRSZW1vdmFsKGN1ckZyb21Ob2RlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdlIHNraXAgbmVzdGVkIGtleWVkIG5vZGVzIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSB0aGVyZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgc3RpbGwgYSBjaGFuY2UgdGhleSB3aWxsIGJlIG1hdGNoZWQgdXAgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY3VyRnJvbU5vZGVDaGlsZCwgZnJvbUVsLCB0cnVlIC8qIHNraXAga2V5ZWQgbm9kZXMgKi8pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY3VyRnJvbU5vZGVDaGlsZCA9IGZyb21OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9IC8vIEVORDogd2hpbGUoY3VyRnJvbU5vZGVDaGlsZCkge31cblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGdvdCB0aGlzIGZhciB0aGVuIHdlIGRpZCBub3QgZmluZCBhIGNhbmRpZGF0ZSBtYXRjaCBmb3JcbiAgICAgICAgICAgICAgICAvLyBvdXIgXCJ0byBub2RlXCIgYW5kIHdlIGV4aGF1c3RlZCBhbGwgb2YgdGhlIGNoaWxkcmVuIFwiZnJvbVwiXG4gICAgICAgICAgICAgICAgLy8gbm9kZXMuIFRoZXJlZm9yZSwgd2Ugd2lsbCBqdXN0IGFwcGVuZCB0aGUgY3VycmVudCBcInRvXCIgbm9kZVxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBlbmRcbiAgICAgICAgICAgICAgICBpZiAoY3VyVG9Ob2RlS2V5ICYmIChtYXRjaGluZ0Zyb21FbCA9IGZyb21Ob2Rlc0xvb2t1cFtjdXJUb05vZGVLZXldKSAmJiBjb21wYXJlTm9kZU5hbWVzKG1hdGNoaW5nRnJvbUVsLCBjdXJUb05vZGVDaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUVsLmFwcGVuZENoaWxkKG1hdGNoaW5nRnJvbUVsKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTU9SUEhcbiAgICAgICAgICAgICAgICAgICAgbW9ycGhFbChtYXRjaGluZ0Zyb21FbCwgY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdCA9IG9uQmVmb3JlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uQmVmb3JlTm9kZUFkZGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVG9Ob2RlQ2hpbGQgPSBvbkJlZm9yZU5vZGVBZGRlZFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clRvTm9kZUNoaWxkLmFjdHVhbGl6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gY3VyVG9Ob2RlQ2hpbGQuYWN0dWFsaXplKGZyb21FbC5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tRWwuYXBwZW5kQ2hpbGQoY3VyVG9Ob2RlQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlTm9kZUFkZGVkKGN1clRvTm9kZUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN1clRvTm9kZUNoaWxkID0gdG9OZXh0U2libGluZztcbiAgICAgICAgICAgICAgICBjdXJGcm9tTm9kZUNoaWxkID0gZnJvbU5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjbGVhbnVwRnJvbUVsKGZyb21FbCwgY3VyRnJvbU5vZGVDaGlsZCwgY3VyRnJvbU5vZGVLZXkpO1xuXG4gICAgICAgICAgICB2YXIgc3BlY2lhbEVsSGFuZGxlciA9IHNwZWNpYWxFbEhhbmRsZXJzW2Zyb21FbC5ub2RlTmFtZV07XG4gICAgICAgICAgICBpZiAoc3BlY2lhbEVsSGFuZGxlcikge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxFbEhhbmRsZXIoZnJvbUVsLCB0b0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBFTkQ6IG1vcnBoQ2hpbGRyZW4oLi4uKVxuXG4gICAgICAgIHZhciBtb3JwaGVkTm9kZSA9IGZyb21Ob2RlO1xuICAgICAgICB2YXIgbW9ycGhlZE5vZGVUeXBlID0gbW9ycGhlZE5vZGUubm9kZVR5cGU7XG4gICAgICAgIHZhciB0b05vZGVUeXBlID0gdG9Ob2RlLm5vZGVUeXBlO1xuXG4gICAgICAgIGlmICghY2hpbGRyZW5Pbmx5KSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgYXJlIGdpdmVuIHR3byBET00gbm9kZXMgdGhhdCBhcmUgbm90XG4gICAgICAgICAgICAvLyBjb21wYXRpYmxlIChlLmcuIDxkaXY+IC0tPiA8c3Bhbj4gb3IgPGRpdj4gLS0+IFRFWFQpXG4gICAgICAgICAgICBpZiAobW9ycGhlZE5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9Ob2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZU5vZGVOYW1lcyhmcm9tTm9kZSwgdG9Ob2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Ob2RlRGlzY2FyZGVkKGZyb21Ob2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcnBoZWROb2RlID0gbW92ZUNoaWxkcmVuKGZyb21Ob2RlLCBjcmVhdGVFbGVtZW50TlModG9Ob2RlLm5vZGVOYW1lLCB0b05vZGUubmFtZXNwYWNlVVJJKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBHb2luZyBmcm9tIGFuIGVsZW1lbnQgbm9kZSB0byBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vcnBoZWROb2RlVHlwZSA9PT0gVEVYVF9OT0RFIHx8IG1vcnBoZWROb2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7IC8vIFRleHQgb3IgY29tbWVudCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKHRvTm9kZVR5cGUgPT09IG1vcnBoZWROb2RlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9ycGhlZE5vZGUubm9kZVZhbHVlICE9PSB0b05vZGUubm9kZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZS5ub2RlVmFsdWUgPSB0b05vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHQgbm9kZSB0byBzb21ldGhpbmcgZWxzZVxuICAgICAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IHRvTm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9ycGhlZE5vZGUgPT09IHRvTm9kZSkge1xuICAgICAgICAgICAgLy8gVGhlIFwidG8gbm9kZVwiIHdhcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBcImZyb20gbm9kZVwiIHNvIHdlIGhhZCB0b1xuICAgICAgICAgICAgLy8gdG9zcyBvdXQgdGhlIFwiZnJvbSBub2RlXCIgYW5kIHVzZSB0aGUgXCJ0byBub2RlXCJcbiAgICAgICAgICAgIG9uTm9kZURpc2NhcmRlZChmcm9tTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodG9Ob2RlLmlzU2FtZU5vZGUgJiYgdG9Ob2RlLmlzU2FtZU5vZGUobW9ycGhlZE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3JwaEVsKG1vcnBoZWROb2RlLCB0b05vZGUsIGNoaWxkcmVuT25seSk7XG5cbiAgICAgICAgICAgIC8vIFdlIG5vdyBuZWVkIHRvIGxvb3Agb3ZlciBhbnkga2V5ZWQgbm9kZXMgdGhhdCBtaWdodCBuZWVkIHRvIGJlXG4gICAgICAgICAgICAvLyByZW1vdmVkLiBXZSBvbmx5IGRvIHRoZSByZW1vdmFsIGlmIHdlIGtub3cgdGhhdCB0aGUga2V5ZWQgbm9kZVxuICAgICAgICAgICAgLy8gbmV2ZXIgZm91bmQgYSBtYXRjaC4gV2hlbiBhIGtleWVkIG5vZGUgaXMgbWF0Y2hlZCB1cCB3ZSByZW1vdmVcbiAgICAgICAgICAgIC8vIGl0IG91dCBvZiBmcm9tTm9kZXNMb29rdXAgYW5kIHdlIHVzZSBmcm9tTm9kZXNMb29rdXAgdG8gZGV0ZXJtaW5lXG4gICAgICAgICAgICAvLyBpZiBhIGtleWVkIG5vZGUgaGFzIGJlZW4gbWF0Y2hlZCB1cCBvciBub3RcbiAgICAgICAgICAgIGlmIChrZXllZFJlbW92YWxMaXN0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaT0wLCBsZW49a2V5ZWRSZW1vdmFsTGlzdC5sZW5ndGg7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsVG9SZW1vdmUgPSBmcm9tTm9kZXNMb29rdXBba2V5ZWRSZW1vdmFsTGlzdFtpXV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbFRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGVsVG9SZW1vdmUsIGVsVG9SZW1vdmUucGFyZW50Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjaGlsZHJlbk9ubHkgJiYgbW9ycGhlZE5vZGUgIT09IGZyb21Ob2RlICYmIGZyb21Ob2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChtb3JwaGVkTm9kZS5hY3R1YWxpemUpIHtcbiAgICAgICAgICAgICAgICBtb3JwaGVkTm9kZSA9IG1vcnBoZWROb2RlLmFjdHVhbGl6ZShmcm9tTm9kZS5vd25lckRvY3VtZW50IHx8IGRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYWQgdG8gc3dhcCBvdXQgdGhlIGZyb20gbm9kZSB3aXRoIGEgbmV3IG5vZGUgYmVjYXVzZSB0aGUgb2xkXG4gICAgICAgICAgICAvLyBub2RlIHdhcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSB0YXJnZXQgbm9kZSB0aGVuIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIG9sZCBET00gbm9kZSBpbiB0aGUgb3JpZ2luYWwgRE9NIHRyZWUuIFRoaXMgaXMgb25seVxuICAgICAgICAgICAgLy8gcG9zc2libGUgaWYgdGhlIG9yaWdpbmFsIERPTSBub2RlIHdhcyBwYXJ0IG9mIGEgRE9NIHRyZWUgd2hpY2hcbiAgICAgICAgICAgIC8vIHdlIGtub3cgaXMgdGhlIGNhc2UgaWYgaXQgaGFzIGEgcGFyZW50IG5vZGUuXG4gICAgICAgICAgICBmcm9tTm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChtb3JwaGVkTm9kZSwgZnJvbU5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vcnBoZWROb2RlO1xuICAgIH07XG59XG5cbnZhciBtb3JwaGRvbSA9IG1vcnBoZG9tRmFjdG9yeShtb3JwaEF0dHJzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBtb3JwaGRvbTtcbiIsImFzc2VydC5ub3RFcXVhbCA9IG5vdEVxdWFsXG5hc3NlcnQubm90T2sgPSBub3RPa1xuYXNzZXJ0LmVxdWFsID0gZXF1YWxcbmFzc2VydC5vayA9IGFzc2VydFxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2VydFxuXG5mdW5jdGlvbiBlcXVhbCAoYSwgYiwgbSkge1xuICBhc3NlcnQoYSA9PSBiLCBtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxufVxuXG5mdW5jdGlvbiBub3RFcXVhbCAoYSwgYiwgbSkge1xuICBhc3NlcnQoYSAhPSBiLCBtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxufVxuXG5mdW5jdGlvbiBub3RPayAodCwgbSkge1xuICBhc3NlcnQoIXQsIG0pXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodCwgbSkge1xuICBpZiAoIXQpIHRocm93IG5ldyBFcnJvcihtIHx8ICdBc3NlcnRpb25FcnJvcicpXG59XG4iLCJ2YXIgd2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxubW9kdWxlLmV4cG9ydHMgPSBuYW5vcmFmXG5cbi8vIE9ubHkgY2FsbCBSQUYgd2hlbiBuZWVkZWRcbi8vIChmbiwgZm4/KSAtPiBmblxuZnVuY3Rpb24gbmFub3JhZiAocmVuZGVyLCByYWYpIHtcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiByZW5kZXIsICdmdW5jdGlvbicsICduYW5vcmFmOiByZW5kZXIgc2hvdWxkIGJlIGEgZnVuY3Rpb24nKVxuICBhc3NlcnQub2sodHlwZW9mIHJhZiA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmFmID09PSAndW5kZWZpbmVkJywgJ25hbm9yYWY6IHJhZiBzaG91bGQgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWQnKVxuXG4gIHJhZiA9IHJhZiB8fCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cbiAgdmFyIGluUmVuZGVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZVxuICB2YXIgcmVkcmF3U2NoZWR1bGVkID0gZmFsc2VcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IG51bGxcblxuICAvLyBwYXNzIG5ldyBzdGF0ZSB0byBiZSByZW5kZXJlZFxuICAvLyAob2JqLCBvYmo/KSAtPiBudWxsXG4gIHJldHVybiBmdW5jdGlvbiBmcmFtZSAoc3RhdGUsIHByZXYpIHtcbiAgICBhc3NlcnQuZXF1YWwodHlwZW9mIHN0YXRlLCAnb2JqZWN0JywgJ25hbm9yYWY6IHN0YXRlIHNob3VsZCBiZSBhbiBvYmplY3QnKVxuICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgcHJldiwgJ29iamVjdCcsICduYW5vcmFmOiBwcmV2IHNob3VsZCBiZSBhbiBvYmplY3QnKVxuICAgIGFzc2VydC5lcXVhbChpblJlbmRlcmluZ1RyYW5zYWN0aW9uLCBmYWxzZSwgJ25hbm9yYWY6IG5ldyBmcmFtZSB3YXMgY3JlYXRlZCBiZWZvcmUgcHJldmlvdXMgZnJhbWUgZmluaXNoZWQnKVxuXG4gICAgLy8gcmVxdWVzdCBhIHJlZHJhdyBmb3IgbmV4dCBmcmFtZVxuICAgIGlmIChjdXJyZW50U3RhdGUgPT09IG51bGwgJiYgIXJlZHJhd1NjaGVkdWxlZCkge1xuICAgICAgcmVkcmF3U2NoZWR1bGVkID0gdHJ1ZVxuXG4gICAgICByYWYoZnVuY3Rpb24gcmVkcmF3ICgpIHtcbiAgICAgICAgcmVkcmF3U2NoZWR1bGVkID0gZmFsc2VcbiAgICAgICAgaWYgKCFjdXJyZW50U3RhdGUpIHJldHVyblxuXG4gICAgICAgIGluUmVuZGVyaW5nVHJhbnNhY3Rpb24gPSB0cnVlXG4gICAgICAgIHJlbmRlcihjdXJyZW50U3RhdGUsIHByZXYpXG4gICAgICAgIGluUmVuZGVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZVxuXG4gICAgICAgIGN1cnJlbnRTdGF0ZSA9IG51bGxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGRhdGEgZm9yIHJlZHJhd1xuICAgIGN1cnJlbnRTdGF0ZSA9IHN0YXRlXG4gIH1cbn1cbiIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIvKiBnbG9iYWwgTXV0YXRpb25PYnNlcnZlciAqL1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnZ2xvYmFsL2RvY3VtZW50JylcbnZhciB3aW5kb3cgPSByZXF1aXJlKCdnbG9iYWwvd2luZG93JylcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIHdhdGNoID0gT2JqZWN0LmNyZWF0ZShudWxsKVxudmFyIEtFWV9JRCA9ICdvbmxvYWRpZCcgKyAobmV3IERhdGUoKSAlIDllNikudG9TdHJpbmcoMzYpXG52YXIgS0VZX0FUVFIgPSAnZGF0YS0nICsgS0VZX0lEXG52YXIgSU5ERVggPSAwXG5cbmlmICh3aW5kb3cgJiYgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKG11dGF0aW9ucykge1xuICAgIGlmIChPYmplY3Qua2V5cyh3YXRjaCkubGVuZ3RoIDwgMSkgcmV0dXJuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChtdXRhdGlvbnNbaV0uYXR0cmlidXRlTmFtZSA9PT0gS0VZX0FUVFIpIHtcbiAgICAgICAgZWFjaEF0dHIobXV0YXRpb25zW2ldLCB0dXJub24sIHR1cm5vZmYpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBlYWNoTXV0YXRpb24obXV0YXRpb25zW2ldLnJlbW92ZWROb2RlcywgdHVybm9mZilcbiAgICAgIGVhY2hNdXRhdGlvbihtdXRhdGlvbnNbaV0uYWRkZWROb2RlcywgdHVybm9uKVxuICAgIH1cbiAgfSlcbiAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICBiZWdpbk9ic2VydmUob2JzZXJ2ZXIpXG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgYmVnaW5PYnNlcnZlKG9ic2VydmVyKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYmVnaW5PYnNlcnZlIChvYnNlcnZlcikge1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwge1xuICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICBzdWJ0cmVlOiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgYXR0cmlidXRlRmlsdGVyOiBbS0VZX0FUVFJdXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gb25sb2FkIChlbCwgb24sIG9mZiwgY2FsbGVyKSB7XG4gIGFzc2VydChkb2N1bWVudC5ib2R5LCAnb24tbG9hZDogd2lsbCBub3Qgd29yayBwcmlvciB0byBET01Db250ZW50TG9hZGVkJylcbiAgb24gPSBvbiB8fCBmdW5jdGlvbiAoKSB7fVxuICBvZmYgPSBvZmYgfHwgZnVuY3Rpb24gKCkge31cbiAgZWwuc2V0QXR0cmlidXRlKEtFWV9BVFRSLCAnbycgKyBJTkRFWClcbiAgd2F0Y2hbJ28nICsgSU5ERVhdID0gW29uLCBvZmYsIDAsIGNhbGxlciB8fCBvbmxvYWQuY2FsbGVyXVxuICBJTkRFWCArPSAxXG4gIHJldHVybiBlbFxufVxuXG5tb2R1bGUuZXhwb3J0cy5LRVlfQVRUUiA9IEtFWV9BVFRSXG5tb2R1bGUuZXhwb3J0cy5LRVlfSUQgPSBLRVlfSURcblxuZnVuY3Rpb24gdHVybm9uIChpbmRleCwgZWwpIHtcbiAgaWYgKHdhdGNoW2luZGV4XVswXSAmJiB3YXRjaFtpbmRleF1bMl0gPT09IDApIHtcbiAgICB3YXRjaFtpbmRleF1bMF0oZWwpXG4gICAgd2F0Y2hbaW5kZXhdWzJdID0gMVxuICB9XG59XG5cbmZ1bmN0aW9uIHR1cm5vZmYgKGluZGV4LCBlbCkge1xuICBpZiAod2F0Y2hbaW5kZXhdWzFdICYmIHdhdGNoW2luZGV4XVsyXSA9PT0gMSkge1xuICAgIHdhdGNoW2luZGV4XVsxXShlbClcbiAgICB3YXRjaFtpbmRleF1bMl0gPSAwXG4gIH1cbn1cblxuZnVuY3Rpb24gZWFjaEF0dHIgKG11dGF0aW9uLCBvbiwgb2ZmKSB7XG4gIHZhciBuZXdWYWx1ZSA9IG11dGF0aW9uLnRhcmdldC5nZXRBdHRyaWJ1dGUoS0VZX0FUVFIpXG4gIGlmIChzYW1lT3JpZ2luKG11dGF0aW9uLm9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICB3YXRjaFtuZXdWYWx1ZV0gPSB3YXRjaFttdXRhdGlvbi5vbGRWYWx1ZV1cbiAgICByZXR1cm5cbiAgfVxuICBpZiAod2F0Y2hbbXV0YXRpb24ub2xkVmFsdWVdKSB7XG4gICAgb2ZmKG11dGF0aW9uLm9sZFZhbHVlLCBtdXRhdGlvbi50YXJnZXQpXG4gIH1cbiAgaWYgKHdhdGNoW25ld1ZhbHVlXSkge1xuICAgIG9uKG5ld1ZhbHVlLCBtdXRhdGlvbi50YXJnZXQpXG4gIH1cbn1cblxuZnVuY3Rpb24gc2FtZU9yaWdpbiAob2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gIGlmICghb2xkVmFsdWUgfHwgIW5ld1ZhbHVlKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIHdhdGNoW29sZFZhbHVlXVszXSA9PT0gd2F0Y2hbbmV3VmFsdWVdWzNdXG59XG5cbmZ1bmN0aW9uIGVhY2hNdXRhdGlvbiAobm9kZXMsIGZuKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMod2F0Y2gpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0gJiYgbm9kZXNbaV0uZ2V0QXR0cmlidXRlICYmIG5vZGVzW2ldLmdldEF0dHJpYnV0ZShLRVlfQVRUUikpIHtcbiAgICAgIHZhciBvbmxvYWRpZCA9IG5vZGVzW2ldLmdldEF0dHJpYnV0ZShLRVlfQVRUUilcbiAgICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAob25sb2FkaWQgPT09IGspIHtcbiAgICAgICAgICBmbihrLCBub2Rlc1tpXSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKG5vZGVzW2ldLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgZWFjaE11dGF0aW9uKG5vZGVzW2ldLmNoaWxkTm9kZXMsIGZuKVxuICAgIH1cbiAgfVxufVxuIiwiY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaFxuXG4vLyBnZXQgdXJsIHBhdGggc2VjdGlvbiBmcm9tIGEgdXJsXG4vLyBzdHJpcCBxdWVyeXN0cmluZ3MgLyBoYXNoZXNcbi8vIHN0cmlwIHByb3RvY29sXG4vLyBzdHJpcCBob3N0bmFtZSBhbmQgcG9ydCAoYm90aCBpcCBhbmQgcm91dGUpXG4vLyBzdHIgLT4gc3RyXG5mdW5jdGlvbiBtYXRjaCAocm91dGUpIHtcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiByb3V0ZSwgJ3N0cmluZycpXG5cbiAgcmV0dXJuIHJvdXRlLnRyaW0oKVxuICAgIC5yZXBsYWNlKC9bXFw/fCNdLiokLywgJycpXG4gICAgLnJlcGxhY2UoL14oPzpodHRwcz9cXDopXFwvXFwvLywgJycpXG4gICAgLnJlcGxhY2UoL14uKj8oXFwvLiopLywgJyQxJylcbiAgICAucmVwbGFjZSgvXFwvJC8sICcnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBhdm9pZCBzY29wZSBjcmVlcCwgdGhlIGtleXMgYXJyYXkgY2FuIHRoZW4gYmUgY29sbGVjdGVkXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG4gIH1cbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwbmEubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHBuYS5uZXh0VGljayhjYiwgZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciByZWFkYWJsZUh3bSA9IG9wdGlvbnMucmVhZGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHJlYWRhYmxlSHdtIHx8IHJlYWRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gcmVhZGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHBuYS5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcG5hLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcG5hLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShlciwgZGF0YSkge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICB0aGlzLnB1c2goZGF0YSk7XG5cbiAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSB7XG4gICAgYWZ0ZXJUcmFuc2Zvcm06IGFmdGVyVHJhbnNmb3JtLmJpbmQodGhpcyksXG4gICAgbmVlZFRyYW5zZm9ybTogZmFsc2UsXG4gICAgdHJhbnNmb3JtaW5nOiBmYWxzZSxcbiAgICB3cml0ZWNiOiBudWxsLFxuICAgIHdyaXRlY2h1bms6IG51bGwsXG4gICAgd3JpdGVlbmNvZGluZzogbnVsbFxuICB9O1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaCgpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpczIuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuICB0aGlzLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xuICB9O1xufVxuLyogPC9yZXBsYWNlbWVudD4gKi9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwbmEubmV4dFRpY2s7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZVxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIHRoYXQgd2UgYWx3YXlzIHJldHVybiBmYWxzZSBpZlxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciB3cml0YWJsZUh3bSA9IG9wdGlvbnMud3JpdGFibGVIaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuXG4gIGlmIChod20gfHwgaHdtID09PSAwKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod207ZWxzZSBpZiAoaXNEdXBsZXggJiYgKHdyaXRhYmxlSHdtIHx8IHdyaXRhYmxlSHdtID09PSAwKSkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gd3JpdGFibGVId207ZWxzZSB0aGlzLmhpZ2hXYXRlck1hcmsgPSBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG5cbiAgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG4gIHRoaXMucGVuZGluZ2NiID0gMDtcblxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG4gIHRoaXMucHJlZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuXG4gIC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuXG4gIC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xufVxuXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5idWZmZXJlZFJlcXVlc3Q7XG4gIHZhciBvdXQgPSBbXTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpO1xuXG4vLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cbnZhciByZWFsSGFzSW5zdGFuY2U7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gIXN0YXRlLm9iamVjdE1vZGUgJiYgX2lzVWludDhBcnJheShjaHVuayk7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwbmEubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxuICAgIC8vIGFsd2F5cyBmb2xsb3cgZXJyb3JcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcikgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7ZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICAvKjxyZXBsYWNlbWVudD4qL1xuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgICAgLyo8L3JlcGxhY2VtZW50PiovXG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7XG5cbiAgICAvLyBkb1dyaXRlIGlzIGFsbW9zdCBhbHdheXMgYXN5bmMsIGRlZmVyIHRoZXNlIHRvIHNhdmUgYSBiaXQgb2YgdGltZVxuICAgIC8vIGFzIHRoZSBob3QgcGF0aCBlbmRzIHdpdGggZG9Xcml0ZVxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfVxuXG4gIC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cbiAgaWYgKCFzdGF0ZS5lbmRpbmcgJiYgIXN0YXRlLmZpbmlzaGVkKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkICYmICFzdGF0ZS5maW5hbENhbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwbmEubmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICBpZiAoY2IpIHtcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHBuYS5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMuZW5kKCk7XG4gIGNiKGVycik7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBzcmMuY29weSh0YXJnZXQsIG9mZnNldCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogdGhpcy5oZWFkIH07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIC0tdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgIH1yZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdChuKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuaGVhZC5kYXRhO1xuICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7XG5cbmlmICh1dGlsICYmIHV0aWwuaW5zcGVjdCAmJiB1dGlsLmluc3BlY3QuY3VzdG9tKSB7XG4gIG1vZHVsZS5leHBvcnRzLnByb3RvdHlwZVt1dGlsLmluc3BlY3QuY3VzdG9tXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2JqID0gdXRpbC5pbnNwZWN0KHsgbGVuZ3RoOiB0aGlzLmxlbmd0aCB9KTtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyAnICsgb2JqO1xuICB9O1xufSIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2hcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuIiwiY29uc3Qgd2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hcblxuLy8gbGlzdGVuIHRvIHdpbmRvdyBoYXNoY2hhbmdlIGV2ZW50c1xuLy8gYW5kIHVwZGF0ZSByb3V0ZXIgYWNjb3JkaW5nbHlcbi8vIGZuKGNiKSAtPiBudWxsXG5mdW5jdGlvbiBoYXNoIChjYikge1xuICBhc3NlcnQuZXF1YWwodHlwZW9mIGNiLCAnZnVuY3Rpb24nLCAnY2IgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgd2luZG93Lm9uaGFzaGNoYW5nZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgY2Iod2luZG93LmxvY2F0aW9uLmhhc2gpXG4gIH1cbn1cbiIsImNvbnN0IGRvY3VtZW50ID0gcmVxdWlyZSgnZ2xvYmFsL2RvY3VtZW50JylcbmNvbnN0IHdpbmRvdyA9IHJlcXVpcmUoJ2dsb2JhbC93aW5kb3cnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxubW9kdWxlLmV4cG9ydHMgPSBoaXN0b3J5XG5cbi8vIGxpc3RlbiB0byBodG1sNSBwdXNoc3RhdGUgZXZlbnRzXG4vLyBhbmQgdXBkYXRlIHJvdXRlciBhY2NvcmRpbmdseVxuLy8gZm4oc3RyKSAtPiBudWxsXG5mdW5jdGlvbiBoaXN0b3J5IChjYikge1xuICBhc3NlcnQuZXF1YWwodHlwZW9mIGNiLCAnZnVuY3Rpb24nLCAnY2IgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgd2luZG93Lm9ucG9wc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2IoZG9jdW1lbnQubG9jYXRpb24uaHJlZilcbiAgfVxufVxuIiwiY29uc3Qgd2luZG93ID0gcmVxdWlyZSgnZ2xvYmFsL3dpbmRvdycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhyZWZcblxuLy8gaGFuZGxlIGEgY2xpY2sgaWYgaXMgYW5jaG9yIHRhZyB3aXRoIGFuIGhyZWZcbi8vIGFuZCB1cmwgbGl2ZXMgb24gdGhlIHNhbWUgZG9tYWluLiBSZXBsYWNlc1xuLy8gdHJhaWxpbmcgJyMnIHNvIGVtcHR5IGxpbmtzIHdvcmsgYXMgZXhwZWN0ZWQuXG4vLyBmbihzdHIpIC0+IG51bGxcbmZ1bmN0aW9uIGhyZWYgKGNiKSB7XG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgY2IsICdmdW5jdGlvbicsICdjYiBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuXG4gIHdpbmRvdy5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICBjb25zdCBub2RlID0gKGZ1bmN0aW9uIHRyYXZlcnNlIChub2RlKSB7XG4gICAgICBpZiAoIW5vZGUpIHJldHVyblxuICAgICAgaWYgKG5vZGUubG9jYWxOYW1lICE9PSAnYScpIHJldHVybiB0cmF2ZXJzZShub2RlLnBhcmVudE5vZGUpXG4gICAgICBpZiAobm9kZS5ocmVmID09PSB1bmRlZmluZWQpIHJldHVybiB0cmF2ZXJzZShub2RlLnBhcmVudE5vZGUpXG4gICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhvc3QgIT09IG5vZGUuaG9zdCkgcmV0dXJuIHRyYXZlcnNlKG5vZGUucGFyZW50Tm9kZSlcbiAgICAgIHJldHVybiBub2RlXG4gICAgfSkoZS50YXJnZXQpXG5cbiAgICBpZiAoIW5vZGUpIHJldHVyblxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgY29uc3QgaHJlZiA9IG5vZGUuaHJlZi5yZXBsYWNlKC8jJC8sICcnKVxuICAgIGNiKGhyZWYpXG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCBudWxsLCBocmVmKVxuICB9XG59XG4iLCJjb25zdCBwYXRobmFtZSA9IHJlcXVpcmUoJ3BhdGhuYW1lLW1hdGNoJylcbmNvbnN0IHdheWZhcmVyID0gcmVxdWlyZSgnd2F5ZmFyZXInKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcblxubW9kdWxlLmV4cG9ydHMgPSBzaGVldFJvdXRlclxuXG4vLyBGYXN0LCBtb2R1bGFyIGNsaWVudCByb3V0ZXJcbi8vIGZuKHN0ciwgYW55Wy4uXSwgZm4/KSAtPiBmbihzdHIsIGFueVsuLl0pXG5mdW5jdGlvbiBzaGVldFJvdXRlciAoZGZ0LCBjcmVhdGVUcmVlLCBjcmVhdGVSb3V0ZSkge1xuICBjcmVhdGVSb3V0ZSA9IChjcmVhdGVSb3V0ZSA/IGNyZWF0ZVJvdXRlKF9jcmVhdGVSb3V0ZSkgOiBfY3JlYXRlUm91dGUpXG5cbiAgaWYgKCFjcmVhdGVUcmVlKSB7XG4gICAgY3JlYXRlVHJlZSA9IGRmdFxuICAgIGRmdCA9ICcnXG4gIH1cblxuICBhc3NlcnQuZXF1YWwodHlwZW9mIGRmdCwgJ3N0cmluZycsICdzaGVldC1yb3V0ZXI6IGRmdCBtdXN0IGJlIGEgc3RyaW5nJylcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBjcmVhdGVUcmVlLCAnZnVuY3Rpb24nLCAnc2hlZXQtcm91dGVyOiBjcmVhdGVUcmVlIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gIGFzc2VydC5lcXVhbCh0eXBlb2YgY3JlYXRlUm91dGUsICdmdW5jdGlvbicsICdzaGVldC1yb3V0ZXI6IGNyZWF0ZVJvdXRlIG11c3QgYmUgYSBmdW5jdGlvbicpXG5cbiAgY29uc3Qgcm91dGVyID0gd2F5ZmFyZXIoZGZ0KVxuICBjb25zdCB0cmVlID0gY3JlYXRlVHJlZShjcmVhdGVSb3V0ZSlcblxuICAvLyByZWdpc3RlciB0cmVlIGluIHJvdXRlclxuICA7KGZ1bmN0aW9uIHdhbGsgKHRyZWUsIHJvdXRlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJlZVswXSkpIHtcbiAgICAgIC8vIHdhbGsgb3ZlciBhbGwgcm91dGVzIGF0IHRoZSByb290IG9mIHRoZSB0cmVlXG4gICAgICB0cmVlLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgd2Fsayhub2RlLCByb3V0ZSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICh0cmVlWzFdKSB7XG4gICAgICAvLyBoYW5kbGUgaW5saW5lIGZ1bmN0aW9ucyBhcyBhcmdzXG4gICAgICBjb25zdCBpbm5lclJvdXRlID0gdHJlZVswXVxuICAgICAgICA/IHJvdXRlLmNvbmNhdCh0cmVlWzBdKS5qb2luKCcvJylcbiAgICAgICAgOiByb3V0ZS5sZW5ndGggPyByb3V0ZS5qb2luKCcvJykgOiB0cmVlWzBdXG4gICAgICByb3V0ZXIub24oaW5uZXJSb3V0ZSwgdHJlZVsxXSlcbiAgICAgIHdhbGsodHJlZVsyXSwgcm91dGUuY29uY2F0KHRyZWVbMF0pKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0cmVlWzJdKSkge1xuICAgICAgLy8gdHJhdmVyc2UgYW5kIGFwcGVuZCByb3V0ZVxuICAgICAgd2Fsayh0cmVlWzJdLCByb3V0ZS5jb25jYXQodHJlZVswXSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlZ2lzdGVyIHBhdGggaW4gcm91dGVyXG4gICAgICBjb25zdCBud1JvdXRlID0gdHJlZVswXVxuICAgICAgICA/IHJvdXRlLmNvbmNhdCh0cmVlWzBdKS5qb2luKCcvJylcbiAgICAgICAgOiByb3V0ZS5sZW5ndGggPyByb3V0ZS5qb2luKCcvJykgOiB0cmVlWzBdXG4gICAgICByb3V0ZXIub24obndSb3V0ZSwgdHJlZVsyXSlcbiAgICB9XG4gIH0pKHRyZWUsIFtdKVxuXG4gIC8vIG1hdGNoIGEgcm91dGUgb24gdGhlIHJvdXRlclxuICByZXR1cm4gZnVuY3Rpb24gbWF0Y2ggKHJvdXRlKSB7XG4gICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiByb3V0ZSwgJ3N0cmluZycsICdyb3V0ZSBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICBjb25zdCBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgYXJnc1swXSA9IHBhdGhuYW1lKGFyZ3NbMF0pXG4gICAgcmV0dXJuIHJvdXRlci5hcHBseShudWxsLCBhcmdzKVxuICB9XG59XG5cbi8vIHJlZ2lzdGVyIHJlZ3VsYXIgcm91dGVcbmZ1bmN0aW9uIF9jcmVhdGVSb3V0ZSAocm91dGUsIGlubGluZSwgY2hpbGQpIHtcbiAgaWYgKCFjaGlsZCkge1xuICAgIGNoaWxkID0gaW5saW5lXG4gICAgaW5saW5lID0gbnVsbFxuICB9XG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygcm91dGUsICdzdHJpbmcnLCAncm91dGUgbXVzdCBiZSBhIHN0cmluZycpXG4gIGFzc2VydC5vayhjaGlsZCwgJ2NoaWxkIGV4aXN0cycpXG4gIHJvdXRlID0gcm91dGUucmVwbGFjZSgvXlxcLy8sICcnKVxuICByZXR1cm4gWyByb3V0ZSwgaW5saW5lLCBjaGlsZCBdXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgdHJpZSA9IHJlcXVpcmUoJy4vdHJpZScpXG5cbm1vZHVsZS5leHBvcnRzID0gV2F5ZmFyZXJcblxuLy8gY3JlYXRlIGEgcm91dGVyXG4vLyBzdHIgLT4gb2JqXG5mdW5jdGlvbiBXYXlmYXJlciAoZGZ0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXYXlmYXJlcikpIHJldHVybiBuZXcgV2F5ZmFyZXIoZGZ0KVxuXG4gIHZhciBfZGVmYXVsdCA9IChkZnQgfHwgJycpLnJlcGxhY2UoL15cXC8vLCAnJylcbiAgdmFyIF90cmllID0gdHJpZSgpXG5cbiAgZW1pdC5fdHJpZSA9IF90cmllXG4gIGVtaXQub24gPSBvblxuICBlbWl0LmVtaXQgPSBlbWl0XG4gIGVtaXQubWF0Y2ggPSBtYXRjaFxuICBlbWl0Ll93YXlmYXJlciA9IHRydWVcblxuICByZXR1cm4gZW1pdFxuXG4gIC8vIGRlZmluZSBhIHJvdXRlXG4gIC8vIChzdHIsIGZuKSAtPiBvYmpcbiAgZnVuY3Rpb24gb24gKHJvdXRlLCBmbikge1xuICAgIGFzc2VydC5lcXVhbCh0eXBlb2Ygcm91dGUsICdzdHJpbmcnKVxuICAgIGFzc2VydC5lcXVhbCh0eXBlb2YgZm4sICdmdW5jdGlvbicpXG5cbiAgICB2YXIgY2IgPSBmbi5fd2F5ZmFyZXIgJiYgZm4uX3RyaWUgPyBmbiA6IHByb3h5XG4gICAgcm91dGUgPSByb3V0ZSB8fCAnLydcbiAgICBjYi5yb3V0ZSA9IHJvdXRlXG5cbiAgICBpZiAoY2IuX3dheWZhcmVyICYmIGNiLl90cmllKSB7XG4gICAgICBfdHJpZS5tb3VudChyb3V0ZSwgY2IuX3RyaWUudHJpZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vZGUgPSBfdHJpZS5jcmVhdGUocm91dGUpXG4gICAgICBub2RlLmNiID0gY2JcbiAgICB9XG5cbiAgICByZXR1cm4gZW1pdFxuXG4gICAgZnVuY3Rpb24gcHJveHkgKCkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgfVxuICB9XG5cbiAgLy8gbWF0Y2ggYW5kIGNhbGwgYSByb3V0ZVxuICAvLyAoc3RyLCBvYmo/KSAtPiBudWxsXG4gIGZ1bmN0aW9uIGVtaXQgKHJvdXRlKSB7XG4gICAgdmFyIG1hdGNoZWQgPSBtYXRjaChyb3V0ZSlcblxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgYXJnc1swXSA9IG1hdGNoZWQucGFyYW1zXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZWQuY2IuYXBwbHkobWF0Y2hlZC5jYiwgYXJncylcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hdGNoIChyb3V0ZSkge1xuICAgIGFzc2VydC5ub3RFcXVhbChyb3V0ZSwgdW5kZWZpbmVkLCBcIidyb3V0ZScgbXVzdCBiZSBkZWZpbmVkXCIpXG5cbiAgICB2YXIgbWF0Y2hlZCA9IF90cmllLm1hdGNoKHJvdXRlKVxuICAgIGlmIChtYXRjaGVkICYmIG1hdGNoZWQuY2IpIHJldHVybiBuZXcgUm91dGUobWF0Y2hlZClcblxuICAgIHZhciBkZnQgPSBfdHJpZS5tYXRjaChfZGVmYXVsdClcbiAgICBpZiAoZGZ0ICYmIGRmdC5jYikgcmV0dXJuIG5ldyBSb3V0ZShkZnQpXG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyb3V0ZSAnXCIgKyByb3V0ZSArIFwiJyBkaWQgbm90IG1hdGNoXCIpXG4gIH1cblxuICBmdW5jdGlvbiBSb3V0ZSAobWF0Y2hlZCkge1xuICAgIHRoaXMuY2IgPSBtYXRjaGVkLmNiXG4gICAgdGhpcy5yb3V0ZSA9IG1hdGNoZWQuY2Iucm91dGVcbiAgICB0aGlzLnBhcmFtcyA9IG1hdGNoZWQucGFyYW1zXG4gIH1cbn1cbiIsInZhciBtdXRhdGUgPSByZXF1aXJlKCd4dGVuZC9tdXRhYmxlJylcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIHh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyaWVcblxuLy8gY3JlYXRlIGEgbmV3IHRyaWVcbi8vIG51bGwgLT4gb2JqXG5mdW5jdGlvbiBUcmllICgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyaWUpKSByZXR1cm4gbmV3IFRyaWUoKVxuICB0aGlzLnRyaWUgPSB7IG5vZGVzOiB7fSB9XG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgb24gdGhlIHRyaWUgYXQgcm91dGVcbi8vIGFuZCByZXR1cm4gYSBub2RlXG4vLyBzdHIgLT4gbnVsbFxuVHJpZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHJvdXRlKSB7XG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygcm91dGUsICdzdHJpbmcnLCAncm91dGUgc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgLy8gc3RyaXAgbGVhZGluZyAnLycgYW5kIHNwbGl0IHJvdXRlc1xuICB2YXIgcm91dGVzID0gcm91dGUucmVwbGFjZSgvXlxcLy8sICcnKS5zcGxpdCgnLycpXG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZSAoaW5kZXgsIHRyaWUpIHtcbiAgICB2YXIgdGhpc1JvdXRlID0gKHJvdXRlcy5oYXNPd25Qcm9wZXJ0eShpbmRleCkgJiYgcm91dGVzW2luZGV4XSlcbiAgICBpZiAodGhpc1JvdXRlID09PSBmYWxzZSkgcmV0dXJuIHRyaWVcblxuICAgIHZhciBub2RlID0gbnVsbFxuICAgIGlmICgvXjp8XlxcKi8udGVzdCh0aGlzUm91dGUpKSB7XG4gICAgICAvLyBpZiBub2RlIGlzIGEgbmFtZSBtYXRjaCwgc2V0IG5hbWUgYW5kIGFwcGVuZCB0byAnOicgbm9kZVxuICAgICAgaWYgKCF0cmllLm5vZGVzLmhhc093blByb3BlcnR5KCckJCcpKSB7XG4gICAgICAgIG5vZGUgPSB7IG5vZGVzOiB7fSB9XG4gICAgICAgIHRyaWUubm9kZXNbJyQkJ10gPSBub2RlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gdHJpZS5ub2Rlc1snJCQnXVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1JvdXRlWzBdID09PSAnKicpIHtcbiAgICAgICAgdHJpZS53aWxkY2FyZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgdHJpZS5uYW1lID0gdGhpc1JvdXRlLnJlcGxhY2UoL146fF5cXCovLCAnJylcbiAgICB9IGVsc2UgaWYgKCF0cmllLm5vZGVzLmhhc093blByb3BlcnR5KHRoaXNSb3V0ZSkpIHtcbiAgICAgIG5vZGUgPSB7IG5vZGVzOiB7fSB9XG4gICAgICB0cmllLm5vZGVzW3RoaXNSb3V0ZV0gPSBub2RlXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSB0cmllLm5vZGVzW3RoaXNSb3V0ZV1cbiAgICB9XG5cbiAgICAvLyB3ZSBtdXN0IHJlY3Vyc2UgZGVlcGVyXG4gICAgcmV0dXJuIGNyZWF0ZU5vZGUoaW5kZXggKyAxLCBub2RlKVxuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZU5vZGUoMCwgdGhpcy50cmllKVxufVxuXG4vLyBtYXRjaCBhIHJvdXRlIG9uIHRoZSB0cmllXG4vLyBhbmQgcmV0dXJuIHRoZSBub2RlXG4vLyBzdHIgLT4gb2JqXG5UcmllLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChyb3V0ZSkge1xuICBhc3NlcnQuZXF1YWwodHlwZW9mIHJvdXRlLCAnc3RyaW5nJywgJ3JvdXRlIHNob3VsZCBiZSBhIHN0cmluZycpXG5cbiAgdmFyIHJvdXRlcyA9IHJvdXRlLnJlcGxhY2UoL15cXC8vLCAnJykuc3BsaXQoJy8nKVxuICB2YXIgcGFyYW1zID0ge31cblxuICBmdW5jdGlvbiBzZWFyY2ggKGluZGV4LCB0cmllKSB7XG4gICAgLy8gZWl0aGVyIHRoZXJlJ3Mgbm8gbWF0Y2gsIG9yIHdlJ3JlIGRvbmUgc2VhcmNoaW5nXG4gICAgaWYgKHRyaWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHZhciB0aGlzUm91dGUgPSByb3V0ZXNbaW5kZXhdXG4gICAgaWYgKHRoaXNSb3V0ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdHJpZVxuXG4gICAgaWYgKHRyaWUubm9kZXMuaGFzT3duUHJvcGVydHkodGhpc1JvdXRlKSkge1xuICAgICAgLy8gbWF0Y2ggcmVndWxhciByb3V0ZXMgZmlyc3RcbiAgICAgIHJldHVybiBzZWFyY2goaW5kZXggKyAxLCB0cmllLm5vZGVzW3RoaXNSb3V0ZV0pXG4gICAgfSBlbHNlIGlmICh0cmllLm5hbWUpIHtcbiAgICAgIC8vIG1hdGNoIG5hbWVkIHJvdXRlc1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyYW1zW3RyaWUubmFtZV0gPSBkZWNvZGVVUklDb21wb25lbnQodGhpc1JvdXRlKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc2VhcmNoKGluZGV4LCB1bmRlZmluZWQpXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VhcmNoKGluZGV4ICsgMSwgdHJpZS5ub2Rlc1snJCQnXSlcbiAgICB9IGVsc2UgaWYgKHRyaWUud2lsZGNhcmQpIHtcbiAgICAgIC8vIG1hdGNoIHdpbGRjYXJkc1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyYW1zWyd3aWxkY2FyZCddID0gZGVjb2RlVVJJQ29tcG9uZW50KHJvdXRlcy5zbGljZShpbmRleCkuam9pbignLycpKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc2VhcmNoKGluZGV4LCB1bmRlZmluZWQpXG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gZWFybHksIG9yIGVsc2Ugc2VhcmNoIG1heSBrZWVwIHJlY3Vyc2luZyB0aHJvdWdoIHRoZSB3aWxkY2FyZFxuICAgICAgcmV0dXJuIHRyaWUubm9kZXNbJyQkJ11cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm8gbWF0Y2hlcyBmb3VuZFxuICAgICAgcmV0dXJuIHNlYXJjaChpbmRleCArIDEpXG4gICAgfVxuICB9XG5cbiAgdmFyIG5vZGUgPSBzZWFyY2goMCwgdGhpcy50cmllKVxuXG4gIGlmICghbm9kZSkgcmV0dXJuIHVuZGVmaW5lZFxuICBub2RlID0geHRlbmQobm9kZSlcbiAgbm9kZS5wYXJhbXMgPSBwYXJhbXNcbiAgcmV0dXJuIG5vZGVcbn1cblxuLy8gbW91bnQgYSB0cmllIG9udG8gYSBub2RlIGF0IHJvdXRlXG4vLyAoc3RyLCBvYmopIC0+IG51bGxcblRyaWUucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24gKHJvdXRlLCB0cmllKSB7XG4gIGFzc2VydC5lcXVhbCh0eXBlb2Ygcm91dGUsICdzdHJpbmcnLCAncm91dGUgc2hvdWxkIGJlIGEgc3RyaW5nJylcbiAgYXNzZXJ0LmVxdWFsKHR5cGVvZiB0cmllLCAnb2JqZWN0JywgJ3RyaWUgc2hvdWxkIGJlIGEgb2JqZWN0JylcblxuICB2YXIgc3BsaXQgPSByb3V0ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJylcbiAgdmFyIG5vZGUgPSBudWxsXG4gIHZhciBrZXkgPSBudWxsXG5cbiAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMSkge1xuICAgIGtleSA9IHNwbGl0WzBdXG4gICAgbm9kZSA9IHRoaXMuY3JlYXRlKGtleSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgaGVhZCA9IHNwbGl0LmpvaW4oJy8nKVxuICAgIGtleSA9IHNwbGl0WzBdXG4gICAgbm9kZSA9IHRoaXMuY3JlYXRlKGhlYWQpXG4gIH1cblxuICBtdXRhdGUobm9kZS5ub2RlcywgdHJpZS5ub2RlcylcbiAgaWYgKHRyaWUubmFtZSkgbm9kZS5uYW1lID0gdHJpZS5uYW1lXG5cbiAgLy8gZGVsZWdhdGUgcHJvcGVydGllcyBmcm9tICcvJyB0byB0aGUgbmV3IG5vZGVcbiAgLy8gJy8nIGNhbm5vdCBiZSByZWFjaGVkIG9uY2UgbW91bnRlZFxuICBpZiAobm9kZS5ub2Rlc1snJ10pIHtcbiAgICBPYmplY3Qua2V5cyhub2RlLm5vZGVzWycnXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoa2V5ID09PSAnbm9kZXMnKSByZXR1cm5cbiAgICAgIG5vZGVba2V5XSA9IG5vZGUubm9kZXNbJyddW2tleV1cbiAgICB9KVxuICAgIG11dGF0ZShub2RlLm5vZGVzLCBub2RlLm5vZGVzWycnXS5ub2RlcylcbiAgICBkZWxldGUgbm9kZS5ub2Rlc1snJ10ubm9kZXNcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwidmFyIGJlbCA9IHJlcXVpcmUoJ2JlbCcpIC8vIHR1cm5zIHRlbXBsYXRlIHRhZyBpbnRvIERPTSBlbGVtZW50c1xudmFyIG1vcnBoZG9tID0gcmVxdWlyZSgnbW9ycGhkb20nKSAvLyBlZmZpY2llbnRseSBkaWZmcyArIG1vcnBocyB0d28gRE9NIGVsZW1lbnRzXG52YXIgZGVmYXVsdEV2ZW50cyA9IHJlcXVpcmUoJy4vdXBkYXRlLWV2ZW50cy5qcycpIC8vIGRlZmF1bHQgZXZlbnRzIHRvIGJlIGNvcGllZCB3aGVuIGRvbSBlbGVtZW50cyB1cGRhdGVcblxubW9kdWxlLmV4cG9ydHMgPSBiZWxcblxuLy8gVE9ETyBtb3ZlIHRoaXMgKyBkZWZhdWx0RXZlbnRzIHRvIGEgbmV3IG1vZHVsZSBvbmNlIHdlIHJlY2VpdmUgbW9yZSBmZWVkYmFja1xubW9kdWxlLmV4cG9ydHMudXBkYXRlID0gZnVuY3Rpb24gKGZyb21Ob2RlLCB0b05vZGUsIG9wdHMpIHtcbiAgaWYgKCFvcHRzKSBvcHRzID0ge31cbiAgaWYgKG9wdHMuZXZlbnRzICE9PSBmYWxzZSkge1xuICAgIGlmICghb3B0cy5vbkJlZm9yZUVsVXBkYXRlZCkgb3B0cy5vbkJlZm9yZUVsVXBkYXRlZCA9IGNvcGllclxuICB9XG5cbiAgcmV0dXJuIG1vcnBoZG9tKGZyb21Ob2RlLCB0b05vZGUsIG9wdHMpXG5cbiAgLy8gbW9ycGhkb20gb25seSBjb3BpZXMgYXR0cmlidXRlcy4gd2UgZGVjaWRlZCB3ZSBhbHNvIHdhbnRlZCB0byBjb3B5IGV2ZW50c1xuICAvLyB0aGF0IGNhbiBiZSBzZXQgdmlhIGF0dHJpYnV0ZXNcbiAgZnVuY3Rpb24gY29waWVyIChmLCB0KSB7XG4gICAgLy8gY29weSBldmVudHM6XG4gICAgdmFyIGV2ZW50cyA9IG9wdHMuZXZlbnRzIHx8IGRlZmF1bHRFdmVudHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV2ID0gZXZlbnRzW2ldXG4gICAgICBpZiAodFtldl0pIHsgLy8gaWYgbmV3IGVsZW1lbnQgaGFzIGEgd2hpdGVsaXN0ZWQgYXR0cmlidXRlXG4gICAgICAgIGZbZXZdID0gdFtldl0gLy8gdXBkYXRlIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgIH0gZWxzZSBpZiAoZltldl0pIHsgLy8gaWYgZXhpc3RpbmcgZWxlbWVudCBoYXMgaXQgYW5kIG5ldyBvbmUgZG9lc250XG4gICAgICAgIGZbZXZdID0gdW5kZWZpbmVkIC8vIHJlbW92ZSBpdCBmcm9tIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG9sZFZhbHVlID0gZi52YWx1ZVxuICAgIHZhciBuZXdWYWx1ZSA9IHQudmFsdWVcbiAgICAvLyBjb3B5IHZhbHVlcyBmb3IgZm9ybSBlbGVtZW50c1xuICAgIGlmICgoZi5ub2RlTmFtZSA9PT0gJ0lOUFVUJyAmJiBmLnR5cGUgIT09ICdmaWxlJykgfHwgZi5ub2RlTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgIGlmICghbmV3VmFsdWUgJiYgIXQuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgIHQudmFsdWUgPSBmLnZhbHVlXG4gICAgICB9IGVsc2UgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICBmLnZhbHVlID0gbmV3VmFsdWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGYubm9kZU5hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgIGlmICh0LmdldEF0dHJpYnV0ZSgndmFsdWUnKSA9PT0gbnVsbCkgZi52YWx1ZSA9IHQudmFsdWVcbiAgICB9XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gW1xuICAvLyBhdHRyaWJ1dGUgZXZlbnRzIChjYW4gYmUgc2V0IHdpdGggYXR0cmlidXRlcylcbiAgJ29uY2xpY2snLFxuICAnb25kYmxjbGljaycsXG4gICdvbm1vdXNlZG93bicsXG4gICdvbm1vdXNldXAnLFxuICAnb25tb3VzZW92ZXInLFxuICAnb25tb3VzZW1vdmUnLFxuICAnb25tb3VzZW91dCcsXG4gICdvbmRyYWdzdGFydCcsXG4gICdvbmRyYWcnLFxuICAnb25kcmFnZW50ZXInLFxuICAnb25kcmFnbGVhdmUnLFxuICAnb25kcmFnb3ZlcicsXG4gICdvbmRyb3AnLFxuICAnb25kcmFnZW5kJyxcbiAgJ29ua2V5ZG93bicsXG4gICdvbmtleXByZXNzJyxcbiAgJ29ua2V5dXAnLFxuICAnb251bmxvYWQnLFxuICAnb25hYm9ydCcsXG4gICdvbmVycm9yJyxcbiAgJ29ucmVzaXplJyxcbiAgJ29uc2Nyb2xsJyxcbiAgJ29uc2VsZWN0JyxcbiAgJ29uY2hhbmdlJyxcbiAgJ29uc3VibWl0JyxcbiAgJ29ucmVzZXQnLFxuICAnb25mb2N1cycsXG4gICdvbmJsdXInLFxuICAnb25pbnB1dCcsXG4gIC8vIG90aGVyIGNvbW1vbiBldmVudHNcbiAgJ29uY29udGV4dG1lbnUnLFxuICAnb25mb2N1c2luJyxcbiAgJ29uZm9jdXNvdXQnXG5dXG4iLCJjb25zdCBCTiA9IHJlcXVpcmUoJ2JuLmpzJylcbmNvbnN0IGV0aFV0aWwgPSByZXF1aXJlKCdldGhlcmV1bWpzLXV0aWwnKVxuY29uc3Qgb3Bjb2RlcyA9IHJlcXVpcmUoJy4vb3Bjb2Rlcy5qcycpXG5jb25zdCB3YXN0U3luY0ludGVyZmFjZSA9IHJlcXVpcmUoJy4vd2FzbS93YXN0Lmpzb24nKVxuY29uc3Qgd2FzdEFzeW5jSW50ZXJmYWNlID0gcmVxdWlyZSgnLi93YXNtL3dhc3QtYXN5bmMuanNvbicpXG4vLyBjb25zdCB3YWJ0ID0gcmVxdWlyZSgnd2FidCcpXG5cbi8vIG1hcCB0byB0cmFjayBkZXBlbmRlbnQgV0FTTSBmdW5jdGlvbnNcbmNvbnN0IGRlcE1hcCA9IG5ldyBNYXAoW1xuICBbJ2NhbGxiYWNrXzI1NicsIFsnYnN3YXBfbTI1NiddXSxcbiAgWydjYWxsYmFja18xNjAnLCBbJ2Jzd2FwX20xNjAnXV0sXG4gIFsnY2FsbGJhY2tfMTI4JywgWydic3dhcF9tMTI4J11dLFxuICBbJ2Jzd2FwX20yNTYnLCBbJ2Jzd2FwX2k2NCddXSxcbiAgWydic3dhcF9tMTI4JywgWydic3dhcF9pNjQnXV0sXG4gIFsnYnN3YXBfbTE2MCcsIFsnYnN3YXBfaTY0JywgJ2Jzd2FwX2kzMiddXSxcbiAgWydrZWNjYWsnLCBbJ21lbWNweScsICdtZW1zZXQnXV0sXG4gIFsnbW9kXzMyMCcsIFsnaXN6ZXJvXzMyMCcsICdndGVfMzIwJ11dLFxuICBbJ21vZF81MTInLCBbJ2lzemVyb181MTInLCAnZ3RlXzUxMiddXSxcbiAgWydNT0QnLCBbJ2lzemVyb18yNTYnLCAnZ3RlXzI1NiddXSxcbiAgWydBRERNT0QnLCBbJ21vZF8zMjAnXV0sXG4gIFsnTVVMTU9EJywgWydtb2RfNTEyJ11dLFxuICBbJ1NESVYnLCBbJ2lzemVyb18yNTYnLCAnZ3RlXzI1NiddXSxcbiAgWydTTU9EJywgWydpc3plcm9fMjU2JywgJ2d0ZV8yNTYnXV0sXG4gIFsnRElWJywgWydpc3plcm9fMjU2JywgJ2d0ZV8yNTYnXV0sXG4gIFsnRVhQJywgWydpc3plcm9fMjU2JywgJ211bF8yNTYnXV0sXG4gIFsnTVVMJywgWydtdWxfMjU2J11dLFxuICBbJ0lTWkVSTycsIFsnaXN6ZXJvXzI1NiddXSxcbiAgWydNU1RPUkUnLCBbJ21lbXVzZWdhcycsICdic3dhcF9tMjU2JywgJ2NoZWNrX292ZXJmbG93J11dLFxuICBbJ01MT0FEJywgWydtZW11c2VnYXMnLCAnYnN3YXBfbTI1NicsICdjaGVja19vdmVyZmxvdyddXSxcbiAgWydNU1RPUkU4JywgWydtZW11c2VnYXMnLCAnY2hlY2tfb3ZlcmZsb3cnXV0sXG4gIFsnQ09ERUNPUFknLCBbJ2NhbGxiYWNrJywgJ21lbXVzZWdhcycsICdjaGVja19vdmVyZmxvdycsICdtZW1zZXQnXV0sXG4gIFsnQ0FMTERBVEFMT0FEJywgWydic3dhcF9tMjU2JywgJ2Jzd2FwX2k2NCcsICdjaGVja19vdmVyZmxvdyddXSxcbiAgWydDQUxMREFUQUNPUFknLCBbJ21lbXVzZWdhcycsICdjaGVja19vdmVyZmxvdycsICdtZW1zZXQnXV0sXG4gIFsnQ0FMTFZBTFVFJywgWydic3dhcF9tMjU2J11dLFxuICBbJ0VYVENPREVDT1BZJywgWydic3dhcF9tMjU2JywgJ2NhbGxiYWNrJywgJ21lbXVzZWdhcycsICdjaGVja19vdmVyZmxvdycsICdtZW1zZXQnXV0sXG4gIFsnRVhUQ09ERVNJWkUnLCBbJ2Jzd2FwX20yNTYnLCAnY2FsbGJhY2tfMzInXV0sXG4gIFsnRVhUQ09ERUhBU0gnLCBbJ2Jzd2FwX20yNTYnLCAnY2FsbGJhY2tfMjU2J11dLFxuICBbJ1JFVFVSTkRBVEFDT1BZJywgWydtZW11c2VnYXMnLCAnY2hlY2tfb3ZlcmZsb3cnLCAnbWVtc2V0J11dLFxuICBbJ0xPRycsIFsnbWVtdXNlZ2FzJywgJ2Jzd2FwX20yNTYnLCAnY2hlY2tfb3ZlcmZsb3cnXV0sXG4gIFsnQkxPQ0tIQVNIJywgWydjaGVja19vdmVyZmxvdycsICdjYWxsYmFja18yNTYnXV0sXG4gIFsnU0hBMycsIFsnbWVtdXNlZ2FzJywgJ2Jzd2FwX20yNTYnLCAnY2hlY2tfb3ZlcmZsb3cnLCAna2VjY2FrJ11dLFxuICBbJ0NBTEwnLCBbJ2Jzd2FwX20yNTYnLCAnYnN3YXBfbTI1NicsICdjYWxsYmFjaycsICdtZW11c2VnYXMnLCAnY2hlY2tfb3ZlcmZsb3dfaTY0JywgJ2NoZWNrX292ZXJmbG93JywgJ2NoZWNrX292ZXJmbG93X2k2NCcsICdtZW1zZXQnLCAnY2FsbGJhY2tfMzInXV0sXG4gIFsnREVMRUdBVEVDQUxMJywgWydic3dhcF9tMjU2JywgJ2NhbGxiYWNrJywgJ21lbXVzZWdhcycsICdjaGVja19vdmVyZmxvd19pNjQnLCAnY2hlY2tfb3ZlcmZsb3cnLCAnbWVtc2V0JywgJ2NhbGxiYWNrXzMyJ11dLFxuICBbJ1NUQVRJQ0NBTEwnLCBbJ2Jzd2FwX20yNTYnLCAnY2FsbGJhY2snLCAnbWVtdXNlZ2FzJywgJ2NoZWNrX292ZXJmbG93X2k2NCcsICdjaGVja19vdmVyZmxvdycsICdtZW1zZXQnLCAnY2FsbGJhY2tfMzInXV0sXG4gIFsnQ0FMTENPREUnLCBbJ2Jzd2FwX20yNTYnLCAnYnN3YXBfbTI1NicsICdjYWxsYmFjaycsICdtZW11c2VnYXMnLCAnY2hlY2tfb3ZlcmZsb3dfaTY0JywgJ2NoZWNrX292ZXJmbG93JywgJ2NoZWNrX292ZXJmbG93X2k2NCcsICdtZW1zZXQnLCAnY2FsbGJhY2tfMzInXV0sXG4gIFsnQ1JFQVRFJywgWydic3dhcF9tMjU2JywgJ2Jzd2FwX20xNjAnLCAnY2FsbGJhY2tfMjU2JywgJ21lbXVzZWdhcycsICdjaGVja19vdmVyZmxvdyddXSxcbiAgWydDUkVBVEUyJywgWydic3dhcF9tMjU2JywgJ2Jzd2FwX20xNjAnLCAnY2FsbGJhY2tfMjU2JywgJ21lbXVzZWdhcycsICdjaGVja19vdmVyZmxvdyddXSxcbiAgWydSRVRVUk4nLCBbJ21lbXVzZWdhcycsICdjaGVja19vdmVyZmxvdyddXSxcbiAgWydSRVZFUlQnLCBbJ21lbXVzZWdhcycsICdjaGVja19vdmVyZmxvdyddXSxcbiAgWydCQUxBTkNFJywgWydic3dhcF9tMjU2JywgJ2NhbGxiYWNrXzI1NiddXSxcbiAgWydTRUxGQkFMQU5DRScsIFsnY2FsbGJhY2tfMjU2J11dLFxuICBbJ1NFTEZERVNUUlVDVCcsIFsnYnN3YXBfbTI1NiddXSxcbiAgWydTU1RPUkUnLCBbJ2Jzd2FwX20yNTYnLCAnY2FsbGJhY2snXV0sXG4gIFsnU0xPQUQnLCBbJ2Jzd2FwX20yNTYnLCAnY2FsbGJhY2tfMjU2J11dLFxuICBbJ0NPREVTSVpFJywgWydjYWxsYmFja18zMiddXSxcbiAgWydESUZGSUNVTFRZJywgWydic3dhcF9tMjU2J11dLFxuICBbJ0NIQUlOSUQnLCBbJ2Jzd2FwX20yNTYnXV0sXG4gIFsnQkFTRUZFRScsIFsnYnN3YXBfbTE2MCddXSxcbiAgWydDT0lOQkFTRScsIFsnYnN3YXBfbTI1NiddXSxcbiAgWydPUklHSU4nLCBbJ2Jzd2FwX20yNTYnXV0sXG4gIFsnQUREUkVTUycsIFsnYnN3YXBfbTI1NiddXSxcbiAgWydDQUxMRVInLCBbJ2Jzd2FwX20yNTYnXV1cbl0pXG5cbi8vIG1hcHMgdGhlIGFzeW5jIG9wcyB0byB0aGVpciBjYWxsIGJhY2sgZnVuY3Rpb25cbmNvbnN0IGNhbGxiYWNrRnVuY3MgPSBuZXcgTWFwKFtcbiAgWydTU1RPUkUnLCAnJGNhbGxiYWNrJ10sXG4gIFsnU0xPQUQnLCAnJGNhbGxiYWNrXzI1NiddLFxuICBbJ0NSRUFURScsICckY2FsbGJhY2tfMjU2J10sXG4gIFsnQ1JFQVRFMicsICckY2FsbGJhY2tfMjU2J10sXG4gIFsnQ0FMTCcsICckY2FsbGJhY2tfMzInXSxcbiAgWydERUxFR0FURUNBTEwnLCAnJGNhbGxiYWNrJ10sXG4gIFsnQ0FMTENPREUnLCAnJGNhbGxiYWNrXzMyJ10sXG4gIFsnRVhUQ09ERUNPUFknLCAnJGNhbGxiYWNrJ10sXG4gIFsnRVhUQ09ERVNJWkUnLCAnJGNhbGxiYWNrXzMyJ10sXG4gIFsnRVhUQ09ERUhBU0gnLCAnJGNhbGxiYWNrXzI1NiddLFxuICBbJ0NPREVDT1BZJywgJyRjYWxsYmFjayddLFxuICBbJ0NPREVTSVpFJywgJyRjYWxsYmFja18zMiddLFxuICBbJ0JBTEFOQ0UnLCAnJGNhbGxiYWNrXzI1NiddLFxuICBbJ1NFTEZCQUxBTkNFJywgJyRjYWxsYmFja18yNTYnXSxcbiAgWydDSEFJTklEJywgJyRjYWxsYmFja18yNTYnXSxcbiAgWydCTE9DS0hBU0gnLCAnJGNhbGxiYWNrXzI1NiddXG5dKVxuXG5jb25zdCBJTlRFUkZBQ0VfQ0xBU1NJQyA9IFwiZXdhc21fZW52XzFcIjtcbmNvbnN0IElOVEVSRkFDRV9JTlRFUlBSRVRFUiA9IFwiZXdhc21fZXdhc21fMVwiO1xuXG4vLyAvKipcbi8vICAqIGNvbXBpbGVzIGV2bUNvZGUgdG8gd2FzbSBpbiB0aGUgYmluYXJ5IGZvcm1hdFxuLy8gICogQHBhcmFtIHtBcnJheX0gZXZtQ29kZVxuLy8gICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbi8vICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0cy5zdGFja1RyYWNlIGlmIGB0cnVlYCBnZW5lcmF0ZXMgYW4gcnVudGltZSBFVk0gc3RhY2sgdHJhY2UgKGRlZmF1bHQ6IGZhbHNlKVxuLy8gICogQHBhcmFtIHtib29sZWFufSBvcHRzLmlubGluZU9wcyBpZiBgdHJ1ZWAgaW5saW5lcyB0aGUgRVZNMSBvcGVyYXRpb25zIChkZWZhdWx0OiB0cnVlKVxuLy8gICogQHBhcmFtIHtTdHJpbmd9IG9wdHMudGVzdE5hbWUgaXMgdGhlIG5hbWUgdXNlZCBmb3IgdGhlIHdhc3QgZmlsZSAoZGVmYXVsdDogJ3RlbXAnKVxuLy8gICogQHBhcmFtIHtib29sZWFufSBvcHRzLmNoYXJnZVBlck9wIGlmIGB0cnVlYCBhZGRzIG1ldGVyaW5nIHN0YXRlbWVudHMgZm9yIHRoZSB3YXNtIGNvZGUgc2VjdGlvbiBjb3JyZXNwb25kaW5nIHRvIGVhY2ggRVZNIG9wY29kZSBhcyBvcHBvc2VkIHRvIG1ldGVyaW5nIG9uY2UgcGVyIGJyYW5jaCBzZWdtZW50IChkZWZhdWx0OiBmYWxzZSkuXG4vLyAgKiBAcmV0dXJuIHtzdHJpbmd9XG4vLyAgKi9cbi8vIGV4cG9ydHMuZXZtMndhc20gPSBmdW5jdGlvbiAoZXZtQ29kZSwgb3B0cyA9IHtcbi8vICAgJ3N0YWNrVHJhY2UnOiBmYWxzZSxcbi8vICAgJ3VzZUFzeW5jQVBJJzogZmFsc2UsXG4vLyAgICdpbmxpbmVPcHMnOiB0cnVlLFxuLy8gICAndGVzdE5hbWUnOiAndGVtcCcsXG4vLyAgICdjaGFyZ2VQZXJPcCc6IGZhbHNlLFxuLy8gICAnaXNDb25zdHJ1Y3Rvcic6ZmFsc2UsXG4vLyB9KSB7XG4vLyAgIGNvbnN0IHdhc3QgPSBleHBvcnRzLmV2bTJ3YXN0KGV2bUNvZGUsIG9wdHMpXG4vLyAgIGNvbnN0IG1vZCA9IHdhYnQucGFyc2VXYXQoJ2FyYml0cmFyeU1vZHVsZU5hbWUnLCB3YXN0KVxuLy8gICBtb2QucmVzb2x2ZU5hbWVzKClcbi8vICAgbW9kLnZhbGlkYXRlKClcbi8vICAgY29uc3QgYmluID0gbW9kLnRvQmluYXJ5KHtsb2c6IGZhbHNlLCB3cml0ZV9kZWJ1Z19uYW1lczogZmFsc2V9KS5idWZmZXJcbi8vICAgbW9kLmRlc3Ryb3koKVxuLy8gICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJpbilcbi8vIH1cblxuLyoqXG4gKiBUcmFuc2NvbXBpbGVzIEVWTSBjb2RlIHRvIGV3YXNtIGluIHRoZSBzZXhwcmVzc2lvbiB0ZXh0IGZvcm1hdC4gVGhlIEVWTSBjb2RlXG4gKiBpcyBicm9rZW4gaW50byBzZWdtZW50cyBhbmQgZWFjaCBpbnN0cnVjdGlvbiBpbiB0aG9zZSBzZWdtZW50cyBpcyByZXBsYWNlZFxuICogd2l0aCBhIGBjYWxsYCB0byB3YXNtIGZ1bmN0aW9uIHRoYXQgZG9lcyB0aGUgZXF1aXZhbGVudCBvcGVyYXRpb24uIEVhY2hcbiAqIG9wY29kZSBmdW5jdGlvbiB0YWtlcyBpbiBhbmQgcmV0dXJucyB0aGUgc3RhY2sgcG9pbnRlci5cbiAqXG4gKiBTZWdtZW50cyBhcmUgc2VjdGlvbnMgb2YgRVZNIGNvZGUgaW4gYmV0d2VlbiBmbG93IGNvbnRyb2xcbiAqIG9wY29kZXMgKEpVTVBJLiBKVU1QKS5cbiAqIEFsbCBzZWdtZW50cyBzdGFydCBhdFxuICogKiB0aGUgYmVnaW5uaW5nIGZvciBFVk0gY29kZVxuICogKiBhIEdBUyBvcGNvZGVcbiAqICogYSBKVU1QREVTVCBvcGNvZGVcbiAqICogQWZ0ZXIgYSBKVU1QSSBvcGNvZGVcbiAqIEBwYXJhbSB7SW50ZWdlcn0gZXZtQ29kZSB0aGUgZXZtIGJ5dGUgY29kZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0cy5zdGFja1RyYWNlIGlmIGB0cnVlYCBnZW5lcmF0ZXMgYSBzdGFjayB0cmFjZSAoZGVmYXVsdDogZmFsc2UpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdHMuaW5saW5lT3BzIGlmIGB0cnVlYCBpbmxpbmVzIHRoZSBFVk0xIG9wZXJhdGlvbnMgKGRlZmF1bHQ6IHRydWUpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdHMuY2hhcmdlUGVyT3AgaWYgYHRydWVgIGFkZHMgbWV0ZXJpbmcgc3RhdGVtZW50cyBmb3IgdGhlIHdhc20gY29kZSBzZWN0aW9uIGNvcnJlc3BvbmRpbmcgdG8gZWFjaCBFVk0gb3Bjb2RlIGFzIG9wcG9zZWQgdG8gbWV0ZXJpbmcgb25jZSBwZXIgYnJhbmNoIHNlZ21lbnQgKGRlZmF1bHQ6IGZhbHNlKS5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5ldm0yd2FzdCA9IGZ1bmN0aW9uIChkZXBsb3ltZW50RXZtQ29kZSwgb3B0cyA9IHtcbiAgJ3N0YWNrVHJhY2UnOiBmYWxzZSxcbiAgJ3VzZUFzeW5jQVBJJzogZmFsc2UsXG4gICdpbmxpbmVPcHMnOiB0cnVlLFxuICAnY2hhcmdlUGVyT3AnOiBmYWxzZSxcbiAgJ2lzQ29uc3RydWN0b3InOmZhbHNlLFxuICAnbm9nYXMnOiB0cnVlLFxufSkge1xuICAvLyBzb2w6IDM5IDYwIDAwIGYzIGZlXG4gIC8vIHl1bDogMzkgNjEwMTk2IDYwIDAwIGYzIGZlXG4gIC8vIGNvZGVjb3B5ICsgKHB1c2gyPykgKyBwdXNoMSAwICsgcmV0dXJuICsgaW52YWxpZFxuXG4gIGZ1bmN0aW9uIHNwbGl0Q29uc3RydWN0b3IoY29kZSkge1xuICAgIGlmIChjb2RlLmxlbmd0aCA8IDUpIHJldHVybiBbbmV3IEJ1ZmZlcigwKSwgY29kZV07XG4gICAgZm9yIChsZXQgaSA9IDMgOyBpIDwgY29kZS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gXCI2MDAwZjNmZVwiIFwiNjAwMGYzMDBcIlxuICAgICAgaWYgKGNvZGVbaS0zXSA9PSAweDYwICYmIGNvZGVbaS0yXSA9PSAweDAwICYmIGNvZGVbaS0xXSA9PSAweGYzICYmIChjb2RlW2ldID09IDB4ZmUgfHwgY29kZVtpXSA9PSAweDAwKSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIG5ldyBCdWZmZXIuZnJvbShVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvZGUpLnNsaWNlKDAsaSsxKSksXG4gICAgICAgICAgbmV3IEJ1ZmZlci5mcm9tKFVpbnQ4QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29kZSkuc2xpY2UoaSsxKSksXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbmV3IEJ1ZmZlcigwKSwgY29kZV07XG4gIH1cblxuICAvLyBhZGRzIHN0YWNrIGhlaWdodCBjaGVja3MgdG8gdGhlIGJlZ2lubmluZyBvZiBhIHNlZ21lbnRcbiAgZnVuY3Rpb24gYWRkU3RhY2tDaGVjayAoKSB7XG4gICAgbGV0IGNoZWNrID0gJydcbiAgICBpZiAoc2VnbWVudFN0YWNrSGlnaCAhPT0gMCkge1xuICAgICAgY2hlY2sgPSBgKGlmIChpMzIuZ3RfcyAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgJHsoMTAyMyAtIHNlZ21lbnRTdGFja0hpZ2gpICogMzJ9KSlcbiAgICAgICAgICAgICAgICAgKHRoZW4gKHVucmVhY2hhYmxlKSkpYFxuICAgIH1cbiAgICBpZiAoc2VnbWVudFN0YWNrTG93ICE9PSAwKSB7XG4gICAgICBjaGVjayArPSBgKGlmIChpMzIubHRfcyAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgJHstc2VnbWVudFN0YWNrTG93ICogMzIgLSAzMn0pKVxuICAgICAgICAgICAgICAgICAgKHRoZW4gKHVucmVhY2hhYmxlKSkpYFxuICAgIH1cbiAgICBzZWdtZW50ID0gY2hlY2sgKyBzZWdtZW50XG4gICAgc2VnbWVudFN0YWNrSGlnaCA9IDBcbiAgICBzZWdtZW50U3RhY2tMb3cgPSAwXG4gICAgc2VnbWVudFN0YWNrRGVsdGEgPSAwXG4gIH1cblxuICAvLyBhZGQgYSBtZXRlcmluZyBzdGF0bWVudCBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgc2VnbWVudFxuICAvLyBUT0RPIGZpeG1lIC0gdGhpcyBuZWVkcyB0byBiZSBpbnRlZ3JhdGVkIGluIHRoZSBpbnRlcnByZXRlciBvcGNvZGVzXG4gIGZ1bmN0aW9uIGFkZE1ldGVyaW5nICgpIHtcbiAgICBpZiAoIW9wdHMuY2hhcmdlUGVyT3AgJiYgIW9wdHMubm9nYXMpIHtcbiAgICAgIGlmIChnYXNDb3VudCAhPT0gMCkge1xuICAgICAgICB3YXN0ICs9IGAoY2FsbCAkdXNlR2FzIChpNjQuY29uc3QgJHtnYXNDb3VudH0pKSBgXG4gICAgICB9XG4gICAgfVxuXG4gICAgd2FzdCArPSBzZWdtZW50XG4gICAgc2VnbWVudCA9ICcnXG4gICAgZ2FzQ291bnQgPSAwXG4gIH1cblxuICAvLyBmaW5pc2hlcyBvZmYgYSBzZWdtZW50XG4gIGZ1bmN0aW9uIGVuZFNlZ21lbnQgKCkge1xuICAgIHNlZ21lbnQgKz0gJyknXG4gICAgYWRkU3RhY2tDaGVjaygpXG4gICAgYWRkTWV0ZXJpbmcoKVxuICB9XG5cbiAgbGV0IGludGVyZmFjZVZlcnNpb24gPSBJTlRFUkZBQ0VfQ0xBU1NJQztcbiAgaWYgKCFvcHRzLmlubGluZU9wcykge1xuICAgIGludGVyZmFjZVZlcnNpb24gPSBJTlRFUkZBQ0VfSU5URVJQUkVURVI7XG4gIH1cblxuICAvLyB0aGlzIGtlZXAgdHJhY2sgb2YgdGhlIG9wY29kZSB3ZSBoYXZlIGZvdW5kIHNvIGZhci4gVGhpcyB3aWxsIGJlIHVzZWQgdG9cbiAgLy8gdG8gZmlndXJlIG91dCB3aGF0IC53YXN0IGZpbGVzIHRvIGluY2x1ZGVcbiAgY29uc3Qgb3Bjb2Rlc1VzZWQgPSBuZXcgU2V0KClcbiAgY29uc3QgaWdub3JlZE9wcyA9IG5ldyBTZXQoWydKVU1QJywgJ0pVTVBJJywgJ0pVTVBERVNUJywgJ1BPUCcsICdTVE9QJywgJ0lOVkFMSUQnXSlcbiAgbGV0IGNhbGxiYWNrVGFibGUgPSBbXVxuXG4gIC8vIGFuIGFycmF5IG9mIGZvdW5kIHNlZ21lbnRzXG4gIGNvbnN0IGp1bXBTZWdtZW50cyA9IFtdXG4gIC8vIHRoZSB0cmFuc2NvbXBpbGVkIEVWTSBjb2RlXG4gIGxldCB3YXN0ID0gJydcbiAgbGV0IHNlZ21lbnQgPSAnJ1xuICAvLyBrZWVwcyB0cmFjayBvZiB0aGUgZ2FzIHRoYXQgZWFjaCBzZWN0aW9uIHVzZXNcbiAgbGV0IGdhc0NvdW50ID0gMFxuICAvLyB1c2VkIGZvciBwcnVuaW5nIGRlYWQgY29kZVxuICBsZXQganVtcEZvdW5kID0gZmFsc2VcbiAgLy8gdGhlIGFjY3VtbGl0aXZlIHN0YWNrIGRpZmZlcmVuY2UgZm9yIHRoZSBjdXJyZW50IHNlZ21uZXRcbiAgbGV0IHNlZ21lbnRTdGFja0RlbHRhID0gMFxuICBsZXQgc2VnbWVudFN0YWNrSGlnaCA9IDBcbiAgbGV0IHNlZ21lbnRTdGFja0xvdyA9IDBcblxuICBsZXQgZXZtQ29kZSA9IGRlcGxveW1lbnRFdm1Db2RlO1xuICBsZXQgZXZtQ29uc3RydWN0b3JDb2RlID0gbmV3IEJ1ZmZlcigwKVxuICBsZXQgYWRkRnVuY3MgPSBbXTtcbiAgaWYgKCFvcHRzLmlzQ29uc3RydWN0b3IpIHtcbiAgICBjb25zdCBbX19ldm1Db25zdHJ1Y3RvciwgX19ldm1Db2RlXSA9IHNwbGl0Q29uc3RydWN0b3IoZGVwbG95bWVudEV2bUNvZGUpO1xuICAgIGNvbnNvbGUubG9nKCdjb25zdHJ1Y3RvcicsIGV0aFV0aWwuYnVmZmVyVG9IZXgoX19ldm1Db25zdHJ1Y3RvcikpO1xuICAgIGNvbnNvbGUubG9nKCdydW50aW1lJywgZXRoVXRpbC5idWZmZXJUb0hleChfX2V2bUNvZGUpKTtcblxuICAgIGlmIChfX2V2bUNvbnN0cnVjdG9yLmxlbmd0aCA+IDUpIHtcbiAgICAgIGV2bUNvbnN0cnVjdG9yQ29kZSA9IF9fZXZtQ29uc3RydWN0b3I7XG4gICAgICBjb25zdCBbY29uc3RydWN0b3JDb2RlLCBjb25zdHJ1Y3Rvck9wY29kZXNdID0gZXhwb3J0cy5ldm0yd2FzdChfX2V2bUNvbnN0cnVjdG9yLCB7aXNDb25zdHJ1Y3RvcjogdHJ1ZX0pO1xuICAgICAgYWRkRnVuY3MgPSBbY29uc3RydWN0b3JDb2RlXTtcbiAgICAgIC8vIGFkZCB0aGUgc291cmNlcyBmb3IgdGhlIGNvbnN0cnVjdG9yIG9wY29kZXNcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgY29uc3RydWN0b3JPcGNvZGVzLnZhbHVlcygpKSB7XG4gICAgICAgIG9wY29kZXNVc2VkLmFkZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGV2bUNvZGUgPSBfX2V2bUNvZGU7XG4gIH1cblxuICAvLyBwcmUtYW5hbHlzaXMgZm9yIGN1c3RvbSBtZXNzYWdlc1xuICBsZXQgY29zbW9zSW1wb3J0cyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgQ09TTU9TX01TR19NQVJLRVIgPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZTJiODkxZTkxMTIyMzM0NDU1NjY3Nzg4OTkwMFwiO1xuICBjb25zdCBDT1NNT1NfUVVFUllfTUFSS0VSID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZlMTQzYjM5MTEyMjMzNDQ1NTY2Nzc4ODk5MDBcIjtcbiAgZnVuY3Rpb24gcmVwbGFjZUFsbE9jY3VycmVuY2VzKG1haW5BcnJheSwgc3ViQXJyYXksIHJlcGxhY2VtZW50QXJyYXkpIHtcbiAgICBjb25zdCBzdWJsZW4gPSBzdWJBcnJheS5sZW5ndGg7XG4gICAgbGV0IGNvcHlNYWluQXJyYXkgPSBuZXcgQnVmZmVyLmZyb20oWy4uLm1haW5BcnJheV0pO1xuICAgIGNvbnN0IGluZGV4ZXMgPSBbLi4ubWFpbkFycmF5XS5tYXAoKF8sIGkpID0+IGkpO1xuICAgIGNvbnN0IGZpbHRlcmVkSW5kZXhlcyA9IGluZGV4ZXMuZmlsdGVyKGkgPT4gbWFpbkFycmF5LnNsaWNlKGksIGkgKyBzdWJsZW4pLmV2ZXJ5KChlbGVtLCBqKSA9PiBlbGVtID09PSBzdWJBcnJheVtqXSkpO1xuXG4gICAgZmlsdGVyZWRJbmRleGVzLnJldmVyc2UoKS5tYXAoaSA9PiB7XG4gICAgICBjb3B5TWFpbkFycmF5ID0gbmV3IEJ1ZmZlci5mcm9tKFtcbiAgICAgICAgLi4uVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb3B5TWFpbkFycmF5KS5zbGljZSgwLCBpKSxcbiAgICAgICAgLi4ucmVwbGFjZW1lbnRBcnJheSxcbiAgICAgICAgLi4uVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb3B5TWFpbkFycmF5KS5zbGljZShpICsgc3VibGVuKSxcbiAgICAgIF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjb3B5TWFpbkFycmF5O1xuICB9XG5cbiAgLy8gZm9yIGNvc21vcyBtc2cgMHhlMmI4OTFlOSwgcmVwbGFjZSBqdW1wZGVzdCAtPiBqdW1wIHRoYXQgY29udGFpbnMgUFVTSDE0IDB4ZTJiODkxZTkxMTIyMzM0NDU1NjY3Nzg4OTkwMFxuICAvLyB3aXRoXG4gIC8vIEpVTVBERVNUIFBVU0hYIDB4ZTJiODkxZTkxMTIyMzM0NDU1NjY3Nzg4OTkwMDAwMC4uICAweDQwIG1sb2FkIHJldHVybmRhdGFzaXplIGR1cDEgZHVwMyBhZGQgMHg0MCBtc3RvcmUgMHgwMCBkdXAzIHJldHVybmRhdGFjb3B5IHN3YXAxIHN3YXAyIEpVTVBcbiAgZXZtQ29kZSA9IHJlcGxhY2VBbGxPY2N1cnJlbmNlcyhldm1Db2RlLCBldGhVdGlsLnRvQnVmZmVyKFwiMHg2MDAwNjA2MDYwMDA2ZGUyYjg5MWU5MTEyMjMzNDQ1NTY2Nzc4ODk5MDA5MDUwNjAwMTkyNTA1MDkxNTA5MVwiKSwgZXRoVXRpbC50b0J1ZmZlcihcIjB4NmRlMmI4OTFlOTExMjIzMzQ0NTU2Njc3ODg5OTAwNjA0MDUxM2Q4MDgyMDE2MDQwNTI2MDAwODIzZTkwOTFcIikpXG5cbiAgLy8gcmVwbGFjZSBmb3IgY29zbW9zIHF1ZXJpZXMgMHhmZTE0M2IzOVxuICBldm1Db2RlID0gcmVwbGFjZUFsbE9jY3VycmVuY2VzKGV2bUNvZGUsIGV0aFV0aWwudG9CdWZmZXIoXCIweDYwMDA2MDYwNjAwMDZkZmUxNDNiMzkxMTIyMzM0NDU1NjY3Nzg4OTkwMDkwNTA2MDAxOTI1MDUwOTE1MDkxXCIpLCBldGhVdGlsLnRvQnVmZmVyKFwiMHg2ZGZlMTQzYjM5MTEyMjMzNDQ1NTY2Nzc4ODk5MDA2MDQwNTEzZDgwODIwMTYwNDA1MjYwMDA4MjNlOTA5MVwiKSlcblxuICAvLyBodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvbWV0YWRhdGEuaHRtbCNlbmNvZGluZy1vZi10aGUtbWV0YWRhdGEtaGFzaC1pbi10aGUtYnl0ZWNvZGVcbiAgLy8gVE9ETyBmaW5kIG1ldGFkYXRhIGhhc2ggJiBrZWVwIGl0IGluIHRoZSB3YXNtY29kZVxuXG4gIGZvciAobGV0IHBjID0gMDsgcGMgPCBldm1Db2RlLmxlbmd0aDsgcGMrKykge1xuICAgIGNvbnN0IG9waW50ID0gZXZtQ29kZVtwY11cbiAgICBjb25zdCBvcCA9IG9wY29kZXMob3BpbnQpXG5cbiAgICAvLyBjcmVhdGVzIGEgc3RhY2sgdHJhY2VcbiAgICBpZiAob3B0cy5zdGFja1RyYWNlKSB7XG4gICAgICBzZWdtZW50ICs9IGAoY2FsbCAkc3RhY2tUcmFjZSAoaTMyLmNvbnN0ICR7cGN9KSAoaTMyLmNvbnN0ICR7b3BpbnR9KSAoaTMyLmNvbnN0ICR7b3AuZmVlfSkgKGdsb2JhbC5nZXQgJHNwKSlcXG5gXG4gICAgfVxuXG4gICAgbGV0IGJ5dGVzXG4gICAgaWYgKG9wdHMuY2hhcmdlUGVyT3AgJiYgIW9wdHMubm9nYXMpIHtcbiAgICAgIGlmIChvcC5mZWUgIT09IDApIHtcbiAgICAgICAgc2VnbWVudCArPSBgKGNhbGwgJHVzZUdhcyAoaTY0LmNvbnN0ICR7b3AuZmVlfSkpIGBcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZG8gbm90IGNoYXJnZSBnYXMgZm9yIGludGVyZmFjZSBtZXRob2RzXG4gICAgLy8gVE9ETzogaW1wbGVtZW50IHByb3BlciBnYXMgY2hhcmdpbmcgYW5kIGVuYWJsZSB0aGlzIGhlcmVcbiAgICBpZiAob3BpbnQgPCAweDMwIHx8IChvcGludCA+IDB4NDUgJiYgb3BpbnQgPCAweGEwKSkge1xuICAgICAgZ2FzQ291bnQgKz0gb3AuZmVlXG4gICAgfVxuXG4gICAgc2VnbWVudFN0YWNrRGVsdGEgKz0gb3Aub25cbiAgICBpZiAoc2VnbWVudFN0YWNrRGVsdGEgPiBzZWdtZW50U3RhY2tIaWdoKSB7XG4gICAgICBzZWdtZW50U3RhY2tIaWdoID0gc2VnbWVudFN0YWNrRGVsdGFcbiAgICB9XG5cbiAgICBzZWdtZW50U3RhY2tEZWx0YSAtPSBvcC5vZmZcbiAgICBpZiAoc2VnbWVudFN0YWNrRGVsdGEgPCBzZWdtZW50U3RhY2tMb3cpIHtcbiAgICAgIHNlZ21lbnRTdGFja0xvdyA9IHNlZ21lbnRTdGFja0RlbHRhXG4gICAgfVxuICAgIGxldCBjYW5JbmNyZWFzZVNwID0gdHJ1ZTtcblxuICAgIHN3aXRjaCAob3AubmFtZSkge1xuICAgICAgY2FzZSAnSlVNUCc6XG4gICAgICAgIGp1bXBGb3VuZCA9IHRydWVcbiAgICAgICAgc2VnbWVudCArPSBgOzsganVtcFxuICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJGp1bXBfZGVzdCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAoZ2xvYmFsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXG4gICAgICAgICAgICAgICAgICAgICAgKGJyICRsb29wKWBcbiAgICAgICAgb3Bjb2Rlc1VzZWQuYWRkKCdjaGVja19vdmVyZmxvdycpXG4gICAgICAgIHBjID0gZmluZE5leHRKdW1wRGVzdChldm1Db2RlLCBwYylcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ0pVTVBJJzpcbiAgICAgICAganVtcEZvdW5kID0gdHJ1ZVxuICAgICAgICBzZWdtZW50ICs9IGAobG9jYWwuc2V0ICRqdW1wX2Rlc3QgKGNhbGwgJGNoZWNrX292ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkpXG5cbiAgICAgICAgICAgICAgICAgICAgKGdsb2JhbC5zZXQgJHNwIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA2NCkpKVxuICAgICAgICAgICAgICAgICAgICAoYnJfaWYgJGxvb3AgKGkzMi5lcXogKGk2NC5lcXogKGk2NC5vclxuICAgICAgICAgICAgICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSlcbiAgICAgICAgICAgICAgICAgICAgICAoaTY0Lm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDQwKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAoaTY0Lm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNDgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA1NikpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSkpKVxcbmBcbiAgICAgICAgb3Bjb2Rlc1VzZWQuYWRkKCdjaGVja19vdmVyZmxvdycpXG4gICAgICAgIGFkZFN0YWNrQ2hlY2soKVxuICAgICAgICBhZGRNZXRlcmluZygpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdKVU1QREVTVCc6XG4gICAgICAgIGVuZFNlZ21lbnQoKVxuICAgICAgICBqdW1wU2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgbnVtYmVyOiBwYyxcbiAgICAgICAgICB0eXBlOiAnanVtcF9kZXN0J1xuICAgICAgICB9KVxuICAgICAgICBnYXNDb3VudCA9IDFcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ0dBUyc6XG4gICAgICAgIHNlZ21lbnQgKz0gYChjYWxsICRHQVMpXFxuYFxuICAgICAgICAvLyBhZGRNZXRlcmluZygpIC8vIHRoaXMgY2F1c2VzIGFuIHVucmVhY2hhYmxlIGVycm9yIGluIHN0YWNrT3ZlcmZsb3dNMSAtZCAxNFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnTE9HJzpcbiAgICAgICAgc2VnbWVudCArPSBgKGNhbGwgJExPRyAoaTMyLmNvbnN0ICR7b3AubnVtYmVyfSkpXFxuYFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnRFVQJzpcbiAgICAgIGNhc2UgJ1NXQVAnOlxuICAgICAgICAvLyBhZGRzIHRoZSBudW1iZXIgb24gdGhlIHN0YWNrIHRvIFNXQVBcbiAgICAgICAgc2VnbWVudCArPSBgKGNhbGwgJCR7b3AubmFtZX0gKGkzMi5jb25zdCAke29wLm51bWJlciAtIDF9KSlcXG5gXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdQQyc6XG4gICAgICAgIHNlZ21lbnQgKz0gYChjYWxsICRQQyAoaTMyLmNvbnN0ICR7cGN9KSlcXG5gXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdQVVNIJzpcbiAgICAgICAgcGMrK1xuICAgICAgICBieXRlcyA9IGV0aFV0aWwuc2V0TGVuZ3RoKGV2bUNvZGUuc2xpY2UocGMsIHBjICs9IG9wLm51bWJlciksIDMyKVxuICAgICAgICBjb25zdCBieXRlc1JvdW5kZWQgPSBNYXRoLmNlaWwob3AubnVtYmVyIC8gOClcbiAgICAgICAgbGV0IHB1c2ggPSAnJ1xuICAgICAgICBsZXQgcSA9IDBcbiAgICAgICAgLy8gcGFkIHRoZSByZW1haW5pbmcgb2YgdGhlIHdvcmQgd2l0aCAwXG4gICAgICAgIGZvciAoOyBxIDwgNCAtIGJ5dGVzUm91bmRlZDsgcSsrKSB7XG4gICAgICAgICAgcHVzaCA9ICcoaTY0LmNvbnN0IDApJyArIHB1c2hcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBxIDwgNDsgcSsrKSB7XG4gICAgICAgICAgY29uc3QgaW50NjQgPSBieXRlczJpbnQ2NChieXRlcy5zbGljZShxICogOCwgcSAqIDggKyA4KSlcbiAgICAgICAgICBwdXNoID0gcHVzaCArIGAoaTY0LmNvbnN0ICR7aW50NjR9KWBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldGhVdGlsLmJ1ZmZlclRvSGV4KGJ5dGVzKSA9PT0gQ09TTU9TX01TR19NQVJLRVIpIHtcbiAgICAgICAgICBjYW5JbmNyZWFzZVNwID0gZmFsc2U7XG4gICAgICAgICAgc2VnbWVudCArPSBgKGNhbGwgJFNFTkRDT1NNT1NNU0cpYFxuICAgICAgICAgIGNvc21vc0ltcG9ydHMuYWRkKFwiU0VORENPU01PU01TR1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldGhVdGlsLmJ1ZmZlclRvSGV4KGJ5dGVzKSA9PT0gQ09TTU9TX1FVRVJZX01BUktFUikge1xuICAgICAgICAgIGNhbkluY3JlYXNlU3AgPSBmYWxzZTtcbiAgICAgICAgICBzZWdtZW50ICs9IGAoY2FsbCAkU0VORENPU01PU1FVRVJZKWBcbiAgICAgICAgICBjb3Ntb3NJbXBvcnRzLmFkZChcIlNFTkRDT1NNT1NRVUVSWVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzZWdtZW50ICs9IGAoY2FsbCAkUFVTSCAke3B1c2h9KWBcbiAgICAgICAgfVxuXG4gICAgICAgIHBjLS1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ1BPUCc6XG4gICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ1NUT1AnOlxuICAgICAgICBzZWdtZW50ICs9ICcoYnIgJGRvbmUpJ1xuICAgICAgICBpZiAoanVtcEZvdW5kKSB7XG4gICAgICAgICAgcGMgPSBmaW5kTmV4dEp1bXBEZXN0KGV2bUNvZGUsIHBjKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoZSByZXN0IGlzIGRlYWQgY29kZVxuICAgICAgICAgIHBjID0gZXZtQ29kZS5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnU0VMRkRFU1RSVUNUJzpcbiAgICAgIGNhc2UgJ1JFVFVSTic6XG4gICAgICBjYXNlICdSRVZFUlQnOlxuICAgICAgICBzZWdtZW50ICs9IGAoY2FsbCAkJHtvcC5uYW1lfSkgKGJyICRkb25lKVxcbmBcbiAgICAgICAgaWYgKGp1bXBGb3VuZCkge1xuICAgICAgICAgIHBjID0gZmluZE5leHRKdW1wRGVzdChldm1Db2RlLCBwYylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGUgcmVzdCBpcyBkZWFkIGNvZGVcbiAgICAgICAgICBwYyA9IGV2bUNvZGUubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ0lOVkFMSUQnOlxuICAgICAgICBzZWdtZW50ID0gJyh1bnJlYWNoYWJsZSknXG4gICAgICAgIHBjID0gZmluZE5leHRKdW1wRGVzdChldm1Db2RlLCBwYylcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChvcHRzLnVzZUFzeW5jQVBJICYmIGNhbGxiYWNrRnVuY3MuaGFzKG9wLm5hbWUpKSB7XG4gICAgICAgICAgY29uc3QgY2JGdW5jID0gY2FsbGJhY2tGdW5jcy5nZXQob3AubmFtZSlcbiAgICAgICAgICBsZXQgaW5kZXggPSBjYWxsYmFja1RhYmxlLmluZGV4T2YoY2JGdW5jKVxuICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGluZGV4ID0gY2FsbGJhY2tUYWJsZS5wdXNoKGNiRnVuYykgLSAxXG4gICAgICAgICAgfVxuICAgICAgICAgIHNlZ21lbnQgKz0gYChjYWxsICQke29wLm5hbWV9IChpMzIuY29uc3QgJHtpbmRleH0pKVxcbmBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB1c2Ugc3luY2hyb25vdXMgQVBJXG4gICAgICAgICAgc2VnbWVudCArPSBgKGNhbGwgJCR7b3AubmFtZX0pXFxuYFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFpZ25vcmVkT3BzLmhhcyhvcC5uYW1lKSkge1xuICAgICAgb3Bjb2Rlc1VzZWQuYWRkKG9wLm5hbWUpXG4gICAgfVxuXG4gICAgY29uc3Qgc3RhY2tEZWx0YSA9IG9wLm9uIC0gb3Aub2ZmXG4gICAgLy8gdXBkYXRlIHRoZSBzdGFjayBwb2ludGVyXG4gICAgaWYgKHN0YWNrRGVsdGEgIT09IDAgJiYgY2FuSW5jcmVhc2VTcCkge1xuICAgICAgc2VnbWVudCArPSBgKGdsb2JhbC5zZXQgJHNwIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAke3N0YWNrRGVsdGEgKiAzMn0pKSlcXG5gXG4gICAgfVxuXG4gICAgLy8gYWRkcyB0aGUgbG9naWMgdG8gc2F2ZSB0aGUgc3RhY2sgcG9pbnRlciBiZWZvcmUgZXhpdGluZyB0byB3aWF0IHRvIGZvciBhIGNhbGxiYWNrXG4gICAgLy8gbm90ZSwgdGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHRoZSBzcCBpcyB1cGRhdGVkIGFib3ZlXlxuICAgIGlmIChvcHRzLnVzZUFzeW5jQVBJICYmIGNhbGxiYWNrRnVuY3MuaGFzKG9wLm5hbWUpKSB7XG4gICAgICBzZWdtZW50ICs9IGAoZ2xvYmFsLnNldCAkY2JfZGVzdCAoaTMyLmNvbnN0ICR7anVtcFNlZ21lbnRzLmxlbmd0aCArIDF9KSlcbiAgICAgICAgICAoYnIgJGRvbmUpKWBcbiAgICAgIGp1bXBTZWdtZW50cy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NiX2Rlc3QnXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGVuZFNlZ21lbnQoKVxuXG4gIGlmIChvcHRzLmlzQ29uc3RydWN0b3IpIHtcbiAgICB3YXN0ID0gYXNzZW1ibGVJbnN0YW50aWF0ZShqdW1wU2VnbWVudHMpICsgd2FzdCArICcpKSdcbiAgICByZXR1cm4gW3dhc3QsIG9wY29kZXNVc2VkXTtcbiAgfSBlbHNlIHtcblxuICAgIHdhc3QgPSBhc3NlbWJsZVNlZ21lbnRzKGp1bXBTZWdtZW50cywgZXZtQ29uc3RydWN0b3JDb2RlLmxlbmd0aCA+IDApICsgd2FzdCArICcpKSdcbiAgfVxuXG4gIGxldCB3YXN0RmlsZXMgPSB3YXN0U3luY0ludGVyZmFjZSAvLyBkZWZhdWx0IHRvIHN5bmNocm9ub3VzIGludGVyZmFjZVxuICBpZiAob3B0cy51c2VBc3luY0FQSSkge1xuICAgIHdhc3RGaWxlcyA9IHdhc3RBc3luY0ludGVyZmFjZVxuICB9XG5cbiAgbGV0IGltcG9ydHMgPSBbXVxuICBsZXQgZnVuY3MgPSBbXVxuICAvLyBpbmxpbmUgRVZNIG9wY29kZSBpbXBsZW1lbnRpb25cbiAgaWYgKG9wdHMuaW5saW5lT3BzKSB7XG4gICAgW2Z1bmNzLCBpbXBvcnRzXSA9IGV4cG9ydHMucmVzb2x2ZUZ1bmN0aW9ucyhvcGNvZGVzVXNlZCwgd2FzdEZpbGVzKVxuICB9IGVsc2Uge1xuICAgIFssLCBpbmxpbmVfaW1wb3J0c10gPSBleHBvcnRzLnJlc29sdmVGdW5jdGlvbnMob3Bjb2Rlc1VzZWQsIHdhc3RGaWxlcylcbiAgICBpbXBvcnRzID0gaW5saW5lX2ltcG9ydHM7XG4gICAgaW1wb3J0cy5wdXNoKCcoaW1wb3J0IFwiZXdhc21cIiBcIkdMT0JBTF9HRVRfU1BcIiAoZnVuYyAkR0xPQkFMX0dFVF9TUCAocmVzdWx0IGkzMikpKScpXG4gICAgaW1wb3J0cy5wdXNoKCcoaW1wb3J0IFwiZXdhc21cIiBcIkdMT0JBTF9TRVRfU1BcIiAoZnVuYyAkR0xPQkFMX1NFVF9TUCAocGFyYW0gaTMyKSkpJylcbiAgICBpbXBvcnRzLnB1c2goJyhpbXBvcnQgXCJld2FzbVwiIFwiZXRoZXJldW1fdXNlR2FzXCIgKGZ1bmMgJHVzZUdhcyAocGFyYW0gaTY0KSkpJylcbiAgfVxuICBmb3IgKGxldCBjb3Ntb3NJbXBvcnQgb2YgY29zbW9zSW1wb3J0cy52YWx1ZXMoKSkge1xuICAgIGltcG9ydHMucHVzaChjb3Ntb3NGdW5jdGlvbnNbY29zbW9zSW1wb3J0XS5pbXBvcnQpO1xuICAgIGZ1bmNzLnB1c2goY29zbW9zRnVuY3Rpb25zW2Nvc21vc0ltcG9ydF0uZGVmKTtcbiAgfVxuICBmdW5jcyA9IGFkZEZ1bmNzLmNvbmNhdChmdW5jcyk7XG5cbiAgLy8gaW1wb3J0IHN0YWNrIHRyYWNlIGZ1bmN0aW9uXG4gIGlmIChvcHRzLnN0YWNrVHJhY2UpIHtcbiAgICBpbXBvcnRzLnB1c2goJyhpbXBvcnQgXCJlbnZcIiBcImV0aGVyZXVtX2RlYnVnUHJpbnRNZW1IZXhcIiAoZnVuYyAkcHJpbnRNZW0gKHBhcmFtIGkzMiBpMzIpKSknKVxuICAgIGltcG9ydHMucHVzaCgnKGltcG9ydCBcImVudlwiIFwiZXRoZXJldW1fZGVidWdQcmludGkzMlwiIChmdW5jICRwcmludEkzMiAocGFyYW0gaTMyKSkpJylcbiAgICBpbXBvcnRzLnB1c2goJyhpbXBvcnQgXCJlbnZcIiBcImV0aGVyZXVtX2RlYnVnUHJpbnRpNjRcIiAoZnVuYyAkcHJpbnRJNjQgKHBhcmFtIGk2NCkpKScpXG4gICAgaW1wb3J0cy5wdXNoKCcoaW1wb3J0IFwiZW52XCIgXCJldGhlcmV1bV9kZWJ1Z19ldm1UcmFjZVwiIChmdW5jICRzdGFja1RyYWNlIChwYXJhbSBpMzIgaTMyIGkzMiBpMzIpKSknKVxuICB9XG4gIGlmIChvcHRzLmlubGluZU9wcykge1xuICAgIGltcG9ydHMucHVzaCgnKGltcG9ydCBcImVudlwiIFwiZXRoZXJldW1fdXNlR2FzXCIgKGZ1bmMgJHVzZUdhcyAocGFyYW0gaTY0KSkpJylcbiAgfVxuXG5cbiAgZnVuY3MucHVzaCh3YXN0KVxuICB3YXN0ID0gZXhwb3J0cy5idWlsZE1vZHVsZShmdW5jcywgaW1wb3J0cywgY2FsbGJhY2tUYWJsZSwgZXZtQ29uc3RydWN0b3JDb2RlLCBldm1Db2RlLCBvcHRzLmlzQ29uc3RydWN0b3IsIGludGVyZmFjZVZlcnNpb24pXG5cbiAgaWYgKGludGVyZmFjZVZlcnNpb24gPT09IElOVEVSRkFDRV9JTlRFUlBSRVRFUikge1xuICAgIHdhc3QgPSB3YXN0LnJlcGxhY2UoL1xcKGdsb2JhbFxcLmdldCBcXCRzcFxcKS9nLCBcIihjYWxsICRHTE9CQUxfR0VUX1NQKVwiKVxuICAgIHdhc3QgPSB3YXN0LnJlcGxhY2UoL1xcKGdsb2JhbFxcLnNldCBcXCRzcCAvZywgXCIoY2FsbCAkR0xPQkFMX1NFVF9TUCBcIilcbiAgfVxuXG4gIHJldHVybiB3YXN0XG59XG5cbi8vIGdpdmVuIGFuIGFycmF5IGZvciBzZWdtZW50cyBidWlsZHMgYSB3YXNtIG1vZHVsZSBmcm9tIHRob3NlIHNlZ21lbnRzXG4vLyBAcGFyYW0ge0FycmF5fSBzZWdtZW50c1xuLy8gQHJldHVybiB7U3RyaW5nfVxuZnVuY3Rpb24gYXNzZW1ibGVTZWdtZW50cyAoc2VnbWVudHMsIGhhc0NvbnN0cnVjdG9yKSB7XG4gIGxldCB3YXNtID0gYnVpbGRKdW1wTWFwKHNlZ21lbnRzKVxuXG4gIHNlZ21lbnRzLmZvckVhY2goKHNlZywgaW5kZXgpID0+IHtcbiAgICB3YXNtID0gYChibG9jayAkJHtpbmRleCArIDF9ICR7d2FzbX1gXG4gIH0pXG5cbiAgcmV0dXJuIGBcbiAgJHtoYXNDb25zdHJ1Y3RvciA/IFwiXCIgOiBgKGZ1bmMgJGluc3RhbnRpYXRlIChleHBvcnQgXCJpbnN0YW50aWF0ZVwiKSlgfVxuICAoZnVuYyAkbWFpblxuICAgIChleHBvcnQgXCJtYWluXCIpXG4gICAgKGxvY2FsICRqdW1wX2Rlc3QgaTMyKSAobG9jYWwgJGp1bXBfbWFwX3N3aXRjaCBpMzIpXG4gICAgKGxvY2FsLnNldCAkanVtcF9kZXN0IChpMzIuY29uc3QgLTEpKVxuXG4gICAgKGJsb2NrICRkb25lXG4gICAgICAobG9vcCAkbG9vcFxuICAgICAgICAke3dhc219YFxufVxuXG5mdW5jdGlvbiBhc3NlbWJsZUluc3RhbnRpYXRlIChzZWdtZW50cykge1xuICBsZXQgd2FzbSA9IGJ1aWxkSnVtcE1hcChzZWdtZW50cylcblxuICBzZWdtZW50cy5mb3JFYWNoKChzZWcsIGluZGV4KSA9PiB7XG4gICAgd2FzbSA9IGAoYmxvY2sgJCR7aW5kZXggKyAxfSAke3dhc219YFxuICB9KVxuXG4gIHJldHVybiBgXG4gIChmdW5jICRpbnN0YW50aWF0ZVxuICAgIChleHBvcnQgXCJpbnN0YW50aWF0ZVwiKVxuICAgIChsb2NhbCAkanVtcF9kZXN0IGkzMikgKGxvY2FsICRqdW1wX21hcF9zd2l0Y2ggaTMyKVxuICAgIChsb2NhbC5zZXQgJGp1bXBfZGVzdCAoaTMyLmNvbnN0IC0xKSlcblxuICAgIChibG9jayAkZG9uZVxuICAgICAgKGxvb3AgJGxvb3BcbiAgICAgICAgJHt3YXNtfWBcbn1cblxuLy8gQnVpbGRzIHRoZSBKdW1wIG1hcCwgd2hpY2ggbWFwcyBFVk0ganVtcCBsb2NhdGlvbiB0byBhIGJsb2NrIGxhYmVsXG4vLyBAcGFyYW0ge0FycmF5fSBzZWdtZW50c1xuLy8gQHJldHVybiB7U3RyaW5nfVxuZnVuY3Rpb24gYnVpbGRKdW1wTWFwIChzZWdtZW50cykge1xuICBsZXQgd2FzbSA9ICcodW5yZWFjaGFibGUpJ1xuXG4gIGxldCBiclRhYmxlID0gJydcbiAgc2VnbWVudHMuZm9yRWFjaCgoc2VnLCBpbmRleCkgPT4ge1xuICAgIGJyVGFibGUgKz0gJyAkJyArIChpbmRleCArIDEpXG4gICAgaWYgKHNlZy50eXBlID09PSAnanVtcF9kZXN0Jykge1xuICAgICAgd2FzbSA9IGAoaWYgKGkzMi5lcSAobG9jYWwuZ2V0ICRqdW1wX2Rlc3QpIChpMzIuY29uc3QgJHtzZWcubnVtYmVyfSkpXG4gICAgICAgICAgICAgICAgKHRoZW4gKGJyICQke2luZGV4ICsgMX0pKVxuICAgICAgICAgICAgICAgIChlbHNlICR7d2FzbX0pKWBcbiAgICB9XG4gIH0pXG5cbiAgd2FzbSA9IGBcbiAgKGJsb2NrICQwXG4gICAgKGlmXG4gICAgICAoaTMyLmVxeiAoZ2xvYmFsLmdldCAkaW5pdCkpXG4gICAgICAodGhlblxuICAgICAgICAoZ2xvYmFsLnNldCAkaW5pdCAoaTMyLmNvbnN0IDEpKVxuICAgICAgICAoYnIgJDApKVxuICAgICAgKGVsc2VcbiAgICAgICAgOzsgdGhlIGNhbGxiYWNrIGRlc3QgY2FuIG5ldmVyIGJlIGluIHRoZSBmaXJzdCBibG9ja1xuICAgICAgICAoaWYgKGkzMi5lcSAoZ2xvYmFsLmdldCAkY2JfZGVzdCkgKGkzMi5jb25zdCAwKSlcbiAgICAgICAgICAodGhlblxuICAgICAgICAgICAgJHt3YXNtfVxuICAgICAgICAgIClcbiAgICAgICAgICAoZWxzZVxuICAgICAgICAgICAgOzsgcmV0dXJuIGNhbGxiYWNrIGRlc3RpbmF0aW9uIGFuZCB6ZXJvIG91dCAkY2JfZGVzdFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkanVtcF9tYXBfc3dpdGNoIChnbG9iYWwuZ2V0ICRjYl9kZXN0KSlcbiAgICAgICAgICAgIChnbG9iYWwuc2V0ICRjYl9kZXN0IChpMzIuY29uc3QgMCkpXG4gICAgICAgICAgICAoYnJfdGFibGUgJDAgJHticlRhYmxlfSAobG9jYWwuZ2V0ICRqdW1wX21hcF9zd2l0Y2gpKVxuICAgICAgICAgICkpKSkpYFxuXG4gIHJldHVybiB3YXNtXG59XG5cbi8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGp1bXAgZGVzdGluYXRpb24gb3Bjb2RlIGluIGdpdmVuIEVWTSBjb2RlIGluIGFuXG4vLyBhcnJheSBhbmQgYSBzdGFydGluZyBpbmRleFxuLy8gQHBhcmFtIHtBcnJheX0gZXZtQ29kZVxuLy8gQHBhcmFtIHtJbnRlZ2VyfSBpbmRleFxuLy8gQHJldHVybiB7SW50ZWdlcn1cbmZ1bmN0aW9uIGZpbmROZXh0SnVtcERlc3QgKGV2bUNvZGUsIGkpIHtcbiAgZm9yICg7IGkgPCBldm1Db2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgb3BpbnQgPSBldm1Db2RlW2ldXG4gICAgY29uc3Qgb3AgPSBvcGNvZGVzKG9waW50KVxuICAgIHN3aXRjaCAob3AubmFtZSkge1xuICAgICAgY2FzZSAnUFVTSCc6XG4gICAgICAgIC8vIHNraXAgYWRkIGhvdyBtYW55IGJ5dGVzIHdoZXJlIHB1c2hlZFxuICAgICAgICBpICs9IG9wLm51bWJlclxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnSlVNUERFU1QnOlxuICAgICAgICByZXR1cm4gLS1pXG4gICAgfVxuICB9XG4gIHJldHVybiAtLWlcbn1cblxuLy8gY29udmVydHMgOCBieXRlcyBpbnRvIGEgaW50IDY0XG4vLyBAcGFyYW0ge0ludGVnZXJ9XG4vLyBAcmV0dXJuIHtTdHJpbmd9XG5mdW5jdGlvbiBieXRlczJpbnQ2NCAoYnl0ZXMpIHtcbiAgcmV0dXJuIG5ldyBCTihieXRlcykuZnJvbVR3b3MoNjQpLnRvU3RyaW5nKClcbn1cblxuLy8gRW5zdXJlIHRoYXQgZGVwZW5kZW5jaWVzIGFyZSBvbmx5IGltcG9ydGVkIG9uY2UgKHVzZSB0aGUgU2V0KVxuLy8gQHBhcmFtIHtTZXR9IGZ1bmNTZXQgYSBzZXQgb2Ygd2FzbSBmdW5jdGlvbiB0aGF0IG5lZWQgdG8gYmUgbGlua2VkIHRvIHRoZWlyIGRlcGVuZGVuY2llc1xuLy8gQHJldHVybiB7U2V0fVxuZnVuY3Rpb24gcmVzb2x2ZUZ1bmN0aW9uRGVwcyAoZnVuY1NldCkge1xuICBsZXQgZnVuY3MgPSBmdW5jU2V0XG4gIGZvciAobGV0IGZ1bmMgb2YgZnVuY1NldCkge1xuICAgIGNvbnN0IGRlcHMgPSBkZXBNYXAuZ2V0KGZ1bmMpXG4gICAgaWYgKGRlcHMpIHtcbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcbiAgICAgICAgZnVuY3MuYWRkKGRlcClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZ1bmNzXG59XG5cbi8qKlxuICogZ2l2ZW4gYSBTZXQgb2Ygd2FzbSBmdW5jdGlvbiB0aGlzIHJldHVybiBhbiBhcnJheSBmb3Igd2FzbSBlcXVpdmFsZW50c1xuICogQHBhcmFtIHtTZXR9IGZ1bmNTZXRcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5leHBvcnRzLnJlc29sdmVGdW5jdGlvbnMgPSBmdW5jdGlvbiAoZnVuY1NldCwgd2FzdEZpbGVzKSB7XG4gIGxldCBmdW5jcyA9IFtdXG4gIGxldCBpbXBvcnRzID0gW11cbiAgbGV0IGlubGluZV9pbXBvcnRzID0gW11cbiAgY29uc29sZS5sb2coXCJyZXNvbHZlRnVuY3Rpb25zXCIsIGZ1bmNTZXQpXG4gIGZvciAobGV0IGZ1bmMgb2YgcmVzb2x2ZUZ1bmN0aW9uRGVwcyhmdW5jU2V0KSkge1xuICAgIGZ1bmNzLnB1c2god2FzdEZpbGVzW2Z1bmNdLndhc3QpXG4gICAgaWYgKGZ1bmMgIT09ICdDQUxMREFUQUxPQUQnIHx8ICFmdW5jU2V0LmhhcyhcIkNBTExEQVRBQ09QWVwiKSkge1xuICAgICAgaW1wb3J0cy5wdXNoKHdhc3RGaWxlc1tmdW5jXS5pbXBvcnRzKVxuICAgICAgaW5saW5lX2ltcG9ydHMucHVzaCh3YXN0RmlsZXNbZnVuY10uaW5saW5lX2ltcG9ydHMpXG4gICAgfVxuICB9XG4gIHJldHVybiBbZnVuY3MsIGltcG9ydHMsIGlubGluZV9pbXBvcnRzXVxufVxuXG4vKipcbiAqIGJ1aWxkcyBhIHdhc20gbW9kdWxlXG4gKiBAcGFyYW0ge0FycmF5fSBmdW5jcyB0aGUgZnVuY3Rpb24gdG8gaW5jbHVkZSBpbiB0aGUgbW9kdWxlXG4gKiBAcGFyYW0ge0FycmF5fSBpbXBvcnRzIHRoZSBpbXBvcnRzIGZvciB0aGUgbW9kdWxlJ3MgaW1wb3J0IHRhYmxlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuYnVpbGRNb2R1bGUgPSBmdW5jdGlvbiAoZnVuY3MsIGltcG9ydHMgPSBbXSwgY2FsbGJhY2tzID0gW10sIGV2bUNvbnN0cnVjdG9yQ29kZSwgZXZtQ29kZSwgaXNDb25zdHJ1Y3RvciwgaW50ZXJmYWNlVmVyc2lvbikge1xuICBsZXQgZnVuY1N0ciA9ICcnXG4gIGZvciAobGV0IGZ1bmMgb2YgZnVuY3MpIHtcbiAgICBmdW5jU3RyICs9IGZ1bmNcbiAgfVxuXG4gIGxldCBjYWxsYmFja1RhYmxlU3RyID0gJydcbiAgaWYgKGNhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICBjYWxsYmFja1RhYmxlU3RyID0gYFxuICAgICh0YWJsZVxuICAgICAgKGV4cG9ydCBcImNhbGxiYWNrXCIpIDs7IG5hbWUgb2YgdGFibGVcbiAgICAgICAgYW55ZnVuY1xuICAgICAgICAoZWxlbSAke2NhbGxiYWNrcy5qb2luKCcgJyl9KSA7OyBlbGVtZW50cyB3aWxsIGhhdmUgaW5kZXhlcyBpbiBvcmRlclxuICAgICAgKWBcbiAgfVxuICBsZXQgZXZtQ29kZVN0ciA9ICcnXG4gIGlmIChldm1Db2RlICYmICFpc0NvbnN0cnVjdG9yKSB7XG4gICAgbGV0IGV2bWJ5dGVjb2Rlc3RhcnQgPSAzMzgzMlxuICAgIGxldCBldm1ydW50aW1lc3RhcnQgPSBldm1ieXRlY29kZXN0YXJ0ICsgZXZtQ29uc3RydWN0b3JDb2RlLmxlbmd0aFxuICAgIGxldCBjb25zdHJ1Y3RvckNvZGUgPSAnJ1xuICAgIGZvciAoY29uc3QgdmFsIG9mIGV2bUNvbnN0cnVjdG9yQ29kZS52YWx1ZXMoKSkge1xuICAgICAgY29uc3RydWN0b3JDb2RlICs9IFwiXFxcXFwiK3ZhbC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgIH1cbiAgICBsZXQgcnVudGltZUNvZGUgPSAnJ1xuICAgIGZvciAoY29uc3QgdmFsIG9mIGV2bUNvZGUudmFsdWVzKCkpIHtcbiAgICAgIHJ1bnRpbWVDb2RlICs9IFwiXFxcXFwiK3ZhbC50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgIH1cbiAgICBldm1Db2RlU3RyID0gYFxuKGRhdGEgKGkzMi5jb25zdCAke2V2bWJ5dGVjb2Rlc3RhcnR9KSBcIiR7Y29uc3RydWN0b3JDb2RlfVwiKVxuKGRhdGEgKGkzMi5jb25zdCAke2V2bXJ1bnRpbWVzdGFydH0pIFwiJHtydW50aW1lQ29kZX1cIilcbihmdW5jICRldm1fYnl0ZWNvZGUgKGV4cG9ydCBcImV2bV9ieXRlY29kZVwiKSAocmVzdWx0IGkzMiBpMzIgaTMyKVxuICAgIGkzMi5jb25zdCAke2V2bWJ5dGVjb2Rlc3RhcnR9XG4gICAgaTMyLmNvbnN0ICR7ZXZtQ29uc3RydWN0b3JDb2RlLmxlbmd0aH1cbiAgICBpMzIuY29uc3QgJHtldm1Db2RlLmxlbmd0aH0pXG4gICAgYFxuICB9XG5cbiAgbGV0IG9wY29kZUhlbHBlcnM7XG4gIGlmIChpbnRlcmZhY2VWZXJzaW9uID09PSBJTlRFUkZBQ0VfQ0xBU1NJQykge1xuICAgIG9wY29kZUhlbHBlcnMgPSBgXG4gIChnbG9iYWwgJGNiX2Rlc3QgKG11dCBpMzIpIChpMzIuY29uc3QgMCkpXG4gIChnbG9iYWwgJHNwIChtdXQgaTMyKSAoaTMyLmNvbnN0IC0zMikpXG4gIChnbG9iYWwgJGluaXQgKG11dCBpMzIpIChpMzIuY29uc3QgMCkpXG5cbiAgOzsgbWVtb3J5IHJlbGF0ZWQgZ2xvYmFsXG4gIDs7IChnbG9iYWwgJGV2bWJ5dGVjb2Rlc3RhcnQgaTMyICAoaTMyLmNvbnN0IDMzODMyKSlcbiAgKGdsb2JhbCAkbWVtc3RhcnQgaTMyICAoaTMyLmNvbnN0IDYyNjMyKSlcbiAgOzsgdGhlIG51bWJlciBvZiAyNTYgd29yZHMgc3RvcmVkIGluIG1lbW9yeVxuICAoZ2xvYmFsICR3b3JkQ291bnQgKG11dCBpNjQpIChpNjQuY29uc3QgMCkpXG4gIDs7IHdoYXQgd2FzIGNoYXJnZWQgZm9yIHRoZSBsYXN0IG1lbW9yeSBhbGxvY2F0aW9uXG4gIChnbG9iYWwgJHByZXZNZW1Db3N0IChtdXQgaTY0KSAoaTY0LmNvbnN0IDApKVxuXG4gIDs7IGZvciBTSEwsIFNIUiwgU0FSXG4gIChnbG9iYWwgJGdsb2JhbF8gKG11dCBpNjQpIChpNjQuY29uc3QgMCkpXG4gIChnbG9iYWwgJGdsb2JhbF9fMSAobXV0IGk2NCkgKGk2NC5jb25zdCAwKSlcbiAgKGdsb2JhbCAkZ2xvYmFsX18yIChtdXQgaTY0KSAoaTY0LmNvbnN0IDApKVxuICAgIGBcbiAgfSBlbHNlIHtcbiAgICBvcGNvZGVIZWxwZXJzID0gYFxuICAoZ2xvYmFsICRjYl9kZXN0IChtdXQgaTMyKSAoaTMyLmNvbnN0IDApKVxuICAoZ2xvYmFsICRpbml0IChtdXQgaTMyKSAoaTMyLmNvbnN0IDApKVxuICAgIGBcbiAgfVxuXG4gIHJldHVybiBgXG4obW9kdWxlXG4gICR7aW1wb3J0cy5qb2luKCdcXG4nKX1cblxuICAodHlwZSAkZXQxMiAoZnVuYykpXG4gIChmdW5jICQke2ludGVyZmFjZVZlcnNpb259IChleHBvcnQgXCIke2ludGVyZmFjZVZlcnNpb259XCIpICh0eXBlICRldDEyKSAobm9wKSlcblxuXG4gICR7b3Bjb2RlSGVscGVyc31cblxuICA7OyBUT0RPOiBtZW1vcnkgc2hvdWxkIG9ubHkgYmUgMSwgYnV0IGNhbid0IHJlc2l6ZSByaWdodCBub3dcbiAgKG1lbW9yeSA1MDApXG4gIChleHBvcnQgXCJtZW1vcnlcIiAobWVtb3J5IDApKVxuXG4gICR7Y2FsbGJhY2tUYWJsZVN0cn1cblxuICAke2Z1bmNTdHJ9XG5cbiAgJHtldm1Db2RlU3RyfVxuXG4pYFxufVxuXG5jb25zdCBjb3Ntb3NGdW5jdGlvbnMgPSB7XG4gIFwiU0VORENPU01PU01TR1wiOntcbiAgICBpbXBvcnQ6IGAoaW1wb3J0IFwiZW52XCIgXCJldGhlcmV1bV9zZW5kQ29zbW9zTXNnXCIgKGZ1bmMgJHNlbmRDb3Ntb3NNc2cgKHBhcmFtIGkzMiBpMzIpIChyZXN1bHQgaTMyKSApKWAsXG4gICAgZGVmOiBgKGZ1bmMgJFNFTkRDT1NNT1NNU0cgKGxvY2FsICRvZmZzZXQwIGkzMikobG9jYWwgJGxlbmd0aDAgaTMyKShsb2NhbC5zZXQgJG9mZnNldDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XG4gICAgICAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSlcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKVxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKVxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkpXG5cbiAgKGxvY2FsLnNldCAkb2Zmc2V0MCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpIChsb2NhbC5nZXQgJG9mZnNldDApKSlcblxuICA7OyB0b2RvIGZpeCBsZW5ndGggLSByZWFkIGZyb20gbWVtb3J5IGFuZCBpbmNyZW1lbnQgb2Zmc2V0IHdpdGggMzJcbiAgKGxvY2FsLnNldCAkbGVuZ3RoMCAoaTMyLmNvbnN0IDApKVxuICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJG9mZnNldDApIChpMzIuY29uc3QgMzIpKVxuXG4gIDs7IChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGxvY2FsLmdldCAkb2Zmc2V0MCkgKGkzMi5jb25zdCAzMikpKVxuXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDApKSAoaTY0LmV4dGVuZF9pMzJfdSAoaTMyLmVxeiAoY2FsbCAkc2VuZENvc21vc01zZyhsb2NhbC5nZXQgJG9mZnNldDApKGxvY2FsLmdldCAkbGVuZ3RoMCkpKSkpXG4gIDs7IHplcm8gb3V0IG1lbVxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkgKGk2NC5jb25zdCAwKSlcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAoaTY0LmNvbnN0IDApKVxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQuY29uc3QgMCkpKWBcbiAgfSxcbiAgXCJTRU5EQ09TTU9TUVVFUllcIjp7XG4gICAgaW1wb3J0OiBgKGltcG9ydCBcImVudlwiIFwiZXRoZXJldW1fc2VuZENvc21vc1F1ZXJ5XCIgKGZ1bmMgJHNlbmRDb3Ntb3NRdWVyeSAocGFyYW0gaTMyIGkzMikgKHJlc3VsdCBpMzIpICkpYCxcbiAgICBkZWY6IGAoZnVuYyAkU0VORENPU01PU1FVRVJZIChsb2NhbCAkb2Zmc2V0MCBpMzIpKGxvY2FsICRsZW5ndGgwIGkzMikobG9jYWwuc2V0ICRvZmZzZXQwIChjYWxsICRjaGVja19vdmVyZmxvd1xuICAgICAgKGk2NC5sb2FkIChnbG9iYWwuZ2V0ICRzcCkpXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSlcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSlcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpKVxuXG4gIChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQwKSkpXG5cbiAgOzsgdG9kbyBmaXggbGVuZ3RoIC0gcmVhZCBmcm9tIG1lbW9yeSBhbmQgaW5jcmVtZW50IG9mZnNldCB3aXRoIDMyXG4gIChsb2NhbC5zZXQgJGxlbmd0aDAgKGkzMi5jb25zdCAwKSlcbiAgKGNhbGwgJG1lbXVzZWdhcyAobG9jYWwuZ2V0ICRvZmZzZXQwKSAoaTMyLmNvbnN0IDMyKSlcblxuICA7OyAobG9jYWwuc2V0ICRvZmZzZXQwIChpMzIuYWRkIChsb2NhbC5nZXQgJG9mZnNldDApIChpMzIuY29uc3QgMzIpKSlcblxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAwKSkgKGk2NC5leHRlbmRfaTMyX3UgKGkzMi5lcXogKGNhbGwgJHNlbmRDb3Ntb3NRdWVyeShsb2NhbC5nZXQgJG9mZnNldDApKGxvY2FsLmdldCAkbGVuZ3RoMCkpKSkpXG4gIDs7IHplcm8gb3V0IG1lbVxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkgKGk2NC5jb25zdCAwKSlcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAoaTY0LmNvbnN0IDApKVxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQuY29uc3QgMCkpKWAsXG4gIH1cbn1cbiIsIihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVdGlsc1xuICBmdW5jdGlvbiBhc3NlcnQgKHZhbCwgbXNnKSB7XG4gICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIC8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4gIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG4gIGZ1bmN0aW9uIGluaGVyaXRzIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICB9XG5cbiAgLy8gQk5cblxuICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAoQk4uaXNCTihudW1iZXIpKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMud29yZHMgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFJlZHVjdGlvbiBjb250ZXh0XG4gICAgdGhpcy5yZWQgPSBudWxsO1xuXG4gICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuICAgICAgICBlbmRpYW4gPSBiYXNlO1xuICAgICAgICBiYXNlID0gMTA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJOID0gQk47XG4gIH1cblxuICBCTi5CTiA9IEJOO1xuICBCTi53b3JkU2l6ZSA9IDI2O1xuXG4gIHZhciBCdWZmZXI7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgQnVmZmVyID0gd2luZG93LkJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG5cbiAgQk4uaXNCTiA9IGZ1bmN0aW9uIGlzQk4gKG51bSkge1xuICAgIGlmIChudW0gaW5zdGFuY2VvZiBCTikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bSAhPT0gbnVsbCAmJiB0eXBlb2YgbnVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG4gIH07XG5cbiAgQk4ubWF4ID0gZnVuY3Rpb24gbWF4IChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPCAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdCAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAnaGV4Jykge1xuICAgICAgYmFzZSA9IDE2O1xuICAgIH1cbiAgICBhc3NlcnQoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNik7XG5cbiAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgc3RhcnQrKztcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IG51bWJlci5sZW5ndGgpIHtcbiAgICAgIGlmIChiYXNlID09PSAxNikge1xuICAgICAgICB0aGlzLl9wYXJzZUhleChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuICAgICAgICBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICAgICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbIG51bWJlciAmIDB4M2ZmZmZmZiBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpIC0gMV0gPDwgOCkgfCAobnVtYmVyW2kgLSAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXg0Qml0cyAoc3RyaW5nLCBpbmRleCkge1xuICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIC8vICdBJyAtICdGJ1xuICAgIGlmIChjID49IDY1ICYmIGMgPD0gNzApIHtcbiAgICAgIHJldHVybiBjIC0gNTU7XG4gICAgLy8gJ2EnIC0gJ2YnXG4gICAgfSBlbHNlIGlmIChjID49IDk3ICYmIGMgPD0gMTAyKSB7XG4gICAgICByZXR1cm4gYyAtIDg3O1xuICAgIC8vICcwJyAtICc5J1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGMgLSA0OCkgJiAweGY7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXhCeXRlIChzdHJpbmcsIGxvd2VyQm91bmQsIGluZGV4KSB7XG4gICAgdmFyIHIgPSBwYXJzZUhleDRCaXRzKHN0cmluZywgaW5kZXgpO1xuICAgIGlmIChpbmRleCAtIDEgPj0gbG93ZXJCb3VuZCkge1xuICAgICAgciB8PSBwYXJzZUhleDRCaXRzKHN0cmluZywgaW5kZXggLSAxKSA8PCA0O1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXggKG51bWJlciwgc3RhcnQsIGVuZGlhbikge1xuICAgIC8vIENyZWF0ZSBwb3NzaWJseSBiaWdnZXIgYXJyYXkgdG8gZW5zdXJlIHRoYXQgaXQgZml0cyB0aGUgbnVtYmVyXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIC8vIDI0LWJpdHMgY2h1bmtzXG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIGogPSAwO1xuXG4gICAgdmFyIHc7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnQ7IGkgLT0gMikge1xuICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ICYgMHgzZmZmZmZmO1xuICAgICAgICBpZiAob2ZmID49IDE4KSB7XG4gICAgICAgICAgb2ZmIC09IDE4O1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgPj4+IDI2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJzZUxlbmd0aCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICAgIGZvciAoaSA9IHBhcnNlTGVuZ3RoICUgMiA9PT0gMCA/IHN0YXJ0ICsgMSA6IHN0YXJ0OyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VCYXNlIChzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByICo9IG11bDtcblxuICAgICAgLy8gJ2EnXG4gICAgICBpZiAoYyA+PSA0OSkge1xuICAgICAgICByICs9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcpIHtcbiAgICAgICAgciArPSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciArPSBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZSAobnVtYmVyLCBiYXNlLCBzdGFydCkge1xuICAgIC8vIEluaXRpYWxpemUgYXMgemVyb1xuICAgIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2VcbiAgICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpIHtcbiAgICAgIGxpbWJMZW4rKztcbiAgICB9XG4gICAgbGltYkxlbi0tO1xuICAgIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgbW9kID0gdG90YWwgJSBsaW1iTGVuO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgICB2YXIgd29yZCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZCAhPT0gMCkge1xuICAgICAgdmFyIHBvdyA9IDE7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2Q7IGkrKykge1xuICAgICAgICBwb3cgKj0gYmFzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbXVsbihwb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcbiAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIH1cbiAgICBkZXN0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciByID0gbmV3IEJOKG51bGwpO1xuICAgIHRoaXMuY29weShyKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQgKHNpemUpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGxlYWRpbmcgYDBgIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwICgpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbiAoKSB7XG4gICAgLy8gLTAgPSAwXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xuICB9O1xuXG4gIC8qXG5cbiAgdmFyIHplcm9zID0gW107XG4gIHZhciBncm91cFNpemVzID0gW107XG4gIHZhciBncm91cEJhc2VzID0gW107XG5cbiAgdmFyIHMgPSAnJztcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XG4gICAgemVyb3NbaV0gPSBzO1xuICAgIHMgKz0gJzAnO1xuICB9XG4gIGdyb3VwU2l6ZXNbMF0gPSAwO1xuICBncm91cFNpemVzWzFdID0gMDtcbiAgZ3JvdXBCYXNlc1swXSA9IDA7XG4gIGdyb3VwQmFzZXNbMV0gPSAwO1xuICB2YXIgYmFzZSA9IDIgLSAxO1xuICB3aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XG4gICAgdmFyIGdyb3VwU2l6ZSA9IDA7XG4gICAgdmFyIGdyb3VwQmFzZSA9IDE7XG4gICAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcbiAgICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xuICAgICAgZ3JvdXBTaXplICs9IDE7XG4gICAgfVxuICAgIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XG4gICAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcbiAgfVxuXG4gICovXG5cbiAgdmFyIHplcm9zID0gW1xuICAgICcnLFxuICAgICcwJyxcbiAgICAnMDAnLFxuICAgICcwMDAnLFxuICAgICcwMDAwJyxcbiAgICAnMDAwMDAnLFxuICAgICcwMDAwMDAnLFxuICAgICcwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICBdO1xuXG4gIHZhciBncm91cFNpemVzID0gW1xuICAgIDAsIDAsXG4gICAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuICAgIDgsIDcsIDcsIDcsIDcsIDYsIDYsXG4gICAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDVcbiAgXTtcblxuICB2YXIgZ3JvdXBCYXNlcyA9IFtcbiAgICAwLCAwLFxuICAgIDMzNTU0NDMyLCA0MzA0NjcyMSwgMTY3NzcyMTYsIDQ4ODI4MTI1LCA2MDQ2NjE3NiwgNDAzNTM2MDcsIDE2Nzc3MjE2LFxuICAgIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG4gICAgMTY3NzcyMTYsIDI0MTM3NTY5LCAzNDAxMjIyNCwgNDcwNDU4ODEsIDY0MDAwMDAwLCA0MDg0MTAxLCA1MTUzNjMyLFxuICAgIDY0MzYzNDMsIDc5NjI2MjQsIDk3NjU2MjUsIDExODgxMzc2LCAxNDM0ODkwNywgMTcyMTAzNjgsIDIwNTExMTQ5LFxuICAgIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG4gIF07XG5cbiAgQk4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGJhc2UsIHBhZGRpbmcpIHtcbiAgICBiYXNlID0gYmFzZSB8fCAxMDtcbiAgICBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcblxuICAgIHZhciBvdXQ7XG4gICAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgb3V0ID0gY2FycnkudG9TdHJpbmcoMTYpICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcbiAgICAgIC8vIHZhciBncm91cFNpemUgPSBNYXRoLmZsb29yKEJOLndvcmRTaXplICogTWF0aC5MTjIgLyBNYXRoLmxvZyhiYXNlKSk7XG4gICAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplc1tiYXNlXTtcbiAgICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuICAgICAgdmFyIGdyb3VwQmFzZSA9IGdyb3VwQmFzZXNbYmFzZV07XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuICAgICAgYy5uZWdhdGl2ZSA9IDA7XG4gICAgICB3aGlsZSAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIHIgPSBjLm1vZG4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgICBpZiAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG4gICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDB4MDEpIHtcbiAgICAgIC8vIE5PVEU6IGF0IHRoaXMgc3RhZ2UgaXQgaXMga25vd24gdGhhdCB0aGUgdG9wIGJpdCBpcyBzZXRcbiAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLm5lZ2F0aXZlICE9PSAwKSA/IC1yZXQgOiByZXQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuICAgIGFzc2VydCh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyk7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyLCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5IChlbmRpYW4sIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24gdG9BcnJheUxpa2UgKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aCgpO1xuICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG4gICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuICAgIGFzc2VydChyZXFMZW5ndGggPiAwLCAnUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwJyk7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG4gICAgdmFyIGxpdHRsZUVuZGlhbiA9IGVuZGlhbiA9PT0gJ2xlJztcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5VHlwZShyZXFMZW5ndGgpO1xuXG4gICAgdmFyIGIsIGk7XG4gICAgdmFyIHEgPSB0aGlzLmNsb25lKCk7XG4gICAgaWYgKCFsaXR0bGVFbmRpYW4pIHtcbiAgICAgIC8vIEFzc3VtZSBiaWctZW5kaWFuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcmVxTGVuZ3RoIC0gYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tyZXFMZW5ndGggLSBpIC0gMV0gPSBiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG4gICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgICBxLml1c2hybig4KTtcblxuICAgICAgICByZXNbaV0gPSBiO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgaSA8IHJlcUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBpZiAoTWF0aC5jbHozMikge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgdmFyIHQgPSB3O1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYgKHQgPj0gMHgxMDAwKSB7XG4gICAgICAgIHIgKz0gMTM7XG4gICAgICAgIHQgPj4+PSAxMztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4NDApIHtcbiAgICAgICAgciArPSA3O1xuICAgICAgICB0ID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgICByICs9IDQ7XG4gICAgICAgIHQgPj4+PSA0O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHgwMikge1xuICAgICAgICByICs9IDI7XG4gICAgICAgIHQgPj4+PSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIgKyB0O1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG4gICAgLy8gU2hvcnQtY3V0XG4gICAgaWYgKHcgPT09IDApIHJldHVybiAyNjtcblxuICAgIHZhciB0ID0gdztcbiAgICB2YXIgciA9IDA7XG4gICAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNztcbiAgICAgIHQgPj4+PSA3O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweGYpID09PSAwKSB7XG4gICAgICByICs9IDQ7XG4gICAgICB0ID4+Pj0gNDtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuICAgICAgciArPSAyO1xuICAgICAgdCA+Pj49IDI7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG51bWJlciBvZiB1c2VkIGJpdHMgaW4gYSBCTlxuICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0JpdEFycmF5IChudW0pIHtcbiAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG4gICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG4gICAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgICB3W2JpdF0gPSAobnVtLndvcmRzW29mZl0gJiAoMSA8PCB3Yml0KSkgPj4+IHdiaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICAvLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG4gIEJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzICgpIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG5cbiAgICB2YXIgciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xuICAgICAgciArPSBiO1xuICAgICAgaWYgKGIgIT09IDI2KSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gdG9Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gZnJvbVR3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMudGVzdG4od2lkdGggLSAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMubm90bih3aWR0aCkuaWFkZG4oMSkuaW5lZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uIGlzTmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMDtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24gaW5lZyAoKSB7XG4gICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yIChudW0pIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gfCBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdW9yKG51bSk7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVvcih0aGlzKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1YW5kID0gZnVuY3Rpb24gaXVhbmQgKG51bSkge1xuICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZCAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1YW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuICAgIH1cblxuICAgIGlmICh0aGlzICE9PSBhKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXhvcihudW0pO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXhvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXV4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gTm90IGBgdGhpc2BgIHdpdGggYGB3aWR0aGBgIGJpdHdpZHRoXG4gIEJOLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuICh3aWR0aCkge1xuICAgIGFzc2VydCh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHdpZHRoID49IDApO1xuXG4gICAgdmFyIGJ5dGVzTmVlZGVkID0gTWF0aC5jZWlsKHdpZHRoIC8gMjYpIHwgMDtcbiAgICB2YXIgYml0c0xlZnQgPSB3aWR0aCAlIDI2O1xuXG4gICAgLy8gRXh0ZW5kIHRoZSBidWZmZXIgd2l0aCBsZWFkaW5nIHplcm9lc1xuICAgIHRoaXMuX2V4cGFuZChieXRlc05lZWRlZCk7XG5cbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICBieXRlc05lZWRlZC0tO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb21wbGV0ZSB3b3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNOZWVkZWQ7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgcmVzaWR1ZVxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmICgweDNmZmZmZmYgPj4gKDI2IC0gYml0c0xlZnQpKTtcbiAgICB9XG5cbiAgICAvLyBBbmQgcmVtb3ZlIGxlYWRpbmcgemVyb2VzXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubm90biA9IGZ1bmN0aW9uIG5vdG4gKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG4gIH07XG5cbiAgLy8gU2V0IGBiaXRgIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgdGhpcy5fZXhwYW5kKG9mZiArIDEpO1xuXG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChudW0pIHtcbiAgICB2YXIgcjtcblxuICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cbiAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSBudW0uc3ViKHRoaXMpO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcbiAgICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZChudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmVcbiAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuICAgIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gYSA+IGJcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoY21wID4gMCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgICBpZiAoY2FycnkgPT09IDAgJiYgaSA8IGEubGVuZ3RoICYmIGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICAgIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNtYWxsTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICB2YXIgbGVuID0gKHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aCkgfCAwO1xuICAgIG91dC5sZW5ndGggPSBsZW47XG4gICAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuICAgIC8vIFBlZWwgb25lIGl0ZXJhdGlvbiAoY29tcGlsZXIgY2FuJ3QgZG8gaXQsIGJlY2F1c2Ugb2YgY29kZSBjb21wbGV4aXR5KVxuICAgIHZhciBhID0gc2VsZi53b3Jkc1swXSB8IDA7XG4gICAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuICAgIHZhciByID0gYSAqIGI7XG5cbiAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgb3V0LndvcmRzWzBdID0gbG87XG5cbiAgICBmb3IgKHZhciBrID0gMTsgayA8IGxlbjsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGNhcnJ5ID4+PiAyNjtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG4gICAgICAgIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHIgPSBhICogYiArIHJ3b3JkO1xuICAgICAgICBuY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgICAgcndvcmQgPSByICYgMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQgfCAwO1xuICAgICAgY2FycnkgPSBuY2FycnkgfCAwO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5IHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIC8vIFRPRE8oaW5kdXRueSk6IGl0IG1heSBiZSByZWFzb25hYmxlIHRvIG9taXQgaXQgZm9yIHVzZXJzIHdobyBkb24ndCBuZWVkXG4gIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcbiAgLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cbiAgdmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuICAgIHZhciBiID0gbnVtLndvcmRzO1xuICAgIHZhciBvID0gb3V0LndvcmRzO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgbG87XG4gICAgdmFyIG1pZDtcbiAgICB2YXIgaGk7XG4gICAgdmFyIGEwID0gYVswXSB8IDA7XG4gICAgdmFyIGFsMCA9IGEwICYgMHgxZmZmO1xuICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG4gICAgdmFyIGExID0gYVsxXSB8IDA7XG4gICAgdmFyIGFsMSA9IGExICYgMHgxZmZmO1xuICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG4gICAgdmFyIGEyID0gYVsyXSB8IDA7XG4gICAgdmFyIGFsMiA9IGEyICYgMHgxZmZmO1xuICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG4gICAgdmFyIGEzID0gYVszXSB8IDA7XG4gICAgdmFyIGFsMyA9IGEzICYgMHgxZmZmO1xuICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG4gICAgdmFyIGE0ID0gYVs0XSB8IDA7XG4gICAgdmFyIGFsNCA9IGE0ICYgMHgxZmZmO1xuICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG4gICAgdmFyIGE1ID0gYVs1XSB8IDA7XG4gICAgdmFyIGFsNSA9IGE1ICYgMHgxZmZmO1xuICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG4gICAgdmFyIGE2ID0gYVs2XSB8IDA7XG4gICAgdmFyIGFsNiA9IGE2ICYgMHgxZmZmO1xuICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG4gICAgdmFyIGE3ID0gYVs3XSB8IDA7XG4gICAgdmFyIGFsNyA9IGE3ICYgMHgxZmZmO1xuICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG4gICAgdmFyIGE4ID0gYVs4XSB8IDA7XG4gICAgdmFyIGFsOCA9IGE4ICYgMHgxZmZmO1xuICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG4gICAgdmFyIGE5ID0gYVs5XSB8IDA7XG4gICAgdmFyIGFsOSA9IGE5ICYgMHgxZmZmO1xuICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG4gICAgdmFyIGIwID0gYlswXSB8IDA7XG4gICAgdmFyIGJsMCA9IGIwICYgMHgxZmZmO1xuICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG4gICAgdmFyIGIxID0gYlsxXSB8IDA7XG4gICAgdmFyIGJsMSA9IGIxICYgMHgxZmZmO1xuICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG4gICAgdmFyIGIyID0gYlsyXSB8IDA7XG4gICAgdmFyIGJsMiA9IGIyICYgMHgxZmZmO1xuICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG4gICAgdmFyIGIzID0gYlszXSB8IDA7XG4gICAgdmFyIGJsMyA9IGIzICYgMHgxZmZmO1xuICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG4gICAgdmFyIGI0ID0gYls0XSB8IDA7XG4gICAgdmFyIGJsNCA9IGI0ICYgMHgxZmZmO1xuICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG4gICAgdmFyIGI1ID0gYls1XSB8IDA7XG4gICAgdmFyIGJsNSA9IGI1ICYgMHgxZmZmO1xuICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG4gICAgdmFyIGI2ID0gYls2XSB8IDA7XG4gICAgdmFyIGJsNiA9IGI2ICYgMHgxZmZmO1xuICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG4gICAgdmFyIGI3ID0gYls3XSB8IDA7XG4gICAgdmFyIGJsNyA9IGI3ICYgMHgxZmZmO1xuICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG4gICAgdmFyIGI4ID0gYls4XSB8IDA7XG4gICAgdmFyIGJsOCA9IGI4ICYgMHgxZmZmO1xuICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG4gICAgdmFyIGI5ID0gYls5XSB8IDA7XG4gICAgdmFyIGJsOSA9IGI5ICYgMHgxZmZmO1xuICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cbiAgICBvdXQubmVnYXRpdmUgPSBzZWxmLm5lZ2F0aXZlIF4gbnVtLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSAxOTtcbiAgICAvKiBrID0gMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuICAgIHZhciB3MCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuICAgIHcwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMSkpIHwgMDtcbiAgICB2YXIgdzEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcbiAgICB3MSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgyKSkgfCAwO1xuICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzIgPj4+IDI2KSkgfCAwO1xuICAgIHcyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgzKSkgfCAwO1xuICAgIHZhciB3MyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuICAgIHczICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNCkpIHwgMDtcbiAgICB2YXIgdzQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgICB3NCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg1KSkgfCAwO1xuICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzUgPj4+IDI2KSkgfCAwO1xuICAgIHc1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg2KSkgfCAwO1xuICAgIHZhciB3NiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuICAgIHc2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNykpIHwgMDtcbiAgICB2YXIgdzcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgICB3NyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg4KSkgfCAwO1xuICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzggPj4+IDI2KSkgfCAwO1xuICAgIHc4ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg5KSkgfCAwO1xuICAgIHZhciB3OSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuICAgIHc5ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwxKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gICAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzExID4+PiAyNikpIHwgMDtcbiAgICB3MTEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gICAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw0KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gICAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgICB3MTQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gICAgdzE1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw3KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG4gICAgdzE2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE3ID4+PiAyNikpIHwgMDtcbiAgICB3MTcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuICAgIHZhciB3MTggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE4ICY9IDB4M2ZmZmZmZjtcbiAgICBvWzBdID0gdzA7XG4gICAgb1sxXSA9IHcxO1xuICAgIG9bMl0gPSB3MjtcbiAgICBvWzNdID0gdzM7XG4gICAgb1s0XSA9IHc0O1xuICAgIG9bNV0gPSB3NTtcbiAgICBvWzZdID0gdzY7XG4gICAgb1s3XSA9IHc3O1xuICAgIG9bOF0gPSB3ODtcbiAgICBvWzldID0gdzk7XG4gICAgb1sxMF0gPSB3MTA7XG4gICAgb1sxMV0gPSB3MTE7XG4gICAgb1sxMl0gPSB3MTI7XG4gICAgb1sxM10gPSB3MTM7XG4gICAgb1sxNF0gPSB3MTQ7XG4gICAgb1sxNV0gPSB3MTU7XG4gICAgb1sxNl0gPSB3MTY7XG4gICAgb1sxN10gPSB3MTc7XG4gICAgb1sxOF0gPSB3MTg7XG4gICAgaWYgKGMgIT09IDApIHtcbiAgICAgIG9bMTldID0gYztcbiAgICAgIG91dC5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICAvLyBQb2x5ZmlsbCBjb21iXG4gIGlmICghTWF0aC5pbXVsKSB7XG4gICAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuICB9XG5cbiAgZnVuY3Rpb24gYmlnTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICB2YXIgaG5jYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgICBobmNhcnJ5ID0gMDtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cbiAgICAgICAgaG5jYXJyeSArPSBuY2FycnkgPj4+IDI2O1xuICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgICBjYXJyeSA9IG5jYXJyeTtcbiAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBqdW1ib011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBmZnRtID0gbmV3IEZGVE0oKTtcbiAgICByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uIG11bFRvIChudW0sIG91dCkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG4gICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCA2Mykge1xuICAgICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG4gICAgICByZXMgPSBiaWdNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG4gIC8vIHNsaWdodGx5IHJldmlzaXRlZCB0byByZWx5IG9uIGxvb3BpbmcgaW5zdGVhZCBvZiByZWN1cnNpb25cblxuICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQgKE4pIHtcbiAgICB2YXIgdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdFtpXSA9IHRoaXMucmV2QmluKGksIGwsIE4pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4gKHgsIGwsIE4pIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSkgcmV0dXJuIHg7XG5cbiAgICB2YXIgcmIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByYiB8PSAoeCAmIDEpIDw8IChsIC0gaSAtIDEpO1xuICAgICAgeCA+Pj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmI7XG4gIH07XG5cbiAgLy8gUGVyZm9ybXMgXCJ0d2VlZGxpbmdcIiBwaGFzZSwgdGhlcmVmb3JlICdlbXVsYXRpbmcnXG4gIC8vIGJlaGF2aW91ciBvZiB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobVxuICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBydHdzW2ldID0gcndzW3JidFtpXV07XG4gICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuICAgIGZvciAodmFyIHMgPSAxOyBzIDwgTjsgcyA8PD0gMSkge1xuICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cbiAgICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG4gICAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG4gICAgICAgIHZhciBpdHdkZl8gPSBpdHdkZjtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuICAgICAgICAgIHZhciBpZSA9IGl0d3NbcCArIGpdO1xuXG4gICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuICAgICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuICAgICAgICAgIHZhciByeCA9IHJ0d2RmXyAqIHJvIC0gaXR3ZGZfICogaW87XG5cbiAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG4gICAgICAgICAgcm8gPSByeDtcblxuICAgICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcbiAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cbiAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGogKyBzXSA9IGllIC0gaW87XG5cbiAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuICAgICAgICAgIGlmIChqICE9PSBsKSB7XG4gICAgICAgICAgICByeCA9IHJ0d2RmICogcnR3ZGZfIC0gaXR3ZGYgKiBpdHdkZl87XG5cbiAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG4gICAgICAgICAgICBydHdkZl8gPSByeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYiAobiwgbSkge1xuICAgIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuICAgIHZhciBvZGQgPSBOICYgMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAxIDw8IGkgKyAxICsgb2RkO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSAocndzLCBpd3MsIE4pIHtcbiAgICBpZiAoTiA8PSAxKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB0ID0gcndzW2ldO1xuXG4gICAgICByd3NbaV0gPSByd3NbTiAtIGkgLSAxXTtcbiAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuICAgICAgdCA9IGl3c1tpXTtcblxuICAgICAgaXdzW2ldID0gLWl3c1tOIC0gaSAtIDFdO1xuICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcbiAgICAgICAgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArXG4gICAgICAgIGNhcnJ5O1xuXG4gICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cbiAgICAgIGlmICh3IDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gdyAvIDB4NDAwMDAwMCB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdzO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICAgIHJ3c1syICogaSArIDFdID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgIH1cblxuICAgIC8vIFBhZCB3aXRoIHplcm9lc1xuICAgIGZvciAoaSA9IDIgKiBsZW47IGkgPCBOOyArK2kpIHtcbiAgICAgIHJ3c1tpXSA9IDA7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAwKTtcbiAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbiBzdHViIChOKSB7XG4gICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBwaFtpXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBoO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcbiAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cbiAgICB2YXIgcmJ0ID0gdGhpcy5tYWtlUkJUKE4pO1xuXG4gICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cbiAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciByd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIG5yd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5yd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBybXdzID0gb3V0LndvcmRzO1xuICAgIHJtd3MubGVuZ3RoID0gTjtcblxuICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcbiAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuXG4gICAgdGhpcy50cmFuc2Zvcm0ocndzLCBfLCByd3N0LCBpd3N0LCBOLCByYnQpO1xuICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG4gICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuICAgICAgcndzdFtpXSA9IHJ4O1xuICAgIH1cblxuICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG4gICAgdGhpcy5jb25qdWdhdGUocm13cywgXywgTik7XG4gICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cbiAgICBvdXQubmVnYXRpdmUgPSB4Lm5lZ2F0aXZlIF4geS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0geC5sZW5ndGggKyB5Lmxlbmd0aDtcbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG4gIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGVtcGxveWluZyBGRlRcbiAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBNdWx0aXBsaWNhdGlvblxuICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblxuICAgIC8vIENhcnJ5XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcbiAgICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG4gICAgICBjYXJyeSA+Pj0gMjY7XG4gICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuICAgICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcbiAgfTtcblxuICAvLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuICBCTi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChudW0pIHtcbiAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcbiAgICBpZiAody5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQk4oMSk7XG5cbiAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXG4gICAgdmFyIHJlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpIHtcbiAgICAgIGlmICh3W2ldICE9PSAwKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIHEgPSByZXMuc3FyKCk7IGkgPCB3Lmxlbmd0aDsgaSsrLCBxID0gcS5zcXIoKSkge1xuICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gcmVzLm11bChxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uIGl1c2hsbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcbiAgICB2YXIgY2FycnlNYXNrID0gKDB4M2ZmZmZmZiA+Pj4gKDI2IC0gcikpIDw8ICgyNiAtIHIpO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG4gICAgICAgIHZhciBjID0gKCh0aGlzLndvcmRzW2ldIHwgMCkgLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcbiAgICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMgIT09IDApIHtcbiAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24gaXNobG4gKGJpdHMpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG4gIC8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xuICAvLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXG4gIEJOLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbiBpdXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciBoO1xuICAgIGlmIChoaW50KSB7XG4gICAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSBNYXRoLm1pbigoYml0cyAtIHIpIC8gMjYsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuICAgIGggLT0gcztcbiAgICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cbiAgICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG4gICAgaWYgKG1hc2tlZFdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG4gICAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuICAgIH1cblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaSArIHNdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKGNhcnJ5IDw8ICgyNiAtIHIpKSB8ICh3b3JkID4+PiByKTtcbiAgICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBjYXJyaWVkIGJpdHMgYXMgYSBtYXNrXG4gICAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKSB7XG4gICAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdFxuICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHRcbiAgQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG4gIEJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG4gICAgcmV0dXJuICEhKHcgJiBxKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuICBCTi5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24gaW1hc2tuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcysrO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG4gIH07XG5cbiAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gICAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2VcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPCBudW0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4gKG51bSkge1xuICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG4gICAgLy8gQ2FycnlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkbihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhcnJ5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bCAobnVtLCBtdWwsIHNoaWZ0KSB7XG4gICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcbiAgICB2YXIgaTtcblxuICAgIHRoaXMuX2V4cGFuZChsZW4pO1xuXG4gICAgdmFyIHc7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG4gICAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ID09PSAwKSByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXG4gICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcbiAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdiAobnVtLCBtb2RlKSB7XG4gICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW07XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuICAgIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgYiA9IGIudXNobG4oc2hpZnQpO1xuICAgICAgYS5pdXNobG4oc2hpZnQpO1xuICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG4gICAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICAgIHZhciBxO1xuXG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICBxID0gbmV3IEJOKG51bGwpO1xuICAgICAgcS5sZW5ndGggPSBtICsgMTtcbiAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHEud29yZHNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcbiAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgYSA9IGRpZmY7XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW21dID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuICAgICAgICAoYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXSB8IDApO1xuXG4gICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgICAgLy8gKDB4N2ZmZmZmZilcbiAgICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cbiAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICAgIHdoaWxlIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIHFqLS07XG4gICAgICAgIGEubmVnYXRpdmUgPSAwO1xuICAgICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcbiAgICAgICAgaWYgKCFhLmlzWmVybygpKSB7XG4gICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW2pdID0gcWo7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxKSB7XG4gICAgICBxLnN0cmlwKCk7XG4gICAgfVxuICAgIGEuc3RyaXAoKTtcblxuICAgIC8vIERlbm9ybWFsaXplXG4gICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG4gICAgICBhLml1c2hybihzaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogcSB8fCBudWxsLFxuICAgICAgbW9kOiBhXG4gICAgfTtcbiAgfTtcblxuICAvLyBOT1RFOiAxKSBgbW9kZWAgY2FuIGJlIHNldCB0byBgbW9kYCB0byByZXF1ZXN0IG1vZCBvbmx5LFxuICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cbiAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuICAvLyAgICAgICAyKSBgcG9zaXRpdmVgIGlzIHRydWUgaWYgdW5zaWduZWQgbW9kIGlzIHJlcXVlc3RlZFxuICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG4gICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IG5ldyBCTigwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGl2LCBtb2QsIHJlcztcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IHJlcy5tb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaXN1YihudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogcmVzLmRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cbiAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiB0aGlzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFZlcnkgc2hvcnQgcmVkdWN0aW9uXG4gICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG4gIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCBmYWxzZSkubW9kO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcbiAgfTtcblxuICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuICBCTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZCAobnVtKSB7XG4gICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG4gICAgaWYgKGRtLm1vZC5pc1plcm8oKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG4gICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG4gICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gICAgLy8gUm91bmQgZG93blxuICAgIGlmIChjbXAgPCAwIHx8IHIyID09PSAxICYmIGNtcCA9PT0gMCkgcmV0dXJuIGRtLmRpdjtcblxuICAgIC8vIFJvdW5kIHVwXG4gICAgcmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcbiAgICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuICAgICAgY2FycnkgPSB3ICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgeCA9IHRoaXM7XG4gICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgeCA9IHgudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBBICogeCArIEIgKiB5ID0geFxuICAgIHZhciBBID0gbmV3IEJOKDEpO1xuICAgIHZhciBCID0gbmV3IEJOKDApO1xuXG4gICAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgICB2YXIgRCA9IG5ldyBCTigxKTtcblxuICAgIHZhciBnID0gMDtcblxuICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICAgIHguaXVzaHJuKDEpO1xuICAgICAgeS5pdXNocm4oMSk7XG4gICAgICArK2c7XG4gICAgfVxuXG4gICAgdmFyIHlwID0geS5jbG9uZSgpO1xuICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuICAgIHdoaWxlICgheC5pc1plcm8oKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB4Lml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgICAgQS5pYWRkKHlwKTtcbiAgICAgICAgICAgIEIuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQS5pdXNocm4oMSk7XG4gICAgICAgICAgQi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICB5Lml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuICAgICAgICAgICAgQy5pYWRkKHlwKTtcbiAgICAgICAgICAgIEQuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgICAgRC5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgICAgeC5pc3ViKHkpO1xuICAgICAgICBBLmlzdWIoQyk7XG4gICAgICAgIEIuaXN1YihEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkuaXN1Yih4KTtcbiAgICAgICAgQy5pc3ViKEEpO1xuICAgICAgICBELmlzdWIoQik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IEMsXG4gICAgICBiOiBELFxuICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4gIC8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGIgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgYSA9IGEudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG4gICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBhLml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDEuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgYi5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgICBhLmlzdWIoYik7XG4gICAgICAgIHgxLmlzdWIoeDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi5pc3ViKGEpO1xuICAgICAgICB4Mi5pc3ViKHgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmIChhLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIHJlcyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB4MjtcbiAgICB9XG5cbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICBiLm5lZ2F0aXZlID0gMDtcblxuICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgICBhLml1c2hybigxKTtcbiAgICAgIGIuaXVzaHJuKDEpO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgICAgYi5pdXNocm4oMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gYS5jbXAoYik7XG4gICAgICBpZiAociA8IDApIHtcbiAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0O1xuICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYS5pc3ViKGIpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcbiAgfTtcblxuICAvLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcbiAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICB9O1xuXG4gIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cbiAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xuICB9O1xuXG4gIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcbiAgQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcbiAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG4gICAgdmFyIGNhcnJ5ID0gcTtcbiAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB3ICs9IGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcbiAgICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG4gICAgdGhpcy5zdHJpcCgpO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbnVtID0gLW51bTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4gIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG4gIC8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbiAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcblxuICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuICBCTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAgKG51bSkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHJldHVybiAtMTtcblxuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG4gICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG4gICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmVzID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24gZ3RlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24gbHRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gbHRlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbiBlcW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG4gIH07XG5cbiAgLy9cbiAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbiAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG4gIC8vXG4gIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuICAgIHRoaXMucmVkID0gY3R4O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNobCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICB9O1xuXG4gIC8vIFNxdWFyZSByb290IG92ZXIgcFxuICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcbiAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG4gIH07XG5cbiAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cbiAgdmFyIHByaW1lcyA9IHtcbiAgICBrMjU2OiBudWxsLFxuICAgIHAyMjQ6IG51bGwsXG4gICAgcDE5MjogbnVsbCxcbiAgICBwMjU1MTk6IG51bGxcbiAgfTtcblxuICAvLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbiAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG4gICAgLy8gUCA9IDIgXiBOIC0gS1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gICAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gIH1cblxuICBNUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wICgpIHtcbiAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcbiAgICByZXR1cm4gdG1wO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuICAgIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcbiAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG4gICAgdmFyIHIgPSBudW07XG4gICAgdmFyIHJsZW47XG5cbiAgICBkbyB7XG4gICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByLndvcmRzWzBdID0gMDtcbiAgICAgIHIubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIHIuaXN1Yih0aGlzLnApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoci5zdHJpcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHIgaXMgQk4gdjQgaW5zdGFuY2VcbiAgICAgICAgci5zdHJpcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gciBpcyBCTiB2NSBpbnN0YW5jZVxuICAgICAgICByLl9zdHJpcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dCkge1xuICAgIGlucHV0Lml1c2hybih0aGlzLm4sIDAsIG91dCk7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICByZXR1cm4gbnVtLmltdWwodGhpcy5rKTtcbiAgfTtcblxuICBmdW5jdGlvbiBLMjU2ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnazI1NicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcbiAgfVxuICBpbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuXG4gIEsyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXRwdXQpIHtcbiAgICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuICAgIHZhciBtYXNrID0gMHgzZmZmZmY7XG5cbiAgICB2YXIgb3V0TGVuID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCA5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKSB7XG4gICAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcbiAgICB9XG4gICAgb3V0cHV0Lmxlbmd0aCA9IG91dExlbjtcblxuICAgIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuICAgICAgaW5wdXQud29yZHNbMF0gPSAwO1xuICAgICAgaW5wdXQubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCBieSA5IGxpbWJzXG4gICAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcbiAgICBvdXRwdXQud29yZHNbb3V0cHV0Lmxlbmd0aCsrXSA9IHByZXYgJiBtYXNrO1xuXG4gICAgZm9yIChpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHQgPSBpbnB1dC53b3Jkc1tpXSB8IDA7XG4gICAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gKChuZXh0ICYgbWFzaykgPDwgNCkgfCAocHJldiA+Pj4gMjIpO1xuICAgICAgcHJldiA9IG5leHQ7XG4gICAgfVxuICAgIHByZXYgPj4+PSAyMjtcbiAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldjtcbiAgICBpZiAocHJldiA9PT0gMCAmJiBpbnB1dC5sZW5ndGggPiAxMCkge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gOTtcbiAgICB9XG4gIH07XG5cbiAgSzI1Ni5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTAwMDAwM2QxID0gWyAweDQwLCAweDNkMSBdXG4gICAgbnVtLndvcmRzW251bS5sZW5ndGhdID0gMDtcbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aCArIDFdID0gMDtcbiAgICBudW0ubGVuZ3RoICs9IDI7XG5cbiAgICAvLyBib3VuZGVkIGF0OiAweDQwICogMHgzZmZmZmZmICsgMHgzZDAgPSAweDEwMDAwMDM5MFxuICAgIHZhciBsbyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gbnVtLndvcmRzW2ldIHwgMDtcbiAgICAgIGxvICs9IHcgKiAweDNkMTtcbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgbG8gPSB3ICogMHg0MCArICgobG8gLyAweDQwMDAwMDApIHwgMCk7XG4gICAgfVxuXG4gICAgLy8gRmFzdCBsZW5ndGggcmVkdWN0aW9uXG4gICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICBmdW5jdGlvbiBQMjI0ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDIyNCcsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnKTtcbiAgfVxuICBpbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAxOTIgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMTkyJyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicpO1xuICB9XG4gIGluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDI1NTE5ICgpIHtcbiAgICAvLyAyIF4gMjU1IC0gMTlcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnMjU1MTknLFxuICAgICAgJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnKTtcbiAgfVxuICBpbmhlcml0cyhQMjU1MTksIE1QcmltZSk7XG5cbiAgUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxM1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoaSA9IChudW0ud29yZHNbaV0gfCAwKSAqIDB4MTMgKyBjYXJyeTtcbiAgICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuICAgICAgaGkgPj4+PSAyNjtcblxuICAgICAgbnVtLndvcmRzW2ldID0gbG87XG4gICAgICBjYXJyeSA9IGhpO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG4gIEJOLl9wcmltZSA9IGZ1bmN0aW9uIHByaW1lIChuYW1lKSB7XG4gICAgLy8gQ2FjaGVkIHZlcnNpb24gb2YgcHJpbWVcbiAgICBpZiAocHJpbWVzW25hbWVdKSByZXR1cm4gcHJpbWVzW25hbWVdO1xuXG4gICAgdmFyIHByaW1lO1xuICAgIGlmIChuYW1lID09PSAnazI1NicpIHtcbiAgICAgIHByaW1lID0gbmV3IEsyNTYoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjI0Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AxOTInKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMTkyKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDI1NTE5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG4gICAgcmV0dXJuIHByaW1lO1xuICB9O1xuXG4gIC8vXG4gIC8vIEJhc2UgcmVkdWN0aW9uIGVuZ2luZVxuICAvL1xuICBmdW5jdGlvbiBSZWQgKG0pIHtcbiAgICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcHJpbWUgPSBCTi5fcHJpbWUobSk7XG4gICAgICB0aGlzLm0gPSBwcmltZS5wO1xuICAgICAgdGhpcy5wcmltZSA9IHByaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobS5ndG4oMSksICdtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcbiAgICAgIHRoaXMubSA9IG07XG4gICAgICB0aGlzLnByaW1lID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkxID0gZnVuY3Rpb24gX3ZlcmlmeTEgKGEpIHtcbiAgICBhc3NlcnQoYS5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkLCAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbiBfdmVyaWZ5MiAoYSwgYikge1xuICAgIGFzc2VydCgoYS5uZWdhdGl2ZSB8IGIubmVnYXRpdmUpID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQgJiYgYS5yZWQgPT09IGIucmVkLFxuICAgICAgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kIChhKSB7XG4gICAgaWYgKHRoaXMucHJpbWUpIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICAgIHJldHVybiBhLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tLnN1YihhKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5zdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwgKGEsIG51bSkge1xuICAgIHRoaXMuX3ZlcmlmeTEoYSk7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLmltdWwoYSwgYS5jbG9uZSgpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLm11bChhLCBhKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0IChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcbiAgICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG4gICAgLy8gRmFzdCBjYXNlXG4gICAgaWYgKG1vZDMgPT09IDMpIHtcbiAgICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXVzaHJuKDIpO1xuICAgICAgcmV0dXJuIHRoaXMucG93KGEsIHBvdyk7XG4gICAgfVxuXG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuICAgIC8vXG4gICAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcbiAgICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuICAgIHZhciBzID0gMDtcbiAgICB3aGlsZSAoIXEuaXNaZXJvKCkgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgICAgcysrO1xuICAgICAgcS5pdXNocm4oMSk7XG4gICAgfVxuICAgIGFzc2VydCghcS5pc1plcm8oKSk7XG5cbiAgICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG4gICAgLy8gRmluZCBxdWFkcmF0aWMgbm9uLXJlc2lkdWVcbiAgICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cbiAgICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLml1c2hybigxKTtcbiAgICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICB6ID0gbmV3IEJOKDIgKiB6ICogeikudG9SZWQodGhpcyk7XG5cbiAgICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKSB7XG4gICAgICB6LnJlZElBZGQobk9uZSk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcbiAgICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pdXNocm4oMSkpO1xuICAgIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG4gICAgdmFyIG0gPSBzO1xuICAgIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG4gICAgICB2YXIgdG1wID0gdDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKykge1xuICAgICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoaSA8IG0pO1xuICAgICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4oMSkuaXVzaGxuKG0gLSBpIC0gMSkpO1xuXG4gICAgICByID0gci5yZWRNdWwoYik7XG4gICAgICBjID0gYi5yZWRTcXIoKTtcbiAgICAgIHQgPSB0LnJlZE11bChjKTtcbiAgICAgIG0gPSBpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgICBpZiAoaW52Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpbnYubmVnYXRpdmUgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludik7XG4gICAgfVxuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChhLCBudW0pIHtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIGlmIChudW0uY21wbigxKSA9PT0gMCkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciB3aW5kb3dTaXplID0gNDtcbiAgICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG4gICAgd25kWzBdID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHduZFsxXSA9IGE7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCB3bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHduZFtpXSA9IHRoaXMubXVsKHduZFtpIC0gMV0sIGEpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB3bmRbMF07XG4gICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgIHZhciBjdXJyZW50TGVuID0gMDtcbiAgICB2YXIgc3RhcnQgPSBudW0uYml0TGVuZ3RoKCkgJSAyNjtcbiAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgZm9yIChpID0gbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IG51bS53b3Jkc1tpXTtcbiAgICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBiaXQgPSAod29yZCA+PiBqKSAmIDE7XG4gICAgICAgIGlmIChyZXMgIT09IHduZFswXSkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuc3FyKHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0ID09PSAwICYmIGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPDw9IDE7XG4gICAgICAgIGN1cnJlbnQgfD0gYml0O1xuICAgICAgICBjdXJyZW50TGVuKys7XG4gICAgICAgIGlmIChjdXJyZW50TGVuICE9PSB3aW5kb3dTaXplICYmIChpICE9PSAwIHx8IGogIT09IDApKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIHduZFtjdXJyZW50XSk7XG4gICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgdmFyIHIgPSBudW0udW1vZCh0aGlzLm0pO1xuXG4gICAgcmV0dXJuIHIgPT09IG51bSA/IHIuY2xvbmUoKSA6IHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG4gICAgcmVzLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvL1xuICAvLyBNb250Z29tZXJ5IG1ldGhvZCBlbmdpbmVcbiAgLy9cblxuICBCTi5tb250ID0gZnVuY3Rpb24gbW9udCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBNb250KG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTW9udCAobSkge1xuICAgIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG4gICAgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICBpZiAodGhpcy5zaGlmdCAlIDI2ICE9PSAwKSB7XG4gICAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XG4gICAgfVxuXG4gICAgdGhpcy5yID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLnNoaWZ0KTtcbiAgICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG4gICAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG4gICAgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO1xuICAgIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMucik7XG4gICAgdGhpcy5taW52ID0gdGhpcy5yLnN1Yih0aGlzLm1pbnYpO1xuICB9XG4gIGluaGVyaXRzKE1vbnQsIFJlZCk7XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgICByLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSB7XG4gICAgICBhLndvcmRzWzBdID0gMDtcbiAgICAgIGEubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHZhciB0ID0gYS5pbXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuXG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIHZhciB0ID0gYS5tdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcbiAgICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcbn0pKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgdGhpcyk7XG4iLCJ2YXIgcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByYW5kKGxlbikge1xuICBpZiAoIXIpXG4gICAgciA9IG5ldyBSYW5kKG51bGwpO1xuXG4gIHJldHVybiByLmdlbmVyYXRlKGxlbik7XG59O1xuXG5mdW5jdGlvbiBSYW5kKHJhbmQpIHtcbiAgdGhpcy5yYW5kID0gcmFuZDtcbn1cbm1vZHVsZS5leHBvcnRzLlJhbmQgPSBSYW5kO1xuXG5SYW5kLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKGxlbikge1xuICByZXR1cm4gdGhpcy5fcmFuZChsZW4pO1xufTtcblxuLy8gRW11bGF0ZSBjcnlwdG8gQVBJIHVzaW5nIHJhbmR5XG5SYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgaWYgKHRoaXMucmFuZC5nZXRCeXRlcylcbiAgICByZXR1cm4gdGhpcy5yYW5kLmdldEJ5dGVzKG4pO1xuXG4gIHZhciByZXMgPSBuZXcgVWludDhBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspXG4gICAgcmVzW2ldID0gdGhpcy5yYW5kLmdldEJ5dGUoKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbmlmICh0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcpIHtcbiAgaWYgKHNlbGYuY3J5cHRvICYmIHNlbGYuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIE1vZGVybiBicm93c2Vyc1xuICAgIFJhbmQucHJvdG90eXBlLl9yYW5kID0gZnVuY3Rpb24gX3JhbmQobikge1xuICAgICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgc2VsZi5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoc2VsZi5tc0NyeXB0byAmJiBzZWxmLm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIElFXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbiBfcmFuZChuKSB7XG4gICAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgICBzZWxmLm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9O1xuXG4gIC8vIFNhZmFyaSdzIFdlYldvcmtlcnMgZG8gbm90IGhhdmUgYGNyeXB0b2BcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0Jykge1xuICAgIC8vIE9sZCBqdW5rXG4gICAgUmFuZC5wcm90b3R5cGUuX3JhbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgIH07XG4gIH1cbn0gZWxzZSB7XG4gIC8vIE5vZGUuanMgb3IgV2ViIHdvcmtlciB3aXRoIG5vIGNyeXB0byBzdXBwb3J0XG4gIHRyeSB7XG4gICAgdmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAgIGlmICh0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBSYW5kLnByb3RvdHlwZS5fcmFuZCA9IGZ1bmN0aW9uIF9yYW5kKG4pIHtcbiAgICAgIHJldHVybiBjcnlwdG8ucmFuZG9tQnl0ZXMobik7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdzdHJlYW0nKS5UcmFuc2Zvcm1cbnZhciBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIENpcGhlckJhc2UgKGhhc2hNb2RlKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG4gIHRoaXMuaGFzaE1vZGUgPSB0eXBlb2YgaGFzaE1vZGUgPT09ICdzdHJpbmcnXG4gIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgdGhpc1toYXNoTW9kZV0gPSB0aGlzLl9maW5hbE9yRGlnZXN0XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maW5hbCA9IHRoaXMuX2ZpbmFsT3JEaWdlc3RcbiAgfVxuICBpZiAodGhpcy5fZmluYWwpIHtcbiAgICB0aGlzLl9fZmluYWwgPSB0aGlzLl9maW5hbFxuICAgIHRoaXMuX2ZpbmFsID0gbnVsbFxuICB9XG4gIHRoaXMuX2RlY29kZXIgPSBudWxsXG4gIHRoaXMuX2VuY29kaW5nID0gbnVsbFxufVxuaW5oZXJpdHMoQ2lwaGVyQmFzZSwgVHJhbnNmb3JtKVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgaW5wdXRFbmMsIG91dHB1dEVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGlucHV0RW5jKVxuICB9XG5cbiAgdmFyIG91dERhdGEgPSB0aGlzLl91cGRhdGUoZGF0YSlcbiAgaWYgKHRoaXMuaGFzaE1vZGUpIHJldHVybiB0aGlzXG5cbiAgaWYgKG91dHB1dEVuYykge1xuICAgIG91dERhdGEgPSB0aGlzLl90b1N0cmluZyhvdXREYXRhLCBvdXRwdXRFbmMpXG4gIH1cblxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRvUGFkZGluZyA9IGZ1bmN0aW9uICgpIHt9XG5DaXBoZXJCYXNlLnByb3RvdHlwZS5nZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBnZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBdXRoVGFnID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3RyeWluZyB0byBzZXQgYXV0aCB0YWcgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5zZXRBQUQgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcigndHJ5aW5nIHRvIHNldCBhYWQgaW4gdW5zdXBwb3J0ZWQgc3RhdGUnKVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGRhdGEsIF8sIG5leHQpIHtcbiAgdmFyIGVyclxuICB0cnkge1xuICAgIGlmICh0aGlzLmhhc2hNb2RlKSB7XG4gICAgICB0aGlzLl91cGRhdGUoZGF0YSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wdXNoKHRoaXMuX3VwZGF0ZShkYXRhKSlcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH0gZmluYWxseSB7XG4gICAgbmV4dChlcnIpXG4gIH1cbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChkb25lKSB7XG4gIHZhciBlcnJcbiAgdHJ5IHtcbiAgICB0aGlzLnB1c2godGhpcy5fX2ZpbmFsKCkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnIgPSBlXG4gIH1cblxuICBkb25lKGVycilcbn1cbkNpcGhlckJhc2UucHJvdG90eXBlLl9maW5hbE9yRGlnZXN0ID0gZnVuY3Rpb24gKG91dHB1dEVuYykge1xuICB2YXIgb3V0RGF0YSA9IHRoaXMuX19maW5hbCgpIHx8IEJ1ZmZlci5hbGxvYygwKVxuICBpZiAob3V0cHV0RW5jKSB7XG4gICAgb3V0RGF0YSA9IHRoaXMuX3RvU3RyaW5nKG91dERhdGEsIG91dHB1dEVuYywgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb3V0RGF0YVxufVxuXG5DaXBoZXJCYXNlLnByb3RvdHlwZS5fdG9TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGVuYywgZmluKSB7XG4gIGlmICghdGhpcy5fZGVjb2Rlcikge1xuICAgIHRoaXMuX2RlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpXG4gICAgdGhpcy5fZW5jb2RpbmcgPSBlbmNcbiAgfVxuXG4gIGlmICh0aGlzLl9lbmNvZGluZyAhPT0gZW5jKSB0aHJvdyBuZXcgRXJyb3IoJ2NhblxcJ3Qgc3dpdGNoIGVuY29kaW5ncycpXG5cbiAgdmFyIG91dCA9IHRoaXMuX2RlY29kZXIud3JpdGUodmFsdWUpXG4gIGlmIChmaW4pIHtcbiAgICBvdXQgKz0gdGhpcy5fZGVjb2Rlci5lbmQoKVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENpcGhlckJhc2VcbiIsIid1c2Ugc3RyaWN0J1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIE1ENSA9IHJlcXVpcmUoJ21kNS5qcycpXG52YXIgUklQRU1EMTYwID0gcmVxdWlyZSgncmlwZW1kMTYwJylcbnZhciBzaGEgPSByZXF1aXJlKCdzaGEuanMnKVxudmFyIEJhc2UgPSByZXF1aXJlKCdjaXBoZXItYmFzZScpXG5cbmZ1bmN0aW9uIEhhc2ggKGhhc2gpIHtcbiAgQmFzZS5jYWxsKHRoaXMsICdkaWdlc3QnKVxuXG4gIHRoaXMuX2hhc2ggPSBoYXNoXG59XG5cbmluaGVyaXRzKEhhc2gsIEJhc2UpXG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLl9oYXNoLnVwZGF0ZShkYXRhKVxufVxuXG5IYXNoLnByb3RvdHlwZS5fZmluYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNoLmRpZ2VzdCgpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlSGFzaCAoYWxnKSB7XG4gIGFsZyA9IGFsZy50b0xvd2VyQ2FzZSgpXG4gIGlmIChhbGcgPT09ICdtZDUnKSByZXR1cm4gbmV3IE1ENSgpXG4gIGlmIChhbGcgPT09ICdybWQxNjAnIHx8IGFsZyA9PT0gJ3JpcGVtZDE2MCcpIHJldHVybiBuZXcgUklQRU1EMTYwKClcblxuICByZXR1cm4gbmV3IEhhc2goc2hhKGFsZykpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbGxpcHRpYyA9IGV4cG9ydHM7XG5cbmVsbGlwdGljLnZlcnNpb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuZWxsaXB0aWMudXRpbHMgPSByZXF1aXJlKCcuL2VsbGlwdGljL3V0aWxzJyk7XG5lbGxpcHRpYy5yYW5kID0gcmVxdWlyZSgnYnJvcmFuZCcpO1xuZWxsaXB0aWMuY3VydmUgPSByZXF1aXJlKCcuL2VsbGlwdGljL2N1cnZlJyk7XG5lbGxpcHRpYy5jdXJ2ZXMgPSByZXF1aXJlKCcuL2VsbGlwdGljL2N1cnZlcycpO1xuXG4vLyBQcm90b2NvbHNcbmVsbGlwdGljLmVjID0gcmVxdWlyZSgnLi9lbGxpcHRpYy9lYycpO1xuZWxsaXB0aWMuZWRkc2EgPSByZXF1aXJlKCcuL2VsbGlwdGljL2VkZHNhJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGdldE5BRiA9IHV0aWxzLmdldE5BRjtcbnZhciBnZXRKU0YgPSB1dGlscy5nZXRKU0Y7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBCYXNlQ3VydmUodHlwZSwgY29uZikge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnAgPSBuZXcgQk4oY29uZi5wLCAxNik7XG5cbiAgLy8gVXNlIE1vbnRnb21lcnksIHdoZW4gdGhlcmUgaXMgbm8gZmFzdCByZWR1Y3Rpb24gZm9yIHRoZSBwcmltZVxuICB0aGlzLnJlZCA9IGNvbmYucHJpbWUgPyBCTi5yZWQoY29uZi5wcmltZSkgOiBCTi5tb250KHRoaXMucCk7XG5cbiAgLy8gVXNlZnVsIGZvciBtYW55IGN1cnZlc1xuICB0aGlzLnplcm8gPSBuZXcgQk4oMCkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLm9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudHdvID0gbmV3IEJOKDIpLnRvUmVkKHRoaXMucmVkKTtcblxuICAvLyBDdXJ2ZSBjb25maWd1cmF0aW9uLCBvcHRpb25hbFxuICB0aGlzLm4gPSBjb25mLm4gJiYgbmV3IEJOKGNvbmYubiwgMTYpO1xuICB0aGlzLmcgPSBjb25mLmcgJiYgdGhpcy5wb2ludEZyb21KU09OKGNvbmYuZywgY29uZi5nUmVkKTtcblxuICAvLyBUZW1wb3JhcnkgYXJyYXlzXG4gIHRoaXMuX3duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQyID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDMgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUNCA9IG5ldyBBcnJheSg0KTtcblxuICB0aGlzLl9iaXRMZW5ndGggPSB0aGlzLm4gPyB0aGlzLm4uYml0TGVuZ3RoKCkgOiAwO1xuXG4gIC8vIEdlbmVyYWxpemVkIEdyZWcgTWF4d2VsbCdzIHRyaWNrXG4gIHZhciBhZGp1c3RDb3VudCA9IHRoaXMubiAmJiB0aGlzLnAuZGl2KHRoaXMubik7XG4gIGlmICghYWRqdXN0Q291bnQgfHwgYWRqdXN0Q291bnQuY21wbigxMDApID4gMCkge1xuICAgIHRoaXMucmVkTiA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbWF4d2VsbFRyaWNrID0gdHJ1ZTtcbiAgICB0aGlzLnJlZE4gPSB0aGlzLm4udG9SZWQodGhpcy5yZWQpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VDdXJ2ZTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fZml4ZWROYWZNdWwgPSBmdW5jdGlvbiBfZml4ZWROYWZNdWwocCwgaykge1xuICBhc3NlcnQocC5wcmVjb21wdXRlZCk7XG4gIHZhciBkb3VibGVzID0gcC5fZ2V0RG91YmxlcygpO1xuXG4gIHZhciBuYWYgPSBnZXROQUYoaywgMSwgdGhpcy5fYml0TGVuZ3RoKTtcbiAgdmFyIEkgPSAoMSA8PCAoZG91Ymxlcy5zdGVwICsgMSkpIC0gKGRvdWJsZXMuc3RlcCAlIDIgPT09IDAgPyAyIDogMSk7XG4gIEkgLz0gMztcblxuICAvLyBUcmFuc2xhdGUgaW50byBtb3JlIHdpbmRvd2VkIGZvcm1cbiAgdmFyIHJlcHIgPSBbXTtcbiAgdmFyIGo7XG4gIHZhciBuYWZXO1xuICBmb3IgKGogPSAwOyBqIDwgbmFmLmxlbmd0aDsgaiArPSBkb3VibGVzLnN0ZXApIHtcbiAgICBuYWZXID0gMDtcbiAgICBmb3IgKHZhciBsID0gaiArIGRvdWJsZXMuc3RlcCAtIDE7IGwgPj0gajsgbC0tKVxuICAgICAgbmFmVyA9IChuYWZXIDw8IDEpICsgbmFmW2xdO1xuICAgIHJlcHIucHVzaChuYWZXKTtcbiAgfVxuXG4gIHZhciBhID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciBiID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBJOyBpID4gMDsgaS0tKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IHJlcHIubGVuZ3RoOyBqKyspIHtcbiAgICAgIG5hZlcgPSByZXByW2pdO1xuICAgICAgaWYgKG5hZlcgPT09IGkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdKTtcbiAgICAgIGVsc2UgaWYgKG5hZlcgPT09IC1pKVxuICAgICAgICBiID0gYi5taXhlZEFkZChkb3VibGVzLnBvaW50c1tqXS5uZWcoKSk7XG4gICAgfVxuICAgIGEgPSBhLmFkZChiKTtcbiAgfVxuICByZXR1cm4gYS50b1AoKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWwgPSBmdW5jdGlvbiBfd25hZk11bChwLCBrKSB7XG4gIHZhciB3ID0gNDtcblxuICAvLyBQcmVjb21wdXRlIHdpbmRvd1xuICB2YXIgbmFmUG9pbnRzID0gcC5fZ2V0TkFGUG9pbnRzKHcpO1xuICB3ID0gbmFmUG9pbnRzLnduZDtcbiAgdmFyIHduZCA9IG5hZlBvaW50cy5wb2ludHM7XG5cbiAgLy8gR2V0IE5BRiBmb3JtXG4gIHZhciBuYWYgPSBnZXROQUYoaywgdywgdGhpcy5fYml0TGVuZ3RoKTtcblxuICAvLyBBZGQgYHRoaXNgKihOKzEpIGZvciBldmVyeSB3LU5BRiBpbmRleFxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAvLyBDb3VudCB6ZXJvZXNcbiAgICBmb3IgKHZhciBsID0gMDsgaSA+PSAwICYmIG5hZltpXSA9PT0gMDsgaS0tKVxuICAgICAgbCsrO1xuICAgIGlmIChpID49IDApXG4gICAgICBsKys7XG4gICAgYWNjID0gYWNjLmRibHAobCk7XG5cbiAgICBpZiAoaSA8IDApXG4gICAgICBicmVhaztcbiAgICB2YXIgeiA9IG5hZltpXTtcbiAgICBhc3NlcnQoeiAhPT0gMCk7XG4gICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpIHtcbiAgICAgIC8vIEogKy0gUFxuICAgICAgaWYgKHogPiAwKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWygteiAtIDEpID4+IDFdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSiArLSBKXG4gICAgICBpZiAoeiA+IDApXG4gICAgICAgIGFjYyA9IGFjYy5hZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuICAgICAgZWxzZVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwLnR5cGUgPT09ICdhZmZpbmUnID8gYWNjLnRvUCgpIDogYWNjO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bEFkZCA9IGZ1bmN0aW9uIF93bmFmTXVsQWRkKGRlZlcsXG4gIHBvaW50cyxcbiAgY29lZmZzLFxuICBsZW4sXG4gIGphY29iaWFuUmVzdWx0KSB7XG4gIHZhciB3bmRXaWR0aCA9IHRoaXMuX3duYWZUMTtcbiAgdmFyIHduZCA9IHRoaXMuX3duYWZUMjtcbiAgdmFyIG5hZiA9IHRoaXMuX3duYWZUMztcblxuICAvLyBGaWxsIGFsbCBhcnJheXNcbiAgdmFyIG1heCA9IDA7XG4gIHZhciBpO1xuICB2YXIgajtcbiAgdmFyIHA7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHAgPSBwb2ludHNbaV07XG4gICAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyhkZWZXKTtcbiAgICB3bmRXaWR0aFtpXSA9IG5hZlBvaW50cy53bmQ7XG4gICAgd25kW2ldID0gbmFmUG9pbnRzLnBvaW50cztcbiAgfVxuXG4gIC8vIENvbWIgc21hbGwgd2luZG93IE5BRnNcbiAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAxOyBpIC09IDIpIHtcbiAgICB2YXIgYSA9IGkgLSAxO1xuICAgIHZhciBiID0gaTtcbiAgICBpZiAod25kV2lkdGhbYV0gIT09IDEgfHwgd25kV2lkdGhbYl0gIT09IDEpIHtcbiAgICAgIG5hZlthXSA9IGdldE5BRihjb2VmZnNbYV0sIHduZFdpZHRoW2FdLCB0aGlzLl9iaXRMZW5ndGgpO1xuICAgICAgbmFmW2JdID0gZ2V0TkFGKGNvZWZmc1tiXSwgd25kV2lkdGhbYl0sIHRoaXMuX2JpdExlbmd0aCk7XG4gICAgICBtYXggPSBNYXRoLm1heChuYWZbYV0ubGVuZ3RoLCBtYXgpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2JdLmxlbmd0aCwgbWF4KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjb21iID0gW1xuICAgICAgcG9pbnRzW2FdLCAvKiAxICovXG4gICAgICBudWxsLCAvKiAzICovXG4gICAgICBudWxsLCAvKiA1ICovXG4gICAgICBwb2ludHNbYl0sIC8qIDcgKi9cbiAgICBdO1xuXG4gICAgLy8gVHJ5IHRvIGF2b2lkIFByb2plY3RpdmUgcG9pbnRzLCBpZiBwb3NzaWJsZVxuICAgIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkpID09PSAwKSB7XG4gICAgICBjb21iWzFdID0gcG9pbnRzW2FdLmFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH0gZWxzZSBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55LnJlZE5lZygpKSA9PT0gMCkge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0pO1xuICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IFtcbiAgICAgIC0zLCAvKiAtMSAtMSAqL1xuICAgICAgLTEsIC8qIC0xIDAgKi9cbiAgICAgIC01LCAvKiAtMSAxICovXG4gICAgICAtNywgLyogMCAtMSAqL1xuICAgICAgMCwgLyogMCAwICovXG4gICAgICA3LCAvKiAwIDEgKi9cbiAgICAgIDUsIC8qIDEgLTEgKi9cbiAgICAgIDEsIC8qIDEgMCAqL1xuICAgICAgMywgIC8qIDEgMSAqL1xuICAgIF07XG5cbiAgICB2YXIganNmID0gZ2V0SlNGKGNvZWZmc1thXSwgY29lZmZzW2JdKTtcbiAgICBtYXggPSBNYXRoLm1heChqc2ZbMF0ubGVuZ3RoLCBtYXgpO1xuICAgIG5hZlthXSA9IG5ldyBBcnJheShtYXgpO1xuICAgIG5hZltiXSA9IG5ldyBBcnJheShtYXgpO1xuICAgIGZvciAoaiA9IDA7IGogPCBtYXg7IGorKykge1xuICAgICAgdmFyIGphID0ganNmWzBdW2pdIHwgMDtcbiAgICAgIHZhciBqYiA9IGpzZlsxXVtqXSB8IDA7XG5cbiAgICAgIG5hZlthXVtqXSA9IGluZGV4WyhqYSArIDEpICogMyArIChqYiArIDEpXTtcbiAgICAgIG5hZltiXVtqXSA9IDA7XG4gICAgICB3bmRbYV0gPSBjb21iO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIHRtcCA9IHRoaXMuX3duYWZUNDtcbiAgZm9yIChpID0gbWF4OyBpID49IDA7IGktLSkge1xuICAgIHZhciBrID0gMDtcblxuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgIHZhciB6ZXJvID0gdHJ1ZTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBsZW47IGorKykge1xuICAgICAgICB0bXBbal0gPSBuYWZbal1baV0gfCAwO1xuICAgICAgICBpZiAodG1wW2pdICE9PSAwKVxuICAgICAgICAgIHplcm8gPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghemVybylcbiAgICAgICAgYnJlYWs7XG4gICAgICBrKys7XG4gICAgICBpLS07XG4gICAgfVxuICAgIGlmIChpID49IDApXG4gICAgICBrKys7XG4gICAgYWNjID0gYWNjLmRibHAoayk7XG4gICAgaWYgKGkgPCAwKVxuICAgICAgYnJlYWs7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciB6ID0gdG1wW2pdO1xuICAgICAgcDtcbiAgICAgIGlmICh6ID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGVsc2UgaWYgKHogPiAwKVxuICAgICAgICBwID0gd25kW2pdWyh6IC0gMSkgPj4gMV07XG4gICAgICBlbHNlIGlmICh6IDwgMClcbiAgICAgICAgcCA9IHduZFtqXVsoLXogLSAxKSA+PiAxXS5uZWcoKTtcblxuICAgICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG4gICAgICAgIGFjYyA9IGFjYy5taXhlZEFkZChwKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLmFkZChwKTtcbiAgICB9XG4gIH1cbiAgLy8gWmVyb2lmeSByZWZlcmVuY2VzXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICB3bmRbaV0gPSBudWxsO1xuXG4gIGlmIChqYWNvYmlhblJlc3VsdClcbiAgICByZXR1cm4gYWNjO1xuICBlbHNlXG4gICAgcmV0dXJuIGFjYy50b1AoKTtcbn07XG5cbmZ1bmN0aW9uIEJhc2VQb2ludChjdXJ2ZSwgdHlwZSkge1xuICB0aGlzLmN1cnZlID0gY3VydmU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMucHJlY29tcHV0ZWQgPSBudWxsO1xufVxuQmFzZUN1cnZlLkJhc2VQb2ludCA9IEJhc2VQb2ludDtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxKC8qb3RoZXIqLykge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS52YWxpZGF0ZSh0aGlzKTtcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuZGVjb2RlUG9pbnQgPSBmdW5jdGlvbiBkZWNvZGVQb2ludChieXRlcywgZW5jKSB7XG4gIGJ5dGVzID0gdXRpbHMudG9BcnJheShieXRlcywgZW5jKTtcblxuICB2YXIgbGVuID0gdGhpcy5wLmJ5dGVMZW5ndGgoKTtcblxuICAvLyB1bmNvbXByZXNzZWQsIGh5YnJpZC1vZGQsIGh5YnJpZC1ldmVuXG4gIGlmICgoYnl0ZXNbMF0gPT09IDB4MDQgfHwgYnl0ZXNbMF0gPT09IDB4MDYgfHwgYnl0ZXNbMF0gPT09IDB4MDcpICYmXG4gICAgICBieXRlcy5sZW5ndGggLSAxID09PSAyICogbGVuKSB7XG4gICAgaWYgKGJ5dGVzWzBdID09PSAweDA2KVxuICAgICAgYXNzZXJ0KGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMCk7XG4gICAgZWxzZSBpZiAoYnl0ZXNbMF0gPT09IDB4MDcpXG4gICAgICBhc3NlcnQoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAxKTtcblxuICAgIHZhciByZXMgPSAgdGhpcy5wb2ludChieXRlcy5zbGljZSgxLCAxICsgbGVuKSxcbiAgICAgIGJ5dGVzLnNsaWNlKDEgKyBsZW4sIDEgKyAyICogbGVuKSk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKChieXRlc1swXSA9PT0gMHgwMiB8fCBieXRlc1swXSA9PT0gMHgwMykgJiZcbiAgICAgICAgICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRGcm9tWChieXRlcy5zbGljZSgxLCAxICsgbGVuKSwgYnl0ZXNbMF0gPT09IDB4MDMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwb2ludCBmb3JtYXQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIGVuY29kZUNvbXByZXNzZWQoZW5jKSB7XG4gIHJldHVybiB0aGlzLmVuY29kZShlbmMsIHRydWUpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gX2VuY29kZShjb21wYWN0KSB7XG4gIHZhciBsZW4gPSB0aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpO1xuICB2YXIgeCA9IHRoaXMuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgbGVuKTtcblxuICBpZiAoY29tcGFjdClcbiAgICByZXR1cm4gWyB0aGlzLmdldFkoKS5pc0V2ZW4oKSA/IDB4MDIgOiAweDAzIF0uY29uY2F0KHgpO1xuXG4gIHJldHVybiBbIDB4MDQgXS5jb25jYXQoeCwgdGhpcy5nZXRZKCkudG9BcnJheSgnYmUnLCBsZW4pKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGVuYywgY29tcGFjdCkge1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMuX2VuY29kZShjb21wYWN0KSwgZW5jKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUocG93ZXIpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHByZWNvbXB1dGVkID0ge1xuICAgIGRvdWJsZXM6IG51bGwsXG4gICAgbmFmOiBudWxsLFxuICAgIGJldGE6IG51bGwsXG4gIH07XG4gIHByZWNvbXB1dGVkLm5hZiA9IHRoaXMuX2dldE5BRlBvaW50cyg4KTtcbiAgcHJlY29tcHV0ZWQuZG91YmxlcyA9IHRoaXMuX2dldERvdWJsZXMoNCwgcG93ZXIpO1xuICBwcmVjb21wdXRlZC5iZXRhID0gdGhpcy5fZ2V0QmV0YSgpO1xuICB0aGlzLnByZWNvbXB1dGVkID0gcHJlY29tcHV0ZWQ7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9oYXNEb3VibGVzID0gZnVuY3Rpb24gX2hhc0RvdWJsZXMoaykge1xuICBpZiAoIXRoaXMucHJlY29tcHV0ZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkb3VibGVzID0gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuICBpZiAoIWRvdWJsZXMpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiBkb3VibGVzLnBvaW50cy5sZW5ndGggPj0gTWF0aC5jZWlsKChrLmJpdExlbmd0aCgpICsgMSkgLyBkb3VibGVzLnN0ZXApO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0RG91YmxlcyA9IGZ1bmN0aW9uIF9nZXREb3VibGVzKHN0ZXAsIHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcylcbiAgICByZXR1cm4gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuXG4gIHZhciBkb3VibGVzID0gWyB0aGlzIF07XG4gIHZhciBhY2MgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvd2VyOyBpICs9IHN0ZXApIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN0ZXA7IGorKylcbiAgICAgIGFjYyA9IGFjYy5kYmwoKTtcbiAgICBkb3VibGVzLnB1c2goYWNjKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0ZXA6IHN0ZXAsXG4gICAgcG9pbnRzOiBkb3VibGVzLFxuICB9O1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0TkFGUG9pbnRzID0gZnVuY3Rpb24gX2dldE5BRlBvaW50cyh3bmQpIHtcbiAgaWYgKHRoaXMucHJlY29tcHV0ZWQgJiYgdGhpcy5wcmVjb21wdXRlZC5uYWYpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQubmFmO1xuXG4gIHZhciByZXMgPSBbIHRoaXMgXTtcbiAgdmFyIG1heCA9ICgxIDw8IHduZCkgLSAxO1xuICB2YXIgZGJsID0gbWF4ID09PSAxID8gbnVsbCA6IHRoaXMuZGJsKCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbWF4OyBpKyspXG4gICAgcmVzW2ldID0gcmVzW2kgLSAxXS5hZGQoZGJsKTtcbiAgcmV0dXJuIHtcbiAgICB3bmQ6IHduZCxcbiAgICBwb2ludHM6IHJlcyxcbiAgfTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKGspIHtcbiAgdmFyIHIgPSB0aGlzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKylcbiAgICByID0gci5kYmwoKTtcbiAgcmV0dXJuIHI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBFZHdhcmRzQ3VydmUoY29uZikge1xuICAvLyBOT1RFOiBJbXBvcnRhbnQgYXMgd2UgYXJlIGNyZWF0aW5nIHBvaW50IGluIEJhc2UuY2FsbCgpXG4gIHRoaXMudHdpc3RlZCA9IChjb25mLmEgfCAwKSAhPT0gMTtcbiAgdGhpcy5tT25lQSA9IHRoaXMudHdpc3RlZCAmJiAoY29uZi5hIHwgMCkgPT09IC0xO1xuICB0aGlzLmV4dGVuZGVkID0gdGhpcy5tT25lQTtcblxuICBCYXNlLmNhbGwodGhpcywgJ2Vkd2FyZHMnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudW1vZCh0aGlzLnJlZC5tKTtcbiAgdGhpcy5hID0gdGhpcy5hLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5jID0gbmV3IEJOKGNvbmYuYywgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5jMiA9IHRoaXMuYy5yZWRTcXIoKTtcbiAgdGhpcy5kID0gbmV3IEJOKGNvbmYuZCwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5kZCA9IHRoaXMuZC5yZWRBZGQodGhpcy5kKTtcblxuICBhc3NlcnQoIXRoaXMudHdpc3RlZCB8fCB0aGlzLmMuZnJvbVJlZCgpLmNtcG4oMSkgPT09IDApO1xuICB0aGlzLm9uZUMgPSAoY29uZi5jIHwgMCkgPT09IDE7XG59XG5pbmhlcml0cyhFZHdhcmRzQ3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBFZHdhcmRzQ3VydmU7XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUuX211bEEgPSBmdW5jdGlvbiBfbXVsQShudW0pIHtcbiAgaWYgKHRoaXMubU9uZUEpXG4gICAgcmV0dXJuIG51bS5yZWROZWcoKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmEucmVkTXVsKG51bSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLl9tdWxDID0gZnVuY3Rpb24gX211bEMobnVtKSB7XG4gIGlmICh0aGlzLm9uZUMpXG4gICAgcmV0dXJuIG51bTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmMucmVkTXVsKG51bSk7XG59O1xuXG4vLyBKdXN0IGZvciBjb21wYXRpYmlsaXR5IHdpdGggU2hvcnQgY3VydmVcbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUuanBvaW50ID0gZnVuY3Rpb24ganBvaW50KHgsIHksIHosIHQpIHtcbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSwgeiwgdCk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50RnJvbVggPSBmdW5jdGlvbiBwb2ludEZyb21YKHgsIG9kZCkge1xuICB4ID0gbmV3IEJOKHgsIDE2KTtcbiAgaWYgKCF4LnJlZClcbiAgICB4ID0geC50b1JlZCh0aGlzLnJlZCk7XG5cbiAgdmFyIHgyID0geC5yZWRTcXIoKTtcbiAgdmFyIHJocyA9IHRoaXMuYzIucmVkU3ViKHRoaXMuYS5yZWRNdWwoeDIpKTtcbiAgdmFyIGxocyA9IHRoaXMub25lLnJlZFN1Yih0aGlzLmMyLnJlZE11bCh0aGlzLmQpLnJlZE11bCh4MikpO1xuXG4gIHZhciB5MiA9IHJocy5yZWRNdWwobGhzLnJlZEludm0oKSk7XG4gIHZhciB5ID0geTIucmVkU3FydCgpO1xuICBpZiAoeS5yZWRTcXIoKS5yZWRTdWIoeTIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuXG4gIHZhciBpc09kZCA9IHkuZnJvbVJlZCgpLmlzT2RkKCk7XG4gIGlmIChvZGQgJiYgIWlzT2RkIHx8ICFvZGQgJiYgaXNPZGQpXG4gICAgeSA9IHkucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnBvaW50RnJvbVkgPSBmdW5jdGlvbiBwb2ludEZyb21ZKHksIG9kZCkge1xuICB5ID0gbmV3IEJOKHksIDE2KTtcbiAgaWYgKCF5LnJlZClcbiAgICB5ID0geS50b1JlZCh0aGlzLnJlZCk7XG5cbiAgLy8geF4yID0gKHleMiAtIGNeMikgLyAoY14yIGQgeV4yIC0gYSlcbiAgdmFyIHkyID0geS5yZWRTcXIoKTtcbiAgdmFyIGxocyA9IHkyLnJlZFN1Yih0aGlzLmMyKTtcbiAgdmFyIHJocyA9IHkyLnJlZE11bCh0aGlzLmQpLnJlZE11bCh0aGlzLmMyKS5yZWRTdWIodGhpcy5hKTtcbiAgdmFyIHgyID0gbGhzLnJlZE11bChyaHMucmVkSW52bSgpKTtcblxuICBpZiAoeDIuY21wKHRoaXMuemVybykgPT09IDApIHtcbiAgICBpZiAob2RkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMucG9pbnQodGhpcy56ZXJvLCB5KTtcbiAgfVxuXG4gIHZhciB4ID0geDIucmVkU3FydCgpO1xuICBpZiAoeC5yZWRTcXIoKS5yZWRTdWIoeDIpLmNtcCh0aGlzLnplcm8pICE9PSAwKVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuXG4gIGlmICh4LmZyb21SZWQoKS5pc09kZCgpICE9PSBvZGQpXG4gICAgeCA9IHgucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5FZHdhcmRzQ3VydmUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUocG9pbnQpIHtcbiAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyBDdXJ2ZTogQSAqIFheMiArIFleMiA9IENeMiAqICgxICsgRCAqIFheMiAqIFleMilcbiAgcG9pbnQubm9ybWFsaXplKCk7XG5cbiAgdmFyIHgyID0gcG9pbnQueC5yZWRTcXIoKTtcbiAgdmFyIHkyID0gcG9pbnQueS5yZWRTcXIoKTtcbiAgdmFyIGxocyA9IHgyLnJlZE11bCh0aGlzLmEpLnJlZEFkZCh5Mik7XG4gIHZhciByaHMgPSB0aGlzLmMyLnJlZE11bCh0aGlzLm9uZS5yZWRBZGQodGhpcy5kLnJlZE11bCh4MikucmVkTXVsKHkyKSkpO1xuXG4gIHJldHVybiBsaHMuY21wKHJocykgPT09IDA7XG59O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgeiwgdCkge1xuICBCYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAncHJvamVjdGl2ZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLnplcm87XG4gICAgdGhpcy55ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy50ID0gdGhpcy5jdXJ2ZS56ZXJvO1xuICAgIHRoaXMuek9uZSA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgIHRoaXMueiA9IHogPyBuZXcgQk4oeiwgMTYpIDogdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy50ID0gdCAmJiBuZXcgQk4odCwgMTYpO1xuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnkucmVkKVxuICAgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICBpZiAoIXRoaXMuei5yZWQpXG4gICAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICh0aGlzLnQgJiYgIXRoaXMudC5yZWQpXG4gICAgICB0aGlzLnQgPSB0aGlzLnQudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIHRoaXMuek9uZSA9IHRoaXMueiA9PT0gdGhpcy5jdXJ2ZS5vbmU7XG5cbiAgICAvLyBVc2UgZXh0ZW5kZWQgY29vcmRpbmF0ZXNcbiAgICBpZiAodGhpcy5jdXJ2ZS5leHRlbmRlZCAmJiAhdGhpcy50KSB7XG4gICAgICB0aGlzLnQgPSB0aGlzLngucmVkTXVsKHRoaXMueSk7XG4gICAgICBpZiAoIXRoaXMuek9uZSlcbiAgICAgICAgdGhpcy50ID0gdGhpcy50LnJlZE11bCh0aGlzLnoucmVkSW52bSgpKTtcbiAgICB9XG4gIH1cbn1cbmluaGVyaXRzKFBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cbkVkd2FyZHNDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmopO1xufTtcblxuRWR3YXJkc0N1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIHosIHQpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB5LCB6LCB0KTtcbn07XG5cblBvaW50LmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04oY3VydmUsIG9iaikge1xuICByZXR1cm4gbmV3IFBvaW50KGN1cnZlLCBvYmpbMF0sIG9ialsxXSwgb2JqWzJdKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG4gIHJldHVybiAnPEVDIFBvaW50IHg6ICcgKyB0aGlzLnguZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHk6ICcgKyB0aGlzLnkuZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArXG4gICAgICAnIHo6ICcgKyB0aGlzLnouZnJvbVJlZCgpLnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cblBvaW50LnByb3RvdHlwZS5pc0luZmluaXR5ID0gZnVuY3Rpb24gaXNJbmZpbml0eSgpIHtcbiAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcbiAgcmV0dXJuIHRoaXMueC5jbXBuKDApID09PSAwICYmXG4gICAgKHRoaXMueS5jbXAodGhpcy56KSA9PT0gMCB8fFxuICAgICh0aGlzLnpPbmUgJiYgdGhpcy55LmNtcCh0aGlzLmN1cnZlLmMpID09PSAwKSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2V4dERibCA9IGZ1bmN0aW9uIF9leHREYmwoKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgLy8gNE0gKyA0U1xuXG4gIC8vIEEgPSBYMV4yXG4gIHZhciBhID0gdGhpcy54LnJlZFNxcigpO1xuICAvLyBCID0gWTFeMlxuICB2YXIgYiA9IHRoaXMueS5yZWRTcXIoKTtcbiAgLy8gQyA9IDIgKiBaMV4yXG4gIHZhciBjID0gdGhpcy56LnJlZFNxcigpO1xuICBjID0gYy5yZWRJQWRkKGMpO1xuICAvLyBEID0gYSAqIEFcbiAgdmFyIGQgPSB0aGlzLmN1cnZlLl9tdWxBKGEpO1xuICAvLyBFID0gKFgxICsgWTEpXjIgLSBBIC0gQlxuICB2YXIgZSA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKS5yZWRJU3ViKGEpLnJlZElTdWIoYik7XG4gIC8vIEcgPSBEICsgQlxuICB2YXIgZyA9IGQucmVkQWRkKGIpO1xuICAvLyBGID0gRyAtIENcbiAgdmFyIGYgPSBnLnJlZFN1YihjKTtcbiAgLy8gSCA9IEQgLSBCXG4gIHZhciBoID0gZC5yZWRTdWIoYik7XG4gIC8vIFgzID0gRSAqIEZcbiAgdmFyIG54ID0gZS5yZWRNdWwoZik7XG4gIC8vIFkzID0gRyAqIEhcbiAgdmFyIG55ID0gZy5yZWRNdWwoaCk7XG4gIC8vIFQzID0gRSAqIEhcbiAgdmFyIG50ID0gZS5yZWRNdWwoaCk7XG4gIC8vIFozID0gRiAqIEdcbiAgdmFyIG56ID0gZi5yZWRNdWwoZyk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnosIG50KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fcHJvakRibCA9IGZ1bmN0aW9uIF9wcm9qRGJsKCkge1xuICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1wcm9qZWN0aXZlLmh0bWxcbiAgLy8gICAgICNkb3VibGluZy1kYmwtMjAwOC1iYmpscFxuICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA3LWJsXG4gIC8vIGFuZCBvdGhlcnNcbiAgLy8gR2VuZXJhbGx5IDNNICsgNFMgb3IgMk0gKyA0U1xuXG4gIC8vIEIgPSAoWDEgKyBZMSleMlxuICB2YXIgYiA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRTcXIoKTtcbiAgLy8gQyA9IFgxXjJcbiAgdmFyIGMgPSB0aGlzLngucmVkU3FyKCk7XG4gIC8vIEQgPSBZMV4yXG4gIHZhciBkID0gdGhpcy55LnJlZFNxcigpO1xuXG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIHZhciBlO1xuICB2YXIgaDtcbiAgdmFyIGo7XG4gIGlmICh0aGlzLmN1cnZlLnR3aXN0ZWQpIHtcbiAgICAvLyBFID0gYSAqIENcbiAgICBlID0gdGhpcy5jdXJ2ZS5fbXVsQShjKTtcbiAgICAvLyBGID0gRSArIERcbiAgICB2YXIgZiA9IGUucmVkQWRkKGQpO1xuICAgIGlmICh0aGlzLnpPbmUpIHtcbiAgICAgIC8vIFgzID0gKEIgLSBDIC0gRCkgKiAoRiAtIDIpXG4gICAgICBueCA9IGIucmVkU3ViKGMpLnJlZFN1YihkKS5yZWRNdWwoZi5yZWRTdWIodGhpcy5jdXJ2ZS50d28pKTtcbiAgICAgIC8vIFkzID0gRiAqIChFIC0gRClcbiAgICAgIG55ID0gZi5yZWRNdWwoZS5yZWRTdWIoZCkpO1xuICAgICAgLy8gWjMgPSBGXjIgLSAyICogRlxuICAgICAgbnogPSBmLnJlZFNxcigpLnJlZFN1YihmKS5yZWRTdWIoZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEggPSBaMV4yXG4gICAgICBoID0gdGhpcy56LnJlZFNxcigpO1xuICAgICAgLy8gSiA9IEYgLSAyICogSFxuICAgICAgaiA9IGYucmVkU3ViKGgpLnJlZElTdWIoaCk7XG4gICAgICAvLyBYMyA9IChCLUMtRCkqSlxuICAgICAgbnggPSBiLnJlZFN1YihjKS5yZWRJU3ViKGQpLnJlZE11bChqKTtcbiAgICAgIC8vIFkzID0gRiAqIChFIC0gRClcbiAgICAgIG55ID0gZi5yZWRNdWwoZS5yZWRTdWIoZCkpO1xuICAgICAgLy8gWjMgPSBGICogSlxuICAgICAgbnogPSBmLnJlZE11bChqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRSA9IEMgKyBEXG4gICAgZSA9IGMucmVkQWRkKGQpO1xuICAgIC8vIEggPSAoYyAqIFoxKV4yXG4gICAgaCA9IHRoaXMuY3VydmUuX211bEModGhpcy56KS5yZWRTcXIoKTtcbiAgICAvLyBKID0gRSAtIDIgKiBIXG4gICAgaiA9IGUucmVkU3ViKGgpLnJlZFN1YihoKTtcbiAgICAvLyBYMyA9IGMgKiAoQiAtIEUpICogSlxuICAgIG54ID0gdGhpcy5jdXJ2ZS5fbXVsQyhiLnJlZElTdWIoZSkpLnJlZE11bChqKTtcbiAgICAvLyBZMyA9IGMgKiBFICogKEMgLSBEKVxuICAgIG55ID0gdGhpcy5jdXJ2ZS5fbXVsQyhlKS5yZWRNdWwoYy5yZWRJU3ViKGQpKTtcbiAgICAvLyBaMyA9IEUgKiBKXG4gICAgbnogPSBlLnJlZE11bChqKTtcbiAgfVxuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnksIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBEb3VibGUgaW4gZXh0ZW5kZWQgY29vcmRpbmF0ZXNcbiAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQpXG4gICAgcmV0dXJuIHRoaXMuX2V4dERibCgpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuX3Byb2pEYmwoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fZXh0QWRkID0gZnVuY3Rpb24gX2V4dEFkZChwKSB7XG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbFxuICAvLyAgICAgI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2QtM1xuICAvLyA4TVxuXG4gIC8vIEEgPSAoWTEgLSBYMSkgKiAoWTIgLSBYMilcbiAgdmFyIGEgPSB0aGlzLnkucmVkU3ViKHRoaXMueCkucmVkTXVsKHAueS5yZWRTdWIocC54KSk7XG4gIC8vIEIgPSAoWTEgKyBYMSkgKiAoWTIgKyBYMilcbiAgdmFyIGIgPSB0aGlzLnkucmVkQWRkKHRoaXMueCkucmVkTXVsKHAueS5yZWRBZGQocC54KSk7XG4gIC8vIEMgPSBUMSAqIGsgKiBUMlxuICB2YXIgYyA9IHRoaXMudC5yZWRNdWwodGhpcy5jdXJ2ZS5kZCkucmVkTXVsKHAudCk7XG4gIC8vIEQgPSBaMSAqIDIgKiBaMlxuICB2YXIgZCA9IHRoaXMuei5yZWRNdWwocC56LnJlZEFkZChwLnopKTtcbiAgLy8gRSA9IEIgLSBBXG4gIHZhciBlID0gYi5yZWRTdWIoYSk7XG4gIC8vIEYgPSBEIC0gQ1xuICB2YXIgZiA9IGQucmVkU3ViKGMpO1xuICAvLyBHID0gRCArIENcbiAgdmFyIGcgPSBkLnJlZEFkZChjKTtcbiAgLy8gSCA9IEIgKyBBXG4gIHZhciBoID0gYi5yZWRBZGQoYSk7XG4gIC8vIFgzID0gRSAqIEZcbiAgdmFyIG54ID0gZS5yZWRNdWwoZik7XG4gIC8vIFkzID0gRyAqIEhcbiAgdmFyIG55ID0gZy5yZWRNdWwoaCk7XG4gIC8vIFQzID0gRSAqIEhcbiAgdmFyIG50ID0gZS5yZWRNdWwoaCk7XG4gIC8vIFozID0gRiAqIEdcbiAgdmFyIG56ID0gZi5yZWRNdWwoZyk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSwgbnosIG50KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5fcHJvakFkZCA9IGZ1bmN0aW9uIF9wcm9qQWRkKHApIHtcbiAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtcHJvamVjdGl2ZS5odG1sXG4gIC8vICAgICAjYWRkaXRpb24tYWRkLTIwMDgtYmJqbHBcbiAgLy8gICAgICNhZGRpdGlvbi1hZGQtMjAwNy1ibFxuICAvLyAxME0gKyAxU1xuXG4gIC8vIEEgPSBaMSAqIFoyXG4gIHZhciBhID0gdGhpcy56LnJlZE11bChwLnopO1xuICAvLyBCID0gQV4yXG4gIHZhciBiID0gYS5yZWRTcXIoKTtcbiAgLy8gQyA9IFgxICogWDJcbiAgdmFyIGMgPSB0aGlzLngucmVkTXVsKHAueCk7XG4gIC8vIEQgPSBZMSAqIFkyXG4gIHZhciBkID0gdGhpcy55LnJlZE11bChwLnkpO1xuICAvLyBFID0gZCAqIEMgKiBEXG4gIHZhciBlID0gdGhpcy5jdXJ2ZS5kLnJlZE11bChjKS5yZWRNdWwoZCk7XG4gIC8vIEYgPSBCIC0gRVxuICB2YXIgZiA9IGIucmVkU3ViKGUpO1xuICAvLyBHID0gQiArIEVcbiAgdmFyIGcgPSBiLnJlZEFkZChlKTtcbiAgLy8gWDMgPSBBICogRiAqICgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBDIC0gRClcbiAgdmFyIHRtcCA9IHRoaXMueC5yZWRBZGQodGhpcy55KS5yZWRNdWwocC54LnJlZEFkZChwLnkpKS5yZWRJU3ViKGMpLnJlZElTdWIoZCk7XG4gIHZhciBueCA9IGEucmVkTXVsKGYpLnJlZE11bCh0bXApO1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgaWYgKHRoaXMuY3VydmUudHdpc3RlZCkge1xuICAgIC8vIFkzID0gQSAqIEcgKiAoRCAtIGEgKiBDKVxuICAgIG55ID0gYS5yZWRNdWwoZykucmVkTXVsKGQucmVkU3ViKHRoaXMuY3VydmUuX211bEEoYykpKTtcbiAgICAvLyBaMyA9IEYgKiBHXG4gICAgbnogPSBmLnJlZE11bChnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBZMyA9IEEgKiBHICogKEQgLSBDKVxuICAgIG55ID0gYS5yZWRNdWwoZykucmVkTXVsKGQucmVkU3ViKGMpKTtcbiAgICAvLyBaMyA9IGMgKiBGICogR1xuICAgIG56ID0gdGhpcy5jdXJ2ZS5fbXVsQyhmKS5yZWRNdWwoZyk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG55LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwO1xuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgaWYgKHRoaXMuY3VydmUuZXh0ZW5kZWQpXG4gICAgcmV0dXJuIHRoaXMuX2V4dEFkZChwKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9wcm9qQWRkKHApO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG4gIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBrKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcCwgazIpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgWyB0aGlzLCBwIF0sIFsgazEsIGsyIF0sIDIsIGZhbHNlKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24gam11bEFkZChrMSwgcCwgazIpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgWyB0aGlzLCBwIF0sIFsgazEsIGsyIF0sIDIsIHRydWUpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgaWYgKHRoaXMuek9uZSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBOb3JtYWxpemUgY29vcmRpbmF0ZXNcbiAgdmFyIHppID0gdGhpcy56LnJlZEludm0oKTtcbiAgdGhpcy54ID0gdGhpcy54LnJlZE11bCh6aSk7XG4gIHRoaXMueSA9IHRoaXMueS5yZWRNdWwoemkpO1xuICBpZiAodGhpcy50KVxuICAgIHRoaXMudCA9IHRoaXMudC5yZWRNdWwoemkpO1xuICB0aGlzLnogPSB0aGlzLmN1cnZlLm9uZTtcbiAgdGhpcy56T25lID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTmVnKCksXG4gICAgdGhpcy55LFxuICAgIHRoaXMueixcbiAgICB0aGlzLnQgJiYgdGhpcy50LnJlZE5lZygpKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcbiAgdGhpcy5ub3JtYWxpemUoKTtcbiAgcmV0dXJuIHRoaXMueC5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gIHRoaXMubm9ybWFsaXplKCk7XG4gIHJldHVybiB0aGlzLnkuZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMgPT09IG90aGVyIHx8XG4gICAgICAgICB0aGlzLmdldFgoKS5jbXAob3RoZXIuZ2V0WCgpKSA9PT0gMCAmJlxuICAgICAgICAgdGhpcy5nZXRZKCkuY21wKG90aGVyLmdldFkoKSkgPT09IDA7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXFYVG9QID0gZnVuY3Rpb24gZXFYVG9QKHgpIHtcbiAgdmFyIHJ4ID0geC50b1JlZCh0aGlzLmN1cnZlLnJlZCkucmVkTXVsKHRoaXMueik7XG4gIGlmICh0aGlzLnguY21wKHJ4KSA9PT0gMClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeGMgPSB4LmNsb25lKCk7XG4gIHZhciB0ID0gdGhpcy5jdXJ2ZS5yZWROLnJlZE11bCh0aGlzLnopO1xuICBmb3IgKDs7KSB7XG4gICAgeGMuaWFkZCh0aGlzLmN1cnZlLm4pO1xuICAgIGlmICh4Yy5jbXAodGhpcy5jdXJ2ZS5wKSA+PSAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcngucmVkSUFkZCh0KTtcbiAgICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gQ29tcGF0aWJpbGl0eSB3aXRoIEJhc2VDdXJ2ZVxuUG9pbnQucHJvdG90eXBlLnRvUCA9IFBvaW50LnByb3RvdHlwZS5ub3JtYWxpemU7XG5Qb2ludC5wcm90b3R5cGUubWl4ZWRBZGQgPSBQb2ludC5wcm90b3R5cGUuYWRkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmUgPSBleHBvcnRzO1xuXG5jdXJ2ZS5iYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5jdXJ2ZS5zaG9ydCA9IHJlcXVpcmUoJy4vc2hvcnQnKTtcbmN1cnZlLm1vbnQgPSByZXF1aXJlKCcuL21vbnQnKTtcbmN1cnZlLmVkd2FyZHMgPSByZXF1aXJlKCcuL2Vkd2FyZHMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5mdW5jdGlvbiBNb250Q3VydmUoY29uZikge1xuICBCYXNlLmNhbGwodGhpcywgJ21vbnQnLCBjb25mKTtcblxuICB0aGlzLmEgPSBuZXcgQk4oY29uZi5hLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmIgPSBuZXcgQk4oY29uZi5iLCAxNikudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLmk0ID0gbmV3IEJOKDQpLnRvUmVkKHRoaXMucmVkKS5yZWRJbnZtKCk7XG4gIHRoaXMudHdvID0gbmV3IEJOKDIpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5hMjQgPSB0aGlzLmk0LnJlZE11bCh0aGlzLmEucmVkQWRkKHRoaXMudHdvKSk7XG59XG5pbmhlcml0cyhNb250Q3VydmUsIEJhc2UpO1xubW9kdWxlLmV4cG9ydHMgPSBNb250Q3VydmU7XG5cbk1vbnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICB2YXIgeCA9IHBvaW50Lm5vcm1hbGl6ZSgpLng7XG4gIHZhciB4MiA9IHgucmVkU3FyKCk7XG4gIHZhciByaHMgPSB4Mi5yZWRNdWwoeCkucmVkQWRkKHgyLnJlZE11bCh0aGlzLmEpKS5yZWRBZGQoeCk7XG4gIHZhciB5ID0gcmhzLnJlZFNxcnQoKTtcblxuICByZXR1cm4geS5yZWRTcXIoKS5jbXAocmhzKSA9PT0gMDtcbn07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB6KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdwcm9qZWN0aXZlJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSB0aGlzLmN1cnZlLnplcm87XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnogPSBuZXcgQk4oeiwgMTYpO1xuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnoucmVkKVxuICAgICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcbiAgcmV0dXJuIHRoaXMucG9pbnQodXRpbHMudG9BcnJheShieXRlcywgZW5jKSwgMSk7XG59O1xuXG5Nb250Q3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeikge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHopO1xufTtcblxuTW9udEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmopIHtcbiAgcmV0dXJuIFBvaW50LmZyb21KU09OKHRoaXMsIG9iaik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUoKSB7XG4gIC8vIE5vLW9wXG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2VuY29kZSA9IGZ1bmN0aW9uIF9lbmNvZGUoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKS50b0FycmF5KCdiZScsIHRoaXMuY3VydmUucC5ieXRlTGVuZ3RoKCkpO1xufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqKSB7XG4gIHJldHVybiBuZXcgUG9pbnQoY3VydmUsIG9ialswXSwgb2JqWzFdIHx8IGN1cnZlLm9uZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcbn07XG5cblBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tbW9udGdvbS14ei5odG1sI2RvdWJsaW5nLWRibC0xOTg3LW0tM1xuICAvLyAyTSArIDJTICsgNEFcblxuICAvLyBBID0gWDEgKyBaMVxuICB2YXIgYSA9IHRoaXMueC5yZWRBZGQodGhpcy56KTtcbiAgLy8gQUEgPSBBXjJcbiAgdmFyIGFhID0gYS5yZWRTcXIoKTtcbiAgLy8gQiA9IFgxIC0gWjFcbiAgdmFyIGIgPSB0aGlzLngucmVkU3ViKHRoaXMueik7XG4gIC8vIEJCID0gQl4yXG4gIHZhciBiYiA9IGIucmVkU3FyKCk7XG4gIC8vIEMgPSBBQSAtIEJCXG4gIHZhciBjID0gYWEucmVkU3ViKGJiKTtcbiAgLy8gWDMgPSBBQSAqIEJCXG4gIHZhciBueCA9IGFhLnJlZE11bChiYik7XG4gIC8vIFozID0gQyAqIChCQiArIEEyNCAqIEMpXG4gIHZhciBueiA9IGMucmVkTXVsKGJiLnJlZEFkZCh0aGlzLmN1cnZlLmEyNC5yZWRNdWwoYykpKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobngsIG56KTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiBNb250Z29tZXJ5IGN1cnZlJyk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGlmZkFkZCA9IGZ1bmN0aW9uIGRpZmZBZGQocCwgZGlmZikge1xuICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLW1vbnRnb20teHouaHRtbCNkaWZmYWRkLWRhZGQtMTk4Ny1tLTNcbiAgLy8gNE0gKyAyUyArIDZBXG5cbiAgLy8gQSA9IFgyICsgWjJcbiAgdmFyIGEgPSB0aGlzLngucmVkQWRkKHRoaXMueik7XG4gIC8vIEIgPSBYMiAtIFoyXG4gIHZhciBiID0gdGhpcy54LnJlZFN1Yih0aGlzLnopO1xuICAvLyBDID0gWDMgKyBaM1xuICB2YXIgYyA9IHAueC5yZWRBZGQocC56KTtcbiAgLy8gRCA9IFgzIC0gWjNcbiAgdmFyIGQgPSBwLngucmVkU3ViKHAueik7XG4gIC8vIERBID0gRCAqIEFcbiAgdmFyIGRhID0gZC5yZWRNdWwoYSk7XG4gIC8vIENCID0gQyAqIEJcbiAgdmFyIGNiID0gYy5yZWRNdWwoYik7XG4gIC8vIFg1ID0gWjEgKiAoREEgKyBDQileMlxuICB2YXIgbnggPSBkaWZmLnoucmVkTXVsKGRhLnJlZEFkZChjYikucmVkU3FyKCkpO1xuICAvLyBaNSA9IFgxICogKERBIC0gQ0IpXjJcbiAgdmFyIG56ID0gZGlmZi54LnJlZE11bChkYS5yZWRJU3ViKGNiKS5yZWRTcXIoKSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgdmFyIHQgPSBrLmNsb25lKCk7XG4gIHZhciBhID0gdGhpczsgLy8gKE4gLyAyKSAqIFEgKyBRXG4gIHZhciBiID0gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTsgLy8gKE4gLyAyKSAqIFFcbiAgdmFyIGMgPSB0aGlzOyAvLyBRXG5cbiAgZm9yICh2YXIgYml0cyA9IFtdOyB0LmNtcG4oMCkgIT09IDA7IHQuaXVzaHJuKDEpKVxuICAgIGJpdHMucHVzaCh0LmFuZGxuKDEpKTtcblxuICBmb3IgKHZhciBpID0gYml0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChiaXRzW2ldID09PSAwKSB7XG4gICAgICAvLyBOICogUSArIFEgPSAoKE4gLyAyKSAqIFEgKyBRKSkgKyAoTiAvIDIpICogUVxuICAgICAgYSA9IGEuZGlmZkFkZChiLCBjKTtcbiAgICAgIC8vIE4gKiBRID0gMiAqICgoTiAvIDIpICogUSArIFEpKVxuICAgICAgYiA9IGIuZGJsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE4gKiBRID0gKChOIC8gMikgKiBRICsgUSkgKyAoKE4gLyAyKSAqIFEpXG4gICAgICBiID0gYS5kaWZmQWRkKGIsIGMpO1xuICAgICAgLy8gTiAqIFEgKyBRID0gMiAqICgoTiAvIDIpICogUSArIFEpXG4gICAgICBhID0gYS5kYmwoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGI7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZScpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmp1bWxBZGQgPSBmdW5jdGlvbiBqdW1sQWRkKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gTW9udGdvbWVyeSBjdXJ2ZScpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WCgpLmNtcChvdGhlci5nZXRYKCkpID09PSAwO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgdGhpcy54ID0gdGhpcy54LnJlZE11bCh0aGlzLnoucmVkSW52bSgpKTtcbiAgdGhpcy56ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICAvLyBOb3JtYWxpemUgY29vcmRpbmF0ZXNcbiAgdGhpcy5ub3JtYWxpemUoKTtcblxuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XG5cbnZhciBhc3NlcnQgPSB1dGlscy5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNob3J0Q3VydmUoY29uZikge1xuICBCYXNlLmNhbGwodGhpcywgJ3Nob3J0JywgY29uZik7XG5cbiAgdGhpcy5hID0gbmV3IEJOKGNvbmYuYSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy5iID0gbmV3IEJOKGNvbmYuYiwgMTYpLnRvUmVkKHRoaXMucmVkKTtcbiAgdGhpcy50aW52ID0gdGhpcy50d28ucmVkSW52bSgpO1xuXG4gIHRoaXMuemVyb0EgPSB0aGlzLmEuZnJvbVJlZCgpLmNtcG4oMCkgPT09IDA7XG4gIHRoaXMudGhyZWVBID0gdGhpcy5hLmZyb21SZWQoKS5zdWIodGhpcy5wKS5jbXBuKC0zKSA9PT0gMDtcblxuICAvLyBJZiB0aGUgY3VydmUgaXMgZW5kb21vcnBoaWMsIHByZWNhbGN1bGF0ZSBiZXRhIGFuZCBsYW1iZGFcbiAgdGhpcy5lbmRvID0gdGhpcy5fZ2V0RW5kb21vcnBoaXNtKGNvbmYpO1xuICB0aGlzLl9lbmRvV25hZlQxID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl9lbmRvV25hZlQyID0gbmV3IEFycmF5KDQpO1xufVxuaW5oZXJpdHMoU2hvcnRDdXJ2ZSwgQmFzZSk7XG5tb2R1bGUuZXhwb3J0cyA9IFNob3J0Q3VydmU7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc20gPSBmdW5jdGlvbiBfZ2V0RW5kb21vcnBoaXNtKGNvbmYpIHtcbiAgLy8gTm8gZWZmaWNpZW50IGVuZG9tb3JwaGlzbVxuICBpZiAoIXRoaXMuemVyb0EgfHwgIXRoaXMuZyB8fCAhdGhpcy5uIHx8IHRoaXMucC5tb2RuKDMpICE9PSAxKVxuICAgIHJldHVybjtcblxuICAvLyBDb21wdXRlIGJldGEgYW5kIGxhbWJkYSwgdGhhdCBsYW1iZGEgKiBQID0gKGJldGEgKiBQeDsgUHkpXG4gIHZhciBiZXRhO1xuICB2YXIgbGFtYmRhO1xuICBpZiAoY29uZi5iZXRhKSB7XG4gICAgYmV0YSA9IG5ldyBCTihjb25mLmJldGEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJldGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMucCk7XG4gICAgLy8gQ2hvb3NlIHRoZSBzbWFsbGVzdCBiZXRhXG4gICAgYmV0YSA9IGJldGFzWzBdLmNtcChiZXRhc1sxXSkgPCAwID8gYmV0YXNbMF0gOiBiZXRhc1sxXTtcbiAgICBiZXRhID0gYmV0YS50b1JlZCh0aGlzLnJlZCk7XG4gIH1cbiAgaWYgKGNvbmYubGFtYmRhKSB7XG4gICAgbGFtYmRhID0gbmV3IEJOKGNvbmYubGFtYmRhLCAxNik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hvb3NlIHRoZSBsYW1iZGEgdGhhdCBpcyBtYXRjaGluZyBzZWxlY3RlZCBiZXRhXG4gICAgdmFyIGxhbWJkYXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5uKTtcbiAgICBpZiAodGhpcy5nLm11bChsYW1iZGFzWzBdKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzFdO1xuICAgICAgYXNzZXJ0KHRoaXMuZy5tdWwobGFtYmRhKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKTtcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgYmFzaXMgdmVjdG9ycywgdXNlZCBmb3IgYmFsYW5jZWQgbGVuZ3RoLXR3byByZXByZXNlbnRhdGlvblxuICB2YXIgYmFzaXM7XG4gIGlmIChjb25mLmJhc2lzKSB7XG4gICAgYmFzaXMgPSBjb25mLmJhc2lzLm1hcChmdW5jdGlvbih2ZWMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGE6IG5ldyBCTih2ZWMuYSwgMTYpLFxuICAgICAgICBiOiBuZXcgQk4odmVjLmIsIDE2KSxcbiAgICAgIH07XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgYmFzaXMgPSB0aGlzLl9nZXRFbmRvQmFzaXMobGFtYmRhKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmV0YTogYmV0YSxcbiAgICBsYW1iZGE6IGxhbWJkYSxcbiAgICBiYXNpczogYmFzaXMsXG4gIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzID0gZnVuY3Rpb24gX2dldEVuZG9Sb290cyhudW0pIHtcbiAgLy8gRmluZCByb290cyBvZiBmb3IgeF4yICsgeCArIDEgaW4gRlxuICAvLyBSb290ID0gKC0xICstIFNxcnQoLTMpKSAvIDJcbiAgLy9cbiAgdmFyIHJlZCA9IG51bSA9PT0gdGhpcy5wID8gdGhpcy5yZWQgOiBCTi5tb250KG51bSk7XG4gIHZhciB0aW52ID0gbmV3IEJOKDIpLnRvUmVkKHJlZCkucmVkSW52bSgpO1xuICB2YXIgbnRpbnYgPSB0aW52LnJlZE5lZygpO1xuXG4gIHZhciBzID0gbmV3IEJOKDMpLnRvUmVkKHJlZCkucmVkTmVnKCkucmVkU3FydCgpLnJlZE11bCh0aW52KTtcblxuICB2YXIgbDEgPSBudGludi5yZWRBZGQocykuZnJvbVJlZCgpO1xuICB2YXIgbDIgPSBudGludi5yZWRTdWIocykuZnJvbVJlZCgpO1xuICByZXR1cm4gWyBsMSwgbDIgXTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvQmFzaXMgPSBmdW5jdGlvbiBfZ2V0RW5kb0Jhc2lzKGxhbWJkYSkge1xuICAvLyBhcHJ4U3FydCA+PSBzcXJ0KHRoaXMubilcbiAgdmFyIGFwcnhTcXJ0ID0gdGhpcy5uLnVzaHJuKE1hdGguZmxvb3IodGhpcy5uLmJpdExlbmd0aCgpIC8gMikpO1xuXG4gIC8vIDMuNzRcbiAgLy8gUnVuIEVHQ0QsIHVudGlsIHIoTCArIDEpIDwgYXByeFNxcnRcbiAgdmFyIHUgPSBsYW1iZGE7XG4gIHZhciB2ID0gdGhpcy5uLmNsb25lKCk7XG4gIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgdmFyIHkxID0gbmV3IEJOKDApO1xuICB2YXIgeDIgPSBuZXcgQk4oMCk7XG4gIHZhciB5MiA9IG5ldyBCTigxKTtcblxuICAvLyBOT1RFOiBhbGwgdmVjdG9ycyBhcmUgcm9vdHMgb2Y6IGEgKyBiICogbGFtYmRhID0gMCAobW9kIG4pXG4gIHZhciBhMDtcbiAgdmFyIGIwO1xuICAvLyBGaXJzdCB2ZWN0b3JcbiAgdmFyIGExO1xuICB2YXIgYjE7XG4gIC8vIFNlY29uZCB2ZWN0b3JcbiAgdmFyIGEyO1xuICB2YXIgYjI7XG5cbiAgdmFyIHByZXZSO1xuICB2YXIgaSA9IDA7XG4gIHZhciByO1xuICB2YXIgeDtcbiAgd2hpbGUgKHUuY21wbigwKSAhPT0gMCkge1xuICAgIHZhciBxID0gdi5kaXYodSk7XG4gICAgciA9IHYuc3ViKHEubXVsKHUpKTtcbiAgICB4ID0geDIuc3ViKHEubXVsKHgxKSk7XG4gICAgdmFyIHkgPSB5Mi5zdWIocS5tdWwoeTEpKTtcblxuICAgIGlmICghYTEgJiYgci5jbXAoYXByeFNxcnQpIDwgMCkge1xuICAgICAgYTAgPSBwcmV2Ui5uZWcoKTtcbiAgICAgIGIwID0geDE7XG4gICAgICBhMSA9IHIubmVnKCk7XG4gICAgICBiMSA9IHg7XG4gICAgfSBlbHNlIGlmIChhMSAmJiArK2kgPT09IDIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2UiA9IHI7XG5cbiAgICB2ID0gdTtcbiAgICB1ID0gcjtcbiAgICB4MiA9IHgxO1xuICAgIHgxID0geDtcbiAgICB5MiA9IHkxO1xuICAgIHkxID0geTtcbiAgfVxuICBhMiA9IHIubmVnKCk7XG4gIGIyID0geDtcblxuICB2YXIgbGVuMSA9IGExLnNxcigpLmFkZChiMS5zcXIoKSk7XG4gIHZhciBsZW4yID0gYTIuc3FyKCkuYWRkKGIyLnNxcigpKTtcbiAgaWYgKGxlbjIuY21wKGxlbjEpID49IDApIHtcbiAgICBhMiA9IGEwO1xuICAgIGIyID0gYjA7XG4gIH1cblxuICAvLyBOb3JtYWxpemUgc2lnbnNcbiAgaWYgKGExLm5lZ2F0aXZlKSB7XG4gICAgYTEgPSBhMS5uZWcoKTtcbiAgICBiMSA9IGIxLm5lZygpO1xuICB9XG4gIGlmIChhMi5uZWdhdGl2ZSkge1xuICAgIGEyID0gYTIubmVnKCk7XG4gICAgYjIgPSBiMi5uZWcoKTtcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgeyBhOiBhMSwgYjogYjEgfSxcbiAgICB7IGE6IGEyLCBiOiBiMiB9LFxuICBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9TcGxpdCA9IGZ1bmN0aW9uIF9lbmRvU3BsaXQoaykge1xuICB2YXIgYmFzaXMgPSB0aGlzLmVuZG8uYmFzaXM7XG4gIHZhciB2MSA9IGJhc2lzWzBdO1xuICB2YXIgdjIgPSBiYXNpc1sxXTtcblxuICB2YXIgYzEgPSB2Mi5iLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuICB2YXIgYzIgPSB2MS5iLm5lZygpLm11bChrKS5kaXZSb3VuZCh0aGlzLm4pO1xuXG4gIHZhciBwMSA9IGMxLm11bCh2MS5hKTtcbiAgdmFyIHAyID0gYzIubXVsKHYyLmEpO1xuICB2YXIgcTEgPSBjMS5tdWwodjEuYik7XG4gIHZhciBxMiA9IGMyLm11bCh2Mi5iKTtcblxuICAvLyBDYWxjdWxhdGUgYW5zd2VyXG4gIHZhciBrMSA9IGsuc3ViKHAxKS5zdWIocDIpO1xuICB2YXIgazIgPSBxMS5hZGQocTIpLm5lZygpO1xuICByZXR1cm4geyBrMTogazEsIGsyOiBrMiB9O1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG4gIHggPSBuZXcgQk4oeCwgMTYpO1xuICBpZiAoIXgucmVkKVxuICAgIHggPSB4LnRvUmVkKHRoaXMucmVkKTtcblxuICB2YXIgeTIgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKHgucmVkTXVsKHRoaXMuYSkpLnJlZElBZGQodGhpcy5iKTtcbiAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG4gIGlmICh5LnJlZFNxcigpLnJlZFN1Yih5MikuY21wKHRoaXMuemVybykgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50Jyk7XG5cbiAgLy8gWFhYIElzIHRoZXJlIGFueSB3YXkgdG8gdGVsbCBpZiB0aGUgbnVtYmVyIGlzIG9kZCB3aXRob3V0IGNvbnZlcnRpbmcgaXRcbiAgLy8gdG8gbm9uLXJlZCBmb3JtP1xuICB2YXIgaXNPZGQgPSB5LmZyb21SZWQoKS5pc09kZCgpO1xuICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuICAgIHkgPSB5LnJlZE5lZygpO1xuXG4gIHJldHVybiB0aGlzLnBvaW50KHgsIHkpO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZShwb2ludCkge1xuICBpZiAocG9pbnQuaW5mKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4ID0gcG9pbnQueDtcbiAgdmFyIHkgPSBwb2ludC55O1xuXG4gIHZhciBheCA9IHRoaXMuYS5yZWRNdWwoeCk7XG4gIHZhciByaHMgPSB4LnJlZFNxcigpLnJlZE11bCh4KS5yZWRJQWRkKGF4KS5yZWRJQWRkKHRoaXMuYik7XG4gIHJldHVybiB5LnJlZFNxcigpLnJlZElTdWIocmhzKS5jbXBuKDApID09PSAwO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9XbmFmTXVsQWRkID1cbiAgICBmdW5jdGlvbiBfZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIGphY29iaWFuUmVzdWx0KSB7XG4gICAgICB2YXIgbnBvaW50cyA9IHRoaXMuX2VuZG9XbmFmVDE7XG4gICAgICB2YXIgbmNvZWZmcyA9IHRoaXMuX2VuZG9XbmFmVDI7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3BsaXQgPSB0aGlzLl9lbmRvU3BsaXQoY29lZmZzW2ldKTtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciBiZXRhID0gcC5fZ2V0QmV0YSgpO1xuXG4gICAgICAgIGlmIChzcGxpdC5rMS5uZWdhdGl2ZSkge1xuICAgICAgICAgIHNwbGl0LmsxLmluZWcoKTtcbiAgICAgICAgICBwID0gcC5uZWcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0LmsyLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgc3BsaXQuazIuaW5lZygpO1xuICAgICAgICAgIGJldGEgPSBiZXRhLm5lZyh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5wb2ludHNbaSAqIDJdID0gcDtcbiAgICAgICAgbnBvaW50c1tpICogMiArIDFdID0gYmV0YTtcbiAgICAgICAgbmNvZWZmc1tpICogMl0gPSBzcGxpdC5rMTtcbiAgICAgICAgbmNvZWZmc1tpICogMiArIDFdID0gc3BsaXQuazI7XG4gICAgICB9XG4gICAgICB2YXIgcmVzID0gdGhpcy5fd25hZk11bEFkZCgxLCBucG9pbnRzLCBuY29lZmZzLCBpICogMiwgamFjb2JpYW5SZXN1bHQpO1xuXG4gICAgICAvLyBDbGVhbi11cCByZWZlcmVuY2VzIHRvIHBvaW50cyBhbmQgY29lZmZpY2llbnRzXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGkgKiAyOyBqKyspIHtcbiAgICAgICAgbnBvaW50c1tqXSA9IG51bGw7XG4gICAgICAgIG5jb2VmZnNbal0gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuXG5mdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcbiAgQmFzZS5CYXNlUG9pbnQuY2FsbCh0aGlzLCBjdXJ2ZSwgJ2FmZmluZScpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gbnVsbDtcbiAgICB0aGlzLnkgPSBudWxsO1xuICAgIHRoaXMuaW5mID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnggPSBuZXcgQk4oeCwgMTYpO1xuICAgIHRoaXMueSA9IG5ldyBCTih5LCAxNik7XG4gICAgLy8gRm9yY2UgcmVkZ29tZXJ5IHJlcHJlc2VudGF0aW9uIHdoZW4gbG9hZGluZyBmcm9tIEpTT05cbiAgICBpZiAoaXNSZWQpIHtcbiAgICAgIHRoaXMueC5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgICB0aGlzLnkuZm9yY2VSZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMueC5yZWQpXG4gICAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICAgIGlmICghdGhpcy55LnJlZClcbiAgICAgIHRoaXMueSA9IHRoaXMueS50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgdGhpcy5pbmYgPSBmYWxzZTtcbiAgfVxufVxuaW5oZXJpdHMoUG9pbnQsIEJhc2UuQmFzZVBvaW50KTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCh4LCB5LCBpc1JlZCkge1xuICByZXR1cm4gbmV3IFBvaW50KHRoaXMsIHgsIHksIGlzUmVkKTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50RnJvbUpTT04gPSBmdW5jdGlvbiBwb2ludEZyb21KU09OKG9iaiwgcmVkKSB7XG4gIHJldHVybiBQb2ludC5mcm9tSlNPTih0aGlzLCBvYmosIHJlZCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuX2dldEJldGEgPSBmdW5jdGlvbiBfZ2V0QmV0YSgpIHtcbiAgaWYgKCF0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuO1xuXG4gIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICBpZiAocHJlICYmIHByZS5iZXRhKVxuICAgIHJldHVybiBwcmUuYmV0YTtcblxuICB2YXIgYmV0YSA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LnJlZE11bCh0aGlzLmN1cnZlLmVuZG8uYmV0YSksIHRoaXMueSk7XG4gIGlmIChwcmUpIHtcbiAgICB2YXIgY3VydmUgPSB0aGlzLmN1cnZlO1xuICAgIHZhciBlbmRvTXVsID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIGN1cnZlLnBvaW50KHAueC5yZWRNdWwoY3VydmUuZW5kby5iZXRhKSwgcC55KTtcbiAgICB9O1xuICAgIHByZS5iZXRhID0gYmV0YTtcbiAgICBiZXRhLnByZWNvbXB1dGVkID0ge1xuICAgICAgYmV0YTogbnVsbCxcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKGVuZG9NdWwpLFxuICAgICAgfSxcbiAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcbiAgICAgICAgcG9pbnRzOiBwcmUuZG91Ymxlcy5wb2ludHMubWFwKGVuZG9NdWwpLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG4gIHJldHVybiBiZXRhO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBbIHRoaXMueCwgdGhpcy55IF07XG5cbiAgcmV0dXJuIFsgdGhpcy54LCB0aGlzLnksIHRoaXMucHJlY29tcHV0ZWQgJiYge1xuICAgIGRvdWJsZXM6IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcyAmJiB7XG4gICAgICBzdGVwOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMuc3RlcCxcbiAgICAgIHBvaW50czogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnBvaW50cy5zbGljZSgxKSxcbiAgICB9LFxuICAgIG5hZjogdGhpcy5wcmVjb21wdXRlZC5uYWYgJiYge1xuICAgICAgd25kOiB0aGlzLnByZWNvbXB1dGVkLm5hZi53bmQsXG4gICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQubmFmLnBvaW50cy5zbGljZSgxKSxcbiAgICB9LFxuICB9IF07XG59O1xuXG5Qb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmosIHJlZCkge1xuICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpXG4gICAgb2JqID0gSlNPTi5wYXJzZShvYmopO1xuICB2YXIgcmVzID0gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG4gIGlmICghb2JqWzJdKVxuICAgIHJldHVybiByZXM7XG5cbiAgZnVuY3Rpb24gb2JqMnBvaW50KG9iaikge1xuICAgIHJldHVybiBjdXJ2ZS5wb2ludChvYmpbMF0sIG9ialsxXSwgcmVkKTtcbiAgfVxuXG4gIHZhciBwcmUgPSBvYmpbMl07XG4gIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICBiZXRhOiBudWxsLFxuICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcbiAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5kb3VibGVzLnBvaW50cy5tYXAob2JqMnBvaW50KSksXG4gICAgfSxcbiAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgIHBvaW50czogWyByZXMgXS5jb25jYXQocHJlLm5hZi5wb2ludHMubWFwKG9iajJwb2ludCkpLFxuICAgIH0sXG4gIH07XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBQb2ludCBJbmZpbml0eT4nO1xuICByZXR1cm4gJzxFQyBQb2ludCB4OiAnICsgdGhpcy54LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB5OiAnICsgdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIHJldHVybiB0aGlzLmluZjtcbn07XG5cblBvaW50LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiBwO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gUCArIFAgPSAyUFxuICBpZiAodGhpcy5lcShwKSlcbiAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuICAvLyBQICsgKC1QKSA9IE9cbiAgaWYgKHRoaXMubmVnKCkuZXEocCkpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgLy8gUCArIFEgPSBPXG4gIGlmICh0aGlzLnguY21wKHAueCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIGMgPSB0aGlzLnkucmVkU3ViKHAueSk7XG4gIGlmIChjLmNtcG4oMCkgIT09IDApXG4gICAgYyA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIocC54KS5yZWRJbnZtKCkpO1xuICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54KS5yZWRJU3ViKHAueCk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZGJsID0gZnVuY3Rpb24gZGJsKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gMlAgPSBPXG4gIHZhciB5czEgPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIGlmICh5czEuY21wbigwKSA9PT0gMClcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuICB2YXIgeDIgPSB0aGlzLngucmVkU3FyKCk7XG4gIHZhciBkeWludiA9IHlzMS5yZWRJbnZtKCk7XG4gIHZhciBjID0geDIucmVkQWRkKHgyKS5yZWRJQWRkKHgyKS5yZWRJQWRkKGEpLnJlZE11bChkeWludik7XG5cbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueC5yZWRBZGQodGhpcy54KSk7XG4gIHZhciBueSA9IGMucmVkTXVsKHRoaXMueC5yZWRTdWIobngpKS5yZWRJU3ViKHRoaXMueSk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG54LCBueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gIHJldHVybiB0aGlzLnguZnJvbVJlZCgpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZKCkge1xuICByZXR1cm4gdGhpcy55LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaykge1xuICBrID0gbmV3IEJOKGssIDE2KTtcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB0aGlzO1xuICBlbHNlIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9maXhlZE5hZk11bCh0aGlzLCBrKTtcbiAgZWxzZSBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChbIHRoaXMgXSwgWyBrIF0pO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsQWRkID0gZnVuY3Rpb24gbXVsQWRkKGsxLCBwMiwgazIpIHtcbiAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcbiAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG4gIGlmICh0aGlzLmN1cnZlLmVuZG8pXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsQWRkKDEsIHBvaW50cywgY29lZmZzLCAyKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24gam11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcywgdHJ1ZSk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMiwgdHJ1ZSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG4gIHJldHVybiB0aGlzID09PSBwIHx8XG4gICAgICAgICB0aGlzLmluZiA9PT0gcC5pbmYgJiZcbiAgICAgICAgICAgICAodGhpcy5pbmYgfHwgdGhpcy54LmNtcChwLngpID09PSAwICYmIHRoaXMueS5jbXAocC55KSA9PT0gMCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKF9wcmVjb21wdXRlKSB7XG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gdGhpcztcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSk7XG4gIGlmIChfcHJlY29tcHV0ZSAmJiB0aGlzLnByZWNvbXB1dGVkKSB7XG4gICAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG4gICAgdmFyIG5lZ2F0ZSA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBwLm5lZygpO1xuICAgIH07XG4gICAgcmVzLnByZWNvbXB1dGVkID0ge1xuICAgICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgICAgd25kOiBwcmUubmFmLnduZCxcbiAgICAgICAgcG9pbnRzOiBwcmUubmFmLnBvaW50cy5tYXAobmVnYXRlKSxcbiAgICAgIH0sXG4gICAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChuZWdhdGUpLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9KID0gZnVuY3Rpb24gdG9KKCkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXG4gIHZhciByZXMgPSB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueSwgdGhpcy5jdXJ2ZS5vbmUpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gSlBvaW50KGN1cnZlLCB4LCB5LCB6KSB7XG4gIEJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdqYWNvYmlhbicpO1xuICBpZiAoeCA9PT0gbnVsbCAmJiB5ID09PSBudWxsICYmIHogPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcbiAgICB0aGlzLnogPSBuZXcgQk4oMCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0gbmV3IEJOKHgsIDE2KTtcbiAgICB0aGlzLnkgPSBuZXcgQk4oeSwgMTYpO1xuICAgIHRoaXMueiA9IG5ldyBCTih6LCAxNik7XG4gIH1cbiAgaWYgKCF0aGlzLngucmVkKVxuICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gIGlmICghdGhpcy55LnJlZClcbiAgICB0aGlzLnkgPSB0aGlzLnkudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMuei5yZWQpXG4gICAgdGhpcy56ID0gdGhpcy56LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblxuICB0aGlzLnpPbmUgPSB0aGlzLnogPT09IHRoaXMuY3VydmUub25lO1xufVxuaW5oZXJpdHMoSlBvaW50LCBCYXNlLkJhc2VQb2ludCk7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6KSB7XG4gIHJldHVybiBuZXcgSlBvaW50KHRoaXMsIHgsIHksIHopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50b1AgPSBmdW5jdGlvbiB0b1AoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgemludiA9IHRoaXMuei5yZWRJbnZtKCk7XG4gIHZhciB6aW52MiA9IHppbnYucmVkU3FyKCk7XG4gIHZhciBheCA9IHRoaXMueC5yZWRNdWwoemludjIpO1xuICB2YXIgYXkgPSB0aGlzLnkucmVkTXVsKHppbnYyKS5yZWRNdWwoemludik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoYXgsIGF5KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCksIHRoaXMueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAxMk0gKyA0UyArIDdBXG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54LnJlZE11bChwejIpO1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55LnJlZE11bChwejIucmVkTXVsKHAueikpO1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyLnJlZE11bCh0aGlzLnopKTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24gbWl4ZWRBZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwLnRvSigpO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gOE0gKyAzUyArIDdBXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54O1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55O1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyKS5yZWRNdWwodGhpcy56KTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKHBvdykge1xuICBpZiAocG93ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICghcG93KVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIHZhciBpO1xuICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSB8fCB0aGlzLmN1cnZlLnRocmVlQSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICBmb3IgKGkgPSAwOyBpIDwgcG93OyBpKyspXG4gICAgICByID0gci5kYmwoKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIC8vIDFNICsgMlMgKyAxQSArIE4gKiAoNFMgKyA1TSArIDhBKVxuICAvLyBOID0gMSA9PiA2TSArIDZTICsgOUFcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG4gIHZhciB0aW52ID0gdGhpcy5jdXJ2ZS50aW52O1xuXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICAvLyBSZXVzZSByZXN1bHRzXG4gIHZhciBqeWQgPSBqeS5yZWRBZGQoankpO1xuICBmb3IgKGkgPSAwOyBpIDwgcG93OyBpKyspIHtcbiAgICB2YXIgangyID0gangucmVkU3FyKCk7XG4gICAgdmFyIGp5ZDIgPSBqeWQucmVkU3FyKCk7XG4gICAgdmFyIGp5ZDQgPSBqeWQyLnJlZFNxcigpO1xuICAgIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG4gICAgdmFyIHQxID0gangucmVkTXVsKGp5ZDIpO1xuICAgIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgICB2YXIgdDIgPSB0MS5yZWRJU3ViKG54KTtcbiAgICB2YXIgZG55ID0gYy5yZWRNdWwodDIpO1xuICAgIGRueSA9IGRueS5yZWRJQWRkKGRueSkucmVkSVN1YihqeWQ0KTtcbiAgICB2YXIgbnogPSBqeWQucmVkTXVsKGp6KTtcbiAgICBpZiAoaSArIDEgPCBwb3cpXG4gICAgICBqejQgPSBqejQucmVkTXVsKGp5ZDQpO1xuXG4gICAganggPSBueDtcbiAgICBqeiA9IG56O1xuICAgIGp5ZCA9IGRueTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChqeCwganlkLnJlZE11bCh0aW52KSwganopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSlcbiAgICByZXR1cm4gdGhpcy5femVyb0RibCgpO1xuICBlbHNlIGlmICh0aGlzLmN1cnZlLnRocmVlQSlcbiAgICByZXR1cm4gdGhpcy5fdGhyZWVEYmwoKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9kYmwoKTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3plcm9EYmwgPSBmdW5jdGlvbiBfemVyb0RibCgpIHtcbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgLy8gWiA9IDFcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1tZGJsLTIwMDctYmxcbiAgICAvLyAxTSArIDVTICsgMTRBXG5cbiAgICAvLyBYWCA9IFgxXjJcbiAgICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gWVkgPSBZMV4yXG4gICAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIFlZWVkgPSBZWV4yXG4gICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgICAvLyBTID0gMiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSlcbiAgICB2YXIgcyA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gICAgcyA9IHMucmVkSUFkZChzKTtcbiAgICAvLyBNID0gMyAqIFhYICsgYTsgYSA9IDBcbiAgICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gICAgLy8gVCA9IE0gXiAyIC0gMipTXG4gICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcblxuICAgIC8vIDggKiBZWVlZXG4gICAgdmFyIHl5eXk4ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcblxuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7XG4gICAgLy8gWjMgPSAyKlkxXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA5LWxcbiAgICAvLyAyTSArIDVTICsgMTNBXG5cbiAgICAvLyBBID0gWDFeMlxuICAgIHZhciBhID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIEIgPSBZMV4yXG4gICAgdmFyIGIgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gQyA9IEJeMlxuICAgIHZhciBjID0gYi5yZWRTcXIoKTtcbiAgICAvLyBEID0gMiAqICgoWDEgKyBCKV4yIC0gQSAtIEMpXG4gICAgdmFyIGQgPSB0aGlzLngucmVkQWRkKGIpLnJlZFNxcigpLnJlZElTdWIoYSkucmVkSVN1YihjKTtcbiAgICBkID0gZC5yZWRJQWRkKGQpO1xuICAgIC8vIEUgPSAzICogQVxuICAgIHZhciBlID0gYS5yZWRBZGQoYSkucmVkSUFkZChhKTtcbiAgICAvLyBGID0gRV4yXG4gICAgdmFyIGYgPSBlLnJlZFNxcigpO1xuXG4gICAgLy8gOCAqIENcbiAgICB2YXIgYzggPSBjLnJlZElBZGQoYyk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcbiAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuXG4gICAgLy8gWDMgPSBGIC0gMiAqIERcbiAgICBueCA9IGYucmVkSVN1YihkKS5yZWRJU3ViKGQpO1xuICAgIC8vIFkzID0gRSAqIChEIC0gWDMpIC0gOCAqIENcbiAgICBueSA9IGUucmVkTXVsKGQucmVkSVN1YihueCkpLnJlZElTdWIoYzgpO1xuICAgIC8vIFozID0gMiAqIFkxICogWjFcbiAgICBueiA9IHRoaXMueS5yZWRNdWwodGhpcy56KTtcbiAgICBueiA9IG56LnJlZElBZGQobnopO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5fdGhyZWVEYmwgPSBmdW5jdGlvbiBfdGhyZWVEYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTMuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE1QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGFcbiAgICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCkucmVkSUFkZCh0aGlzLmN1cnZlLmEpO1xuICAgIC8vIFQgPSBNXjIgLSAyICogU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG4gICAgLy8gWDMgPSBUXG4gICAgbnggPSB0O1xuICAgIC8vIFkzID0gTSAqIChTIC0gVCkgLSA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMiAqIFkxXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWwjZG91YmxpbmctZGJsLTIwMDEtYlxuICAgIC8vIDNNICsgNVNcblxuICAgIC8vIGRlbHRhID0gWjFeMlxuICAgIHZhciBkZWx0YSA9IHRoaXMuei5yZWRTcXIoKTtcbiAgICAvLyBnYW1tYSA9IFkxXjJcbiAgICB2YXIgZ2FtbWEgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gYmV0YSA9IFgxICogZ2FtbWFcbiAgICB2YXIgYmV0YSA9IHRoaXMueC5yZWRNdWwoZ2FtbWEpO1xuICAgIC8vIGFscGhhID0gMyAqIChYMSAtIGRlbHRhKSAqIChYMSArIGRlbHRhKVxuICAgIHZhciBhbHBoYSA9IHRoaXMueC5yZWRTdWIoZGVsdGEpLnJlZE11bCh0aGlzLngucmVkQWRkKGRlbHRhKSk7XG4gICAgYWxwaGEgPSBhbHBoYS5yZWRBZGQoYWxwaGEpLnJlZElBZGQoYWxwaGEpO1xuICAgIC8vIFgzID0gYWxwaGFeMiAtIDggKiBiZXRhXG4gICAgdmFyIGJldGE0ID0gYmV0YS5yZWRJQWRkKGJldGEpO1xuICAgIGJldGE0ID0gYmV0YTQucmVkSUFkZChiZXRhNCk7XG4gICAgdmFyIGJldGE4ID0gYmV0YTQucmVkQWRkKGJldGE0KTtcbiAgICBueCA9IGFscGhhLnJlZFNxcigpLnJlZElTdWIoYmV0YTgpO1xuICAgIC8vIFozID0gKFkxICsgWjEpXjIgLSBnYW1tYSAtIGRlbHRhXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueikucmVkU3FyKCkucmVkSVN1YihnYW1tYSkucmVkSVN1YihkZWx0YSk7XG4gICAgLy8gWTMgPSBhbHBoYSAqICg0ICogYmV0YSAtIFgzKSAtIDggKiBnYW1tYV4yXG4gICAgdmFyIGdnYW1tYTggPSBnYW1tYS5yZWRTcXIoKTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBueSA9IGFscGhhLnJlZE11bChiZXRhNC5yZWRJU3ViKG54KSkucmVkSVN1YihnZ2FtbWE4KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX2RibCA9IGZ1bmN0aW9uIF9kYmwoKSB7XG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG4gIC8vIDRNICsgNlMgKyAxMEFcbiAgdmFyIGp4ID0gdGhpcy54O1xuICB2YXIgankgPSB0aGlzLnk7XG4gIHZhciBqeiA9IHRoaXMuejtcbiAgdmFyIGp6NCA9IGp6LnJlZFNxcigpLnJlZFNxcigpO1xuXG4gIHZhciBqeDIgPSBqeC5yZWRTcXIoKTtcbiAgdmFyIGp5MiA9IGp5LnJlZFNxcigpO1xuXG4gIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG4gIHZhciBqeGQ0ID0gangucmVkQWRkKGp4KTtcbiAganhkNCA9IGp4ZDQucmVkSUFkZChqeGQ0KTtcbiAgdmFyIHQxID0ganhkNC5yZWRNdWwoankyKTtcbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHQxLnJlZEFkZCh0MSkpO1xuICB2YXIgdDIgPSB0MS5yZWRJU3ViKG54KTtcblxuICB2YXIganlkOCA9IGp5Mi5yZWRTcXIoKTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodDIpLnJlZElTdWIoanlkOCk7XG4gIHZhciBueiA9IGp5LnJlZEFkZChqeSkucmVkTXVsKGp6KTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLnRycGwgPSBmdW5jdGlvbiB0cnBsKCkge1xuICBpZiAoIXRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCkuYWRkKHRoaXMpO1xuXG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sI3RyaXBsaW5nLXRwbC0yMDA3LWJsXG4gIC8vIDVNICsgMTBTICsgLi4uXG5cbiAgLy8gWFggPSBYMV4yXG4gIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgLy8gWVkgPSBZMV4yXG4gIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgLy8gWlogPSBaMV4yXG4gIHZhciB6eiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgLy8gWVlZWSA9IFlZXjJcbiAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgLy8gTSA9IDMgKiBYWCArIGEgKiBaWjI7IGEgPSAwXG4gIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KTtcbiAgLy8gTU0gPSBNXjJcbiAgdmFyIG1tID0gbS5yZWRTcXIoKTtcbiAgLy8gRSA9IDYgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpIC0gTU1cbiAgdmFyIGUgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICBlID0gZS5yZWRJQWRkKGUpO1xuICBlID0gZS5yZWRBZGQoZSkucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkSVN1YihtbSk7XG4gIC8vIEVFID0gRV4yXG4gIHZhciBlZSA9IGUucmVkU3FyKCk7XG4gIC8vIFQgPSAxNipZWVlZXG4gIHZhciB0ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICAvLyBVID0gKE0gKyBFKV4yIC0gTU0gLSBFRSAtIFRcbiAgdmFyIHUgPSBtLnJlZElBZGQoZSkucmVkU3FyKCkucmVkSVN1YihtbSkucmVkSVN1YihlZSkucmVkSVN1Yih0KTtcbiAgLy8gWDMgPSA0ICogKFgxICogRUUgLSA0ICogWVkgKiBVKVxuICB2YXIgeXl1NCA9IHl5LnJlZE11bCh1KTtcbiAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcbiAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcbiAgdmFyIG54ID0gdGhpcy54LnJlZE11bChlZSkucmVkSVN1Yih5eXU0KTtcbiAgbnggPSBueC5yZWRJQWRkKG54KTtcbiAgbnggPSBueC5yZWRJQWRkKG54KTtcbiAgLy8gWTMgPSA4ICogWTEgKiAoVSAqIChUIC0gVSkgLSBFICogRUUpXG4gIHZhciBueSA9IHRoaXMueS5yZWRNdWwodS5yZWRNdWwodC5yZWRJU3ViKHUpKS5yZWRJU3ViKGUucmVkTXVsKGVlKSkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICAvLyBaMyA9IChaMSArIEUpXjIgLSBaWiAtIEVFXG4gIHZhciBueiA9IHRoaXMuei5yZWRBZGQoZSkucmVkU3FyKCkucmVkSVN1Yih6eikucmVkSVN1YihlZSk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaywga2Jhc2UpIHtcbiAgayA9IG5ldyBCTihrLCBrYmFzZSk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcbiAgICByZXR1cm4gdGhpcy5lcShwLnRvSigpKTtcblxuICBpZiAodGhpcyA9PT0gcClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyB4MSAqIHoyXjIgPT0geDIgKiB6MV4yXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcbiAgaWYgKHRoaXMueC5yZWRNdWwocHoyKS5yZWRJU3ViKHAueC5yZWRNdWwoejIpKS5jbXBuKDApICE9PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyB5MSAqIHoyXjMgPT0geTIgKiB6MV4zXG4gIHZhciB6MyA9IHoyLnJlZE11bCh0aGlzLnopO1xuICB2YXIgcHozID0gcHoyLnJlZE11bChwLnopO1xuICByZXR1cm4gdGhpcy55LnJlZE11bChwejMpLnJlZElTdWIocC55LnJlZE11bCh6MykpLmNtcG4oMCkgPT09IDA7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmVxWFRvUCA9IGZ1bmN0aW9uIGVxWFRvUCh4KSB7XG4gIHZhciB6cyA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHJ4ID0geC50b1JlZCh0aGlzLmN1cnZlLnJlZCkucmVkTXVsKHpzKTtcbiAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4YyA9IHguY2xvbmUoKTtcbiAgdmFyIHQgPSB0aGlzLmN1cnZlLnJlZE4ucmVkTXVsKHpzKTtcbiAgZm9yICg7Oykge1xuICAgIHhjLmlhZGQodGhpcy5jdXJ2ZS5uKTtcbiAgICBpZiAoeGMuY21wKHRoaXMuY3VydmUucCkgPj0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJ4LnJlZElBZGQodCk7XG4gICAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbkpQb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBKUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgSlBvaW50IHg6ICcgKyB0aGlzLngudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgeTogJyArIHRoaXMueS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjdXJ2ZXMgPSBleHBvcnRzO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ2hhc2guanMnKTtcbnZhciBjdXJ2ZSA9IHJlcXVpcmUoJy4vY3VydmUnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxuZnVuY3Rpb24gUHJlc2V0Q3VydmUob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy50eXBlID09PSAnc2hvcnQnKVxuICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmUuc2hvcnQob3B0aW9ucyk7XG4gIGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2Vkd2FyZHMnKVxuICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmUuZWR3YXJkcyhvcHRpb25zKTtcbiAgZWxzZVxuICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmUubW9udChvcHRpb25zKTtcbiAgdGhpcy5nID0gdGhpcy5jdXJ2ZS5nO1xuICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaDtcblxuICBhc3NlcnQodGhpcy5nLnZhbGlkYXRlKCksICdJbnZhbGlkIGN1cnZlJyk7XG4gIGFzc2VydCh0aGlzLmcubXVsKHRoaXMubikuaXNJbmZpbml0eSgpLCAnSW52YWxpZCBjdXJ2ZSwgRypOICE9IE8nKTtcbn1cbmN1cnZlcy5QcmVzZXRDdXJ2ZSA9IFByZXNldEN1cnZlO1xuXG5mdW5jdGlvbiBkZWZpbmVDdXJ2ZShuYW1lLCBvcHRpb25zKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXMsIG5hbWUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN1cnZlID0gbmV3IFByZXNldEN1cnZlKG9wdGlvbnMpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBjdXJ2ZSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGN1cnZlO1xuICAgIH0sXG4gIH0pO1xufVxuXG5kZWZpbmVDdXJ2ZSgncDE5MicsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMTkyJyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzY0MjEwNTE5IGU1OWM4MGU3IDBmYTdlOWFiIDcyMjQzMDQ5IGZlYjhkZWVjIGMxNDZiOWIxJyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDk5ZGVmODM2IDE0NmJjOWIxIGI0ZDIyODMxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzE4OGRhODBlIGIwMzA5MGY2IDdjYmYyMGViIDQzYTE4ODAwIGY0ZmYwYWZkIDgyZmYxMDEyJyxcbiAgICAnMDcxOTJiOTUgZmZjOGRhNzggNjMxMDExZWQgNmIyNGNkZDUgNzNmOTc3YTEgMWU3OTQ4MTEnLFxuICBdLFxufSk7XG5cbmRlZmluZUN1cnZlKCdwMjI0Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ3AyMjQnLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUnLFxuICBiOiAnYjQwNTBhODUgMGMwNGIzYWIgZjU0MTMyNTYgNTA0NGIwYjcgZDdiZmQ4YmEgMjcwYjM5NDMgMjM1NWZmYjQnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZjE2YTIgZTBiOGYwM2UgMTNkZDI5NDUgNWM1YzJhM2QnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnYjcwZTBjYmQgNmJiNGJmN2YgMzIxMzkwYjkgNGEwM2MxZDMgNTZjMjExMjIgMzQzMjgwZDYgMTE1YzFkMjEnLFxuICAgICdiZDM3NjM4OCBiNWY3MjNmYiA0YzIyZGZlNiBjZDQzNzVhMCA1YTA3NDc2NCA0NGQ1ODE5OSA4NTAwN2UzNCcsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AyNTYnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnNWFjNjM1ZDggYWEzYTkzZTcgYjNlYmJkNTUgNzY5ODg2YmMgNjUxZDA2YjAgY2M1M2IwZjYgM2JjZTNjM2UgMjdkMjYwNGInLFxuICBuOiAnZmZmZmZmZmYgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgYmNlNmZhYWQgYTcxNzllODQgZjNiOWNhYzIgZmM2MzI1NTEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnNmIxN2QxZjIgZTEyYzQyNDcgZjhiY2U2ZTUgNjNhNDQwZjIgNzcwMzdkODEgMmRlYjMzYTAgZjRhMTM5NDUgZDg5OGMyOTYnLFxuICAgICc0ZmUzNDJlMiBmZTFhN2Y5YiA4ZWU3ZWI0YSA3YzBmOWUxNiAyYmNlMzM1NyA2YjMxNWVjZSBjYmI2NDA2OCAzN2JmNTFmNScsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ3AzODQnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiBudWxsLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZlIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZjJyxcbiAgYjogJ2IzMzEyZmE3IGUyM2VlN2U0IDk4OGUwNTZiIGUzZjgyZDE5IDE4MWQ5YzZlIGZlODE0MTEyIDAzMTQwODhmICcgK1xuICAgICAnNTAxMzg3NWEgYzY1NjM5OGQgOGEyZWQxOWQgMmE4NWM4ZWQgZDNlYzJhZWYnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgYzc2MzRkODEgJyArXG4gICAgICdmNDM3MmRkZiA1ODFhMGRiMiA0OGIwYTc3YSBlY2VjMTk2YSBjY2M1Mjk3MycsXG4gIGhhc2g6IGhhc2guc2hhMzg0LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICdhYTg3Y2EyMiBiZThiMDUzNyA4ZWIxYzcxZSBmMzIwYWQ3NCA2ZTFkM2I2MiA4YmE3OWI5OCA1OWY3NDFlMCA4MjU0MmEzOCAnICtcbiAgICAnNTUwMmYyNWQgYmY1NTI5NmMgM2E1NDVlMzggNzI3NjBhYjcnLFxuICAgICczNjE3ZGU0YSA5NjI2MmM2ZiA1ZDllOThiZiA5MjkyZGMyOSBmOGY0MWRiZCAyODlhMTQ3YyBlOWRhMzExMyBiNWYwYjhjMCAnICtcbiAgICAnMGE2MGIxY2UgMWQ3ZTgxOWQgN2E0MzFkN2MgOTBlYTBlNWYnLFxuICBdLFxufSk7XG5cbmRlZmluZUN1cnZlKCdwNTIxJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmMnLFxuICBiOiAnMDAwMDAwNTEgOTUzZWI5NjEgOGUxYzlhMWYgOTI5YTIxYTAgYjY4NTQwZWUgYTJkYTcyNWIgJyArXG4gICAgICc5OWIzMTVmMyBiOGI0ODk5MSA4ZWYxMDllMSA1NjE5Mzk1MSBlYzdlOTM3YiAxNjUyYzBiZCAnICtcbiAgICAgJzNiYjFiZjA3IDM1NzNkZjg4IDNkMmMzNGYxIGVmNDUxZmQ0IDZiNTAzZjAwJyxcbiAgbjogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmEgNTE4Njg3ODMgYmYyZjk2NmIgN2ZjYzAxNDggJyArXG4gICAgICdmNzA5YTVkMCAzYmI1YzliOCA4OTljNDdhZSBiYjZmYjcxZSA5MTM4NjQwOScsXG4gIGhhc2g6IGhhc2guc2hhNTEyLFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcwMDAwMDBjNiA4NThlMDZiNyAwNDA0ZTljZCA5ZTNlY2I2NiAyMzk1YjQ0MiA5YzY0ODEzOSAnICtcbiAgICAnMDUzZmI1MjEgZjgyOGFmNjAgNmI0ZDNkYmEgYTE0YjVlNzcgZWZlNzU5MjggZmUxZGMxMjcgJyArXG4gICAgJ2EyZmZhOGRlIDMzNDhiM2MxIDg1NmE0MjliIGY5N2U3ZTMxIGMyZTViZDY2JyxcbiAgICAnMDAwMDAxMTggMzkyOTZhNzggOWEzYmMwMDQgNWM4YTVmYjQgMmM3ZDFiZDkgOThmNTQ0NDkgJyArXG4gICAgJzU3OWI0NDY4IDE3YWZiZDE3IDI3M2U2NjJjIDk3ZWU3Mjk5IDVlZjQyNjQwIGM1NTBiOTAxICcgK1xuICAgICczZmFkMDc2MSAzNTNjNzA4NiBhMjcyYzI0MCA4OGJlOTQ3NiA5ZmQxNjY1MCcsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ2N1cnZlMjU1MTknLCB7XG4gIHR5cGU6ICdtb250JyxcbiAgcHJpbWU6ICdwMjU1MTknLFxuICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG4gIGE6ICc3NmQwNicsXG4gIGI6ICcxJyxcbiAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnOScsXG4gIF0sXG59KTtcblxuZGVmaW5lQ3VydmUoJ2VkMjU1MTknLCB7XG4gIHR5cGU6ICdlZHdhcmRzJyxcbiAgcHJpbWU6ICdwMjU1MTknLFxuICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG4gIGE6ICctMScsXG4gIGM6ICcxJyxcbiAgLy8gLTEyMTY2NSAqICgxMjE2NjZeKC0xKSkgKG1vZCBQKVxuICBkOiAnNTIwMzZjZWUyYjZmZmU3MyA4Y2M3NDA3OTc3NzllODk4IDAwNzAwYTRkNDE0MWQ4YWIgNzVlYjRkY2ExMzU5NzhhMycsXG4gIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnLFxuXG4gICAgLy8gNC81XG4gICAgJzY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnLFxuICBdLFxufSk7XG5cbnZhciBwcmU7XG50cnkge1xuICBwcmUgPSByZXF1aXJlKCcuL3ByZWNvbXB1dGVkL3NlY3AyNTZrMScpO1xufSBjYXRjaCAoZSkge1xuICBwcmUgPSB1bmRlZmluZWQ7XG59XG5cbmRlZmluZUN1cnZlKCdzZWNwMjU2azEnLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAnazI1NicsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicsXG4gIGE6ICcwJyxcbiAgYjogJzcnLFxuICBuOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgYmFhZWRjZTYgYWY0OGEwM2IgYmZkMjVlOGMgZDAzNjQxNDEnLFxuICBoOiAnMScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuXG4gIC8vIFByZWNvbXB1dGVkIGVuZG9tb3JwaGlzbVxuICBiZXRhOiAnN2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScsXG4gIGxhbWJkYTogJzUzNjNhZDRjYzA1YzMwZTBhNTI2MWMwMjg4MTI2NDVhMTIyZTIyZWEyMDgxNjY3OGRmMDI5NjdjMWIyM2JkNzInLFxuICBiYXNpczogW1xuICAgIHtcbiAgICAgIGE6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScsXG4gICAgICBiOiAnLWU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGE6ICcxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnLFxuICAgICAgYjogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1JyxcbiAgICB9LFxuICBdLFxuXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OTgnLFxuICAgICc0ODNhZGE3NzI2YTNjNDY1NWRhNGZiZmMwZTExMDhhOGZkMTdiNDQ4YTY4NTU0MTk5YzQ3ZDA4ZmZiMTBkNGI4JyxcbiAgICBwcmUsXG4gIF0sXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBIbWFjRFJCRyA9IHJlcXVpcmUoJ2htYWMtZHJiZycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuLi9jdXJ2ZXMnKTtcbnZhciByYW5kID0gcmVxdWlyZSgnYnJvcmFuZCcpO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcblxudmFyIEtleVBhaXIgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG5cbmZ1bmN0aW9uIEVDKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVDKSlcbiAgICByZXR1cm4gbmV3IEVDKG9wdGlvbnMpO1xuXG4gIC8vIFNob3J0Y3V0IGBlbGxpcHRpYy5lYyhjdXJ2ZS1uYW1lKWBcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIGFzc2VydChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VydmVzLCBvcHRpb25zKSxcbiAgICAgICdVbmtub3duIGN1cnZlICcgKyBvcHRpb25zKTtcblxuICAgIG9wdGlvbnMgPSBjdXJ2ZXNbb3B0aW9uc107XG4gIH1cblxuICAvLyBTaG9ydGN1dCBmb3IgYGVsbGlwdGljLmVjKGVsbGlwdGljLmN1cnZlcy5jdXJ2ZU5hbWUpYFxuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIGN1cnZlcy5QcmVzZXRDdXJ2ZSlcbiAgICBvcHRpb25zID0geyBjdXJ2ZTogb3B0aW9ucyB9O1xuXG4gIHRoaXMuY3VydmUgPSBvcHRpb25zLmN1cnZlLmN1cnZlO1xuICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG4gIHRoaXMubmggPSB0aGlzLm4udXNocm4oMSk7XG4gIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcblxuICAvLyBQb2ludCBvbiBjdXJ2ZVxuICB0aGlzLmcgPSBvcHRpb25zLmN1cnZlLmc7XG4gIHRoaXMuZy5wcmVjb21wdXRlKG9wdGlvbnMuY3VydmUubi5iaXRMZW5ndGgoKSArIDEpO1xuXG4gIC8vIEhhc2ggZm9yIGZ1bmN0aW9uIGZvciBEUkJHXG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaCB8fCBvcHRpb25zLmN1cnZlLmhhc2g7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEVDO1xuXG5FQy5wcm90b3R5cGUua2V5UGFpciA9IGZ1bmN0aW9uIGtleVBhaXIob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEtleVBhaXIodGhpcywgb3B0aW9ucyk7XG59O1xuXG5FQy5wcm90b3R5cGUua2V5RnJvbVByaXZhdGUgPSBmdW5jdGlvbiBrZXlGcm9tUHJpdmF0ZShwcml2LCBlbmMpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVByaXZhdGUodGhpcywgcHJpdiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5rZXlGcm9tUHVibGljID0gZnVuY3Rpb24ga2V5RnJvbVB1YmxpYyhwdWIsIGVuYykge1xuICByZXR1cm4gS2V5UGFpci5mcm9tUHVibGljKHRoaXMsIHB1YiwgZW5jKTtcbn07XG5cbkVDLnByb3RvdHlwZS5nZW5LZXlQYWlyID0gZnVuY3Rpb24gZ2VuS2V5UGFpcihvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge307XG5cbiAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG4gIHZhciBkcmJnID0gbmV3IEhtYWNEUkJHKHtcbiAgICBoYXNoOiB0aGlzLmhhc2gsXG4gICAgcGVyczogb3B0aW9ucy5wZXJzLFxuICAgIHBlcnNFbmM6IG9wdGlvbnMucGVyc0VuYyB8fCAndXRmOCcsXG4gICAgZW50cm9weTogb3B0aW9ucy5lbnRyb3B5IHx8IHJhbmQodGhpcy5oYXNoLmhtYWNTdHJlbmd0aCksXG4gICAgZW50cm9weUVuYzogb3B0aW9ucy5lbnRyb3B5ICYmIG9wdGlvbnMuZW50cm9weUVuYyB8fCAndXRmOCcsXG4gICAgbm9uY2U6IHRoaXMubi50b0FycmF5KCksXG4gIH0pO1xuXG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBuczIgPSB0aGlzLm4uc3ViKG5ldyBCTigyKSk7XG4gIGZvciAoOzspIHtcbiAgICB2YXIgcHJpdiA9IG5ldyBCTihkcmJnLmdlbmVyYXRlKGJ5dGVzKSk7XG4gICAgaWYgKHByaXYuY21wKG5zMikgPiAwKVxuICAgICAgY29udGludWU7XG5cbiAgICBwcml2LmlhZGRuKDEpO1xuICAgIHJldHVybiB0aGlzLmtleUZyb21Qcml2YXRlKHByaXYpO1xuICB9XG59O1xuXG5FQy5wcm90b3R5cGUuX3RydW5jYXRlVG9OID0gZnVuY3Rpb24gX3RydW5jYXRlVG9OKG1zZywgdHJ1bmNPbmx5KSB7XG4gIHZhciBkZWx0YSA9IG1zZy5ieXRlTGVuZ3RoKCkgKiA4IC0gdGhpcy5uLmJpdExlbmd0aCgpO1xuICBpZiAoZGVsdGEgPiAwKVxuICAgIG1zZyA9IG1zZy51c2hybihkZWx0YSk7XG4gIGlmICghdHJ1bmNPbmx5ICYmIG1zZy5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBtc2cuc3ViKHRoaXMubik7XG4gIGVsc2VcbiAgICByZXR1cm4gbXNnO1xufTtcblxuRUMucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywga2V5LCBlbmMsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBlbmMgPT09ICdvYmplY3QnKSB7XG4gICAgb3B0aW9ucyA9IGVuYztcbiAgICBlbmMgPSBudWxsO1xuICB9XG4gIGlmICghb3B0aW9ucylcbiAgICBvcHRpb25zID0ge307XG5cbiAga2V5ID0gdGhpcy5rZXlGcm9tUHJpdmF0ZShrZXksIGVuYyk7XG4gIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBCTihtc2csIDE2KSk7XG5cbiAgLy8gWmVyby1leHRlbmQga2V5IHRvIHByb3ZpZGUgZW5vdWdoIGVudHJvcHlcbiAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcbiAgdmFyIGJrZXkgPSBrZXkuZ2V0UHJpdmF0ZSgpLnRvQXJyYXkoJ2JlJywgYnl0ZXMpO1xuXG4gIC8vIFplcm8tZXh0ZW5kIG5vbmNlIHRvIGhhdmUgdGhlIHNhbWUgYnl0ZSBzaXplIGFzIE5cbiAgdmFyIG5vbmNlID0gbXNnLnRvQXJyYXkoJ2JlJywgYnl0ZXMpO1xuXG4gIC8vIEluc3RhbnRpYXRlIEhtYWNfRFJCR1xuICB2YXIgZHJiZyA9IG5ldyBIbWFjRFJCRyh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIGVudHJvcHk6IGJrZXksXG4gICAgbm9uY2U6IG5vbmNlLFxuICAgIHBlcnM6IG9wdGlvbnMucGVycyxcbiAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnLFxuICB9KTtcblxuICAvLyBOdW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGVcbiAgdmFyIG5zMSA9IHRoaXMubi5zdWIobmV3IEJOKDEpKTtcblxuICBmb3IgKHZhciBpdGVyID0gMDsgOyBpdGVyKyspIHtcbiAgICB2YXIgayA9IG9wdGlvbnMuayA/XG4gICAgICBvcHRpb25zLmsoaXRlcikgOlxuICAgICAgbmV3IEJOKGRyYmcuZ2VuZXJhdGUodGhpcy5uLmJ5dGVMZW5ndGgoKSkpO1xuICAgIGsgPSB0aGlzLl90cnVuY2F0ZVRvTihrLCB0cnVlKTtcbiAgICBpZiAoay5jbXBuKDEpIDw9IDAgfHwgay5jbXAobnMxKSA+PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIga3AgPSB0aGlzLmcubXVsKGspO1xuICAgIGlmIChrcC5pc0luZmluaXR5KCkpXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBrcFggPSBrcC5nZXRYKCk7XG4gICAgdmFyIHIgPSBrcFgudW1vZCh0aGlzLm4pO1xuICAgIGlmIChyLmNtcG4oMCkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciBzID0gay5pbnZtKHRoaXMubikubXVsKHIubXVsKGtleS5nZXRQcml2YXRlKCkpLmlhZGQobXNnKSk7XG4gICAgcyA9IHMudW1vZCh0aGlzLm4pO1xuICAgIGlmIChzLmNtcG4oMCkgPT09IDApXG4gICAgICBjb250aW51ZTtcblxuICAgIHZhciByZWNvdmVyeVBhcmFtID0gKGtwLmdldFkoKS5pc09kZCgpID8gMSA6IDApIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChrcFguY21wKHIpICE9PSAwID8gMiA6IDApO1xuXG4gICAgLy8gVXNlIGNvbXBsZW1lbnQgb2YgYHNgLCBpZiBpdCBpcyA+IGBuIC8gMmBcbiAgICBpZiAob3B0aW9ucy5jYW5vbmljYWwgJiYgcy5jbXAodGhpcy5uaCkgPiAwKSB7XG4gICAgICBzID0gdGhpcy5uLnN1YihzKTtcbiAgICAgIHJlY292ZXJ5UGFyYW0gXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh7IHI6IHIsIHM6IHMsIHJlY292ZXJ5UGFyYW06IHJlY292ZXJ5UGFyYW0gfSk7XG4gIH1cbn07XG5cbkVDLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobXNnLCBzaWduYXR1cmUsIGtleSwgZW5jKSB7XG4gIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBCTihtc2csIDE2KSk7XG4gIGtleSA9IHRoaXMua2V5RnJvbVB1YmxpYyhrZXksIGVuYyk7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCAnaGV4Jyk7XG5cbiAgLy8gUGVyZm9ybSBwcmltaXRpdmUgdmFsdWVzIHZhbGlkYXRpb25cbiAgdmFyIHIgPSBzaWduYXR1cmUucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUucztcbiAgaWYgKHIuY21wbigxKSA8IDAgfHwgci5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHMuY21wbigxKSA8IDAgfHwgcy5jbXAodGhpcy5uKSA+PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBWYWxpZGF0ZSBzaWduYXR1cmVcbiAgdmFyIHNpbnYgPSBzLmludm0odGhpcy5uKTtcbiAgdmFyIHUxID0gc2ludi5tdWwobXNnKS51bW9kKHRoaXMubik7XG4gIHZhciB1MiA9IHNpbnYubXVsKHIpLnVtb2QodGhpcy5uKTtcbiAgdmFyIHA7XG5cbiAgaWYgKCF0aGlzLmN1cnZlLl9tYXh3ZWxsVHJpY2spIHtcbiAgICBwID0gdGhpcy5nLm11bEFkZCh1MSwga2V5LmdldFB1YmxpYygpLCB1Mik7XG4gICAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHAuZ2V0WCgpLnVtb2QodGhpcy5uKS5jbXAocikgPT09IDA7XG4gIH1cblxuICAvLyBOT1RFOiBHcmVnIE1heHdlbGwncyB0cmljaywgaW5zcGlyZWQgYnk6XG4gIC8vIGh0dHBzOi8vZ2l0LmlvL3ZhZDNLXG5cbiAgcCA9IHRoaXMuZy5qbXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgaWYgKHAuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBDb21wYXJlIGBwLnhgIG9mIEphY29iaWFuIHBvaW50IHdpdGggYHJgLFxuICAvLyB0aGlzIHdpbGwgZG8gYHAueCA9PSByICogcC56XjJgIGluc3RlYWQgb2YgbXVsdGlwbHlpbmcgYHAueGAgYnkgdGhlXG4gIC8vIGludmVyc2Ugb2YgYHAuel4yYFxuICByZXR1cm4gcC5lcVhUb1Aocik7XG59O1xuXG5FQy5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKG1zZywgc2lnbmF0dXJlLCBqLCBlbmMpIHtcbiAgYXNzZXJ0KCgzICYgaikgPT09IGosICdUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG4gIHNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmUoc2lnbmF0dXJlLCBlbmMpO1xuXG4gIHZhciBuID0gdGhpcy5uO1xuICB2YXIgZSA9IG5ldyBCTihtc2cpO1xuICB2YXIgciA9IHNpZ25hdHVyZS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZS5zO1xuXG4gIC8vIEEgc2V0IExTQiBzaWduaWZpZXMgdGhhdCB0aGUgeS1jb29yZGluYXRlIGlzIG9kZFxuICB2YXIgaXNZT2RkID0gaiAmIDE7XG4gIHZhciBpc1NlY29uZEtleSA9IGogPj4gMTtcbiAgaWYgKHIuY21wKHRoaXMuY3VydmUucC51bW9kKHRoaXMuY3VydmUubikpID49IDAgJiYgaXNTZWNvbmRLZXkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtcblxuICAvLyAxLjEuIExldCB4ID0gciArIGpuLlxuICBpZiAoaXNTZWNvbmRLZXkpXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLCBpc1lPZGQpO1xuICBlbHNlXG4gICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLCBpc1lPZGQpO1xuXG4gIHZhciBySW52ID0gc2lnbmF0dXJlLnIuaW52bShuKTtcbiAgdmFyIHMxID0gbi5zdWIoZSkubXVsKHJJbnYpLnVtb2Qobik7XG4gIHZhciBzMiA9IHMubXVsKHJJbnYpLnVtb2Qobik7XG5cbiAgLy8gMS42LjEgQ29tcHV0ZSBRID0gcl4tMSAoc1IgLSAgZUcpXG4gIC8vICAgICAgICAgICAgICAgUSA9IHJeLTEgKHNSICsgLWVHKVxuICByZXR1cm4gdGhpcy5nLm11bEFkZChzMSwgciwgczIpO1xufTtcblxuRUMucHJvdG90eXBlLmdldEtleVJlY292ZXJ5UGFyYW0gPSBmdW5jdGlvbihlLCBzaWduYXR1cmUsIFEsIGVuYykge1xuICBzaWduYXR1cmUgPSBuZXcgU2lnbmF0dXJlKHNpZ25hdHVyZSwgZW5jKTtcbiAgaWYgKHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtICE9PSBudWxsKVxuICAgIHJldHVybiBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHZhciBRcHJpbWU7XG4gICAgdHJ5IHtcbiAgICAgIFFwcmltZSA9IHRoaXMucmVjb3ZlclB1YktleShlLCBzaWduYXR1cmUsIGkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChRcHJpbWUuZXEoUSkpXG4gICAgICByZXR1cm4gaTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHZhbGlkIHJlY292ZXJ5IGZhY3RvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBLZXlQYWlyKGVjLCBvcHRpb25zKSB7XG4gIHRoaXMuZWMgPSBlYztcbiAgdGhpcy5wcml2ID0gbnVsbDtcbiAgdGhpcy5wdWIgPSBudWxsO1xuXG4gIC8vIEtleVBhaXIoZWMsIHsgcHJpdjogLi4uLCBwdWI6IC4uLiB9KVxuICBpZiAob3B0aW9ucy5wcml2KVxuICAgIHRoaXMuX2ltcG9ydFByaXZhdGUob3B0aW9ucy5wcml2LCBvcHRpb25zLnByaXZFbmMpO1xuICBpZiAob3B0aW9ucy5wdWIpXG4gICAgdGhpcy5faW1wb3J0UHVibGljKG9wdGlvbnMucHViLCBvcHRpb25zLnB1YkVuYyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEtleVBhaXI7XG5cbktleVBhaXIuZnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGZyb21QdWJsaWMoZWMsIHB1YiwgZW5jKSB7XG4gIGlmIChwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwdWI7XG5cbiAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG4gICAgcHViOiBwdWIsXG4gICAgcHViRW5jOiBlbmMsXG4gIH0pO1xufTtcblxuS2V5UGFpci5mcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGZyb21Qcml2YXRlKGVjLCBwcml2LCBlbmMpIHtcbiAgaWYgKHByaXYgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwcml2O1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHByaXY6IHByaXYsXG4gICAgcHJpdkVuYzogZW5jLFxuICB9KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG4gIHZhciBwdWIgPSB0aGlzLmdldFB1YmxpYygpO1xuXG4gIGlmIChwdWIuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ0ludmFsaWQgcHVibGljIGtleScgfTtcbiAgaWYgKCFwdWIudmFsaWRhdGUoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5IGlzIG5vdCBhIHBvaW50JyB9O1xuICBpZiAoIXB1Yi5tdWwodGhpcy5lYy5jdXJ2ZS5uKS5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSAqIE4gIT0gTycgfTtcblxuICByZXR1cm4geyByZXN1bHQ6IHRydWUsIHJlYXNvbjogbnVsbCB9O1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0UHVibGljID0gZnVuY3Rpb24gZ2V0UHVibGljKGNvbXBhY3QsIGVuYykge1xuICAvLyBjb21wYWN0IGlzIG9wdGlvbmFsIGFyZ3VtZW50XG4gIGlmICh0eXBlb2YgY29tcGFjdCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmMgPSBjb21wYWN0O1xuICAgIGNvbXBhY3QgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF0aGlzLnB1YilcbiAgICB0aGlzLnB1YiA9IHRoaXMuZWMuZy5tdWwodGhpcy5wcml2KTtcblxuICBpZiAoIWVuYylcbiAgICByZXR1cm4gdGhpcy5wdWI7XG5cbiAgcmV0dXJuIHRoaXMucHViLmVuY29kZShlbmMsIGNvbXBhY3QpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuZ2V0UHJpdmF0ZSA9IGZ1bmN0aW9uIGdldFByaXZhdGUoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB0aGlzLnByaXYudG9TdHJpbmcoMTYsIDIpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMucHJpdjtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLl9pbXBvcnRQcml2YXRlID0gZnVuY3Rpb24gX2ltcG9ydFByaXZhdGUoa2V5LCBlbmMpIHtcbiAgdGhpcy5wcml2ID0gbmV3IEJOKGtleSwgZW5jIHx8IDE2KTtcblxuICAvLyBFbnN1cmUgdGhhdCB0aGUgcHJpdiB3b24ndCBiZSBiaWdnZXIgdGhhbiBuLCBvdGhlcndpc2Ugd2UgbWF5IGZhaWxcbiAgLy8gaW4gZml4ZWQgbXVsdGlwbGljYXRpb24gbWV0aG9kXG4gIHRoaXMucHJpdiA9IHRoaXMucHJpdi51bW9kKHRoaXMuZWMuY3VydmUubik7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHVibGljID0gZnVuY3Rpb24gX2ltcG9ydFB1YmxpYyhrZXksIGVuYykge1xuICBpZiAoa2V5LnggfHwga2V5LnkpIHtcbiAgICAvLyBNb250Z29tZXJ5IHBvaW50cyBvbmx5IGhhdmUgYW4gYHhgIGNvb3JkaW5hdGUuXG4gICAgLy8gV2VpZXJzdHJhc3MvRWR3YXJkcyBwb2ludHMgb24gdGhlIG90aGVyIGhhbmQgaGF2ZSBib3RoIGB4YCBhbmRcbiAgICAvLyBgeWAgY29vcmRpbmF0ZXMuXG4gICAgaWYgKHRoaXMuZWMuY3VydmUudHlwZSA9PT0gJ21vbnQnKSB7XG4gICAgICBhc3NlcnQoa2V5LngsICdOZWVkIHggY29vcmRpbmF0ZScpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnc2hvcnQnIHx8XG4gICAgICAgICAgICAgICB0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdlZHdhcmRzJykge1xuICAgICAgYXNzZXJ0KGtleS54ICYmIGtleS55LCAnTmVlZCBib3RoIHggYW5kIHkgY29vcmRpbmF0ZScpO1xuICAgIH1cbiAgICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUucG9pbnQoa2V5LngsIGtleS55KTtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLmRlY29kZVBvaW50KGtleSwgZW5jKTtcbn07XG5cbi8vIEVDREhcbktleVBhaXIucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIGRlcml2ZShwdWIpIHtcbiAgaWYoIXB1Yi52YWxpZGF0ZSgpKSB7XG4gICAgYXNzZXJ0KHB1Yi52YWxpZGF0ZSgpLCAncHVibGljIHBvaW50IG5vdCB2YWxpZGF0ZWQnKTtcbiAgfVxuICByZXR1cm4gcHViLm11bCh0aGlzLnByaXYpLmdldFgoKTtcbn07XG5cbi8vIEVDRFNBXG5LZXlQYWlyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGVuYywgb3B0aW9ucykge1xuICByZXR1cm4gdGhpcy5lYy5zaWduKG1zZywgdGhpcywgZW5jLCBvcHRpb25zKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSkge1xuICByZXR1cm4gdGhpcy5lYy52ZXJpZnkobXNnLCBzaWduYXR1cmUsIHRoaXMpO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIHJldHVybiAnPEtleSBwcml2OiAnICsgKHRoaXMucHJpdiAmJiB0aGlzLnByaXYudG9TdHJpbmcoMTYsIDIpKSArXG4gICAgICAgICAnIHB1YjogJyArICh0aGlzLnB1YiAmJiB0aGlzLnB1Yi5pbnNwZWN0KCkpICsgJyA+Jztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaWduYXR1cmUob3B0aW9ucywgZW5jKSB7XG4gIGlmIChvcHRpb25zIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBvcHRpb25zO1xuXG4gIGlmICh0aGlzLl9pbXBvcnRERVIob3B0aW9ucywgZW5jKSlcbiAgICByZXR1cm47XG5cbiAgYXNzZXJ0KG9wdGlvbnMuciAmJiBvcHRpb25zLnMsICdTaWduYXR1cmUgd2l0aG91dCByIG9yIHMnKTtcbiAgdGhpcy5yID0gbmV3IEJOKG9wdGlvbnMuciwgMTYpO1xuICB0aGlzLnMgPSBuZXcgQk4ob3B0aW9ucy5zLCAxNik7XG4gIGlmIChvcHRpb25zLnJlY292ZXJ5UGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuICBlbHNlXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gb3B0aW9ucy5yZWNvdmVyeVBhcmFtO1xufVxubW9kdWxlLmV4cG9ydHMgPSBTaWduYXR1cmU7XG5cbmZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICB0aGlzLnBsYWNlID0gMDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoKGJ1ZiwgcCkge1xuICB2YXIgaW5pdGlhbCA9IGJ1ZltwLnBsYWNlKytdO1xuICBpZiAoIShpbml0aWFsICYgMHg4MCkpIHtcbiAgICByZXR1cm4gaW5pdGlhbDtcbiAgfVxuICB2YXIgb2N0ZXRMZW4gPSBpbml0aWFsICYgMHhmO1xuXG4gIC8vIEluZGVmaW5pdGUgbGVuZ3RoIG9yIG92ZXJmbG93XG4gIGlmIChvY3RldExlbiA9PT0gMCB8fCBvY3RldExlbiA+IDQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdmFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIG9mZiA9IHAucGxhY2U7IGkgPCBvY3RldExlbjsgaSsrLCBvZmYrKykge1xuICAgIHZhbCA8PD0gODtcbiAgICB2YWwgfD0gYnVmW29mZl07XG4gICAgdmFsID4+Pj0gMDtcbiAgfVxuXG4gIC8vIExlYWRpbmcgemVyb2VzXG4gIGlmICh2YWwgPD0gMHg3Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHAucGxhY2UgPSBvZmY7XG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIHJtUGFkZGluZyhidWYpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aCAtIDE7XG4gIHdoaWxlICghYnVmW2ldICYmICEoYnVmW2kgKyAxXSAmIDB4ODApICYmIGkgPCBsZW4pIHtcbiAgICBpKys7XG4gIH1cbiAgaWYgKGkgPT09IDApIHtcbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiBidWYuc2xpY2UoaSk7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUuX2ltcG9ydERFUiA9IGZ1bmN0aW9uIF9pbXBvcnRERVIoZGF0YSwgZW5jKSB7XG4gIGRhdGEgPSB1dGlscy50b0FycmF5KGRhdGEsIGVuYyk7XG4gIHZhciBwID0gbmV3IFBvc2l0aW9uKCk7XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MzApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKGxlbiA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKChsZW4gKyBwLnBsYWNlKSAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcmxlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKHJsZW4gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciByID0gZGF0YS5zbGljZShwLnBsYWNlLCBybGVuICsgcC5wbGFjZSk7XG4gIHAucGxhY2UgKz0gcmxlbjtcbiAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgc2xlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcbiAgaWYgKHNsZW4gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkYXRhLmxlbmd0aCAhPT0gc2xlbiArIHAucGxhY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHMgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHNsZW4gKyBwLnBsYWNlKTtcbiAgaWYgKHJbMF0gPT09IDApIHtcbiAgICBpZiAoclsxXSAmIDB4ODApIHtcbiAgICAgIHIgPSByLnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMZWFkaW5nIHplcm9lc1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoc1swXSA9PT0gMCkge1xuICAgIGlmIChzWzFdICYgMHg4MCkge1xuICAgICAgcyA9IHMuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExlYWRpbmcgemVyb2VzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5yID0gbmV3IEJOKHIpO1xuICB0aGlzLnMgPSBuZXcgQk4ocyk7XG4gIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG51bGw7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA8IDB4ODApIHtcbiAgICBhcnIucHVzaChsZW4pO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb2N0ZXRzID0gMSArIChNYXRoLmxvZyhsZW4pIC8gTWF0aC5MTjIgPj4+IDMpO1xuICBhcnIucHVzaChvY3RldHMgfCAweDgwKTtcbiAgd2hpbGUgKC0tb2N0ZXRzKSB7XG4gICAgYXJyLnB1c2goKGxlbiA+Pj4gKG9jdGV0cyA8PCAzKSkgJiAweGZmKTtcbiAgfVxuICBhcnIucHVzaChsZW4pO1xufVxuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvREVSID0gZnVuY3Rpb24gdG9ERVIoZW5jKSB7XG4gIHZhciByID0gdGhpcy5yLnRvQXJyYXkoKTtcbiAgdmFyIHMgPSB0aGlzLnMudG9BcnJheSgpO1xuXG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHJbMF0gJiAweDgwKVxuICAgIHIgPSBbIDAgXS5jb25jYXQocik7XG4gIC8vIFBhZCB2YWx1ZXNcbiAgaWYgKHNbMF0gJiAweDgwKVxuICAgIHMgPSBbIDAgXS5jb25jYXQocyk7XG5cbiAgciA9IHJtUGFkZGluZyhyKTtcbiAgcyA9IHJtUGFkZGluZyhzKTtcblxuICB3aGlsZSAoIXNbMF0gJiYgIShzWzFdICYgMHg4MCkpIHtcbiAgICBzID0gcy5zbGljZSgxKTtcbiAgfVxuICB2YXIgYXJyID0gWyAweDAyIF07XG4gIGNvbnN0cnVjdExlbmd0aChhcnIsIHIubGVuZ3RoKTtcbiAgYXJyID0gYXJyLmNvbmNhdChyKTtcbiAgYXJyLnB1c2goMHgwMik7XG4gIGNvbnN0cnVjdExlbmd0aChhcnIsIHMubGVuZ3RoKTtcbiAgdmFyIGJhY2tIYWxmID0gYXJyLmNvbmNhdChzKTtcbiAgdmFyIHJlcyA9IFsgMHgzMCBdO1xuICBjb25zdHJ1Y3RMZW5ndGgocmVzLCBiYWNrSGFsZi5sZW5ndGgpO1xuICByZXMgPSByZXMuY29uY2F0KGJhY2tIYWxmKTtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZShyZXMsIGVuYyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzaCA9IHJlcXVpcmUoJ2hhc2guanMnKTtcbnZhciBjdXJ2ZXMgPSByZXF1aXJlKCcuLi9jdXJ2ZXMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gdXRpbHMuYXNzZXJ0O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xudmFyIEtleVBhaXIgPSByZXF1aXJlKCcuL2tleScpO1xudmFyIFNpZ25hdHVyZSA9IHJlcXVpcmUoJy4vc2lnbmF0dXJlJyk7XG5cbmZ1bmN0aW9uIEVERFNBKGN1cnZlKSB7XG4gIGFzc2VydChjdXJ2ZSA9PT0gJ2VkMjU1MTknLCAnb25seSB0ZXN0ZWQgd2l0aCBlZDI1NTE5IHNvIGZhcicpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFRERTQSkpXG4gICAgcmV0dXJuIG5ldyBFRERTQShjdXJ2ZSk7XG5cbiAgY3VydmUgPSBjdXJ2ZXNbY3VydmVdLmN1cnZlO1xuICB0aGlzLmN1cnZlID0gY3VydmU7XG4gIHRoaXMuZyA9IGN1cnZlLmc7XG4gIHRoaXMuZy5wcmVjb21wdXRlKGN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuICB0aGlzLnBvaW50Q2xhc3MgPSBjdXJ2ZS5wb2ludCgpLmNvbnN0cnVjdG9yO1xuICB0aGlzLmVuY29kaW5nTGVuZ3RoID0gTWF0aC5jZWlsKGN1cnZlLm4uYml0TGVuZ3RoKCkgLyA4KTtcbiAgdGhpcy5oYXNoID0gaGFzaC5zaGE1MTI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRUREU0E7XG5cbi8qKlxuKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gbWVzc2FnZSAtIG1lc3NhZ2UgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8S2V5UGFpcn0gc2VjcmV0IC0gc2VjcmV0IGJ5dGVzIG9yIGEga2V5cGFpclxuKiBAcmV0dXJucyB7U2lnbmF0dXJlfSAtIHNpZ25hdHVyZVxuKi9cbkVERFNBLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtZXNzYWdlLCBzZWNyZXQpIHtcbiAgbWVzc2FnZSA9IHBhcnNlQnl0ZXMobWVzc2FnZSk7XG4gIHZhciBrZXkgPSB0aGlzLmtleUZyb21TZWNyZXQoc2VjcmV0KTtcbiAgdmFyIHIgPSB0aGlzLmhhc2hJbnQoa2V5Lm1lc3NhZ2VQcmVmaXgoKSwgbWVzc2FnZSk7XG4gIHZhciBSID0gdGhpcy5nLm11bChyKTtcbiAgdmFyIFJlbmNvZGVkID0gdGhpcy5lbmNvZGVQb2ludChSKTtcbiAgdmFyIHNfID0gdGhpcy5oYXNoSW50KFJlbmNvZGVkLCBrZXkucHViQnl0ZXMoKSwgbWVzc2FnZSlcbiAgICAubXVsKGtleS5wcml2KCkpO1xuICB2YXIgUyA9IHIuYWRkKHNfKS51bW9kKHRoaXMuY3VydmUubik7XG4gIHJldHVybiB0aGlzLm1ha2VTaWduYXR1cmUoeyBSOiBSLCBTOiBTLCBSZW5jb2RlZDogUmVuY29kZWQgfSk7XG59O1xuXG4vKipcbiogQHBhcmFtIHtBcnJheX0gbWVzc2FnZSAtIG1lc3NhZ2UgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8U2lnbmF0dXJlfSBzaWcgLSBzaWcgYnl0ZXNcbiogQHBhcmFtIHtBcnJheXxTdHJpbmd8UG9pbnR8S2V5UGFpcn0gcHViIC0gcHVibGljIGtleVxuKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIHB1YmxpYyBrZXkgbWF0Y2hlcyBzaWcgb2YgbWVzc2FnZVxuKi9cbkVERFNBLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnLCBwdWIpIHtcbiAgbWVzc2FnZSA9IHBhcnNlQnl0ZXMobWVzc2FnZSk7XG4gIHNpZyA9IHRoaXMubWFrZVNpZ25hdHVyZShzaWcpO1xuICB2YXIga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKHB1Yik7XG4gIHZhciBoID0gdGhpcy5oYXNoSW50KHNpZy5SZW5jb2RlZCgpLCBrZXkucHViQnl0ZXMoKSwgbWVzc2FnZSk7XG4gIHZhciBTRyA9IHRoaXMuZy5tdWwoc2lnLlMoKSk7XG4gIHZhciBScGx1c0FoID0gc2lnLlIoKS5hZGQoa2V5LnB1YigpLm11bChoKSk7XG4gIHJldHVybiBScGx1c0FoLmVxKFNHKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5oYXNoSW50ID0gZnVuY3Rpb24gaGFzaEludCgpIHtcbiAgdmFyIGhhc2ggPSB0aGlzLmhhc2goKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgaGFzaC51cGRhdGUoYXJndW1lbnRzW2ldKTtcbiAgcmV0dXJuIHV0aWxzLmludEZyb21MRShoYXNoLmRpZ2VzdCgpKS51bW9kKHRoaXMuY3VydmUubik7XG59O1xuXG5FRERTQS5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViKSB7XG4gIHJldHVybiBLZXlQYWlyLmZyb21QdWJsaWModGhpcywgcHViKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5rZXlGcm9tU2VjcmV0ID0gZnVuY3Rpb24ga2V5RnJvbVNlY3JldChzZWNyZXQpIHtcbiAgcmV0dXJuIEtleVBhaXIuZnJvbVNlY3JldCh0aGlzLCBzZWNyZXQpO1xufTtcblxuRUREU0EucHJvdG90eXBlLm1ha2VTaWduYXR1cmUgPSBmdW5jdGlvbiBtYWtlU2lnbmF0dXJlKHNpZykge1xuICBpZiAoc2lnIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuICAgIHJldHVybiBzaWc7XG4gIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMsIHNpZyk7XG59O1xuXG4vKipcbiogKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtam9zZWZzc29uLWVkZHNhLWVkMjU1MTktMDMjc2VjdGlvbi01LjJcbipcbiogRUREU0EgZGVmaW5lcyBtZXRob2RzIGZvciBlbmNvZGluZyBhbmQgZGVjb2RpbmcgcG9pbnRzIGFuZCBpbnRlZ2Vycy4gVGhlc2UgYXJlXG4qIGhlbHBlciBjb252ZW5pZW5jZSBtZXRob2RzLCB0aGF0IHBhc3MgYWxvbmcgdG8gdXRpbGl0eSBmdW5jdGlvbnMgaW1wbGllZFxuKiBwYXJhbWV0ZXJzLlxuKlxuKi9cbkVERFNBLnByb3RvdHlwZS5lbmNvZGVQb2ludCA9IGZ1bmN0aW9uIGVuY29kZVBvaW50KHBvaW50KSB7XG4gIHZhciBlbmMgPSBwb2ludC5nZXRZKCkudG9BcnJheSgnbGUnLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbiAgZW5jW3RoaXMuZW5jb2RpbmdMZW5ndGggLSAxXSB8PSBwb2ludC5nZXRYKCkuaXNPZGQoKSA/IDB4ODAgOiAwO1xuICByZXR1cm4gZW5jO1xufTtcblxuRUREU0EucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMpIHtcbiAgYnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzKGJ5dGVzKTtcblxuICB2YXIgbGFzdEl4ID0gYnl0ZXMubGVuZ3RoIC0gMTtcbiAgdmFyIG5vcm1lZCA9IGJ5dGVzLnNsaWNlKDAsIGxhc3RJeCkuY29uY2F0KGJ5dGVzW2xhc3RJeF0gJiB+MHg4MCk7XG4gIHZhciB4SXNPZGQgPSAoYnl0ZXNbbGFzdEl4XSAmIDB4ODApICE9PSAwO1xuXG4gIHZhciB5ID0gdXRpbHMuaW50RnJvbUxFKG5vcm1lZCk7XG4gIHJldHVybiB0aGlzLmN1cnZlLnBvaW50RnJvbVkoeSwgeElzT2RkKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5lbmNvZGVJbnQgPSBmdW5jdGlvbiBlbmNvZGVJbnQobnVtKSB7XG4gIHJldHVybiBudW0udG9BcnJheSgnbGUnLCB0aGlzLmVuY29kaW5nTGVuZ3RoKTtcbn07XG5cbkVERFNBLnByb3RvdHlwZS5kZWNvZGVJbnQgPSBmdW5jdGlvbiBkZWNvZGVJbnQoYnl0ZXMpIHtcbiAgcmV0dXJuIHV0aWxzLmludEZyb21MRShieXRlcyk7XG59O1xuXG5FRERTQS5wcm90b3R5cGUuaXNQb2ludCA9IGZ1bmN0aW9uIGlzUG9pbnQodmFsKSB7XG4gIHJldHVybiB2YWwgaW5zdGFuY2VvZiB0aGlzLnBvaW50Q2xhc3M7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBwYXJzZUJ5dGVzID0gdXRpbHMucGFyc2VCeXRlcztcbnZhciBjYWNoZWRQcm9wZXJ0eSA9IHV0aWxzLmNhY2hlZFByb3BlcnR5O1xuXG4vKipcbiogQHBhcmFtIHtFRERTQX0gZWRkc2EgLSBpbnN0YW5jZVxuKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gcHVibGljL3ByaXZhdGUga2V5IHBhcmFtZXRlcnNcbipcbiogQHBhcmFtIHtBcnJheTxCeXRlPn0gW3BhcmFtcy5zZWNyZXRdIC0gc2VjcmV0IHNlZWQgYnl0ZXNcbiogQHBhcmFtIHtQb2ludH0gW3BhcmFtcy5wdWJdIC0gcHVibGljIGtleSBwb2ludCAoYWthIGBBYCBpbiBlZGRzYSB0ZXJtcylcbiogQHBhcmFtIHtBcnJheTxCeXRlPn0gW3BhcmFtcy5wdWJdIC0gcHVibGljIGtleSBwb2ludCBlbmNvZGVkIGFzIGJ5dGVzXG4qXG4qL1xuZnVuY3Rpb24gS2V5UGFpcihlZGRzYSwgcGFyYW1zKSB7XG4gIHRoaXMuZWRkc2EgPSBlZGRzYTtcbiAgdGhpcy5fc2VjcmV0ID0gcGFyc2VCeXRlcyhwYXJhbXMuc2VjcmV0KTtcbiAgaWYgKGVkZHNhLmlzUG9pbnQocGFyYW1zLnB1YikpXG4gICAgdGhpcy5fcHViID0gcGFyYW1zLnB1YjtcbiAgZWxzZVxuICAgIHRoaXMuX3B1YkJ5dGVzID0gcGFyc2VCeXRlcyhwYXJhbXMucHViKTtcbn1cblxuS2V5UGFpci5mcm9tUHVibGljID0gZnVuY3Rpb24gZnJvbVB1YmxpYyhlZGRzYSwgcHViKSB7XG4gIGlmIChwdWIgaW5zdGFuY2VvZiBLZXlQYWlyKVxuICAgIHJldHVybiBwdWI7XG4gIHJldHVybiBuZXcgS2V5UGFpcihlZGRzYSwgeyBwdWI6IHB1YiB9KTtcbn07XG5cbktleVBhaXIuZnJvbVNlY3JldCA9IGZ1bmN0aW9uIGZyb21TZWNyZXQoZWRkc2EsIHNlY3JldCkge1xuICBpZiAoc2VjcmV0IGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gc2VjcmV0O1xuICByZXR1cm4gbmV3IEtleVBhaXIoZWRkc2EsIHsgc2VjcmV0OiBzZWNyZXQgfSk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5zZWNyZXQgPSBmdW5jdGlvbiBzZWNyZXQoKSB7XG4gIHJldHVybiB0aGlzLl9zZWNyZXQ7XG59O1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHViQnl0ZXMnLCBmdW5jdGlvbiBwdWJCeXRlcygpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlUG9pbnQodGhpcy5wdWIoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ3B1YicsIGZ1bmN0aW9uIHB1YigpIHtcbiAgaWYgKHRoaXMuX3B1YkJ5dGVzKVxuICAgIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZVBvaW50KHRoaXMuX3B1YkJ5dGVzKTtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZy5tdWwodGhpcy5wcml2KCkpO1xufSk7XG5cbmNhY2hlZFByb3BlcnR5KEtleVBhaXIsICdwcml2Qnl0ZXMnLCBmdW5jdGlvbiBwcml2Qnl0ZXMoKSB7XG4gIHZhciBlZGRzYSA9IHRoaXMuZWRkc2E7XG4gIHZhciBoYXNoID0gdGhpcy5oYXNoKCk7XG4gIHZhciBsYXN0SXggPSBlZGRzYS5lbmNvZGluZ0xlbmd0aCAtIDE7XG5cbiAgdmFyIGEgPSBoYXNoLnNsaWNlKDAsIGVkZHNhLmVuY29kaW5nTGVuZ3RoKTtcbiAgYVswXSAmPSAyNDg7XG4gIGFbbGFzdEl4XSAmPSAxMjc7XG4gIGFbbGFzdEl4XSB8PSA2NDtcblxuICByZXR1cm4gYTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAncHJpdicsIGZ1bmN0aW9uIHByaXYoKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmRlY29kZUludCh0aGlzLnByaXZCeXRlcygpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShLZXlQYWlyLCAnaGFzaCcsIGZ1bmN0aW9uIGhhc2goKSB7XG4gIHJldHVybiB0aGlzLmVkZHNhLmhhc2goKS51cGRhdGUodGhpcy5zZWNyZXQoKSkuZGlnZXN0KCk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoS2V5UGFpciwgJ21lc3NhZ2VQcmVmaXgnLCBmdW5jdGlvbiBtZXNzYWdlUHJlZml4KCkge1xuICByZXR1cm4gdGhpcy5oYXNoKCkuc2xpY2UodGhpcy5lZGRzYS5lbmNvZGluZ0xlbmd0aCk7XG59KTtcblxuS2V5UGFpci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSkge1xuICBhc3NlcnQodGhpcy5fc2VjcmV0LCAnS2V5UGFpciBjYW4gb25seSB2ZXJpZnknKTtcbiAgcmV0dXJuIHRoaXMuZWRkc2Euc2lnbihtZXNzYWdlLCB0aGlzKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlLCBzaWcpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EudmVyaWZ5KG1lc3NhZ2UsIHNpZywgdGhpcyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5nZXRTZWNyZXQgPSBmdW5jdGlvbiBnZXRTZWNyZXQoZW5jKSB7XG4gIGFzc2VydCh0aGlzLl9zZWNyZXQsICdLZXlQYWlyIGlzIHB1YmxpYyBvbmx5Jyk7XG4gIHJldHVybiB1dGlscy5lbmNvZGUodGhpcy5zZWNyZXQoKSwgZW5jKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhlbmMpIHtcbiAgcmV0dXJuIHV0aWxzLmVuY29kZSh0aGlzLnB1YkJ5dGVzKCksIGVuYyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleVBhaXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGFzc2VydCA9IHV0aWxzLmFzc2VydDtcbnZhciBjYWNoZWRQcm9wZXJ0eSA9IHV0aWxzLmNhY2hlZFByb3BlcnR5O1xudmFyIHBhcnNlQnl0ZXMgPSB1dGlscy5wYXJzZUJ5dGVzO1xuXG4vKipcbiogQHBhcmFtIHtFRERTQX0gZWRkc2EgLSBlZGRzYSBpbnN0YW5jZVxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxPYmplY3R9IHNpZyAtXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fFBvaW50fSBbc2lnLlJdIC0gUiBwb2ludCBhcyBQb2ludCBvciBieXRlc1xuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPnxibn0gW3NpZy5TXSAtIFMgc2NhbGFyIGFzIGJuIG9yIGJ5dGVzXG4qIEBwYXJhbSB7QXJyYXk8Qnl0ZXM+fSBbc2lnLlJlbmNvZGVkXSAtIFIgcG9pbnQgZW5jb2RlZFxuKiBAcGFyYW0ge0FycmF5PEJ5dGVzPn0gW3NpZy5TZW5jb2RlZF0gLSBTIHNjYWxhciBlbmNvZGVkXG4qL1xuZnVuY3Rpb24gU2lnbmF0dXJlKGVkZHNhLCBzaWcpIHtcbiAgdGhpcy5lZGRzYSA9IGVkZHNhO1xuXG4gIGlmICh0eXBlb2Ygc2lnICE9PSAnb2JqZWN0JylcbiAgICBzaWcgPSBwYXJzZUJ5dGVzKHNpZyk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc2lnKSkge1xuICAgIHNpZyA9IHtcbiAgICAgIFI6IHNpZy5zbGljZSgwLCBlZGRzYS5lbmNvZGluZ0xlbmd0aCksXG4gICAgICBTOiBzaWcuc2xpY2UoZWRkc2EuZW5jb2RpbmdMZW5ndGgpLFxuICAgIH07XG4gIH1cblxuICBhc3NlcnQoc2lnLlIgJiYgc2lnLlMsICdTaWduYXR1cmUgd2l0aG91dCBSIG9yIFMnKTtcblxuICBpZiAoZWRkc2EuaXNQb2ludChzaWcuUikpXG4gICAgdGhpcy5fUiA9IHNpZy5SO1xuICBpZiAoc2lnLlMgaW5zdGFuY2VvZiBCTilcbiAgICB0aGlzLl9TID0gc2lnLlM7XG5cbiAgdGhpcy5fUmVuY29kZWQgPSBBcnJheS5pc0FycmF5KHNpZy5SKSA/IHNpZy5SIDogc2lnLlJlbmNvZGVkO1xuICB0aGlzLl9TZW5jb2RlZCA9IEFycmF5LmlzQXJyYXkoc2lnLlMpID8gc2lnLlMgOiBzaWcuU2VuY29kZWQ7XG59XG5cbmNhY2hlZFByb3BlcnR5KFNpZ25hdHVyZSwgJ1MnLCBmdW5jdGlvbiBTKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5kZWNvZGVJbnQodGhpcy5TZW5jb2RlZCgpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdSJywgZnVuY3Rpb24gUigpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZGVjb2RlUG9pbnQodGhpcy5SZW5jb2RlZCgpKTtcbn0pO1xuXG5jYWNoZWRQcm9wZXJ0eShTaWduYXR1cmUsICdSZW5jb2RlZCcsIGZ1bmN0aW9uIFJlbmNvZGVkKCkge1xuICByZXR1cm4gdGhpcy5lZGRzYS5lbmNvZGVQb2ludCh0aGlzLlIoKSk7XG59KTtcblxuY2FjaGVkUHJvcGVydHkoU2lnbmF0dXJlLCAnU2VuY29kZWQnLCBmdW5jdGlvbiBTZW5jb2RlZCgpIHtcbiAgcmV0dXJuIHRoaXMuZWRkc2EuZW5jb2RlSW50KHRoaXMuUygpKTtcbn0pO1xuXG5TaWduYXR1cmUucHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKCkge1xuICByZXR1cm4gdGhpcy5SZW5jb2RlZCgpLmNvbmNhdCh0aGlzLlNlbmNvZGVkKCkpO1xufTtcblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uIHRvSGV4KCkge1xuICByZXR1cm4gdXRpbHMuZW5jb2RlKHRoaXMudG9CeXRlcygpLCAnaGV4JykudG9VcHBlckNhc2UoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2lnbmF0dXJlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRvdWJsZXM6IHtcbiAgICBzdGVwOiA0LFxuICAgIHBvaW50czogW1xuICAgICAgW1xuICAgICAgICAnZTYwZmNlOTNiNTllOWVjNTMwMTFhYWJjMjFjMjNlOTdiMmEzMTM2OWI4N2E1YWU5YzQ0ZWU4OWUyYTZkZWMwYScsXG4gICAgICAgICdmN2UzNTA3Mzk5ZTU5NTkyOWRiOTlmMzRmNTc5MzcxMDEyOTY4OTFlNDRkMjNmMGJlMWYzMmNjZTY5NjE2ODIxJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MjgyMjYzMjEyYzYwOWQ5ZWEyYTZlM2UxNzJkZTIzOGQ4YzM5Y2FiZDVhYzFjYTEwNjQ2ZTIzZmQ1ZjUxNTA4JyxcbiAgICAgICAgJzExZjhhODA5ODU1N2RmZTQ1ZTgyNTZlODMwYjYwYWNlNjJkNjEzYWMyZjdiMTdiZWQzMWI2ZWFmZjZlMjZjYWYnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NWUxNTlmNzI4Yjg2NWE3MmY5OWNjNmM2ZmM4NDZkZTBiOTM4MzNmZDIyMjJlZDczZmNlNWI1NTFlNWI3MzknLFxuICAgICAgICAnZDM1MDZlMGQ5ZTNjNzllYmE0ZWY5N2E1MWZmNzFmNWVhY2I1OTU1YWRkMjQzNDVjNmVmYTZmZmVlOWZlZDY5NScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzYzZDkwZDQ0N2IwMGM5Yzk5Y2VhYzA1YjYyNjJlZTA1MzQ0MWM3ZTU1NTUyZmZlNTI2YmFkOGY4M2ZmNDY0MCcsXG4gICAgICAgICc0ZTI3M2FkZmM3MzIyMjE5NTNiNDQ1Mzk3ZjMzNjMxNDViOWE4OTAwODE5OWVjYjYyMDAzYzdmM2JlZTlkZTknLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhiNGI1ZjE2NWRmM2MyYmU4YzYyNDRiNWI3NDU2Mzg4NDNlNGE3ODFhMTViY2QxYjY5Zjc5YTU1ZGZmZGY4MGMnLFxuICAgICAgICAnNGFhZDBhNmY2OGQzMDhiNGIzZmJkNzgxM2FiMGRhMDRmOWUzMzY1NDYxNjJlZTU2YjNlZmYwYzY1ZmQ0ZmQzNicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzIzY2JhYTZlNWRiOTk2ZDZiZjc3MWMwMGJkNTQ4YzdiNzAwZGJmZmE2YzBlNzdiY2I2MTE1OTI1MjMyZmNkYScsXG4gICAgICAgICc5NmU4NjdiNTU5NWNjNDk4YTkyMTEzNzQ4ODgyNGQ2ZTI2NjBhMDY1Mzc3OTQ5NDgwMWRjMDY5ZDllYjM5ZjVmJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlZWJmYTRkNDkzYmViZjk4YmE1ZmVlYzgxMmMyZDNiNTA5NDc5NjEyMzdhOTE5ODM5YTUzM2VjYTBlN2RkN2ZhJyxcbiAgICAgICAgJzVkOWE4Y2EzOTcwZWYwZjI2OWVlN2VkYWYxNzgwODlkOWFlNGNkYzNhNzExZjcxMmRkZmQ0ZmRhZTFkZTg5OTknLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzEwMGY0NGRhNjk2ZTcxNjcyNzkxZDBhMDliN2JkZTQ1OWYxMjE1YTI5YjNjMDNiZmVmZDc4MzViMzlhNDhkYjAnLFxuICAgICAgICAnY2RkOWUxMzE5MmEwMGI3NzJlYzhmMzMwMGMwOTA2NjZiN2ZmNGExOGZmNTE5NWFjMGZiZDVjZDYyYmM2NWEwOScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTEwMzFiZTI2MmM3ZWQxYjFkYzkyMjdhNGEwNGMwMTdhNzdmOGQ0NDY0ZjNiMzg1MmM4YWNkZTZlNTM0ZmQyZCcsXG4gICAgICAgICc5ZDcwNjE5Mjg5NDA0MDVlNmJiNmE0MTc2NTk3NTM1YWYyOTJkZDQxOWUxY2VkNzlhNDRmMThmMjk0NTZhMDBkJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZWVhNmNhZTQ2ZDU1YjUzMGFjMjgzOWYxNDNiZDdlYzVjZjhiMjY2YTQxZDZhZjUyZDVlNjg4ZDkwOTQ2OTZkJyxcbiAgICAgICAgJ2U1N2M2YjZjOTdkY2UxYmFiMDZlNGUxMmJmM2VjZDVjOTgxYzg5NTdjYzQxNDQyZDMxNTVkZWJmMTgwOTAwODgnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RhNjdhOTFkOTEwNDljZGNiMzY3YmU0YmU2ZmZjYTNjZmVlZDY1N2Q4MDg1ODNkZTMzZmE5NzhiYzFlYzZjYjEnLFxuICAgICAgICAnOWJhY2FhMzU0ODE2NDJiYzQxZjQ2M2Y3ZWM5NzgwZTVkZWM3YWRjNTA4Zjc0MGExN2U5ZWE4ZTI3YTY4YmUxZCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTM5MDRmYWEwYjMzNGNkZGE2ZTAwMDkzNWVmMjIxNTFlYzA4ZDBmN2JiMTEwNjlmNTc1NDVjY2MxYTM3YjdjMCcsXG4gICAgICAgICc1YmMwODdkMGJjODAxMDZkODhjOWVjY2FjMjBkM2MxYzEzOTk5OTgxZTE0NDM0Njk5ZGNiMDk2YjAyMjc3MWM4JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4ZTdiY2QwYmQzNTk4M2E3NzE5Y2NhNzc2NGNhOTA2Nzc5YjUzYTA0M2E5YjhiY2FlZmY5NTlmNDNhZDg2MDQ3JyxcbiAgICAgICAgJzEwYjc3NzBiMmEzZGE0YjM5NDAzMTA0MjBjYTk1MTQ1NzllODhlMmU0N2ZkNjhiM2VhMTAwNDdlODQ2MDM3MmEnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzM4NWVlZDM0YzFjZGZmMjFlNmQwODE4Njg5YjgxYmRlNzFhN2Y0ZjE4Mzk3ZTY2OTBhODQxZTE1OTljNDM4NjInLFxuICAgICAgICAnMjgzYmViYzNlOGVhMjNmNTY3MDFkZTE5ZTllYmY0NTc2YjMwNGVlYzIwODZkYzhjYzA0NThmZTU1NDJlNTQ1MycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmY5ZDliODAzZWNmMTkxNjM3YzczYTQ0MTNkZmExODBmZGRmODRhNTk0N2ZiYzljNjA2ZWQ4NmMzZmFjM2E3JyxcbiAgICAgICAgJzdjODBjNjhlNjAzMDU5YmE2OWI4ZTJhMzBlNDVjNGQ0N2VhNGRkMmY1YzI4MTAwMmQ4Njg5MDYwM2E4NDIxNjAnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMzMjJkNDAxMjQzYzRlMjU4MmEyMTQ3YzEwNGQ2ZWNiZjc3NGQxNjNkYjBmNWU1MzEzYjdlMGU3NDJkMGU2YmQnLFxuICAgICAgICAnNTZlNzA3OTdlOTY2NGVmNWJmYjAxOWJjNGRkYWY5YjcyODA1ZjYzZWEyODczYWY2MjRmM2EyZTk2YzI4YjJhMCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODU2NzJjN2QyZGUwYjdkYTJiZDE3NzBkODk2NjU4Njg3NDFiM2Y5YWY3NjQzMzk3NzIxZDc0ZDI4MTM0YWI4MycsXG4gICAgICAgICc3YzQ4MWI5YjViNDNiMmViNjM3NDA0OWJmYTYyYzJlNWU3N2YxN2ZjYzUyOThmNDRjOGUzMDk0Zjc5MDMxM2E2JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NDhiZjgwOWIxOTg4YTQ2YjA2YzlmMTkxOTQxM2IxMGY5MjI2YzYwZjY2ODgzMmZmZDk1OWFmNjBjODJhMGEnLFxuICAgICAgICAnNTNhNTYyODU2ZGNiNjY0NmRjNmI3NGM1ZDFjMzQxOGM2ZDRkZmYwOGM5N2NkMmJlZDRjYjdmODhkOGM4ZTU4OScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjI2MGNlN2Y0NjE4MDFjMzRmMDY3Y2UwZjAyODczYThmMWIwZTQ0ZGZjNjk3NTJhY2NlY2Q4MTlmMzhmZDhlOCcsXG4gICAgICAgICdiYzJkYTgyYjZmYTViNTcxYTdmMDkwNDk3NzZhMWVmN2VjZDI5MjIzODA1MWMxOThjMWE4NGU5NWIyYjRhZTE3JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlNTAzN2RlMGFmYzFkOGQ0M2Q4MzQ4NDE0YmJmNDEwMzA0M2VjOGY1NzViZmRjNDMyOTUzY2M4ZDIwMzdmYTJkJyxcbiAgICAgICAgJzQ1NzE1MzRiYWE5NGQzYjVmOWY5OGQwOWZiOTkwYmRkYmQ1ZjViMDNlYzQ4MWYxMGUwZTVkYzg0MWQ3NTViZGEnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2UwNjM3MmIwZjRhMjA3YWRmNWVhOTA1ZThmMTc3MWI0ZTdlOGRiZDFjNmE2YzViNzI1ODY2YTBhZTRmY2U3MjUnLFxuICAgICAgICAnN2E5MDg5NzRiY2UxOGNmZTEyYTI3YmIyYWQ1YTQ4OGNkNzQ4NGE3Nzg3MTA0ODcwYjI3MDM0Zjk0ZWVlMzFkZCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMjEzYzdhNzE1Y2Q1ZDQ1MzU4ZDBiYmY5ZGMwY2UwMjIwNGIxMGJkZGUyYTNmNTg1NDBhZDY5MDhkMDU1OTc1NCcsXG4gICAgICAgICc0YjZkYWQwYjVhZTQ2MjUwNzAxM2FkMDYyNDViYTE5MGJiNDg1MGY1ZjM2YTdlZWRkZmYyYzI3NTM0YjQ1OGYyJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZTdjMjcyYTdhZjRiMzRlOGRiYjkzNTJhNTQxOWE4N2UyODM4YzcwYWRjNjJjZGRmMGNjM2EzYjA4ZmJkNTNjJyxcbiAgICAgICAgJzE3NzQ5Yzc2NmM5ZDBiMThlMTZmZDA5ZjZkZWY2ODFiNTMwYjk2MTRiZmY3ZGQzM2UwYjM5NDE4MTdkY2FhZTYnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZlYTc0ZTNkYmU3NzhiMWIxMGYyMzhhZDYxNjg2YWE1Yzc2ZTNkYjJiZTQzMDU3NjMyNDI3ZTI4NDBmYjI3YjYnLFxuICAgICAgICAnNmUwNTY4ZGI5YjBiMTMyOTdjZjY3NGRlY2NiNmFmOTMxMjZiNTk2Yjk3M2Y3Yjc3NzAxZDNkYjdmMjNjYjk2ZicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzZlNjQxMTNmNjc3Y2YwZTEwYTI1NzBkNTk5OTY4ZDMxNTQ0ZTE3OWI3NjA0MzI5NTJjMDJhNDQxN2JkZGUzOScsXG4gICAgICAgICdjOTBkZGY4ZGVlNGU5NWNmNTc3MDY2ZDcwNjgxZjBkMzVlMmEzM2QyYjU2ZDIwMzJiNGIxNzUyZDE5MDFhYzAxJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNzM4YzU2YjAzYjJhYmUxZTgyODFiYWE3NDNmOGY5YThmN2NjNjQzZGYyNmNiZWUzYWIxNTAyNDJiY2JiODkxJyxcbiAgICAgICAgJzg5M2ZiNTc4OTUxYWQyNTM3ZjcxOGYyZWFjYmZiYmJiODIzMTRlZWY3ODgwY2ZlOTE3ZTczNWQ5Njk5YTg0YzMnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q4OTU2MjY1NDhiNjViODFlMjY0Yzc2MzdjOTcyODc3ZDFkNzJlNWYzYTkyNTAxNDM3MmU5ZjY1ODhmNmMxNGInLFxuICAgICAgICAnZmViZmFhMzhmMmJjN2VhZTcyOGVjNjA4MThjMzQwZWIwMzQyOGQ2MzJiYjA2N2UxNzkzNjNlZDc1ZDdkOTkxZicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjhkYTk0MDMyYTk1NzUxOGViMGY2NDMzNTcxZTg3NjFjZWZmYzczNjkzZTg0ZWRkNDkxNTBhNTY0ZjY3NmUwMycsXG4gICAgICAgICcyODA0ZGZhNDQ4MDVhMWU0ZDdjOTljYzk3NjI4MDhiMDkyY2M1ODRkOTVmZjNiNTExNDg4ZTRlNzRlZmRmNmU3JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlODBmZWExNDQ0MWZiMzNhN2Q4YWRhYjk0NzVkN2ZhYjIwMTllZmZiNTE1NmE3OTJmMWExMTc3OGUzYzBkZjVkJyxcbiAgICAgICAgJ2VlZDFkZTdmNjM4ZTAwNzcxZTg5NzY4Y2EzY2E5NDQ3MmQxNTVlODBhZjMyMmVhOWZjYjQyOTFiNmFjOWVjNzgnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2EzMDE2OTdiZGZjZDcwNDMxM2JhNDhlNTFkNTY3NTQzZjJhMTgyMDMxZWZkNjkxNWRkYzA3YmJjYzRlMTYwNzAnLFxuICAgICAgICAnNzM3MGY5MWNmYjY3ZTRmNTA4MTgwOWZhMjVkNDBmOWIxNzM1ZGJmN2MwYTExYTEzMGMwZDFhMDQxZTE3N2VhMScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTBhZDg1YjM4OWQ2YjkzNjQ2M2Y5ZDA1MTI2NzhkZTIwOGNjMzMwYjExMzA3ZmZmYWI3YWM2M2UzZmIwNGVkNCcsXG4gICAgICAgICdlNTA3YTM2MjBhMzgyNjFhZmZkY2JkOTQyNzIyMmI4MzlhZWZhYmUxNTgyODk0ZDk5MWQ0ZDQ4Y2I2ZWYxNTAnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhmNjhiOWQyZjYzYjVmMzM5MjM5YzFhZDk4MWYxNjJlZTg4YzU2Nzg3MjNlYTMzNTFiN2I0NDRjOWVjNGMwZGEnLFxuICAgICAgICAnNjYyYTlmMmRiYTA2Mzk4NmRlMWQ5MGMyYjZiZTIxNWRiYmVhMmNmZTk1NTEwYmZkZjIzY2JmNzk1MDFmZmY4MicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTRmM2ZiMDE3NmFmODVkNjVmZjk5ZmY5MTk4YzM2MDkxZjQ4ZTg2NTAzNjgxZTNlNjY4NmZkNTA1MzIzMWUxMScsXG4gICAgICAgICcxZTYzNjMzYWQwZWY0ZjFjMTY2MWE2ZDBlYTAyYjcyODZjYzdlNzRlYzk1MWQxYzk4MjJjMzg1NzZmZWI3M2JjJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YzAwZmE5YjE4ZWJmMzMxZWI5NjE1MzdhNDVhNDI2NmM3MDM0ZjJmMGQ0ZTFkMDcxNmZiNmVhZTIwZWFlMjllJyxcbiAgICAgICAgJ2VmYTQ3MjY3ZmVhNTIxYTFhOWRjMzQzYTM3MzZjOTc0YzJmYWRhZmE4MWUzNmM1NGU3ZDJhNGM2NjcwMjQxNGInLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U3YTI2Y2U2OWRkNDgyOWYzZTEwY2VjMGE5ZTk4ZWQzMTQzZDA4NGYzMDhiOTJjMDk5N2ZkZGZjNjBjYjNlNDEnLFxuICAgICAgICAnMmE3NThlMzAwZmE3OTg0YjQ3MWIwMDZhMWFhZmJiMThkMGE2YjJjMDQyMGU4M2UyMGU4YTk0MjFjZjJjZmQ1MScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjY0NTllMGVlMzY2MmVjOGQyMzU0MGMyMjNiY2JkYzU3MWNiY2I5NjdkNzk0MjRmM2NmMjllYjNkZTZiODBlZicsXG4gICAgICAgICc2N2M4NzZkMDZmM2UwNmRlMWRhZGYxNmU1NjYxZGIzYzRiM2FlNmQ0OGUzNWIyZmYzMGJmMGI2MWE3MWJhNDUnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q2OGE4MGM4MjgwYmI4NDA3OTMyMzRhYTExOGYwNjIzMWQ2ZjFmYzY3ZTczYzVhNWRlZGEwZjViNDk2OTQzZTgnLFxuICAgICAgICAnZGI4YmE5ZmZmNGI1ODZkMDBjNGIxZjkxNzdiMGUyOGI1YjBlN2I4Zjc4NDUyOTVhMjk0Yzg0MjY2YjEzMzEyMCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzI0YWVkN2RmNjVjODA0MjUyZGMwMjcwOTA3YTMwYjA5NjEyYWViOTczNDQ5Y2VhNDA5NTk4MGZjMjhkM2Q1ZCcsXG4gICAgICAgICc2NDhhMzY1Nzc0YjYxZjJmZjEzMGMwYzM1YWVjMWY0ZjE5MjEzYjBjN2UzMzI4NDM5NjcyMjRhZjk2YWI3Yzg0JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZGY5YzE0OTE5Y2RlNjFmNmQ1MWRmZGJlNWZlZTVkY2VlYzQxNDNiYThkMWNhODg4ZThiZDM3M2ZkMDU0Yzk2JyxcbiAgICAgICAgJzM1ZWM1MTA5MmQ4NzI4MDUwOTc0YzIzYTFkODVkNGI1ZDUwNmNkYzI4ODQ5MDE5MmViYWMwNmNhZDEwZDVkJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5YzM5MTlhODRhNDc0ODcwZmFlZDhhOWMxY2M2NjAyMTUyMzQ4OTA1NGQ3ZjAzMDhjYmZjOTljOGFjMWY5OGNkJyxcbiAgICAgICAgJ2RkYjg0ZjBmNGE0ZGRkNTc1ODRmMDQ0YmYyNjBlNjQxOTA1MzI2Zjc2YzY0YzhlNmJlN2U1ZTAzZDRmYzU5OWQnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYwNTcxNzBiMWRkMTJmZGY4ZGUwNWYyODFkOGUwNmJiOTFlMTQ5M2E4YjkxZDRjYzVhMjEzODIxMjBhOTU5ZTUnLFxuICAgICAgICAnOWExYWYwYjI2YTZhNDgwN2FkZDlhMmRhZjcxZGYyNjI0NjUxNTJiYzNlZTI0YzY1ZTg5OWJlOTMyMzg1YTJhOCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTU3NmRmOGUyM2EwODQxMTQyMTQzOWE0NTE4ZGEzMTg4MGNlZjBmYmE3ZDRkZjEyYjFhNjk3M2VlY2I5NDI2NicsXG4gICAgICAgICc0MGE2YmYyMGU3NjY0MGIyYzkyYjk3YWZlNThjZDgyYzQzMmUxMGE3ZjUxNGQ5ZjNlZThiZTExYWUxYjI4ZWM4JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3Nzc4YTc4YzI4ZGVjM2UzMGEwNWZlOTYyOWRlOGMzOGJiMzBkMWY1Y2Y5YTNhMjA4Zjc2Mzg4OWJlNThhZDcxJyxcbiAgICAgICAgJzM0NjI2ZDlhYjVhNWIyMmZmNzA5OGUxMmYyZmY1ODAwODdiMzg0MTFmZjI0YWM1NjNiNTEzZmMxZmQ5ZjQzYWMnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzkyODk1NWVlNjM3YTg0NDYzNzI5ZmQzMGU3YWZkMmVkNWY5NjI3NGU1YWQ3ZTVjYjA5ZWRhOWMwNmQ5MDNhYycsXG4gICAgICAgICdjMjU2MjEwMDNkM2Y0MmE4MjdiNzhhMTMwOTNhOTVlZWFjM2QyNmVmYThhOGQ4M2ZjNTE4MGU5MzViY2QwOTFmJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4NWQwZmVmM2VjNmRiMTA5Mzk5MDY0ZjNhMGUzYjI4NTU2NDViNGE5MDdhZDM1NDUyN2FhZTc1MTYzZDgyNzUxJyxcbiAgICAgICAgJzFmMDM2NDg0MTNhMzhjMGJlMjlkNDk2ZTU4MmNmNTY2M2U4NzUxZTk2ODc3MzMxNTgyYzIzN2EyNGViMWY5NjInLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZmMmIwZGNlOTdlZWNlOTdjMWM5YjYwNDE3OThiODVkZmRmYjZkODg4MmRhMjAzMDhmNTQwNDgyNDUyNjA4N2UnLFxuICAgICAgICAnNDkzZDEzZmVmNTI0YmExODhhZjRjNGRjNTRkMDc5MzZjN2I3ZWQ2ZmI5MGUyY2ViMmM5NTFlMDFmMGMyOTkwNycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODI3ZmJiZTRiMWU4ODBlYTllZDJiMmU2MzAxYjIxMmI1N2YxZWUxNDhjZDZkZDI4NzgwZTVlMmNmODU2ZTI0MScsXG4gICAgICAgICdjNjBmOWM5MjNjNzI3YjBiNzFiZWYyYzY3ZDFkMTI2ODdmZjdhNjMxODY5MDMxNjZkNjA1YjY4YmFlYzI5M2VjJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYWE2NDlmMjFmNTFiZGJhZTdiZTRhZTM0Y2U2ZTUyMTdhNThmZGNlN2Y0N2Y5YWE3ZjNiNThmYTIxMjBlMmIzJyxcbiAgICAgICAgJ2JlMzI3OWVkNWJiYmIwM2FjNjlhODBmODk4NzlhYTVhMDFhNmI5NjVmMTNmN2U1OWQ0N2E1MzA1YmE1YWQ5M2QnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U0YTQyZDQzYzVjZjE2OWQ5MzkxZGY2ZGVjZjQyZWU1NDFiNmQ4ZjBjOWExMzc0MDFlMjM2MzJkZGEzNGQyNGYnLFxuICAgICAgICAnNGQ5ZjkyZTcxNmQxYzczNTI2ZmM5OWNjZmI4YWQzNGNlODg2ZWVkZmE4ZDhlNGYxM2E3ZjcxMzFkZWJhOTQxNCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMWVjODBmZWYzNjBjYmRkOTU0MTYwZmFkYWIzNTJiNmI5MmI1MzU3NmE4OGZlYTQ5NDcxNzNiOWQ0MzAwYmYxOScsXG4gICAgICAgICdhZWVmZTkzNzU2YjUzNDBkMmYzYTQ5NThhN2FiYmY1ZTAxNDZlNzdmNjI5NWEwN2I2NzFjZGMxY2MxMDdjZWZkJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNDZhNzc4YzA0NjcwYzJmOTFiMDBhZjQ2ODBkZmE4YmNlMzQ5MDcxN2Q1OGJhODg5ZGRiNTkyODM2NjY0MmJlJyxcbiAgICAgICAgJ2IzMThlMGVjMzM1NDAyOGFkZDY2OTgyN2Y5ZDRiMjg3MGFhYTk3MWQyZjdlNWVkMWQwYjI5NzQ4M2Q4M2VmZDAnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ZhNTBjMGY2MWQyMmU1ZjA3ZTNhY2ViYjFhYTA3YjEyOGQwMDEyMjA5YTI4Yjk3NzZkNzZhODc5MzE4MGVlZjknLFxuICAgICAgICAnNmI4NGM2OTIyMzk3ZWJhOWI3MmNkMjg3MjI4MWE2OGE1ZTY4MzI5M2E1N2EyMTNiMzhjZDhkN2QzZjRmMjgxMScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGExZDYxZDBjYTcyMWExMWIxYTViZjZiN2Q4OGU4NDIxYTI4OGFiNWQ1YmJhNTIyMGU1M2QzMmI1ZjA2N2VjMicsXG4gICAgICAgICc4MTU3ZjU1YTdjOTkzMDZjNzljMDc2NjE2MWM5MWUyOTY2YTczODk5ZDI3OWI0OGE2NTVmYmEwZjFhZDgzNmYxJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhOGUyODJmZjBjOTcwNjkwNzIxNWZmOThlOGZkNDE2NjE1MzExZGUwNDQ2ZjFlMDYyYTczYjA2MTBkMDY0ZTEzJyxcbiAgICAgICAgJzdmOTczNTViOGRiODFjMDlhYmZiN2YzYzViMjUxNTg4OGI2NzlhM2U1MGRkNmJkNmNlZjdjNzMxMTFmNGNjMGMnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NGE1M2I5YzlhMjg1ODcyZDM5ZTU2ZTY5MTNjYWIxNWQ1OWIxZmE1MTI1MDhjMDIyZjM4MmRlODMxOTQ5N2MnLFxuICAgICAgICAnY2NjOWRjMzdhYmZjOWMxNjU3YjQxNTVmMmM0N2Y5ZTY2NDZiM2ExZDhjYjk4NTQzODNkYTEzYWMwNzlhZmE3MycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTU5Mzk2OTgxOTQzNzg1YzNkM2U1N2VkZjUwMThjZGJlMDM5ZTczMGU0OTE4YjNkODg0ZmRmZjA5NDc1YjdiYScsXG4gICAgICAgICcyZTdlNTUyODg4YzMzMWRkOGJhMDM4NmE0YjljZDY4NDljNjUzZjY0Yzg3MDkzODVlOWI4YWJmODc1MjRmMmZkJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMmE2M2E1MGFlNDAxZTU2ZDY0NWExMTUzYjEwOWE4ZmNjYTBhNDNkNTYxZmJhMmRiYjUxMzQwYzlkODJiMTUxJyxcbiAgICAgICAgJ2U4MmQ4NmZiNjQ0M2ZjYjc1NjVhZWU1OGIyOTQ4MjIwYTcwZjc1MGFmNDg0Y2E1MmQ0MTQyMTc0ZGNmODk0MDUnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzY0NTg3ZTIzMzU0NzFlYjg5MGVlNzg5NmQ3Y2ZkYzg2NmJhY2JkYmQzODM5MzE3YjM0MzZmOWI0NTYxN2UwNzMnLFxuICAgICAgICAnZDk5ZmNkZDViZjY5MDJlMmFlOTZkZDY0NDdjMjk5YTE4NWI5MGEzOTEzM2FlYWIzNTgyOTllNWU5ZmFmNjU4OScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQ4MWJkZTBlNGU0ZDg4NWIzYTU0NmQzZTU0OWRlMDQyZjBhYTZjZWEyNTBlN2ZkMzU4ZDZjODZkZDQ1ZTQ1OCcsXG4gICAgICAgICczOGVlN2I4Y2JhNTQwNGRkODRhMjViZjM5Y2VjYjJjYTkwMGE3OWM0MmIyNjJlNTU2ZDY0YjFiNTk3NzkwNTdlJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMzQ2NGE1N2E3ODEwMmFhNjJiNjk3OWFlODE3ZjQ2MzdmZmNmZWQzYzRiMWNlMzBiY2Q2MzAzZjZjYWY2NjZiJyxcbiAgICAgICAgJzY5YmUxNTkwMDQ2MTQ1ODBlZjdlNDMzNDUzY2NiMGNhNDhmMzAwYTgxZDA5NDJlMTNmNDk1YTkwN2Y2ZWNjMjcnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2JjNGE5ZGY1YjcxM2ZlMmU5YWVmNDMwYmNjMWRjOTdhMGNkOWNjZWRlMmYyODU4OGNhZGEzYTBkMmQ4M2YzNjYnLFxuICAgICAgICAnZDNhODFjYTZlNzg1YzA2MzgzOTM3YWRmNGI3OThjYWE2ZThhOWZiZmE1NDdiMTZkNzU4ZDY2NjU4MWYzM2MxJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4YzI4YTk3YmY4Mjk4YmMwZDIzZDhjNzQ5NDUyYTMyZTY5NGI2NWUzMGE5NDcyYTM5NTRhYjMwZmU1MzI0Y2FhJyxcbiAgICAgICAgJzQwYTMwNDYzYTMzMDUxOTMzNzhmZWRmMzFmN2NjMGViN2FlNzg0ZjA0NTFjYjk0NTllNzFkYzczY2JlZjk0ODInLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhlYTk2NjYxMzk1MjdhOGMxZGQ5NGNlNGYwNzFmZDIzYzhiMzUwYzVhNGJiMzM3NDhjNGJhMTExZmFjY2FlMCcsXG4gICAgICAgICc2MjBlZmFiYmM4ZWUyNzgyZTI0ZTdjMGNmYjk1YzVkNzM1Yjc4M2JlOWNmMGY4ZTk1NWFmMzRhMzBlNjJiOTQ1JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZDM2MjVmYWVmNWJhMDYwNzQ2Njk3MTZiYmQzNzg4ZDg5YmRkZTgxNTk1OTk2ODA5MmY3NmNjNGViOWE5Nzg3JyxcbiAgICAgICAgJzdhMTg4ZmEzNTIwZTMwZDQ2MWRhMjUwMTA0NTczMWNhOTQxNDYxOTgyODgzMzk1OTM3ZjY4ZDAwYzY0NGE1NzMnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Y3MTBkNzlkOWViOTYyMjk3ZTRmNjIzMmI0MGU4ZjdmZWIyYmM2MzgxNDYxNGQ2OTJjMTJkZTc1MjQwODIyMWUnLFxuICAgICAgICAnZWE5OGU2NzIzMmQzYjMyOTVkM2I1MzU1MzIxMTVjY2FjODYxMmM3MjE4NTE2MTc1MjZhZTQ3YTljNzdiZmM4MicsXG4gICAgICBdLFxuICAgIF0sXG4gIH0sXG4gIG5hZjoge1xuICAgIHduZDogNyxcbiAgICBwb2ludHM6IFtcbiAgICAgIFtcbiAgICAgICAgJ2Y5MzA4YTAxOTI1OGMzMTA0OTM0NGY4NWY4OWQ1MjI5YjUzMWM4NDU4MzZmOTliMDg2MDFmMTEzYmNlMDM2ZjknLFxuICAgICAgICAnMzg4ZjdiMGY2MzJkZTgxNDBmZTMzN2U2MmEzN2YzNTY2NTAwYTk5OTM0YzIyMzFiNmNiOWZkNzU4NGI4ZTY3MicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMmY4YmRlNGQxYTA3MjA5MzU1YjRhNzI1MGE1YzUxMjhlODhiODRiZGRjNjE5YWI3Y2JhOGQ1NjliMjQwZWZlNCcsXG4gICAgICAgICdkOGFjMjIyNjM2ZTVlM2Q2ZDRkYmE5ZGRhNmM5YzQyNmY3ODgyNzFiYWIwZDY4NDBkY2E4N2QzYWE2YWM2MmQ2JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1Y2JkZjA2NDZlNWRiNGVhYTM5OGYzNjVmMmVhN2EwZTNkNDE5YjdlMDMzMGUzOWNlOTJiZGRlZGNhYzRmOWJjJyxcbiAgICAgICAgJzZhZWJjYTQwYmEyNTU5NjBhMzE3OGQ2ZDg2MWE1NGRiYTgxM2QwYjgxM2ZkZTdiNWE1MDgyNjI4MDg3MjY0ZGEnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2FjZDQ4NGUyZjBjN2Y2NTMwOWFkMTc4YTlmNTU5YWJkZTA5Nzk2OTc0YzU3ZTcxNGMzNWYxMTBkZmMyN2NjYmUnLFxuICAgICAgICAnY2MzMzg5MjFiMGE3ZDlmZDY0MzgwOTcxNzYzYjYxZTlhZGQ4ODhhNDM3NWY4ZTBmMDVjYzI2MmFjNjRmOWMzNycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc0YWU3Zjg1OGE5NDExZTVlZjQyNDZiNzBjNjVhYWM1NjQ5OTgwYmU1YzE3ODkxYmJlYzE3ODk1ZGEwMDhjYicsXG4gICAgICAgICdkOTg0YTAzMmViNmI1ZTE5MDI0M2RkNTZkN2I3YjM2NTM3MmRiMWUyZGZmOWQ2YTgzMDFkNzRjOWM5NTNjNjFiJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmMjg3NzNjMmQ5NzUyODhiYzdkMWQyMDVjMzc0ODY1MWIwNzVmYmM2NjEwZTU4Y2RkZWVkZGY4ZjE5NDA1YWE4JyxcbiAgICAgICAgJ2FiMDkwMmU4ZDg4MGE4OTc1ODIxMmViNjVjZGFmNDczYTFhMDZkYTUyMWZhOTFmMjliNWNiNTJkYjAzZWQ4MScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDc5MjRkNGY3ZDQzZWE5NjVhNDY1YWUzMDk1ZmY0MTEzMWU1OTQ2ZjNjODVmNzllNDRhZGJjZjhlMjdlMDgwZScsXG4gICAgICAgICc1ODFlMjg3MmE4NmM3MmE2ODM4NDJlYzIyOGNjNmRlZmVhNDBhZjJiZDg5NmQzYTVjNTA0ZGM5ZmY2YTI2YjU4JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkZWZkZWE0Y2RiNjc3NzUwYTQyMGZlZTgwN2VhY2YyMWViOTg5OGFlNzliOTc2ODc2NmU0ZmFhMDRhMmQ0YTM0JyxcbiAgICAgICAgJzQyMTFhYjA2OTQ2MzUxNjhlOTk3YjBlYWQyYTkzZGFlY2VkMWY0YTA0YTk1YzBmNmNmYjE5OWY2OWU1NmViNzcnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzJiNGVhMGE3OTdhNDQzZDI5M2VmNWNmZjQ0NGY0OTc5ZjA2YWNmZWJkN2U4NmQyNzc0NzU2NTYxMzgzODViNmMnLFxuICAgICAgICAnODVlODliYzAzNzk0NWQ5M2IzNDMwODNiNWExYzg2MTMxYTAxZjYwYzUwMjY5NzYzYjU3MGM4NTRlNWMwOWI3YScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzUyYmJmNGE0Y2RkMTI1NjRmOTNmYTMzMmNlMzMzMzAxZDlhZDQwMjcxZjgxMDcxODEzNDBhZWYyNWJlNTlkNScsXG4gICAgICAgICczMjFlYjQwNzUzNDhmNTM0ZDU5YzE4MjU5ZGRhM2UxZjRhMWIzYjJlNzFiMTAzOWM2N2JkM2Q4YmNmODE5OThjJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyZmEyMTA0ZDZiMzhkMTFiMDIzMDAxMDU1OTg3OTEyNGU0MmFiOGRmZWZmNWZmMjlkYzljZGFkZDRlY2FjYzNmJyxcbiAgICAgICAgJzJkZTEwNjgyOTVkZDg2NWI2NDU2OTMzNWJkNWRkODAxODFkNzBlY2ZjODgyNjQ4NDIzYmE3NmI1MzJiN2Q2NycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOTI0ODI3OWIwOWI0ZDY4ZGFiMjFhOWIwNjZlZGRhODMyNjNjM2Q4NGUwOTU3MmUyNjljYTBjZDdmNTQ1MzcxNCcsXG4gICAgICAgICc3MzAxNmY3YmYyMzRhYWRlNWQxYWE3MWJkZWEyYjFmZjNmYzBkZTJhODg3OTEyZmZlNTRhMzJjZTk3Y2IzNDAyJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYWVkNGYyYmUzYThiZjI3OGU3MDEzMmZiMGJlYjc1MjJmNTcwZTE0NGJmNjE1YzA3ZTk5NmQ0NDNkZWU4NzI5JyxcbiAgICAgICAgJ2E2OWRjZTRhN2Q2Yzk4ZThkNGExYWNhODdlZjhkNzAwM2Y4M2MyMzBmM2FmYTcyNmFiNDBlNTIyOTBiZTFjNTUnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0NGQxMmM3MDY1ZDgxMmU4YWNmMjhkN2NiYjE5ZjkwMTFlY2Q5ZTlmZGYyODFiMGU2YTNiNWU4N2QyMmU3ZGInLFxuICAgICAgICAnMjExOWE0NjBjZTMyNmNkYzc2YzQ1OTI2Yzk4MmZkYWMwZTEwNmU4NjFlZGY2MWM1YTAzOTA2M2YwZTBlNjQ4MicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNmEyNDViZjZkYzY5ODUwNGM4OWEyMGNmZGVkNjA4NTMxNTJiNjk1MzM2YzI4MDYzYjYxYzY1Y2JkMjY5ZTZiNCcsXG4gICAgICAgICdlMDIyY2Y0MmMyYmQ0YTcwOGIzZjUxMjZmMTZhMjRhZDhiMzNiYTQ4ZDA0MjNiNmVmZDVlNjM0ODEwMGQ4YTgyJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNjk3ZmZhNmZkOWRlNjI3YzA3N2UzZDJmZTU0MTA4NGNlMTMzMDBiMGJlYzExNDZmOTVhZTU3ZjBkMGJkNmE1JyxcbiAgICAgICAgJ2I5YzM5OGYxODY4MDZmNWQyNzU2MTUwNmU0NTU3NDMzYTJjZjE1MDA5ZTQ5OGFlN2FkZWU5ZDYzZDAxYjIzOTYnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzYwNWJkYjAxOTk4MTcxOGI5ODZkMGYwN2U4MzRjYjBkOWRlYjgzNjBmZmI3ZjYxZGY5ODIzNDVlZjI3YTc0NzknLFxuICAgICAgICAnMjk3MmQyZGU0ZjhkMjA2ODFhNzhkOTNlYzk2ZmUyM2MyNmJmYWU4NGZiMTRkYjQzYjAxZTFlOTA1NmI4YzQ5JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2MmQxNGRhYjQxNTBiZjQ5NzQwMmZkYzQ1YTIxNWUxMGRjYjAxYzM1NDk1OWIxMGNmZTMxYzdlOWQ4N2ZmMzNkJyxcbiAgICAgICAgJzgwZmMwNmJkOGNjNWIwMTA5ODA4OGExOTUwZWVkMGRiMDFhYTEzMjk2N2FiNDcyMjM1ZjU2NDI0ODNiMjVlYWYnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzgwYzYwYWQwMDQwZjI3ZGFkZTViNGIwNmM0MDhlNTZiMmM1MGU5ZjU2YjliOGI0MjVlNTU1YzJmODYzMDhiNmYnLFxuICAgICAgICAnMWMzODMwM2YxY2M1YzMwZjI2ZTY2YmFkN2ZlNzJmNzBhNjVlZWQ0Y2JlNzAyNGViMWFhMDFmNTY0MzBiZDU3YScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnN2E5Mzc1YWQ2MTY3YWQ1NGFhNzRjNjM0OGNjNTRkMzQ0Y2M1ZGM5NDg3ZDg0NzA0OWQ1ZWFiYjBmYTAzYzhmYicsXG4gICAgICAgICdkMGUzZmE5ZWNhODcyNjkwOTU1OWUwZDc5MjY5MDQ2YmRjNTllYTEwYzcwY2UyYjAyZDQ5OWVjMjI0ZGM3ZjcnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2Q1MjhlY2Q5YjY5NmI1NGM5MDdhOWVkMDQ1NDQ3YTc5YmI0MDhlYzM5YjY4ZGY1MDRiYjUxZjQ1OWJjM2ZmYzknLFxuICAgICAgICAnZWVjZjQxMjUzMTM2ZTVmOTk5NjZmMjE4ODFmZDY1NmViYzQzNDU0MDVjNTIwZGJjMDYzNDY1YjUyMTQwOTkzMycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDkzNzBhNGI1ZjQzNDEyZWEyNWY1MTRlOGVjZGFkMDUyNjYxMTVlNGE3ZWNiMTM4NzIzMTgwOGY4YjQ1OTYzJyxcbiAgICAgICAgJzc1OGYzZjQxYWZkNmVkNDI4YjMwODFiMDUxMmZkNjJhNTRjM2YzYWZiYjViNjc2NGI2NTMwNTJhMTI5NDljOWEnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc3ZjIzMDkzNmVlODhjYmJkNzNkZjkzMGQ2NDcwMmVmODgxZDgxMWUwZTE0OThlMmYxYzEzZWIxZmMzNDVkNzQnLFxuICAgICAgICAnOTU4ZWY0MmE3ODg2YjY0MDBhMDgyNjZlOWJhMWIzNzg5NmM5NTMzMGQ5NzA3N2NiYmU4ZWIzYzc2NzFjNjBkNicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZjJkYWM5OTFjYzRjZTRiOWVhNDQ4ODdlNWM3YzBiY2U1OGM4MDA3NGFiOWQ0ZGJhZWIyODUzMWI3NzM5ZjUzMCcsXG4gICAgICAgICdlMGRlZGM5YjNiMmY4ZGFkNGRhMWYzMmRlYzI1MzFkZjllYjVmYmViMDU5OGU0ZmQxYTExN2RiYTcwM2EzYzM3JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0NjNiM2Q5ZjY2MjYyMWZiMWI0YmU4ZmJiZTI1MjAxMjVhMjE2Y2RmYzlkYWUzZGViY2JhNDg1MGM2OTBkNDViJyxcbiAgICAgICAgJzVlZDQzMGQ3OGMyOTZjMzU0MzExNDMwNmRkODYyMmQ3YzYyMmUyN2M5NzBhMWRlMzFjYjM3N2IwMWFmNzMwN2UnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YxNmY4MDQyNDRlNDZlMmEwOTIzMmQ0YWZmM2I1OTk3NmI5OGZhYzE0MzI4YTJkMWEzMjQ5NmI0OTk5OGYyNDcnLFxuICAgICAgICAnY2VkYWJkOWI4MjIwM2Y3ZTEzZDIwNmZjZGY0ZTMzZDkyYTZjNTNjMjZlNWNjZTI2ZDY1Nzk5NjJjNGUzMWRmNicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2FmNzU0MjcyZGM4NDU2M2IwMzUyYjdhMTQzMTFhZjU1ZDI0NTMxNWFjZTI3YzY1MzY5ZTE1ZjcxNTFkNDFkMScsXG4gICAgICAgICdjYjQ3NDY2MGVmMzVmNWYyYTQxYjY0M2ZhNWU0NjA1NzVmNGZhOWI3OTYyMjMyYTVjMzJmOTA4MzE4YTA0NDc2JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyNjAwY2E0YjI4MmNiOTg2Zjg1ZDBmMTcwOTk3OWQ4YjQ0YTA5YzA3Y2I4NmQ3YzEyNDQ5N2JjODZmMDgyMTIwJyxcbiAgICAgICAgJzQxMTliODg3NTNjMTViZDZhNjkzYjAzZmNkZGJiNDVkNWFjNmJlNzRhYjVmMGVmNDRiMGJlOTQ3NWE3ZTRiNDAnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc2MzVjYTcyZDdlODQzMmMzMzhlYzUzY2QxMjIyMGJjMDFjNDg2ODVlMjRmN2RjOGM2MDJhNzc0Njk5OGU0MzUnLFxuICAgICAgICAnOTFiNjQ5NjA5NDg5ZDYxM2QxZDVlNTkwZjc4ZTZkNzRlY2ZjMDYxZDU3MDQ4YmFkOWU3NmYzMDJjNWI5YzYxJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NTRlMzIzOWYzMjU1NzBjZGJiZjRhODdkZWVlOGE2NmI3ZjJiMzM0NzlkNDY4ZmJjMWE1MDc0M2JmNTZjYzE4JyxcbiAgICAgICAgJzY3M2ZiODZlNWJkYTMwZmIzY2QwZWQzMDRlYTQ5YTAyM2VlMzNkMDE5N2E2OTVkMGM1ZDk4MDkzYzUzNjY4MycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTNlNmJkMTA3MWExZTk2YWZmNTc4NTljODJkNTcwZjAzMzA4MDA2NjFkMWM5NTJmOWZlMjY5NDY5MWQ5YjllOCcsXG4gICAgICAgICc1OWM5ZTBiYmEzOTRlNzZmNDBjMGFhNTgzNzlhM2NiNmE1YTIyODM5OTNlOTBjNDE2NzAwMmFmNDkyMGUzN2Y1JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxODZiNDgzZDA1NmEwMzM4MjZhZTczZDg4ZjczMjk4NWM0Y2NiMWYzMmJhMzVmNGI0Y2M0N2ZkY2YwNGFhNmViJyxcbiAgICAgICAgJzNiOTUyZDMyYzY3Y2Y3N2UyZTE3NDQ2ZTIwNDE4MGFiMjFmYjgwOTA4OTUxMzhiNGE0YTc5N2Y4NmU4MDg4OGInLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2RmOWQ3MGE2Yjk4NzZjZTU0NGM5ODU2MWY0YmU0ZjcyNTQ0MmU2ZDJiNzM3ZDljOTFhODMyMTcyNGNlMDk2M2YnLFxuICAgICAgICAnNTVlYjJkYWZkODRkNmNjZDVmODYyYjc4NWRjMzlkNGFiMTU3MjIyNzIwZWY5ZGEyMTdiOGM0NWNmMmJhMjQxNycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNWVkZDVjYzIzYzUxZTg3YTQ5N2NhODE1ZDVkY2UwZjhhYjUyNTU0Zjg0OWVkODk5NWRlNjRjNWYzNGNlNzE0MycsXG4gICAgICAgICdlZmFlOWM4ZGJjMTQxMzA2NjFlOGNlYzAzMGM4OWFkMGMxM2M2NmMwZDE3YTI5MDVjZGM3MDZhYjczOTlhODY4JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyOTA3OThjMmI2NDc2ODMwZGExMmZlMDIyODdlOWU3NzdhYTNmYmExYzM1NWIxN2E3MjJkMzYyZjg0NjE0ZmJhJyxcbiAgICAgICAgJ2UzOGRhNzZkY2Q0NDA2MjE5ODhkMDBiY2Y3OWFmMjVkNWIyOWMwOTRkYjJhMjMxNDZkMDAzYWZkNDE5NDNlN2EnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2FmM2M0MjNhOTVkOWY1YjMwNTQ3NTRlZmExNTBhYzM5Y2QyOTU1MmZlMzYwMjU3MzYyZGZkZWNlZjQwNTNiNDUnLFxuICAgICAgICAnZjk4YTNmZDgzMWViMmI3NDlhOTNiMGU2ZjM1Y2ZiNDBjOGNkNWFhNjY3YTE1NTgxYmMyZmVkZWQ0OThmZDljNicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzY2ZGJiMjRkMTM0ZTc0NWNjY2FhMjhjOTliZjI3NDkwNmJiNjZiMjZkY2Y5OGRmOGQyZmVkNTBkODg0MjQ5YScsXG4gICAgICAgICc3NDRiMTE1MmVhY2JlNWUzOGRjYzg4Nzk4MGRhMzhiODk3NTg0YTY1ZmEwNmNlZGQyYzkyNGY5N2NiYWM1OTk2JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1OWRiZjQ2ZjhjOTQ3NTliYTIxMjc3YzMzNzg0ZjQxNjQ1ZjdiNDRmNmM1OTZhNThjZTkyZTY2NjE5MWFiZTNlJyxcbiAgICAgICAgJ2M1MzRhZDQ0MTc1ZmJjMzAwZjRlYTZjZTY0ODMwOWEwNDJjZTczOWE3OTE5Nzk4Y2Q4NWUyMTZjNGEzMDdmNmUnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YxM2FkYTk1MTAzYzQ1MzczMDVlNjkxZTc0ZTlhNGE4ZGQ2NDdlNzExYTk1ZTczY2I2MmRjNjAxOGNmZDg3YjgnLFxuICAgICAgICAnZTEzODE3YjQ0ZWUxNGRlNjYzYmY0YmM4MDgzNDFmMzI2OTQ5ZTIxYTZhNzVjMjU3MDc3ODQxOWJkYWY1NzMzZCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzc1NGI0ZmEwZThhY2VkMDZkNDE2N2EyYzU5Y2NhNGNkYTE4NjljMDZlYmFkZmI2NDg4NTUwMDE1YTg4NTIyYycsXG4gICAgICAgICczMGU5M2U4NjRlNjY5ZDgyMjI0Yjk2N2MzMDIwYjhmYThkMWU0ZTM1MGI2Y2JjYzUzN2E0OGI1Nzg0MTE2M2EyJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5NDhkY2FkZjU5OTBlMDQ4YWEzODc0ZDQ2YWJlZjlkNzAxODU4Zjk1ZGU4MDQxZDJhNjgyOGM5OWUyMjYyNTE5JyxcbiAgICAgICAgJ2U0OTFhNDI1MzdmNmU1OTdkNWQyOGEzMjI0YjFiYzI1ZGY5MTU0ZWZiZDJlZjFkMmNiYmEyY2FlNTM0N2Q1N2UnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc5NjI0MTQ0NTBjNzZjMTY4OWM3YjQ4ZjgyMDJlYzM3ZmIyMjRjZjVhYzBiZmExNTcwMzI4YThhM2Q3Yzc3YWInLFxuICAgICAgICAnMTAwYjYxMGVjNGZmYjQ3NjBkNWMxZmMxMzNlZjZmNmIxMjUwN2EwNTFmMDRhYzU3NjBhZmE1YjI5ZGI4MzQzNycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzUxNDA4NzgzNDk2NGI1NGIxNWIxNjA2NDRkOTE1NDg1YTE2OTc3MjI1Yjg4NDdiYjBkZDA4NTEzN2VjNDdjYScsXG4gICAgICAgICdlZjBhZmJiMjA1NjIwNTQ0OGUxNjUyYzQ4ZTgxMjdmYzYwMzllNzdjMTVjMjM3OGI3ZTdkMTVhMGRlMjkzMzExJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkM2NjMzBhZDZiNDgzZTRiYzc5Y2UyYzlkZDhiYzU0OTkzZTk0N2ViOGRmNzg3YjQ0Mjk0M2QzZjdiNTI3ZWFmJyxcbiAgICAgICAgJzhiMzc4YTIyZDgyNzI3OGQ4OWM1ZTliZThmOTUwOGFlM2MyYWQ0NjI5MDM1ODYzMGFmYjM0ZGIwNGVlZGUwYTQnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE2MjRkODQ3ODA3MzI4NjBjZTFjNzhmY2JmZWZlMDhiMmIyOTgyM2RiOTEzZjY0OTM5NzViYTBmZjQ4NDc2MTAnLFxuICAgICAgICAnNjg2NTFjZjliNmRhOTAzZTA5MTQ0NDhjNmNkOWQ0Y2E4OTY4NzhmNTI4MmJlNGM4Y2MwNmUyYTQwNDA3ODU3NScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzMzY2U4MGRhOTU1YThhMjY5MDJjOTU2MzNlNjJhOTg1MTkyNDc0YjVhZjIwN2RhNmRmN2I0ZmQ1ZmM2MWNkNCcsXG4gICAgICAgICdmNTQzNWEyYmQyYmFkZjdkNDg1YTRkOGI4ZGI5ZmNjZTNlMWVmOGUwMjAxZTQ1NzhjNTQ2NzNiYzFkYzVlYTFkJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNWQ5NDQxMjU0OTQ1MDY0Y2YxYTFjMzNiYmQzYjQ5Zjg5NjZjNTA5MjE3MWU2OTllZjI1OGRmYWI4MWMwNDVjJyxcbiAgICAgICAgJ2Q1NmViMzBiNjk0NjNlNzIzNGY1MTM3YjczYjg0MTc3NDM0ODAwYmFjZWJmYzY4NWZjMzdiYmU5ZWZlNDA3MGQnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2ExZDBmY2YyZWM5ZGU2NzViNjEyMTM2ZTVjZTcwZDI3MWMyMTQxN2M5ZDJiOGFhYWFjMTM4NTk5ZDA3MTc5NDAnLFxuICAgICAgICAnZWRkNzdmNTBiY2I1YTNjYWIyZTkwNzM3MzA5NjY3ZjI2NDE0NjJhNTQwNzBmM2Q1MTkyMTJkMzljMTk3YTYyOScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTIyZmJlMTVjMGFmOGNjYzU3ODBjMDczNWY4NGRiZTlhNzkwYmFkZWU4MjQ1YzA2YzdjYTM3MzMxY2IzNjk4MCcsXG4gICAgICAgICdhODU1YmFiYWQ1Y2Q2MGM4OGI0MzBhNjlmNTNhMWE3YTM4Mjg5MTU0OTY0Nzk5YmU0M2QwNmQ3N2QzMWRhMDYnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMxMTA5MWRkOTg2MGU4ZTIwZWUxMzQ3M2MxMTU1ZjVmNjk2MzVlMzk0NzA0ZWFhNzQwMDk0NTIyNDZjZmE5YjMnLFxuICAgICAgICAnNjZkYjY1NmY4N2QxZjA0ZmZmZDFmMDQ3ODhjMDY4MzA4NzFlYzVhNjRmZWVlNjg1YmQ4MGYwYjEyODZkODM3NCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzRjMWZkMDRkMzAxYmU4OWIzMWMwNDQyZDNlNmFjMjQ4ODM5MjhiNDVhOTM0MDc4MTg2N2Q0MjMyZWMyZGJkZicsXG4gICAgICAgICc5NDE0Njg1ZTk3YjFiNTk1NGJkNDZmNzMwMTc0MTM2ZDU3ZjFjZWViNDg3NDQzZGM1MzIxODU3YmE3M2FiZWUnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2YyMTllYTVkNmI1NDcwMWMxYzE0ZGU1YjU1N2ViNDJhOGQxM2YzYWJiY2QwOGFmZmNjMmE1ZTZiMDQ5YjhkNjMnLFxuICAgICAgICAnNGNiOTU5NTdlODNkNDBiMGY3M2FmNDU0NGNjY2Y2YjFmNGIwOGQzYzA3YjI3ZmI4ZDhjMjk2MmE0MDA3NjZkMScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDdiODc0MGY3NGE4ZmJhYWIxZjY4M2RiOGY0NWRlMjY1NDNhNTQ5MGJjYTYyNzA4NzIzNjkxMjQ2OWEwYjQ0OCcsXG4gICAgICAgICdmYTc3OTY4MTI4ZDljOTJlZTEwMTBmMzM3YWQ0NzE3ZWZmMTVkYjVlZDNjMDQ5YjM0MTFlMDMxNWVhYTQ1OTNiJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMmQzMWMyMjJmOGY2ZjBlZjg2ZjdjOThkM2EzMzM1ZWFkNWJjZDMyYWJkZDk0Mjg5ZmU0ZDMwOTFhYTgyNGJmJyxcbiAgICAgICAgJzVmMzAzMmY1ODkyMTU2ZTM5Y2NkM2Q3OTE1YjllMWRhMmU2ZGFjOWU2ZjI2ZTk2MTExOGQxNGI4NDYyZTE2NjEnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzc0NjFmMzcxOTE0YWIzMjY3MTA0NWExNTVkOTgzMWVhODc5M2Q3N2NkNTk1OTJjNDM0MGY4NmNiYzE4MzQ3YjUnLFxuICAgICAgICAnOGVjMGJhMjM4Yjk2YmVjMGNiZGRkY2FlMGFhNDQyNTQyZWVlMWZmNTBjOTg2ZWE2YjM5ODQ3YjNjYzA5MmZmNicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWUwNzlhZGIxZGYxODYwMDc0MzU2YTI1YWEzODIwNmE2ZDcxNmIyYzNlNjc0NTNkMjg3Njk4YmFkN2IyYjJkNicsXG4gICAgICAgICc4ZGMyNDEyYWFmZTNiZTVjNGM1ZjM3ZTBlY2M1ZjlmNmE0NDY5ODlhZjA0YzRlMjVlYmFhYzQ3OWVjMWM4YzFlJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxNmVjOTNlNDQ3ZWM4M2YwNDY3YjE4MzAyZWU2MjBmN2U2NWRlMzMxODc0YzlkYzcyYmZkODYxNmJhOWRhNmI1JyxcbiAgICAgICAgJzVlNDYzMTE1MGU2MmZiNDBkMGU4YzJhN2NhNTgwNGEzOWQ1ODE4NmE1MGU0OTcxMzk2MjY3NzhlMjViMDY3NGQnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VhYTVmOTgwYzI0NWY2ZjAzODk3ODI5MGFmYTcwYjZiZDg4NTU4OTdmOThiNmFhNDg1Yjk2MDY1ZDUzN2JkOTknLFxuICAgICAgICAnZjY1ZjVkM2UyOTJjMmUwODE5YTUyODM5MWM5OTQ2MjRkNzg0ODY5ZDdlNmVhNjdmYjE4MDQxMDI0ZWRjMDdkYycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzhjOTQwNzU0NGFjMTMyNjkyZWUxOTEwYTAyNDM5OTU4YWUwNDg3NzE1MTM0MmVhOTZjNGI2YjM1YTQ5ZjUxJyxcbiAgICAgICAgJ2YzZTAzMTkxNjllYjliODVkNTQwNDc5NTUzOWE1ZTY4ZmExZmJkNTgzYzA2NGQyNDYyYjY3NWYxOTRhM2RkYjQnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ5NGY0YmUyMTlhMWE3NzAxNmRjZDgzODQzMWFlYTAwMDFjZGM4YWU3YTZmYzY4ODcyNjU3OGQ5NzAyODU3YTUnLFxuICAgICAgICAnNDIyNDJhOTY5MjgzYTVmMzM5YmE3ZjA3NWUzNmJhMmFmOTI1Y2UzMGQ3NjdlZDZlNTVmNGIwMzE4ODBkNTYyYycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTU5OGE4MDMwZGE2ZDg2YzZiYzdmMmY1MTQ0ZWE1NDlkMjgyMTFlYTU4ZmFhNzBlYmY0YzFlNjY1YzFmZTliNScsXG4gICAgICAgICcyMDRiNWQ2Zjg0ODIyYzMwN2U0YjRhNzE0MDczN2FlYzIzZmM2M2I2NWIzNWY4NmExMDAyNmRiZDJkODY0ZTZiJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNDE5MTYzNjVhYmIyYjVkMDkxOTJmNWYyZGJlYWZlYzIwOGYwMjBmMTI1NzBhMTg0ZGJhZGMzZTU4NTk1OTk3JyxcbiAgICAgICAgJzRmMTQzNTFkMDA4N2VmYTQ5ZDI0NWIzMjg5ODQ5ODlkNWNhZjk0NTBmMzRiZmMwZWQxNmU5NmI1OGZhOTkxMycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODQxZDYwNjNhNTg2ZmE0NzVhNzI0NjA0ZGEwM2JjNWI5MmEyZTBkMmUwYTM2YWNmZTRjNzNhNTUxNDc0Mjg4MScsXG4gICAgICAgICc3Mzg2N2Y1OWMwNjU5ZTgxOTA0ZjlhMWM3NTQzNjk4ZTYyNTYyZDY3NDRjMTY5Y2U3YTM2ZGUwMWE4ZDYxNTQnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzVlOTViYjM5OWE2OTcxZDM3NjAyNjk0N2Y4OWJkZTJmMjgyYjMzODEwOTI4YmU0ZGVkMTEyYWM0ZDcwZTIwZDUnLFxuICAgICAgICAnMzlmMjNmMzY2ODA5MDg1YmVlYmZjNzExODEzMTM3NzVhOTljOWFlZDdkOGJhMzhiMTYxMzg0Yzc0NjAxMjg2NScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzZlNDY0MWE1Mzk0OGZkNDc2YzM5ZjhhOTlmZDk3NGU1ZWMwNzU2NGI1MzE1ZDhiZjk5NDcxYmNhMGVmMmY2NicsXG4gICAgICAgICdkMjQyNGIxYjFhYmU0ZWI4MTY0MjI3YjA4NWM5YWE5NDU2ZWExMzQ5M2ZkNTYzZTA2ZmQ1MWNmNTY5NGM3OGZjJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczMzY1ODFlYTdiZmJiYjI5MGMxOTFhMmY1MDdhNDFjZjU2NDM4NDIxNzBlOTE0ZmFlYWIyN2MyYzU3OWY3MjYnLFxuICAgICAgICAnZWFkMTIxNjg1OTVmZTFiZTk5MjUyMTI5YjZlNTZiMzM5MWY3YWIxNDEwY2QxZTBlZjNkY2RjYWJkMmZkYTIyNCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOGFiODk4MTZkYWRmZDZiNmExZjI2MzRmY2YwMGVjODQwMzc4MTAyNWVkNjg5MGM0ODQ5NzQyNzA2YmQ0M2VkZScsXG4gICAgICAgICc2ZmRjZWYwOWYyZjZkMGEwNDRlNjU0YWVmNjI0MTM2ZjUwM2Q0NTljM2U4OTg0NTg1OGE0N2E5MTI5Y2RkMjRlJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxZTMzZjFhNzQ2YzljNTc3ODEzMzM0NGQ5Mjk5ZmNhYTIwYjA5MzhlOGFjZmYyNTQ0YmI0MDI4NGI4YzVmYjk0JyxcbiAgICAgICAgJzYwNjYwMjU3ZGQxMWIzYWE5YzhlZDYxOGQyNGVkZmYyMzA2ZDMyMGYxZDAzMDEwZTMzYTdkMjA1N2YzYjNiNicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnODViN2MxZGNiM2NlYzFiN2VlN2YzMGRlZDc5ZGQyMGEwZWQxZjRjYzE4Y2JjZmNmYTQxMDM2MWZkOGYwOGYzMScsXG4gICAgICAgICczZDk4YTljZGQwMjZkZDQzZjM5MDQ4ZjI1YTg4NDdmNGZjYWZhZDE4OTVkN2E2MzNjNmZlZDNjMzVlOTk5NTExJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcyOWRmOWZiZDhkOWU0NjUwOTI3NWY0YjEyNWQ2ZDQ1ZDdmYmU5YTNiODc4YTdhZjg3MmEyODAwNjYxYWM1ZjUxJyxcbiAgICAgICAgJ2I0YzRmZTk5Yzc3NWE2MDZlMmQ4ODYyMTc5MTM5ZmZkYTYxZGM4NjFjMDE5ZTU1Y2QyODc2ZWIyYTI3ZDg0YicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYTBiMWNhZTA2YjBhODQ3YTNmZWE2ZTY3MWFhZjhhZGZkZmU1OGNhMmY3NjgxMDVjODA4MmIyZTQ0OWZjZTI1MicsXG4gICAgICAgICdhZTQzNDEwMmVkZGUwOTU4ZWM0YjE5ZDkxN2E2YTI4ZTZiNzJkYTE4MzRhZmYwZTY1MGYwNDk1MDNhMjk2Y2YyJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc0ZThjZWFmYjliM2U5YTEzNmRjN2ZmNjdlODQwMjk1YjQ5OWRmYjNiMjEzM2U0YmExMTNmMmU0YzBlMTIxZTUnLFxuICAgICAgICAnY2YyMTc0MTE4YzhiNmQ3YTRiNDhmNmQ1MzRjZTVjNzk0MjJjMDg2YTYzNDYwNTAyYjgyN2NlNjJhMzI2NjgzYycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDI0YTQ0ZTA0N2UxOWI2ZjVhZmI4MWM3Y2EyZjY5MDgwYTUwNzY2ODlhMDEwOTE5ZjQyNzI1YzJiNzg5YTMzYicsXG4gICAgICAgICc2ZmI4ZDU1OTFiNDY2ZjhmYzYzZGI1MGYxYzBmMWM2OTAxM2Y5OTY4ODdiODI0NGQyY2RlYzQxN2FmZWE4ZmEzJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlYTAxNjA2YTdhNmM5Y2RkMjQ5ZmRmY2ZhY2I5OTU4NDAwMWVkZDI4YWJiYWI3N2I1MTA0ZTk4ZThlM2IzNWQ0JyxcbiAgICAgICAgJzMyMmFmNDkwOGM3MzEyYjBjZmJmZTM2OWY3YTdiM2NkYjdkNDQ5NGJjMjgyMzcwMGNmZDY1MjE4OGEzZWE5OGQnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2FmOGFkZGJmMmI2NjFjOGE2YzYzMjg2NTVlYjk2NjUxMjUyMDA3ZDhjNWVhMzFiZTRhZDE5NmRlOGNlMjEzMWYnLFxuICAgICAgICAnNjc0OWU2N2MwMjliODVmNTJhMDM0ZWFmZDA5NjgzNmIyNTIwODE4NjgwZTI2YWM4ZjNkZmJjZGI3MTc0OTcwMCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZTNhZTE5NzQ1NjZjYTA2Y2M1MTZkNDdlMGZiMTY1YTY3NGEzZGFiY2ZjYTE1ZTcyMmYwZTM0NTBmNDU4ODknLFxuICAgICAgICAnMmFlYWJlN2U0NTMxNTEwMTE2MjE3ZjA3YmY0ZDA3MzAwZGU5N2U0ODc0ZjgxZjUzMzQyMGE3MmVlYjBiZDZhNCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTkxZWUzNTUzMTNkOTk3MjFjZjY5OTNmZmVkMWUzZTMwMTk5M2ZmM2VkMjU4ODAyMDc1ZWE4Y2VkMzk3ZTI0NicsXG4gICAgICAgICdiMGVhNTU4YTExM2MzMGJlYTYwZmM0Nzc1NDYwYzc5MDFmZjBiMDUzZDI1Y2EyYmRlZWU5OGYxYTRiZTVkMTk2JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxMTM5NmQ1NWZkYTU0YzQ5ZjE5YWE5NzMxOGQ4ZGE2MWZhODU4NGU0N2IwODQ5NDUwNzdjZjAzMjU1YjUyOTg0JyxcbiAgICAgICAgJzk5OGM3NGE4Y2Q0NWFjMDEyODlkNTgzM2E3YmViNDc0NGZmNTM2YjAxYjI1N2JlNGM1NzY3YmVhOTNlYTU3YTQnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzNjNWQyYTFiYTM5YzVhMTc5MDAwMDczOGM5ZTBjNDBiOGRjZGZkNTQ2ODc1NGI2NDA1NTQwMTU3ZTAxN2FhN2EnLFxuICAgICAgICAnYjIyODQyNzk5OTVhMzRlMmY5ZDRkZTczOTZmYzE4YjgwZjliOGI5ZmRkMjcwZjY2NjFmNzljYTRjODFiZDI1NycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnY2M4NzA0YjhhNjBhMGRlZmEzYTk5YTcyOTlmMmU5YzNmYmMzOTVhZmIwNGFjMDc4NDI1ZWY4YTE3OTNjYzAzMCcsXG4gICAgICAgICdiZGQ0NjAzOWZlZWQxNzg4MWQxZTA4NjJkYjM0N2Y4Y2YzOTViNzRmYzRiY2RjNGU5NDBiNzRlM2FjMWYxYjEzJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdjNTMzZTRmN2VhODU1NWFhY2Q5Nzc3YWM1Y2FkMjliOTdkZDRkZWZjY2M1M2VlN2VhMjA0MTE5YjI4ODliMTk3JyxcbiAgICAgICAgJzZmMGEyNTZiYzVlZmRmNDI5YTJmYjYyNDJmMWE0M2EyZDliOTI1YmI0YTRiM2EyNmJiOGUwZjQ1ZWI1OTYwOTYnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2MxNGY4ZjJjY2IyN2Q2ZjEwOWY2ZDA4ZDAzY2M5NmE2OWJhOGMzNGVlYzA3YmJjZjU2NmQ0OGUzM2RhNjU5MycsXG4gICAgICAgICdjMzU5ZDY5MjNiYjM5OGY3ZmQ0NDczZTE2ZmUxYzI4NDc1Yjc0MGRkMDk4MDc1ZTZjMGU4NjQ5MTEzZGMzYTM4JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdhNmNiYzMwNDZiYzZhNDUwYmFjMjQ3ODlmYTE3MTE1YTRjOTczOWVkNzVmOGYyMWNlNDQxZjcyZTBiOTBlNmVmJyxcbiAgICAgICAgJzIxYWU3ZjQ2ODBlODg5YmIxMzA2MTllMmMwZjk1YTM2MGNlYjU3M2M3MDYwMzEzOTg2MmFmZDYxN2ZhOWI5ZicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzQ3ZDZkOWEwMmM0ODkyN2ViZmI4NmMxMzU5YjFjYWYxMzBhM2MwMjY3ZDExY2U2MzQ0YjM5Zjk5ZDQzY2MzOCcsXG4gICAgICAgICc2MGVhN2Y2MWEzNTM1MjRkMWM5ODdmNmVjZWM5MmYwODZkNTY1YWI2ODc4NzBjYjEyNjg5ZmYxZTMxYzc0NDQ4JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkYTY1NDVkMjE4MWRiOGQ5ODNmN2RjYjM3NWVmNTg2NmQ0N2M2N2IxYmYzMWM4Y2Y4NTVlZjc0MzdiNzI2NTZhJyxcbiAgICAgICAgJzQ5Yjk2NzE1YWI2ODc4YTc5ZTc4ZjA3Y2U1NjgwYzVkNjY3MzA1MWI0OTM1YmQ4OTdmZWE4MjRiNzdkYzIwOGEnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2M0MDc0N2NjOWQwMTJjYjFhMTNiODE0ODMwOWM2ZGU3ZWMyNWQ2OTQ1ZDY1NzE0NmI5ZDU5OTRiOGZlYjExMTEnLFxuICAgICAgICAnNWNhNTYwNzUzYmUyYTEyZmM2ZGU2Y2FmMmNiNDg5NTY1ZGI5MzYxNTZiOTUxNGUxYmI1ZTgzMDM3ZTBmYTJkNCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNGU0MmM4ZWM4MmM5OTc5OGNjZjNhNjEwYmU4NzBlNzgzMzhjN2Y3MTMzNDhiZDM0YzgyMDNlZjQwMzdmMzUwMicsXG4gICAgICAgICc3NTcxZDc0ZWU1ZTBmYjkyYTdhOGIzM2EwNzc4MzM0MWE1NDkyMTQ0Y2M1NGJjYzQwYTk0NDczNjkzNjA2NDM3JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczNzc1YWI3MDg5YmM2YWY4MjNhYmEyZTFhZjcwYjIzNmQyNTFjYWRiMGM4Njc0MzI4NzUyMmExYjNiMGRlZGVhJyxcbiAgICAgICAgJ2JlNTJkMTA3YmNmYTA5ZDhiY2I5NzM2YTgyOGNmYTdmYWM4ZGIxN2JmN2E3NmEyYzQyYWQ5NjE0MDkwMThjZjcnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2NlZTMxY2JmN2UzNGVjMzc5ZDk0ZmI4MTRkM2Q3NzVhZDk1NDU5NWQxMzE0YmE4ODQ2OTU5ZTNlODJmNzRlMjYnLFxuICAgICAgICAnOGZkNjRhMTRjMDZiNTg5YzI2Yjk0N2FlMmJjZjZiZmEwMTQ5ZWYwYmUxNGVkNGQ4MGY0NDhhMDFjNDNiMWM2ZCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjRmOWVhZWEwOWI2OTE3NjE5ZjZlYTZhNGViNTQ2NGVmZGRiNThmZDQ1YjFlYmVmY2RjMWEwMWQwOGI0Nzk4NicsXG4gICAgICAgICczOWU1Yzk5MjViNWE1NGIwNzQzM2E0ZjE4YzYxNzI2ZjhiYjEzMWMwMTJjYTU0MmViMjRhOGFjMDcyMDA2ODJhJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkNDI2M2RmYzNkMmRmOTIzYTAxNzlhNDg5NjZkMzBjZTg0ZTI1MTVhZmMzZGNjYzFiNzc5MDc3OTJlYmNjNjBlJyxcbiAgICAgICAgJzYyZGZhZjA3YTBmNzhmZWIzMGUzMGQ2Mjk1ODUzY2UxODllMTI3NzYwYWQ2Y2Y3ZmFlMTY0ZTEyMmEyMDhkNTQnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ4NDU3NTI0ODIwZmE2NWE0ZjhkMzVlYjY5MzA4NTdjMDAzMmFjYzBhNGEyZGU0MjIyMzNlZWRhODk3NjEyYzQnLFxuICAgICAgICAnMjVhNzQ4YWIzNjc5NzlkOTg3MzNjMzhhMWZhMWMyZTdkYzZjYzA3ZGIyZDYwYTlhZTdhNzZhYWE0OWJkMGY3NycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZGZlZWVmMTg4MTEwMWYyY2IxMTY0NGYzYTJhZmRmYzIwNDVlMTk5MTkxNTI5MjNmMzY3YTE3NjdjMTFjY2VkYScsXG4gICAgICAgICdlY2ZiNzA1NmNmMWRlMDQyZjk0MjBiYWIzOTY3OTNjMGMzOTBiZGU3NGI0YmJkZmYxNmE4M2FlMDlhOWE3NTE3JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc2ZDdlZjZiMTc1NDNmODM3M2M1NzNmNDRlMWYzODk4MzVkODliY2JjNjA2MmNlZDM2YzgyZGY4M2I4ZmFlODU5JyxcbiAgICAgICAgJ2NkNDUwZWMzMzU0Mzg5ODZkZmVmYTEwYzU3ZmVhOWJjYzUyMWEwOTU5YjJkODBiYmY3NGIxOTBkY2E3MTJkMTAnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U3NTYwNWQ1OTEwMmE1YTI2ODQ1MDBkM2I5OTFmMmUzZjNjODhiOTMyMjU1NDcwMzVhZjI1YWY2NmUwNDU0MWYnLFxuICAgICAgICAnZjVjNTQ3NTRhOGY3MWVlNTQwYjliNDg3Mjg0NzNlMzE0ZjcyOWFjNTMwOGIwNjkzODM2MDk5MGUyYmZhZDEyNScsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZWI5ODY2MGY0YzRkZmFhMDZhMmJlNDUzZDUwMjBiYzk5YTBjMmU2MGFiZTM4ODQ1N2RkNDNmZWZiMWVkNjIwYycsXG4gICAgICAgICc2Y2I5YTg4NzZkOWNiODUyMDYwOWFmM2FkZDI2Y2QyMGEwYTdjZDhhOTQxMTEzMWNlODVmNDQxMDAwOTkyMjNlJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICcxM2U4N2IwMjdkODUxNGQzNTkzOWYyZTY4OTJiMTk5MjIxNTQ1OTY5NDE4ODgzMzZkYzM1NjNlM2I4ZGJhOTQyJyxcbiAgICAgICAgJ2ZlZjVhM2M2ODA1OWE2ZGVjNWQ2MjQxMTRiZjFlOTFhYWMyYjlkYTU2OGQ2YWJlYjI1NzBkNTU2NDZiOGFkZjEnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2VlMTYzMDI2ZTlmZDZmZTAxN2MzOGYwNmE1YmU2ZmMxMjU0MjRiMzcxY2UyNzA4ZTdiZjQ0OTE2OTFlNTc2NGEnLFxuICAgICAgICAnMWFjYjI1MGYyNTVkZDYxYzQzZDk0Y2NjNjcwZDBmNThmNDlhZTNmYTE1Yjk2NjIzZTU0MzBkYTBhZDZjNjJiMicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYjI2OGY1ZWY5YWQ1MWU0ZDc4ZGUzYTc1MGMyZGM4OWIxZTYyNmQ0MzUwNTg2Nzk5OTkzMmU1ZGIzM2FmM2Q4MCcsXG4gICAgICAgICc1ZjMxMGQ0YjNjOTliOWViYjE5Zjc3ZDQxYzFkZWUwMThjZjBkMzRmZDQxOTE2MTQwMDNlOTQ1YTEyMTZlNDIzJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdmZjA3ZjMxMThhOWRmMDM1ZTlmYWQ4NWViNmM3YmZlNDJiMDJmMDFjYTk5Y2VlYTNiZjdmZmRiYTkzYzQ3NTBkJyxcbiAgICAgICAgJzQzODEzNmQ2MDNlODU4YTNhNWM0NDBjMzhlY2NiYWRkYzFkMjk0MjExNGUyZWRkZDQ3NDBkMDk4Y2VkMWYwZDgnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzhkOGI5ODU1YzdjMDUyYTM0MTQ2ZmQyMGZmYjY1OGJlYTRiOWY2OWUwZDgyNWViZWMxNmU4YzNjZTJiNTI2YTEnLFxuICAgICAgICAnY2RiNTU5ZWVkYzJkNzlmOTI2YmFmNDRmYjg0ZWE0ZDQ0YmNmNTBmZWU1MWQ3Y2ViMzBlMmU3ZjQ2MzAzNjc1OCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNTJkYjBiNTM4NGRmYmYwNWJmYTlkNDcyZDdhZTI2ZGZlNGI4NTFjZWNhOTFiMWViYTU0MjYzMTgwZGEzMmI2MycsXG4gICAgICAgICdjM2I5OTdkMDUwZWU1ZDQyM2ViYWY2NmE2ZGI5ZjU3YjMxODBjOTAyODc1Njc5ZGU5MjRiNjlkODRhN2IzNzUnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2U2MmY5NDkwZDNkNTFkYTYzOTVlZmQyNGU4MDkxOWNjN2QwZjI5YzNmM2ZhNDhjNmZmZjU0M2JlY2JkNDMzNTInLFxuICAgICAgICAnNmQ4OWFkN2JhNDg3NmIwYjIyYzJjYTI4MGM2ODI4NjJmMzQyYzg1OTFmMWRhZjUxNzBlMDdiZmQ5Y2NhZmE3ZCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnN2YzMGVhMjQ3NmIzOTliNDk1NzUwOWM4OGY3N2QwMTkxYWZhMmZmNWNiN2IxNGZkNmQ4ZTdkNjVhYWFiMTE5MycsXG4gICAgICAgICdjYTVlZjdkNGIyMzFjOTRjM2IxNTM4OWE1ZjYzMTFlOWRhZmY3YmI2N2IxMDNlOTg4MGVmNGJmZjYzN2FjYWVjJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc1MDk4ZmYxZTFkOWYxNGZiNDZhMjEwZmFkYTZjOTAzZmVmMGZiN2I0YTFkZDFkOWFjNjBhMDM2MTgwMGI3YTAwJyxcbiAgICAgICAgJzk3MzExNDFkODFmYzhmODA4NGQzN2M2ZTc1NDIwMDZiM2VlMWI0MGQ2MGRmZTUzNjJhNWIxMzJmZDE3ZGRjMCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnMzJiNzhjN2RlOWVlNTEyYTcyODk1YmU2YjljYmVmYTZlMmYzYzRjY2NlNDQ1Yzk2YjlmMmM4MWUyNzc4YWQ1OCcsXG4gICAgICAgICdlZTE4NDlmNTEzZGY3MWUzMmVmYzM4OTZlZTI4MjYwYzczYmI4MDU0N2FlMjI3NWJhNDk3MjM3Nzk0Yzg3NTNjJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdlMmNiNzRmZGRjOGU5ZmJjZDA3NmVlZjJhN2M3MmIwY2UzN2Q1MGYwODI2OWRmYzA3NGI1ODE1NTA1NDdhNGY3JyxcbiAgICAgICAgJ2QzYWEyZWQ3MWM5ZGQyMjQ3YTYyZGYwNjI3MzZlYjBiYWRkZWE5ZTM2MTIyZDJiZTg2NDFhYmNiMDA1Y2M0YTQnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzg0Mzg0NDc1NjZkNGQ3YmVkYWRjMjk5NDk2YWIzNTc0MjYwMDlhMzVmMjM1Y2IxNDFiZTBkOTljZDEwYWUzYTgnLFxuICAgICAgICAnYzRlMTAyMDkxNjk4MGE0ZGE1ZDAxYWM1ZTZhZDMzMDczNGVmMGQ3OTA2NjMxYzRmMjM5MDQyNmIyZWRkNzkxZicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNDE2MmQ0ODhiODk0MDIwMzliNTg0YzZmYzZjMzA4ODcwNTg3ZDljNDZmNjYwYjg3OGFiNjVjODJjNzExZDY3ZScsXG4gICAgICAgICc2NzE2M2U5MDMyMzYyODlmNzc2ZjIyYzI1ZmI4YTNhZmMxNzMyZjJiODRiNGU5NWRiZGE0N2FlNWEwODUyNjQ5JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICczZmFkM2ZhODRjYWYwZjM0ZjBmODliZmQyZGNmNTRmYzE3NWQ3NjdhZWMzZTUwNjg0ZjNiYTRhNGJmNWY2ODNkJyxcbiAgICAgICAgJ2NkMWJjN2NiNmNjNDA3YmIyZjBjYTY0N2M3MThhNzMwY2Y3MTg3MmU3ZDBkMmE1M2ZhMjBlZmNkZmU2MTgyNicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNjc0ZjI2MDBhMzAwN2EwMDU2OGMxYTdjZTA1ZDA4MTZjMWZiODRiZjEzNzA3OThmMWM2OTUzMmZhZWIxYTg2YicsXG4gICAgICAgICcyOTlkMjFmOTQxM2YzM2IzZWRmNDNiMjU3MDA0NTgwYjcwZGI1N2RhMGIxODIyNTllMDllZWNjNjllMGQzOGE1JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkMzJmNGRhNTRhZGU3NGFiYjgxYjgxNWFkMWZiM2IyNjNkODJkNmM2OTI3MTRiY2ZmODdkMjliZDVlZTlmMDhmJyxcbiAgICAgICAgJ2Y5NDI5ZTczOGI4ZTUzYjk2OGU5OTAxNmMwNTk3MDc3ODJlMTRmNDUzNTM1OWQ1ODJmYzQxNjkxMGIzZWVhODcnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMwZTRlNjcwNDM1Mzg1NTU2ZTU5MzY1NzEzNTg0NWQzNmZiYjY5MzFmNzJiMDhjYjFlZDk1NGYxZTNjZTNmZjYnLFxuICAgICAgICAnNDYyZjliY2U2MTk4OTg2Mzg0OTkzNTAxMTNiYmM5YjEwYTg3OGQzNWRhNzA3NDBkYzY5NWE1NTllYjg4ZGI3YicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnYmUyMDYyMDAzYzUxY2MzMDA0NjgyOTA0MzMwZTRkZWU3ZjNkY2QxMGIwMWU1ODBiZjE5NzFiMDRkNGNhZDI5NycsXG4gICAgICAgICc2MjE4OGJjNDlkNjFlNTQyODU3M2Q0OGE3NGUxYzY1NWIxYzYxMDkwOTA1NjgyYTBkNTU1OGVkNzJkY2NiOWJjJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc5MzE0NDQyM2FjZTM0NTFlZDI5ZTBmYjlhYzJhZjIxMWNiNmU4NGE2MDFkZjU5OTNjNDE5ODU5ZmZmNWRmMDRhJyxcbiAgICAgICAgJzdjMTBkZmIxNjRjMzQyNWY1YzcxYTNmOWQ3OTkyMDM4ZjEwNjUyMjRmNzJiYjlkMWQ5MDJhNmQxMzAzN2I0N2MnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ2IwMTVmODA0NGY1ZmNiZGNmMjFjYTI2ZDZjMzRmYjgxOTc4MjkyMDVjN2I3ZDJhN2NiNjY0MThjMTU3YjExMmMnLFxuICAgICAgICAnYWI4YzFlMDg2ZDA0ZTgxMzc0NGE2NTViMmRmOGQ1ZjgzYjNjZGM2ZmFhMzA4OGMxZDNhZWExNDU0ZTNhMWQ1ZicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnZDVlOWUxZGE2NDlkOTdkODllNDg2ODExN2E0NjVhM2E0ZjhhMThkZTU3YTE0MGQzNmIzZjJhZjM0MWEyMWI1MicsXG4gICAgICAgICc0Y2IwNDQzN2YzOTFlZDczMTExYTEzY2MxZDRkZDBkYjE2OTM0NjVjMjI0MDQ4MGQ4OTU1ZTg1OTJmMjc0NDdhJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdkM2FlNDEwNDdkZDdjYTA2NWRiZjhlZDc3Yjk5MjQzOTk4MzAwNWNkNzJlMTZkNmY5OTZhNTMxNmQzNjk2NmJiJyxcbiAgICAgICAgJ2JkMWFlYjIxYWQyMmViYjIyYTEwZjAzMDM0MTdjNmQ5NjRmOGNkZDdkZjBhY2E2MTRiMTBkYzE0ZDEyNWFjNDYnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzQ2M2UyNzYzZDg4NWY5NThmYzY2Y2RkMjI4MDBmMGE0ODcxOTdkMGE4MmUzNzdiNDlmODBhZjg3Yzg5N2IwNjUnLFxuICAgICAgICAnYmZlZmFjZGIwZTVkMGZkN2RmM2EzMTFhOTRkZTA2MmIyNmI4MGM2MWZiYzk3NTA4Yjc5OTkyNjcxZWY3Y2E3ZicsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzk4NWZkZmQxMjdjMDU2N2M2ZjUzZWMxYmI2M2VjMzE1OGU1OTdjNDBiZmU3NDdjODNjZGRmYzkxMDY0MTkxNycsXG4gICAgICAgICc2MDNjMTJkYWYzZDk4NjJlZjJiMjVmZTFkZTI4OWFlZDI0ZWQyOTFlMGVjNjcwODcwM2E1YmQ1NjdmMzJlZDAzJyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc3NGExYWQ2YjVmNzZlMzlkYjJkZDI0OTQxMGVhYzdmOTllNzRjNTljYjgzZDJkMGVkNWZmMTU0M2RhNzcwM2U5JyxcbiAgICAgICAgJ2NjNjE1N2VmMThjOWM2M2NkNjE5M2Q4MzYzMWJiZWEwMDkzZTA5Njg5NDJlOGMzM2Q1NzM3ZmQ3OTBlMGRiMDgnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzMwNjgyYTUwNzAzMzc1ZjYwMmQ0MTY2NjRiYTE5YjdmYzliYWI0MmM3Mjc0NzQ2M2E3MWQwODk2YjIyZjZkYTMnLFxuICAgICAgICAnNTUzZTA0ZjZiMDE4YjRmYTZjOGYzOWU3ZjMxMWQzMTc2MjkwZDBlMGYxOWNhNzNmMTc3MTRkOTk3N2EyMmZmOCcsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnOWUyMTU4ZjBkN2MwZDVmMjZjMzc5MWVmZWZhNzk1OTc2NTRlN2EyYjI0NjRmNTJiMWVlNmMxMzQ3NzY5ZWY1NycsXG4gICAgICAgICc3MTJmY2RkMWI5MDUzZjA5MDAzYTM0ODFmYTc3NjJlOWZmZDdjOGVmMzVhMzg1MDllMmZiZjI2MjkwMDgzNzMnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzE3NmUyNjk4OWE0M2M5Y2ZlYmE0MDI5YzIwMjUzOGMyODE3MmU1NjZlM2M0ZmNlNzMyMjg1N2YzYmUzMjdkNjYnLFxuICAgICAgICAnZWQ4Y2M5ZDA0YjI5ZWI4NzdkMjcwYjQ4NzhkYzQzYzE5YWVmZDMxZjRlZWUwOWVlN2I0NzgzNGMxZmE0YjFjMycsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnNzVkNDZlZmVhMzc3MWU2ZTY4YWJiODlhMTNhZDc0N2VjZjE4OTIzOTNkZmM0ZjFiNzAwNDc4OGM1MDM3NGRhOCcsXG4gICAgICAgICc5ODUyMzkwYTk5NTA3Njc5ZmQwYjg2ZmQyYjM5YTg2OGQ3ZWZjMjIxNTEzNDZlMWEzY2E0NzI2NTg2YTZiZWQ4JyxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICc4MDlhMjBjNjdkNjQ5MDBmZmI2OThjNGM4MjVmNmQ1ZjIzMTBmYjA0NTFjODY5MzQ1YjczMTlmNjQ1NjA1NzIxJyxcbiAgICAgICAgJzllOTk0OTgwZDk5MTdlMjJiNzZiMDYxOTI3ZmEwNDE0M2QwOTZjY2M1NDk2M2U2YTVlYmZhNWYzZjhlMjg2YzEnLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJzFiMzg5MDNhNDNmN2YxMTRlZDQ1MDBiNGVhYzcwODNmZGVmZWNlMWNmMjljNjM1MjhkNTYzNDQ2Zjk3MmMxODAnLFxuICAgICAgICAnNDAzNmVkYzkzMWE2MGFlODg5MzUzZjc3ZmQ1M2RlNGEyNzA4YjI2YjZmNWRhNzJhZDMzOTQxMTlkYWY0MDhmOScsXG4gICAgICBdLFxuICAgIF0sXG4gIH0sXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBleHBvcnRzO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBtaW5Bc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgbWluVXRpbHMgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzJyk7XG5cbnV0aWxzLmFzc2VydCA9IG1pbkFzc2VydDtcbnV0aWxzLnRvQXJyYXkgPSBtaW5VdGlscy50b0FycmF5O1xudXRpbHMuemVybzIgPSBtaW5VdGlscy56ZXJvMjtcbnV0aWxzLnRvSGV4ID0gbWluVXRpbHMudG9IZXg7XG51dGlscy5lbmNvZGUgPSBtaW5VdGlscy5lbmNvZGU7XG5cbi8vIFJlcHJlc2VudCBudW0gaW4gYSB3LU5BRiBmb3JtXG5mdW5jdGlvbiBnZXROQUYobnVtLCB3LCBiaXRzKSB7XG4gIHZhciBuYWYgPSBuZXcgQXJyYXkoTWF0aC5tYXgobnVtLmJpdExlbmd0aCgpLCBiaXRzKSArIDEpO1xuICBuYWYuZmlsbCgwKTtcblxuICB2YXIgd3MgPSAxIDw8ICh3ICsgMSk7XG4gIHZhciBrID0gbnVtLmNsb25lKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYWYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgejtcbiAgICB2YXIgbW9kID0gay5hbmRsbih3cyAtIDEpO1xuICAgIGlmIChrLmlzT2RkKCkpIHtcbiAgICAgIGlmIChtb2QgPiAod3MgPj4gMSkgLSAxKVxuICAgICAgICB6ID0gKHdzID4+IDEpIC0gbW9kO1xuICAgICAgZWxzZVxuICAgICAgICB6ID0gbW9kO1xuICAgICAgay5pc3Vibih6KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IDA7XG4gICAgfVxuXG4gICAgbmFmW2ldID0gejtcbiAgICBrLml1c2hybigxKTtcbiAgfVxuXG4gIHJldHVybiBuYWY7XG59XG51dGlscy5nZXROQUYgPSBnZXROQUY7XG5cbi8vIFJlcHJlc2VudCBrMSwgazIgaW4gYSBKb2ludCBTcGFyc2UgRm9ybVxuZnVuY3Rpb24gZ2V0SlNGKGsxLCBrMikge1xuICB2YXIganNmID0gW1xuICAgIFtdLFxuICAgIFtdLFxuICBdO1xuXG4gIGsxID0gazEuY2xvbmUoKTtcbiAgazIgPSBrMi5jbG9uZSgpO1xuICB2YXIgZDEgPSAwO1xuICB2YXIgZDIgPSAwO1xuICB2YXIgbTg7XG4gIHdoaWxlIChrMS5jbXBuKC1kMSkgPiAwIHx8IGsyLmNtcG4oLWQyKSA+IDApIHtcbiAgICAvLyBGaXJzdCBwaGFzZVxuICAgIHZhciBtMTQgPSAoazEuYW5kbG4oMykgKyBkMSkgJiAzO1xuICAgIHZhciBtMjQgPSAoazIuYW5kbG4oMykgKyBkMikgJiAzO1xuICAgIGlmIChtMTQgPT09IDMpXG4gICAgICBtMTQgPSAtMTtcbiAgICBpZiAobTI0ID09PSAzKVxuICAgICAgbTI0ID0gLTE7XG4gICAgdmFyIHUxO1xuICAgIGlmICgobTE0ICYgMSkgPT09IDApIHtcbiAgICAgIHUxID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbTggPSAoazEuYW5kbG4oNykgKyBkMSkgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTI0ID09PSAyKVxuICAgICAgICB1MSA9IC1tMTQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUxID0gbTE0O1xuICAgIH1cbiAgICBqc2ZbMF0ucHVzaCh1MSk7XG5cbiAgICB2YXIgdTI7XG4gICAgaWYgKChtMjQgJiAxKSA9PT0gMCkge1xuICAgICAgdTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBtOCA9IChrMi5hbmRsbig3KSArIGQyKSAmIDc7XG4gICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMTQgPT09IDIpXG4gICAgICAgIHUyID0gLW0yNDtcbiAgICAgIGVsc2VcbiAgICAgICAgdTIgPSBtMjQ7XG4gICAgfVxuICAgIGpzZlsxXS5wdXNoKHUyKTtcblxuICAgIC8vIFNlY29uZCBwaGFzZVxuICAgIGlmICgyICogZDEgPT09IHUxICsgMSlcbiAgICAgIGQxID0gMSAtIGQxO1xuICAgIGlmICgyICogZDIgPT09IHUyICsgMSlcbiAgICAgIGQyID0gMSAtIGQyO1xuICAgIGsxLml1c2hybigxKTtcbiAgICBrMi5pdXNocm4oMSk7XG4gIH1cblxuICByZXR1cm4ganNmO1xufVxudXRpbHMuZ2V0SlNGID0gZ2V0SlNGO1xuXG5mdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eShvYmosIG5hbWUsIGNvbXB1dGVyKSB7XG4gIHZhciBrZXkgPSAnXycgKyBuYW1lO1xuICBvYmoucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkID8gdGhpc1trZXldIDpcbiAgICAgIHRoaXNba2V5XSA9IGNvbXB1dGVyLmNhbGwodGhpcyk7XG4gIH07XG59XG51dGlscy5jYWNoZWRQcm9wZXJ0eSA9IGNhY2hlZFByb3BlcnR5O1xuXG5mdW5jdGlvbiBwYXJzZUJ5dGVzKGJ5dGVzKSB7XG4gIHJldHVybiB0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnID8gdXRpbHMudG9BcnJheShieXRlcywgJ2hleCcpIDpcbiAgICBieXRlcztcbn1cbnV0aWxzLnBhcnNlQnl0ZXMgPSBwYXJzZUJ5dGVzO1xuXG5mdW5jdGlvbiBpbnRGcm9tTEUoYnl0ZXMpIHtcbiAgcmV0dXJuIG5ldyBCTihieXRlcywgJ2hleCcsICdsZScpO1xufVxudXRpbHMuaW50RnJvbUxFID0gaW50RnJvbUxFO1xuXG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcImVsbGlwdGljXCIsXG4gIFwidmVyc2lvblwiOiBcIjYuNS40XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJFQyBjcnlwdG9ncmFwaHlcIixcbiAgXCJtYWluXCI6IFwibGliL2VsbGlwdGljLmpzXCIsXG4gIFwiZmlsZXNcIjogW1xuICAgIFwibGliXCJcbiAgXSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImxpbnRcIjogXCJlc2xpbnQgbGliIHRlc3RcIixcbiAgICBcImxpbnQ6Zml4XCI6IFwibnBtIHJ1biBsaW50IC0tIC0tZml4XCIsXG4gICAgXCJ1bml0XCI6IFwiaXN0YW5idWwgdGVzdCBfbW9jaGEgLS1yZXBvcnRlcj1zcGVjIHRlc3QvaW5kZXguanNcIixcbiAgICBcInRlc3RcIjogXCJucG0gcnVuIGxpbnQgJiYgbnBtIHJ1biB1bml0XCIsXG4gICAgXCJ2ZXJzaW9uXCI6IFwiZ3J1bnQgZGlzdCAmJiBnaXQgYWRkIGRpc3QvXCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdEBnaXRodWIuY29tOmluZHV0bnkvZWxsaXB0aWNcIlxuICB9LFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcIkVDXCIsXG4gICAgXCJFbGxpcHRpY1wiLFxuICAgIFwiY3VydmVcIixcbiAgICBcIkNyeXB0b2dyYXBoeVwiXG4gIF0sXG4gIFwiYXV0aG9yXCI6IFwiRmVkb3IgSW5kdXRueSA8ZmVkb3JAaW5kdXRueS5jb20+XCIsXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWMvaXNzdWVzXCJcbiAgfSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljXCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJyZnNcIjogXCJeMi4wLjJcIixcbiAgICBcImNvdmVyYWxsc1wiOiBcIl4zLjEuMFwiLFxuICAgIFwiZXNsaW50XCI6IFwiXjcuNi4wXCIsXG4gICAgXCJncnVudFwiOiBcIl4xLjIuMVwiLFxuICAgIFwiZ3J1bnQtYnJvd3NlcmlmeVwiOiBcIl41LjMuMFwiLFxuICAgIFwiZ3J1bnQtY2xpXCI6IFwiXjEuMy4yXCIsXG4gICAgXCJncnVudC1jb250cmliLWNvbm5lY3RcIjogXCJeMy4wLjBcIixcbiAgICBcImdydW50LWNvbnRyaWItY29weVwiOiBcIl4xLjAuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi11Z2xpZnlcIjogXCJeNS4wLjBcIixcbiAgICBcImdydW50LW1vY2hhLWlzdGFuYnVsXCI6IFwiXjUuMC4yXCIsXG4gICAgXCJncnVudC1zYXVjZWxhYnNcIjogXCJeOS4wLjFcIixcbiAgICBcImlzdGFuYnVsXCI6IFwiXjAuNC41XCIsXG4gICAgXCJtb2NoYVwiOiBcIl44LjAuMVwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImJuLmpzXCI6IFwiXjQuMTEuOVwiLFxuICAgIFwiYnJvcmFuZFwiOiBcIl4xLjEuMFwiLFxuICAgIFwiaGFzaC5qc1wiOiBcIl4xLjAuMFwiLFxuICAgIFwiaG1hYy1kcmJnXCI6IFwiXjEuMC4xXCIsXG4gICAgXCJpbmhlcml0c1wiOiBcIl4yLjAuNFwiLFxuICAgIFwibWluaW1hbGlzdGljLWFzc2VydFwiOiBcIl4xLjAuMVwiLFxuICAgIFwibWluaW1hbGlzdGljLWNyeXB0by11dGlsc1wiOiBcIl4xLjAuMVwiXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gY3JlYXRlSGFzaEZ1bmN0aW9uKGhhc2hDb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHZhciBoYXNoID0gaGFzaENvbnN0cnVjdG9yKCk7XG4gICAgICAgIGhhc2gudXBkYXRlKG1zZyk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShoYXNoLmRpZ2VzdCgpKTtcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVIYXNoRnVuY3Rpb24gPSBjcmVhdGVIYXNoRnVuY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhhc2hfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2hhc2gtdXRpbHNcIik7XG52YXIgY3JlYXRlS2VjY2FrSGFzaCA9IHJlcXVpcmUoXCJrZWNjYWtcIik7XG5leHBvcnRzLmtlY2NhazIyNCA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKFwia2VjY2FrMjI0XCIpO1xufSk7XG5leHBvcnRzLmtlY2NhazI1NiA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKFwia2VjY2FrMjU2XCIpO1xufSk7XG5leHBvcnRzLmtlY2NhazM4NCA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKFwia2VjY2FrMzg0XCIpO1xufSk7XG5leHBvcnRzLmtlY2NhazUxMiA9IGhhc2hfdXRpbHNfMS5jcmVhdGVIYXNoRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcmVhdGVLZWNjYWtIYXNoKFwia2VjY2FrNTEyXCIpO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZWNjYWsuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmFuZG9tYnl0ZXMgPSByZXF1aXJlKFwicmFuZG9tYnl0ZXNcIik7XG5mdW5jdGlvbiBnZXRSYW5kb21CeXRlcyhieXRlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJhbmRvbWJ5dGVzKGJ5dGVzLCBmdW5jdGlvbiAoZXJyLCByZXNwKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXNwKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmdldFJhbmRvbUJ5dGVzID0gZ2V0UmFuZG9tQnl0ZXM7XG5mdW5jdGlvbiBnZXRSYW5kb21CeXRlc1N5bmMoYnl0ZXMpIHtcbiAgICByZXR1cm4gcmFuZG9tYnl0ZXMoYnl0ZXMpO1xufVxuZXhwb3J0cy5nZXRSYW5kb21CeXRlc1N5bmMgPSBnZXRSYW5kb21CeXRlc1N5bmM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5kb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJzZWNwMjU2azFcIik7XG52YXIgcmFuZG9tXzEgPSByZXF1aXJlKFwiLi9yYW5kb21cIik7XG52YXIgU0VDUDI1NksxX1BSSVZBVEVfS0VZX1NJWkUgPSAzMjtcbmZ1bmN0aW9uIGNyZWF0ZVByaXZhdGVLZXkoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGs7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJ1ZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJhbmRvbV8xLmdldFJhbmRvbUJ5dGVzKFNFQ1AyNTZLMV9QUklWQVRFX0tFWV9TSVpFKV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBwayA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlY3AyNTZrMV8xLnByaXZhdGVLZXlWZXJpZnkocGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcGtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlUHJpdmF0ZUtleSA9IGNyZWF0ZVByaXZhdGVLZXk7XG5mdW5jdGlvbiBjcmVhdGVQcml2YXRlS2V5U3luYygpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcGsgPSByYW5kb21fMS5nZXRSYW5kb21CeXRlc1N5bmMoU0VDUDI1NksxX1BSSVZBVEVfS0VZX1NJWkUpO1xuICAgICAgICBpZiAoc2VjcDI1NmsxXzEucHJpdmF0ZUtleVZlcmlmeShwaykpIHtcbiAgICAgICAgICAgIHJldHVybiBwaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlUHJpdmF0ZUtleVN5bmMgPSBjcmVhdGVQcml2YXRlS2V5U3luYztcbl9fZXhwb3J0KHJlcXVpcmUoXCJzZWNwMjU2azFcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrJyksXG4gICAga2VjY2FrMjI0ID0gX3JlcXVpcmUua2VjY2FrMjI0LFxuICAgIGtlY2NhazM4NCA9IF9yZXF1aXJlLmtlY2NhazM4NCxcbiAgICBrMjU2ID0gX3JlcXVpcmUua2VjY2FrMjU2LFxuICAgIGtlY2NhazUxMiA9IF9yZXF1aXJlLmtlY2NhazUxMjtcblxudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxLWFkYXB0ZXInKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcbnZhciBybHAgPSByZXF1aXJlKCdybHAnKTtcbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgY3JlYXRlSGFzaCA9IHJlcXVpcmUoJ2NyZWF0ZS1oYXNoJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5PYmplY3QuYXNzaWduKGV4cG9ydHMsIHJlcXVpcmUoJ2V0aGpzLXV0aWwnKSk7XG5cbi8qKlxuICogdGhlIG1heCBpbnRlZ2VyIHRoYXQgdGhpcyBWTSBjYW4gaGFuZGxlIChhIGBgYEJOYGBgKVxuICogQHZhciB7Qk59IE1BWF9JTlRFR0VSXG4gKi9cbmV4cG9ydHMuTUFYX0lOVEVHRVIgPSBuZXcgQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnLCAxNik7XG5cbi8qKlxuICogMl4yNTYgKGEgYGBgQk5gYGApXG4gKiBAdmFyIHtCTn0gVFdPX1BPVzI1NlxuICovXG5leHBvcnRzLlRXT19QT1cyNTYgPSBuZXcgQk4oJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgMTYpO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsIChhIGBgYFN0cmluZ2BgYClcbiAqIEB2YXIge1N0cmluZ30gS0VDQ0FLMjU2X05VTExfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MgPSAnYzVkMjQ2MDE4NmY3MjMzYzkyN2U3ZGIyZGNjNzAzYzBlNTAwYjY1M2NhODIyNzNiN2JmYWQ4MDQ1ZDg1YTQ3MCc7XG5leHBvcnRzLlNIQTNfTlVMTF9TID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiBudWxsIChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X05VTExcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX05VTEwgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5IChhIGBgYFN0cmluZ2BgYClcbiAqIEB2YXIge1N0cmluZ30gS0VDQ0FLMjU2X1JMUF9BUlJBWV9TXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TID0gJzFkY2M0ZGU4ZGVjNzVkN2FhYjg1YjU2N2I2Y2NkNDFhZDMxMjQ1MWI5NDhhNzQxM2YwYTE0MmZkNDBkNDkzNDcnO1xuZXhwb3J0cy5TSEEzX1JMUF9BUlJBWV9TID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1M7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXkgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfUkxQX0FSUkFZXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWSA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfUkxQX0FSUkFZID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGwgIChhIGBgYFN0cmluZ2BgYClcbiAqIEB2YXIge1N0cmluZ30gS0VDQ0FLMjU2X1JMUF9TXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TID0gJzU2ZTgxZjE3MWJjYzU1YTZmZjgzNDVlNjkyYzBmODZlNWI0OGUwMWI5OTZjYWRjMDAxNjIyZmI1ZTM2M2I0MjEnO1xuZXhwb3J0cy5TSEEzX1JMUF9TID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1M7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbCAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9STFBcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19STFAgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFA7XG5cbi8qKlxuICogW2BCTmBdKGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzKVxuICogQHZhciB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMuQk4gPSBCTjtcblxuLyoqXG4gKiBbYHJscGBdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bWpzL3JscClcbiAqIEB2YXIge0Z1bmN0aW9ufVxuICovXG5leHBvcnRzLnJscCA9IHJscDtcblxuLyoqXG4gKiBbYHNlY3AyNTZrMWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvc2VjcDI1NmsxLW5vZGUvKVxuICogQHZhciB7T2JqZWN0fVxuICovXG5leHBvcnRzLnNlY3AyNTZrMSA9IHNlY3AyNTZrMTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgYnVmZmVyIGZpbGxlZCB3aXRoIDBzXG4gKiBAbWV0aG9kIHplcm9zXG4gKiBAcGFyYW0ge051bWJlcn0gYnl0ZXMgIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGJ1ZmZlciBzaG91bGQgYmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy56ZXJvcyA9IGZ1bmN0aW9uIChieXRlcykge1xuICByZXR1cm4gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVzKS5maWxsKDApO1xufTtcblxuLyoqXG4gICogUmV0dXJucyBhIHplcm8gYWRkcmVzc1xuICAqIEBtZXRob2QgemVyb0FkZHJlc3NcbiAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICovXG5leHBvcnRzLnplcm9BZGRyZXNzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYWRkcmVzc0xlbmd0aCA9IDIwO1xuICB2YXIgemVyb0FkZHJlc3MgPSBleHBvcnRzLnplcm9zKGFkZHJlc3NMZW5ndGgpO1xuICByZXR1cm4gZXhwb3J0cy5idWZmZXJUb0hleCh6ZXJvQWRkcmVzcyk7XG59O1xuXG4vKipcbiAqIExlZnQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAbWV0aG9kIGxzZXRMZW5ndGhcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBtc2cgdGhlIHZhbHVlIHRvIHBhZFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtyaWdodD1mYWxzZV0gd2hldGhlciB0byBzdGFydCBwYWRkaW5nIGZvcm0gdGhlIGxlZnQgb3IgcmlnaHRcbiAqIEByZXR1cm4ge0J1ZmZlcnxBcnJheX1cbiAqL1xuZXhwb3J0cy5zZXRMZW5ndGhMZWZ0ID0gZXhwb3J0cy5zZXRMZW5ndGggPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgsIHJpZ2h0KSB7XG4gIHZhciBidWYgPSBleHBvcnRzLnplcm9zKGxlbmd0aCk7XG4gIG1zZyA9IGV4cG9ydHMudG9CdWZmZXIobXNnKTtcbiAgaWYgKHJpZ2h0KSB7XG4gICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgIG1zZy5jb3B5KGJ1Zik7XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gbXNnLnNsaWNlKDAsIGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG1zZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgIG1zZy5jb3B5KGJ1ZiwgbGVuZ3RoIC0gbXNnLmxlbmd0aCk7XG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gbXNnLnNsaWNlKC1sZW5ndGgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJpZ2h0IFBhZHMgYW4gYEFycmF5YCBvciBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl9IG1zZyB0aGUgdmFsdWUgdG8gcGFkXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEByZXR1cm4ge0J1ZmZlcnxBcnJheX1cbiAqL1xuZXhwb3J0cy5zZXRMZW5ndGhSaWdodCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCkge1xuICByZXR1cm4gZXhwb3J0cy5zZXRMZW5ndGgobXNnLCBsZW5ndGgsIHRydWUpO1xufTtcblxuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSBgQnVmZmVyYCBvciBhbiBgQXJyYXlgXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd9IGFcbiAqIEByZXR1cm4ge0J1ZmZlcnxBcnJheXxTdHJpbmd9XG4gKi9cbmV4cG9ydHMudW5wYWQgPSBleHBvcnRzLnN0cmlwWmVyb3MgPSBmdW5jdGlvbiAoYSkge1xuICBhID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeChhKTtcbiAgdmFyIGZpcnN0ID0gYVswXTtcbiAgd2hpbGUgKGEubGVuZ3RoID4gMCAmJiBmaXJzdC50b1N0cmluZygpID09PSAnMCcpIHtcbiAgICBhID0gYS5zbGljZSgxKTtcbiAgICBmaXJzdCA9IGFbMF07XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuLyoqXG4gKiBBdHRlbXB0cyB0byB0dXJuIGEgdmFsdWUgaW50byBhIGBCdWZmZXJgLiBBcyBpbnB1dCBpdCBzdXBwb3J0cyBgQnVmZmVyYCwgYFN0cmluZ2AsIGBOdW1iZXJgLCBudWxsL3VuZGVmaW5lZCwgYEJOYCBhbmQgb3RoZXIgb2JqZWN0cyB3aXRoIGEgYHRvQXJyYXkoKWAgbWV0aG9kLlxuICogQHBhcmFtIHsqfSB2IHRoZSB2YWx1ZVxuICovXG5leHBvcnRzLnRvQnVmZmVyID0gZnVuY3Rpb24gKHYpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoZXhwb3J0cy5pc0hleFN0cmluZyh2KSkge1xuICAgICAgICB2ID0gQnVmZmVyLmZyb20oZXhwb3J0cy5wYWRUb0V2ZW4oZXhwb3J0cy5zdHJpcEhleFByZWZpeCh2KSksICdoZXgnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSBCdWZmZXIuZnJvbSh2KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgdiA9IGV4cG9ydHMuaW50VG9CdWZmZXIodik7XG4gICAgfSBlbHNlIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICB9IGVsc2UgaWYgKEJOLmlzQk4odikpIHtcbiAgICAgIHYgPSB2LnRvQXJyYXlMaWtlKEJ1ZmZlcik7XG4gICAgfSBlbHNlIGlmICh2LnRvQXJyYXkpIHtcbiAgICAgIC8vIGNvbnZlcnRzIGEgQk4gdG8gYSBCdWZmZXJcbiAgICAgIHYgPSBCdWZmZXIuZnJvbSh2LnRvQXJyYXkoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0eXBlJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIHRvIGEgYE51bWJlcmBcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEB0aHJvd3MgSWYgdGhlIGlucHV0IG51bWJlciBleGNlZWRzIDUzIGJpdHMuXG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9JbnQgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBuZXcgQk4oZXhwb3J0cy50b0J1ZmZlcihidWYpKS50b051bWJlcigpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5idWZmZXJUb0hleCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgYnVmID0gZXhwb3J0cy50b0J1ZmZlcihidWYpO1xuICByZXR1cm4gJzB4JyArIGJ1Zi50b1N0cmluZygnaGV4Jyk7XG59O1xuXG4vKipcbiAqIEludGVycHJldHMgYSBgQnVmZmVyYCBhcyBhIHNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGEgYEJOYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbnVtXG4gKiBAcmV0dXJuIHtCTn1cbiAqL1xuZXhwb3J0cy5mcm9tU2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gbmV3IEJOKG51bSkuZnJvbVR3b3MoMjU2KTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQk5gIHRvIGFuIHVuc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgaXQgYXMgYSBgQnVmZmVyYC4gQXNzdW1lcyAyNTYtYml0IG51bWJlcnMuXG4gKiBAcGFyYW0ge0JOfSBudW1cbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy50b1Vuc2lnbmVkID0gZnVuY3Rpb24gKG51bSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20obnVtLnRvVHdvcygyNTYpLnRvQXJyYXkoKSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrIGhhc2ggb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gW2JpdHM9MjU2XSB0aGUgS2VjY2FrIHdpZHRoXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMua2VjY2FrID0gZnVuY3Rpb24gKGEsIGJpdHMpIHtcbiAgYSA9IGV4cG9ydHMudG9CdWZmZXIoYSk7XG4gIGlmICghYml0cykgYml0cyA9IDI1NjtcblxuICBzd2l0Y2ggKGJpdHMpIHtcbiAgICBjYXNlIDIyNDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazIyNChhKTtcbiAgICAgIH1cbiAgICBjYXNlIDI1NjpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGsyNTYoYSk7XG4gICAgICB9XG4gICAgY2FzZSAzODQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrZWNjYWszODQoYSk7XG4gICAgICB9XG4gICAgY2FzZSA1MTI6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrZWNjYWs1MTIoYSk7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGQgYWxnb3JpdGhtOiBrZWNjYWsnICsgYml0cyk7XG4gICAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIGlucHV0LCBhbGlhcyBmb3Iga2VjY2FrKGEsIDI1NilcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5rZWNjYWsyNTYgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsoYSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgU0hBLTMgKEtlY2NhaykgaGFzaCBvZiB0aGUgaW5wdXQgW09CU09MRVRFXVxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IFtiaXRzPTI1Nl0gdGhlIFNIQS0zIHdpZHRoXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2hhMyA9IGV4cG9ydHMua2VjY2FrO1xuXG4vKipcbiAqIENyZWF0ZXMgU0hBMjU2IGhhc2ggb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgYSA9IGV4cG9ydHMudG9CdWZmZXIoYSk7XG4gIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYSkuZGlnZXN0KCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgUklQRU1EMTYwIGhhc2ggb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhZGRlZCB3aGV0aGVyIGl0IHNob3VsZCBiZSBwYWRkZWQgdG8gMjU2IGJpdHMgb3Igbm90XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucmlwZW1kMTYwID0gZnVuY3Rpb24gKGEsIHBhZGRlZCkge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgdmFyIGhhc2ggPSBjcmVhdGVIYXNoKCdybWQxNjAnKS51cGRhdGUoYSkuZGlnZXN0KCk7XG4gIGlmIChwYWRkZWQgPT09IHRydWUpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5zZXRMZW5ndGgoaGFzaCwgMzIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBoYXNoO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgU0hBLTMgaGFzaCBvZiB0aGUgUkxQIGVuY29kZWQgdmVyc2lvbiBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5ybHBoYXNoID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKHJscC5lbmNvZGUoYSkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByaXZhdGUga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMS5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRQcml2YXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHB1YmxpYyBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxXG4gKiBhbmQgdGhlIHJlcXVpcmVtZW50cyBvZiBFdGhlcmV1bS5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Nhbml0aXplPWZhbHNlXSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgc2FuaXRpemUpIHtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDY0KSB7XG4gICAgLy8gQ29udmVydCB0byBTRUMxIGZvciBzZWNwMjU2azFcbiAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbNF0pLCBwdWJsaWNLZXldKSk7XG4gIH1cblxuICBpZiAoIXNhbml0aXplKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkocHVibGljS2V5KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHB1YmxpYyBrZXkuXG4gKiBBY2NlcHRzIFwiRXRoZXJldW0gcHVibGljIGtleXNcIiBhbmQgU0VDMSBlbmNvZGVkIGtleXMuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHViS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW5pdGl6ZT1mYWxzZV0gQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wdWJUb0FkZHJlc3MgPSBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyA9IGZ1bmN0aW9uIChwdWJLZXksIHNhbml0aXplKSB7XG4gIHB1YktleSA9IGV4cG9ydHMudG9CdWZmZXIocHViS2V5KTtcbiAgaWYgKHNhbml0aXplICYmIHB1YktleS5sZW5ndGggIT09IDY0KSB7XG4gICAgcHViS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHViS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG4gIH1cbiAgYXNzZXJ0KHB1YktleS5sZW5ndGggPT09IDY0KTtcbiAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhwdWJLZXkpLnNsaWNlKC0yMCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIHB1YmxpYyBrZXkgb2YgYSBnaXZlbiBwcml2YXRlIGtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHByaXZhdGVUb1B1YmxpYyA9IGV4cG9ydHMucHJpdmF0ZVRvUHVibGljID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgcHJpdmF0ZUtleSA9IGV4cG9ydHMudG9CdWZmZXIocHJpdmF0ZUtleSk7XG4gIC8vIHNraXAgdGhlIHR5cGUgZmxhZyBhbmQgdXNlIHRoZSBYLCBZIHBvaW50c1xuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcHVibGljIGtleSB0byB0aGUgRXRoZXJldW0gZm9ybWF0LlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgcHVibGljS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwdWJsaWNLZXkpO1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICBwdWJsaWNLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIGZhbHNlKS5zbGljZSgxKTtcbiAgfVxuICByZXR1cm4gcHVibGljS2V5O1xufTtcblxuLyoqXG4gKiBFQ0RTQSBzaWduXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbXNnSGFzaFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZXhwb3J0cy5lY3NpZ24gPSBmdW5jdGlvbiAobXNnSGFzaCwgcHJpdmF0ZUtleSkge1xuICB2YXIgc2lnID0gc2VjcDI1NmsxLnNpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSk7XG5cbiAgdmFyIHJldCA9IHt9O1xuICByZXQuciA9IHNpZy5zaWduYXR1cmUuc2xpY2UoMCwgMzIpO1xuICByZXQucyA9IHNpZy5zaWduYXR1cmUuc2xpY2UoMzIsIDY0KTtcbiAgcmV0LnYgPSBzaWcucmVjb3ZlcnkgKyAyNztcbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUga2VjY2FrLTI1NiBoYXNoIG9mIGBtZXNzYWdlYCwgcHJlZml4ZWQgd2l0aCB0aGUgaGVhZGVyIHVzZWQgYnkgdGhlIGBldGhfc2lnbmAgUlBDIGNhbGwuXG4gKiBUaGUgb3V0cHV0IG9mIHRoaXMgZnVuY3Rpb24gY2FuIGJlIGZlZCBpbnRvIGBlY3NpZ25gIHRvIHByb2R1Y2UgdGhlIHNhbWUgc2lnbmF0dXJlIGFzIHRoZSBgZXRoX3NpZ25gXG4gKiBjYWxsIGZvciBhIGdpdmVuIGBtZXNzYWdlYCwgb3IgZmVkIHRvIGBlY3JlY292ZXJgIGFsb25nIHdpdGggYSBzaWduYXR1cmUgdG8gcmVjb3ZlciB0aGUgcHVibGljIGtleVxuICogdXNlZCB0byBwcm9kdWNlIHRoZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gbWVzc2FnZVxuICogQHJldHVybnMge0J1ZmZlcn0gaGFzaFxuICovXG5leHBvcnRzLmhhc2hQZXJzb25hbE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICB2YXIgcHJlZml4ID0gZXhwb3J0cy50b0J1ZmZlcignXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG4nICsgbWVzc2FnZS5sZW5ndGgudG9TdHJpbmcoKSk7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhCdWZmZXIuY29uY2F0KFtwcmVmaXgsIG1lc3NhZ2VdKSk7XG59O1xuXG4vKipcbiAqIEVDRFNBIHB1YmxpYyBrZXkgcmVjb3ZlcnkgZnJvbSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBtc2dIYXNoXG4gKiBAcGFyYW0ge051bWJlcn0gdlxuICogQHBhcmFtIHtCdWZmZXJ9IHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IHB1YmxpY0tleVxuICovXG5leHBvcnRzLmVjcmVjb3ZlciA9IGZ1bmN0aW9uIChtc2dIYXNoLCB2LCByLCBzKSB7XG4gIHZhciBzaWduYXR1cmUgPSBCdWZmZXIuY29uY2F0KFtleHBvcnRzLnNldExlbmd0aChyLCAzMiksIGV4cG9ydHMuc2V0TGVuZ3RoKHMsIDMyKV0sIDY0KTtcbiAgdmFyIHJlY292ZXJ5ID0gdiAtIDI3O1xuICBpZiAocmVjb3ZlcnkgIT09IDAgJiYgcmVjb3ZlcnkgIT09IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIHYgdmFsdWUnKTtcbiAgfVxuICB2YXIgc2VuZGVyUHViS2V5ID0gc2VjcDI1NmsxLnJlY292ZXIobXNnSGFzaCwgc2lnbmF0dXJlLCByZWNvdmVyeSk7XG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChzZW5kZXJQdWJLZXksIGZhbHNlKS5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgcGFyYW1ldGVycyBpbnRvIHRoZSBmb3JtYXQgb2YgYGV0aF9zaWduYCBSUEMgbWV0aG9kXG4gKiBAcGFyYW0ge051bWJlcn0gdlxuICogQHBhcmFtIHtCdWZmZXJ9IHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHNpZ1xuICovXG5leHBvcnRzLnRvUnBjU2lnID0gZnVuY3Rpb24gKHYsIHIsIHMpIHtcbiAgLy8gTk9URTogd2l0aCBwb3RlbnRpYWwgaW50cm9kdWN0aW9uIG9mIGNoYWluSWQgdGhpcyBtaWdodCBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgaWYgKHYgIT09IDI3ICYmIHYgIT09IDI4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlY292ZXJ5IGlkJyk7XG4gIH1cblxuICAvLyBnZXRoIChhbmQgdGhlIFJQQyBldGhfc2lnbiBtZXRob2QpIHVzZXMgdGhlIDY1IGJ5dGUgZm9ybWF0IHVzZWQgYnkgQml0Y29pblxuICAvLyBGSVhNRTogdGhpcyBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1M1xuICByZXR1cm4gZXhwb3J0cy5idWZmZXJUb0hleChCdWZmZXIuY29uY2F0KFtleHBvcnRzLnNldExlbmd0aExlZnQociwgMzIpLCBleHBvcnRzLnNldExlbmd0aExlZnQocywgMzIpLCBleHBvcnRzLnRvQnVmZmVyKHYgLSAyNyldKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIGZvcm1hdCBvZiB0aGUgYGV0aF9zaWduYCBSUEMgbWV0aG9kIHRvIHNpZ25hdHVyZSBwYXJhbWV0ZXJzXG4gKiBOT1RFOiBhbGwgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBnZXRoOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWdcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZXhwb3J0cy5mcm9tUnBjU2lnID0gZnVuY3Rpb24gKHNpZykge1xuICBzaWcgPSBleHBvcnRzLnRvQnVmZmVyKHNpZyk7XG5cbiAgLy8gTk9URTogd2l0aCBwb3RlbnRpYWwgaW50cm9kdWN0aW9uIG9mIGNoYWluSWQgdGhpcyBtaWdodCBuZWVkIHRvIGJlIHVwZGF0ZWRcbiAgaWYgKHNpZy5sZW5ndGggIT09IDY1KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSBsZW5ndGgnKTtcbiAgfVxuXG4gIHZhciB2ID0gc2lnWzY0XTtcbiAgLy8gc3VwcG9ydCBib3RoIHZlcnNpb25zIG9mIGBldGhfc2lnbmAgcmVzcG9uc2VzXG4gIGlmICh2IDwgMjcpIHtcbiAgICB2ICs9IDI3O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2OiB2LFxuICAgIHI6IHNpZy5zbGljZSgwLCAzMiksXG4gICAgczogc2lnLnNsaWNlKDMyLCA2NClcbiAgfTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gYWRkcmVzcyBvZiBhIGdpdmVuIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnByaXZhdGVUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICByZXR1cm4gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MocHJpdmF0ZVRvUHVibGljKHByaXZhdGVLZXkpKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQuIEFjY2VwdHMgY2hlY2tzdW1tZWQgYWRkcmVzc2VzIHRvb1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICByZXR1cm4gKC9eMHhbMC05YS1mQS1GXXs0MH0kLy50ZXN0KGFkZHJlc3MpXG4gICk7XG59O1xuXG4vKipcbiAgKiBDaGVja3MgaWYgYSBnaXZlbiBhZGRyZXNzIGlzIGEgemVybyBhZGRyZXNzXG4gICogQG1ldGhvZCBpc1plcm9BZGRyZXNzXG4gICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqL1xuZXhwb3J0cy5pc1plcm9BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgdmFyIHplcm9BZGRyZXNzID0gZXhwb3J0cy56ZXJvQWRkcmVzcygpO1xuICByZXR1cm4gemVyb0FkZHJlc3MgPT09IGV4cG9ydHMuYWRkSGV4UHJlZml4KGFkZHJlc3MpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgY2hlY2tzdW1tZWQgYWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIGFkZHJlc3MgPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4KGFkZHJlc3MpLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBoYXNoID0gZXhwb3J0cy5rZWNjYWsoYWRkcmVzcykudG9TdHJpbmcoJ2hleCcpO1xuICB2YXIgcmV0ID0gJzB4JztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZHJlc3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocGFyc2VJbnQoaGFzaFtpXSwgMTYpID49IDgpIHtcbiAgICAgIHJldCArPSBhZGRyZXNzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCArPSBhZGRyZXNzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqIEBwYXJhbSB7QnVmZmVyfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICByZXR1cm4gZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSAmJiBleHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpID09PSBhZGRyZXNzO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYWRkcmVzcyBvZiBhIG5ld2x5IGNyZWF0ZWQgY29udHJhY3RcbiAqIEBwYXJhbSB7QnVmZmVyfSBmcm9tIHRoZSBhZGRyZXNzIHdoaWNoIGlzIGNyZWF0aW5nIHRoaXMgbmV3IGFkZHJlc3NcbiAqIEBwYXJhbSB7QnVmZmVyfSBub25jZSB0aGUgbm9uY2Ugb2YgdGhlIGZyb20gYWNjb3VudFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzcyA9IGZ1bmN0aW9uIChmcm9tLCBub25jZSkge1xuICBmcm9tID0gZXhwb3J0cy50b0J1ZmZlcihmcm9tKTtcbiAgbm9uY2UgPSBuZXcgQk4obm9uY2UpO1xuXG4gIGlmIChub25jZS5pc1plcm8oKSkge1xuICAgIC8vIGluIFJMUCB3ZSB3YW50IHRvIGVuY29kZSBudWxsIGluIHRoZSBjYXNlIG9mIHplcm8gbm9uY2VcbiAgICAvLyByZWFkIHRoZSBSTFAgZG9jdW1lbnRhdGlvbiBmb3IgYW4gYW5zd2VyIGlmIHlvdSBkYXJlXG4gICAgbm9uY2UgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIG5vbmNlID0gQnVmZmVyLmZyb20obm9uY2UudG9BcnJheSgpKTtcbiAgfVxuXG4gIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICByZXR1cm4gZXhwb3J0cy5ybHBoYXNoKFtmcm9tLCBub25jZV0pLnNsaWNlKC0yMCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3VwcGxpZWQgYWRkcmVzcyBiZWxvbmdzIHRvIGEgcHJlY29tcGlsZWQgYWNjb3VudCAoQnl6YW50aXVtKVxuICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzUHJlY29tcGlsZWQgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICB2YXIgYSA9IGV4cG9ydHMudW5wYWQoYWRkcmVzcyk7XG4gIHJldHVybiBhLmxlbmd0aCA9PT0gMSAmJiBhWzBdID49IDEgJiYgYVswXSA8PSA4O1xufTtcblxuLyoqXG4gKiBBZGRzIFwiMHhcIiB0byBhIGdpdmVuIGBTdHJpbmdgIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgc3RhcnQgd2l0aCBcIjB4XCJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5hZGRIZXhQcmVmaXggPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5pc0hleFByZWZpeGVkKHN0cikgPyBzdHIgOiAnMHgnICsgc3RyO1xufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBFQ0RTQSBzaWduYXR1cmVcbiAqIEBtZXRob2QgaXNWYWxpZFNpZ25hdHVyZVxuICogQHBhcmFtIHtCdWZmZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHBhcmFtIHtCb29sZWFufSBbaG9tZXN0ZWFkPXRydWVdXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmV4cG9ydHMuaXNWYWxpZFNpZ25hdHVyZSA9IGZ1bmN0aW9uICh2LCByLCBzLCBob21lc3RlYWQpIHtcbiAgdmFyIFNFQ1AyNTZLMV9OX0RJVl8yID0gbmV3IEJOKCc3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjVkNTc2ZTczNTdhNDUwMWRkZmU5MmY0NjY4MWIyMGEwJywgMTYpO1xuICB2YXIgU0VDUDI1NksxX04gPSBuZXcgQk4oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnLCAxNik7XG5cbiAgaWYgKHIubGVuZ3RoICE9PSAzMiB8fCBzLmxlbmd0aCAhPT0gMzIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodiAhPT0gMjcgJiYgdiAhPT0gMjgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByID0gbmV3IEJOKHIpO1xuICBzID0gbmV3IEJOKHMpO1xuXG4gIGlmIChyLmlzWmVybygpIHx8IHIuZ3QoU0VDUDI1NksxX04pIHx8IHMuaXNaZXJvKCkgfHwgcy5ndChTRUNQMjU2SzFfTikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaG9tZXN0ZWFkID09PSBmYWxzZSAmJiBuZXcgQk4ocykuY21wKFNFQ1AyNTZLMV9OX0RJVl8yKSA9PT0gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIG9yIGBBcnJheWAgdG8gSlNPTlxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl9IGJhXG4gKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd8bnVsbH1cbiAqL1xuZXhwb3J0cy5iYVRvSlNPTiA9IGZ1bmN0aW9uIChiYSkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJhKSkge1xuICAgIHJldHVybiAnMHgnICsgYmEudG9TdHJpbmcoJ2hleCcpO1xuICB9IGVsc2UgaWYgKGJhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcnJheS5wdXNoKGV4cG9ydHMuYmFUb0pTT04oYmFbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG59O1xuXG4vKipcbiAqIERlZmluZXMgcHJvcGVydGllcyBvbiBhIGBPYmplY3RgLiBJdCBtYWtlIHRoZSBhc3N1bXB0aW9uIHRoYXQgdW5kZXJseWluZyBkYXRhIGlzIGJpbmFyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWxmIHRoZSBgT2JqZWN0YCB0byBkZWZpbmUgcHJvcGVydGllcyBvblxuICogQHBhcmFtIHtBcnJheX0gZmllbGRzIGFuIGFycmF5IGZpZWxkcyB0byBkZWZpbmUuIEZpZWxkcyBjYW4gY29udGFpbjpcbiAqICogYG5hbWVgIC0gdGhlIG5hbWUgb2YgdGhlIHByb3BlcnRpZXNcbiAqICogYGxlbmd0aGAgLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBmaWVsZCBjYW4gaGF2ZVxuICogKiBgYWxsb3dMZXNzYCAtIGlmIHRoZSBmaWVsZCBjYW4gYmUgbGVzcyB0aGFuIHRoZSBsZW5ndGhcbiAqICogYGFsbG93RW1wdHlgXG4gKiBAcGFyYW0geyp9IGRhdGEgZGF0YSB0byBiZSB2YWxpZGF0ZWQgYWdhaW5zdCB0aGUgZGVmaW5pdGlvbnNcbiAqL1xuZXhwb3J0cy5kZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHNlbGYsIGZpZWxkcywgZGF0YSkge1xuICBzZWxmLnJhdyA9IFtdO1xuICBzZWxmLl9maWVsZHMgPSBbXTtcblxuICAvLyBhdHRhY2ggdGhlIGB0b0pTT05gXG4gIHNlbGYudG9KU09OID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICBzZWxmLl9maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgb2JqW2ZpZWxkXSA9ICcweCcgKyBzZWxmW2ZpZWxkXS50b1N0cmluZygnaGV4Jyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRzLmJhVG9KU09OKHRoaXMucmF3KTtcbiAgfTtcblxuICBzZWxmLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gcmxwLmVuY29kZShzZWxmLnJhdyk7XG4gIH07XG5cbiAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkLCBpKSB7XG4gICAgc2VsZi5fZmllbGRzLnB1c2goZmllbGQubmFtZSk7XG4gICAgZnVuY3Rpb24gZ2V0dGVyKCkge1xuICAgICAgcmV0dXJuIHNlbGYucmF3W2ldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXR0ZXIodikge1xuICAgICAgdiA9IGV4cG9ydHMudG9CdWZmZXIodik7XG5cbiAgICAgIGlmICh2LnRvU3RyaW5nKCdoZXgnKSA9PT0gJzAwJyAmJiAhZmllbGQuYWxsb3daZXJvKSB7XG4gICAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWVsZC5hbGxvd0xlc3MgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgIHYgPSBleHBvcnRzLnN0cmlwWmVyb3Modik7XG4gICAgICAgIGFzc2VydChmaWVsZC5sZW5ndGggPj0gdi5sZW5ndGgsICdUaGUgZmllbGQgJyArIGZpZWxkLm5hbWUgKyAnIG11c3Qgbm90IGhhdmUgbW9yZSAnICsgZmllbGQubGVuZ3RoICsgJyBieXRlcycpO1xuICAgICAgfSBlbHNlIGlmICghKGZpZWxkLmFsbG93WmVybyAmJiB2Lmxlbmd0aCA9PT0gMCkgJiYgZmllbGQubGVuZ3RoKSB7XG4gICAgICAgIGFzc2VydChmaWVsZC5sZW5ndGggPT09IHYubGVuZ3RoLCAnVGhlIGZpZWxkICcgKyBmaWVsZC5uYW1lICsgJyBtdXN0IGhhdmUgYnl0ZSBsZW5ndGggb2YgJyArIGZpZWxkLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYucmF3W2ldID0gdjtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQubmFtZSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZ2V0dGVyLFxuICAgICAgc2V0OiBzZXR0ZXJcbiAgICB9KTtcblxuICAgIGlmIChmaWVsZC5kZWZhdWx0KSB7XG4gICAgICBzZWxmW2ZpZWxkLm5hbWVdID0gZmllbGQuZGVmYXVsdDtcbiAgICB9XG5cbiAgICAvLyBhdHRhY2ggYWxpYXNcbiAgICBpZiAoZmllbGQuYWxpYXMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5hbGlhcywge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBzZXQ6IHNldHRlcixcbiAgICAgICAgZ2V0OiBnZXR0ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gaWYgdGhlIGNvbnN0dWN0b3IgaXMgcGFzc2VkIGRhdGFcbiAgaWYgKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBkYXRhID0gQnVmZmVyLmZyb20oZXhwb3J0cy5zdHJpcEhleFByZWZpeChkYXRhKSwgJ2hleCcpO1xuICAgIH1cblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgIGRhdGEgPSBybHAuZGVjb2RlKGRhdGEpO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggPiBzZWxmLl9maWVsZHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgbnVtYmVyIG9mIGZpZWxkcyBpbiBkYXRhJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBhbGwgdGhlIGl0ZW1zIGFyZSBidWZmZXJzXG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgc2VsZltzZWxmLl9maWVsZHNbaV1dID0gZXhwb3J0cy50b0J1ZmZlcihkKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihkYXRhKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIGlmIChrZXlzLmluZGV4T2YoZmllbGQubmFtZSkgIT09IC0xKSBzZWxmW2ZpZWxkLm5hbWVdID0gZGF0YVtmaWVsZC5uYW1lXTtcbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZihmaWVsZC5hbGlhcykgIT09IC0xKSBzZWxmW2ZpZWxkLmFsaWFzXSA9IGRhdGFbZmllbGQuYWxpYXNdO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBkYXRhJyk7XG4gICAgfVxuICB9XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9zZWNwMjU2azEnKTtcblxudmFyIHNlY3AyNTZrMXYzID0gcmVxdWlyZSgnLi9zZWNwMjU2azEtbGliL2luZGV4Jyk7XG52YXIgZGVyID0gcmVxdWlyZSgnLi9zZWNwMjU2azEtbGliL2RlcicpO1xuXG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBwcml2YXRlS2V5XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlWZXJpZnlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgcHJpdmF0ZUtleVZlcmlmeSA9IGZ1bmN0aW9uIHByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSkge1xuICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwcml2YXRlS2V5IGxlbmd0aCBpcyBub3QgMzJcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkpO1xufTtcblxuLyoqXG4gKiBFeHBvcnQgYSBwcml2YXRlS2V5IGluIERFUiBmb3JtYXRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiBwcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgLy8gcHJpdmF0ZUtleUV4cG9ydCBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICB2YXIgcHVibGljS2V5ID0gc2VjcDI1NmsxdjMucHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBjb21wcmVzc2VkKTtcblxuICByZXR1cm4gZGVyLnByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgcHVibGljS2V5LCBjb21wcmVzc2VkKTtcbn07XG5cbi8qKlxuICogSW1wb3J0IGEgcHJpdmF0ZUtleSBpbiBERVIgZm9ybWF0XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlJbXBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cblxudmFyIHByaXZhdGVLZXlJbXBvcnQgPSBmdW5jdGlvbiBwcml2YXRlS2V5SW1wb3J0KHByaXZhdGVLZXkpIHtcbiAgLy8gcHJpdmF0ZUtleUltcG9ydCBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICBwcml2YXRlS2V5ID0gZGVyLnByaXZhdGVLZXlJbXBvcnQocHJpdmF0ZUtleSk7XG4gIGlmIChwcml2YXRlS2V5ICE9PSBudWxsICYmIHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiAmJiBwcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpKSB7XG4gICAgcmV0dXJuIHByaXZhdGVLZXk7XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBpbXBvcnQgZnJvbSBERVIgZm9ybWF0XCIpO1xufTtcblxuLyoqXG4gKiBOZWdhdGUgYSBwcml2YXRlS2V5IGJ5IHN1YnRyYWN0aW5nIGl0IGZyb20gdGhlIG9yZGVyIG9mIHRoZSBjdXJ2ZSdzIGJhc2UgcG9pbnRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleU5lZ2F0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHByaXZhdGVLZXlOZWdhdGUgPSBmdW5jdGlvbiBwcml2YXRlS2V5TmVnYXRlKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5TmVnYXRlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBpbnZlcnNlIG9mIGEgcHJpdmF0ZUtleSAobW9kdWxvIHRoZSBvcmRlciBvZiB0aGUgY3VydmUncyBiYXNlIHBvaW50KS5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleU1vZEludmVyc2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIHByaXZhdGVLZXlNb2RJbnZlcnNlKHByaXZhdGVLZXkpIHtcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azF2My5wcml2YXRlS2V5TW9kSW52ZXJzZShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkpKTtcbn07XG5cbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IGFkZGluZyB0d2VhayB0byBpdC5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleVR3ZWFrQWRkXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlS2V5VHdlYWtBZGQgPSBmdW5jdGlvbiBwcml2YXRlS2V5VHdlYWtBZGQocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtBZGQoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCB0d2VhaykpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHByaXZhdGVLZXkgYnkgbXVsdGlwbHlpbmcgaXQgYnkgYSB0d2Vhay5cbiAqIEBtZXRob2QgcHJpdmF0ZUtleVR3ZWFrTXVsXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiBwcml2YXRlS2V5VHdlYWtNdWwocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtNdWwoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBVaW50OEFycmF5LmZyb20odHdlYWspKSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZUtleS5cbiAqIEBtZXRob2QgcHVibGljS2V5Q3JlYXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlDcmVhdGUgPSBmdW5jdGlvbiBwdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHB1YmxpY0tleSB0byBjb21wcmVzc2VkIG9yIHVuY29tcHJlc3NlZCBmb3JtLlxuICogQG1ldGhvZCBwdWJsaWNLZXlDb252ZXJ0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleUNvbnZlcnQgPSBmdW5jdGlvbiBwdWJsaWNLZXlDb252ZXJ0KHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogVmVyaWZ5IGFuIEVDRFNBIHB1YmxpY0tleS5cbiAqIEBtZXRob2QgcHVibGljS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgcHVibGljS2V5VmVyaWZ5ID0gZnVuY3Rpb24gcHVibGljS2V5VmVyaWZ5KHB1YmxpY0tleSkge1xuICAvLyBzZWNwMjU2azEgdjQgdmVyc2lvbiB0aHJvd3Mgd2hlbiBwdWJsaWNLZXkgbGVuZ3RoIGlzIG5vdCAzMyBvciA2NVxuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMzMgJiYgcHVibGljS2V5Lmxlbmd0aCAhPT0gNjUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSk7XG59O1xuXG4vKipcbiAqIFR3ZWFrIGEgcHVibGljS2V5IGJ5IGFkZGluZyB0d2VhayB0aW1lcyB0aGUgZ2VuZXJhdG9yIHRvIGl0LlxuICogQG1ldGhvZCBwdWJsaWNLZXlUd2Vha0FkZFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleVR3ZWFrQWRkID0gZnVuY3Rpb24gcHVibGljS2V5VHdlYWtBZGQocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrQWRkKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20odHdlYWspLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIFR3ZWFrIGEgcHVibGljS2V5IGJ5IG11bHRpcGx5aW5nIGl0IGJ5IGEgdHdlYWsgdmFsdWVcbiAqIEBtZXRob2QgcHVibGljS2V5VHdlYWtNdWxcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlUd2Vha011bCA9IGZ1bmN0aW9uIHB1YmxpY0tleVR3ZWFrTXVsKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBnaXZlbiBwdWJsaWNLZXlzIHRvZ2V0aGVyLlxuICogQG1ldGhvZCBwdWJsaWNLZXlDb21iaW5lXG4gKiBAcGFyYW0ge0FycmF5PEJ1ZmZlcj59IHB1YmxpY0tleXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5Q29tYmluZSA9IGZ1bmN0aW9uIHB1YmxpY0tleUNvbWJpbmUocHVibGljS2V5cywgY29tcHJlc3NlZCkge1xuICB2YXIga2V5cyA9IFtdO1xuICBwdWJsaWNLZXlzLmZvckVhY2goZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgIGtleXMucHVzaChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSk7XG4gIH0pO1xuXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q29tYmluZShrZXlzLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBzaWduYXR1cmUgdG8gYSBub3JtYWxpemVkIGxvd2VyLVMgZm9ybS5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlTm9ybWFsaXplXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduYXR1cmVOb3JtYWxpemUgPSBmdW5jdGlvbiBzaWduYXR1cmVOb3JtYWxpemUoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlTm9ybWFsaXplKFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuXG4vKipcbiAqIFNlcmlhbGl6ZSBhbiBFQ0RTQSBzaWduYXR1cmUgaW4gREVSIGZvcm1hdC5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlRXhwb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduYXR1cmVFeHBvcnQgPSBmdW5jdGlvbiBzaWduYXR1cmVFeHBvcnQoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlRXhwb3J0KFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgREVSIEVDRFNBIHNpZ25hdHVyZSAoZm9sbG93IGJ5IFtCSVA2Nl0oaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA2Ni5tZWRpYXdpa2kpKS5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlSW1wb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiBzaWduYXR1cmVJbXBvcnQoc2lnbmF0dXJlKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuc2lnbmF0dXJlSW1wb3J0KFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpKSk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgREVSIEVDRFNBIHNpZ25hdHVyZSAobm90IGZvbGxvdyBieSBbQklQNjZdKGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjYubWVkaWF3aWtpKSkuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUltcG9ydExheFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlSW1wb3J0TGF4ID0gZnVuY3Rpb24gc2lnbmF0dXJlSW1wb3J0TGF4KHNpZ25hdHVyZSkge1xuICAvLyBzaWduYXR1cmVJbXBvcnRMYXggbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgLy8gZW5zdXJlIHRoYXQgc2lnbmF0dXJlIGlzIGdyZWF0ZXIgdGhhbiAwXG4gIGlmIChzaWduYXR1cmUubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NpZ25hdHVyZSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgdmFyIHNpZ09iaiA9IGRlci5zaWduYXR1cmVJbXBvcnRMYXgoc2lnbmF0dXJlKTtcbiAgaWYgKHNpZ09iaiA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNvdWxkbid0IHBhcnNlIERFUiBzaWduYXR1cmVcIik7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxdjMuc2lnbmF0dXJlSW1wb3J0KHNpZ09iaik7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFQ0RTQSBzaWduYXR1cmUuIEFsd2F5cyByZXR1cm4gbG93LVMgc2lnbmF0dXJlLlxuICogQG1ldGhvZCBzaWduXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduID0gZnVuY3Rpb24gc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBzaG91bGQgYmUgYW4gT2JqZWN0Jyk7XG4gIH1cblxuICB2YXIgc2lnbk9wdGlvbnMgPSB2b2lkIDA7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBzaWduT3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5kYXRhIHNob3VsZCBiZSBhIEJ1ZmZlcicpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgIC8vIHZhbGlkYXRlIG9wdGlvbi5kYXRhIGxlbmd0aFxuICAgICAgaWYgKG9wdGlvbnMuZGF0YS5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvcHRpb25zLmRhdGEgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgICAgIH1cblxuICAgICAgc2lnbk9wdGlvbnMuZGF0YSA9IG5ldyBVaW50OEFycmF5KG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubm9uY2VmbiA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucy5ub25jZWZuIHNob3VsZCBiZSBhIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubm9uY2Vmbikge1xuICAgICAgLy8gIGNvbnZlcnQgb3B0aW9uLm5vbmNlZm4gZnVuY3Rpb24gc2lnbmF0dXJlXG4gICAgICBzaWduT3B0aW9ucy5ub25jZWZuID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHByaXZhdGVLZXksIGFsZ28sIGRhdGEsIGF0dGVtcHQpIHtcbiAgICAgICAgdmFyIGJ1ZmZlckFsZ28gPSBhbGdvICE9IG51bGwgPyBCdWZmZXIuZnJvbShhbGdvKSA6IG51bGw7XG4gICAgICAgIHZhciBidWZmZXJEYXRhID0gZGF0YSAhPSBudWxsID8gQnVmZmVyLmZyb20oZGF0YSkgOiBudWxsO1xuXG4gICAgICAgIHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbSgnJyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubm9uY2Vmbikge1xuICAgICAgICAgIGJ1ZmZlciA9IG9wdGlvbnMubm9uY2VmbihCdWZmZXIuZnJvbShtZXNzYWdlKSwgQnVmZmVyLmZyb20ocHJpdmF0ZUtleSksIGJ1ZmZlckFsZ28sIGJ1ZmZlckRhdGEsIGF0dGVtcHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgc2lnID0gc2VjcDI1NmsxLmVjZHNhU2lnbihVaW50OEFycmF5LmZyb20obWVzc2FnZSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgc2lnbk9wdGlvbnMpO1xuXG4gIHJldHVybiB7XG4gICAgc2lnbmF0dXJlOiBCdWZmZXIuZnJvbShzaWcuc2lnbmF0dXJlKSxcbiAgICByZWNvdmVyeTogc2lnLnJlY2lkXG4gIH07XG59O1xuXG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnZhciB2ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgLy8gbm90ZTogc2VjcDI1NmsxIHY0IHZlcmlmeSBtZXRob2QgaGFzIGEgZGlmZmVyZW50IGFyZ3VtZW50IG9yZGVyXG4gIHJldHVybiBzZWNwMjU2azEuZWNkc2FWZXJpZnkoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSksIFVpbnQ4QXJyYXkuZnJvbShtZXNzYWdlKSwgcHVibGljS2V5KTtcbn07XG5cbi8qKlxuICogUmVjb3ZlciBhbiBFQ0RTQSBwdWJsaWMga2V5IGZyb20gYSBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHJlY292ZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge051bWJlcn0gcmVjaWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcmVjb3ZlciA9IGZ1bmN0aW9uIHJlY292ZXIobWVzc2FnZSwgc2lnbmF0dXJlLCByZWNpZCwgY29tcHJlc3NlZCkge1xuICAvLyBub3RlOiBzZWNwMjU2azEgdjQgcmVjb3ZlciBtZXRob2QgaGFzIGEgZGlmZmVyZW50IGFyZ3VtZW50IG9yZGVyXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuZWNkc2FSZWNvdmVyKFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpLCByZWNpZCwgVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgYW4gRUMgRGlmZmllLUhlbGxtYW4gc2VjcmV0IGFuZCBhcHBsaWVkIHNoYTI1NiB0byBjb21wcmVzc2VkIHB1YmxpYyBrZXkuXG4gKiBAbWV0aG9kIGVjZGhcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBlY2RoID0gZnVuY3Rpb24gZWNkaChwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgLy8gbm90ZTogc2VjcDI1NmsxIHYzIGRvZXNuJ3QgYWxsb3cgb3B0aW9uYWwgcGFyYW1ldGVyXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEuZWNkaChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCB7fSkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIGFuIEVDIERpZmZpZS1IZWxsbWFuIHNlY3JldCBhbmQgcmV0dXJuIHB1YmxpYyBrZXkgYXMgcmVzdWx0XG4gKiBAbWV0aG9kIGVjZGhVbnNhZmVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIGVjZGhVbnNhZmUgPSBmdW5jdGlvbiBlY2RoVW5zYWZlKHB1YmxpY0tleSwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAvLyBlY2RoVW5zYWZlIG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIC8vIGVuc3VyZSB2YWxpZCBwdWJsaWNLZXkgbGVuZ3RoXG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAzMyAmJiBwdWJsaWNLZXkubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwdWJsaWMga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICAvLyBlbnN1cmUgdmFsaWQgcHJpdmF0ZUtleSBsZW5ndGhcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMXYzLmVjZGhVbnNhZmUoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByaXZhdGVLZXlWZXJpZnk6IHByaXZhdGVLZXlWZXJpZnksXG4gIHByaXZhdGVLZXlFeHBvcnQ6IHByaXZhdGVLZXlFeHBvcnQsXG4gIHByaXZhdGVLZXlJbXBvcnQ6IHByaXZhdGVLZXlJbXBvcnQsXG4gIHByaXZhdGVLZXlOZWdhdGU6IHByaXZhdGVLZXlOZWdhdGUsXG4gIHByaXZhdGVLZXlNb2RJbnZlcnNlOiBwcml2YXRlS2V5TW9kSW52ZXJzZSxcbiAgcHJpdmF0ZUtleVR3ZWFrQWRkOiBwcml2YXRlS2V5VHdlYWtBZGQsXG4gIHByaXZhdGVLZXlUd2Vha011bDogcHJpdmF0ZUtleVR3ZWFrTXVsLFxuXG4gIHB1YmxpY0tleUNyZWF0ZTogcHVibGljS2V5Q3JlYXRlLFxuICBwdWJsaWNLZXlDb252ZXJ0OiBwdWJsaWNLZXlDb252ZXJ0LFxuICBwdWJsaWNLZXlWZXJpZnk6IHB1YmxpY0tleVZlcmlmeSxcbiAgcHVibGljS2V5VHdlYWtBZGQ6IHB1YmxpY0tleVR3ZWFrQWRkLFxuICBwdWJsaWNLZXlUd2Vha011bDogcHVibGljS2V5VHdlYWtNdWwsXG4gIHB1YmxpY0tleUNvbWJpbmU6IHB1YmxpY0tleUNvbWJpbmUsXG5cbiAgc2lnbmF0dXJlTm9ybWFsaXplOiBzaWduYXR1cmVOb3JtYWxpemUsXG4gIHNpZ25hdHVyZUV4cG9ydDogc2lnbmF0dXJlRXhwb3J0LFxuICBzaWduYXR1cmVJbXBvcnQ6IHNpZ25hdHVyZUltcG9ydCxcbiAgc2lnbmF0dXJlSW1wb3J0TGF4OiBzaWduYXR1cmVJbXBvcnRMYXgsXG5cbiAgc2lnbjogc2lnbixcbiAgdmVyaWZ5OiB2ZXJpZnksXG4gIHJlY292ZXI6IHJlY292ZXIsXG5cbiAgZWNkaDogZWNkaCxcbiAgZWNkaFVuc2FmZTogZWNkaFVuc2FmZVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gVGhpcyBmaWxlIGlzIGltcG9ydGVkIGZyb20gc2VjcDI1NmsxIHYzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxudmFyIEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9DT01QUkVTU0VEID0gQnVmZmVyLmZyb20oW1xuLy8gYmVnaW5cbjB4MzAsIDB4ODEsIDB4ZDMsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MDQsIDB4MjAsXG4vLyBwcml2YXRlIGtleVxuMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbi8vIG1pZGRsZVxuMHhhMCwgMHg4MSwgMHg4NSwgMHgzMCwgMHg4MSwgMHg4MiwgMHgwMiwgMHgwMSwgMHgwMSwgMHgzMCwgMHgyYywgMHgwNiwgMHgwNywgMHgyYSwgMHg4NiwgMHg0OCwgMHhjZSwgMHgzZCwgMHgwMSwgMHgwMSwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhmZiwgMHhmZiwgMHhmYywgMHgyZiwgMHgzMCwgMHgwNiwgMHgwNCwgMHgwMSwgMHgwMCwgMHgwNCwgMHgwMSwgMHgwNywgMHgwNCwgMHgyMSwgMHgwMiwgMHg3OSwgMHhiZSwgMHg2NiwgMHg3ZSwgMHhmOSwgMHhkYywgMHhiYiwgMHhhYywgMHg1NSwgMHhhMCwgMHg2MiwgMHg5NSwgMHhjZSwgMHg4NywgMHgwYiwgMHgwNywgMHgwMiwgMHg5YiwgMHhmYywgMHhkYiwgMHgyZCwgMHhjZSwgMHgyOCwgMHhkOSwgMHg1OSwgMHhmMiwgMHg4MSwgMHg1YiwgMHgxNiwgMHhmOCwgMHgxNywgMHg5OCwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhiYSwgMHhhZSwgMHhkYywgMHhlNiwgMHhhZiwgMHg0OCwgMHhhMCwgMHgzYiwgMHhiZiwgMHhkMiwgMHg1ZSwgMHg4YywgMHhkMCwgMHgzNiwgMHg0MSwgMHg0MSwgMHgwMiwgMHgwMSwgMHgwMSwgMHhhMSwgMHgyNCwgMHgwMywgMHgyMiwgMHgwMCxcbi8vIHB1YmxpYyBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdKTtcblxudmFyIEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9VTkNPTVBSRVNTRUQgPSBCdWZmZXIuZnJvbShbXG4vLyBiZWdpblxuMHgzMCwgMHg4MiwgMHgwMSwgMHgxMywgMHgwMiwgMHgwMSwgMHgwMSwgMHgwNCwgMHgyMCxcbi8vIHByaXZhdGUga2V5XG4weDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuLy8gbWlkZGxlXG4weGEwLCAweDgxLCAweGE1LCAweDMwLCAweDgxLCAweGEyLCAweDAyLCAweDAxLCAweDAxLCAweDMwLCAweDJjLCAweDA2LCAweDA3LCAweDJhLCAweDg2LCAweDQ4LCAweGNlLCAweDNkLCAweDAxLCAweDAxLCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZlLCAweGZmLCAweGZmLCAweGZjLCAweDJmLCAweDMwLCAweDA2LCAweDA0LCAweDAxLCAweDAwLCAweDA0LCAweDAxLCAweDA3LCAweDA0LCAweDQxLCAweDA0LCAweDc5LCAweGJlLCAweDY2LCAweDdlLCAweGY5LCAweGRjLCAweGJiLCAweGFjLCAweDU1LCAweGEwLCAweDYyLCAweDk1LCAweGNlLCAweDg3LCAweDBiLCAweDA3LCAweDAyLCAweDliLCAweGZjLCAweGRiLCAweDJkLCAweGNlLCAweDI4LCAweGQ5LCAweDU5LCAweGYyLCAweDgxLCAweDViLCAweDE2LCAweGY4LCAweDE3LCAweDk4LCAweDQ4LCAweDNhLCAweGRhLCAweDc3LCAweDI2LCAweGEzLCAweGM0LCAweDY1LCAweDVkLCAweGE0LCAweGZiLCAweGZjLCAweDBlLCAweDExLCAweDA4LCAweGE4LCAweGZkLCAweDE3LCAweGI0LCAweDQ4LCAweGE2LCAweDg1LCAweDU0LCAweDE5LCAweDljLCAweDQ3LCAweGQwLCAweDhmLCAweGZiLCAweDEwLCAweGQ0LCAweGI4LCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZlLCAweGJhLCAweGFlLCAweGRjLCAweGU2LCAweGFmLCAweDQ4LCAweGEwLCAweDNiLCAweGJmLCAweGQyLCAweDVlLCAweDhjLCAweGQwLCAweDM2LCAweDQxLCAweDQxLCAweDAyLCAweDAxLCAweDAxLCAweGExLCAweDQ0LCAweDAzLCAweDQyLCAweDAwLFxuLy8gcHVibGljIGtleVxuMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMF0pO1xuXG5leHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgcHVibGljS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciByZXN1bHQgPSBCdWZmZXIuZnJvbShjb21wcmVzc2VkID8gRUNfUFJJVktFWV9FWFBPUlRfREVSX0NPTVBSRVNTRUQgOiBFQ19QUklWS0VZX0VYUE9SVF9ERVJfVU5DT01QUkVTU0VEKTtcbiAgcHJpdmF0ZUtleS5jb3B5KHJlc3VsdCwgY29tcHJlc3NlZCA/IDggOiA5KTtcbiAgcHVibGljS2V5LmNvcHkocmVzdWx0LCBjb21wcmVzc2VkID8gMTgxIDogMjE0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydHMucHJpdmF0ZUtleUltcG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBsZW5ndGggPSBwcml2YXRlS2V5Lmxlbmd0aDtcblxuICAvLyBzZXF1ZW5jZSBoZWFkZXJcbiAgdmFyIGluZGV4ID0gMDtcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMSB8fCBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgzMCkgcmV0dXJuIG51bGw7XG4gIGluZGV4ICs9IDE7XG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoIGNvbnN0cnVjdG9yXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgIShwcml2YXRlS2V5W2luZGV4XSAmIDB4ODApKSByZXR1cm4gbnVsbDtcblxuICB2YXIgbGVuYiA9IHByaXZhdGVLZXlbaW5kZXhdICYgMHg3ZjtcbiAgaW5kZXggKz0gMTtcbiAgaWYgKGxlbmIgPCAxIHx8IGxlbmIgPiAyKSByZXR1cm4gbnVsbDtcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgbGVuYikgcmV0dXJuIG51bGw7XG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoXG4gIHZhciBsZW4gPSBwcml2YXRlS2V5W2luZGV4ICsgbGVuYiAtIDFdIHwgKGxlbmIgPiAxID8gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAyXSA8PCA4IDogMCk7XG4gIGluZGV4ICs9IGxlbmI7XG4gIGlmIChsZW5ndGggPCBpbmRleCArIGxlbikgcmV0dXJuIG51bGw7XG5cbiAgLy8gc2VxdWVuY2UgZWxlbWVudCAwOiB2ZXJzaW9uIG51bWJlciAoPTEpXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDMgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MDIgfHwgcHJpdmF0ZUtleVtpbmRleCArIDFdICE9PSAweDAxIHx8IHByaXZhdGVLZXlbaW5kZXggKyAyXSAhPT0gMHgwMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGluZGV4ICs9IDM7XG5cbiAgLy8gc2VxdWVuY2UgZWxlbWVudCAxOiBvY3RldCBzdHJpbmcsIHVwIHRvIDMyIGJ5dGVzXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDIgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MDQgfHwgcHJpdmF0ZUtleVtpbmRleCArIDFdID4gMHgyMCB8fCBsZW5ndGggPCBpbmRleCArIDIgKyBwcml2YXRlS2V5W2luZGV4ICsgMV0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBwcml2YXRlS2V5LnNsaWNlKGluZGV4ICsgMiwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKTtcbn07XG5cbmV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0TGF4ID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICB2YXIgciA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG4gIHZhciBzID0gQnVmZmVyLmFsbG9jKDMyLCAwKTtcblxuICB2YXIgbGVuZ3RoID0gc2lnbmF0dXJlLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZVxuICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDMwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBzZXF1ZW5jZSBsZW5ndGggYnl0ZVxuICB2YXIgbGVuYnl0ZSA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgaWYgKGxlbmJ5dGUgJiAweDgwKSB7XG4gICAgaW5kZXggKz0gbGVuYnl0ZSAtIDB4ODA7XG4gICAgaWYgKGluZGV4ID4gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZSBmb3IgclxuICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBsZW5ndGggZm9yIHJcbiAgdmFyIHJsZW4gPSBzaWduYXR1cmVbaW5kZXgrK107XG4gIGlmIChybGVuICYgMHg4MCkge1xuICAgIGxlbmJ5dGUgPSBybGVuIC0gMHg4MDtcbiAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ25hdHVyZVtpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge31cbiAgICBmb3IgKHJsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKSB7XG4gICAgICBybGVuID0gKHJsZW4gPDwgOCkgKyBzaWduYXR1cmVbaW5kZXhdO1xuICAgIH1cbiAgfVxuICBpZiAocmxlbiA+IGxlbmd0aCAtIGluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJpbmRleCA9IGluZGV4O1xuICBpbmRleCArPSBybGVuO1xuXG4gIC8vIHNlcXVlbmNlIHRhZyBieXRlIGZvciBzXG4gIGlmIChzaWduYXR1cmVbaW5kZXgrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGxlbmd0aCBmb3Igc1xuICB2YXIgc2xlbiA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgaWYgKHNsZW4gJiAweDgwKSB7XG4gICAgbGVuYnl0ZSA9IHNsZW4gLSAweDgwO1xuICAgIGlmIChpbmRleCArIGxlbmJ5dGUgPiBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKDsgbGVuYnl0ZSA+IDAgJiYgc2lnbmF0dXJlW2luZGV4XSA9PT0gMHgwMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKSB7fVxuICAgIGZvciAoc2xlbiA9IDA7IGxlbmJ5dGUgPiAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHtcbiAgICAgIHNsZW4gPSAoc2xlbiA8PCA4KSArIHNpZ25hdHVyZVtpbmRleF07XG4gICAgfVxuICB9XG4gIGlmIChzbGVuID4gbGVuZ3RoIC0gaW5kZXgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc2luZGV4ID0gaW5kZXg7XG4gIGluZGV4ICs9IHNsZW47XG5cbiAgLy8gaWdub3JlIGxlYWRpbmcgemVyb3MgaW4gclxuICBmb3IgKDsgcmxlbiA+IDAgJiYgc2lnbmF0dXJlW3JpbmRleF0gPT09IDB4MDA7IHJsZW4gLT0gMSwgcmluZGV4ICs9IDEpIHt9XG4gIC8vIGNvcHkgciB2YWx1ZVxuICBpZiAocmxlbiA+IDMyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJ2YWx1ZSA9IHNpZ25hdHVyZS5zbGljZShyaW5kZXgsIHJpbmRleCArIHJsZW4pO1xuICBydmFsdWUuY29weShyLCAzMiAtIHJ2YWx1ZS5sZW5ndGgpO1xuXG4gIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHNcbiAgZm9yICg7IHNsZW4gPiAwICYmIHNpZ25hdHVyZVtzaW5kZXhdID09PSAweDAwOyBzbGVuIC09IDEsIHNpbmRleCArPSAxKSB7fVxuICAvLyBjb3B5IHMgdmFsdWVcbiAgaWYgKHNsZW4gPiAzMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBzdmFsdWUgPSBzaWduYXR1cmUuc2xpY2Uoc2luZGV4LCBzaW5kZXggKyBzbGVuKTtcbiAgc3ZhbHVlLmNvcHkocywgMzIgLSBzdmFsdWUubGVuZ3RoKTtcblxuICByZXR1cm4geyByOiByLCBzOiBzIH07XG59OyIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmaWxlIGlzIGltcG9ydGVkIGZyb20gc2VjcDI1NmsxIHYzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWM7XG5cbnZhciBlYyA9IG5ldyBFQygnc2VjcDI1NmsxJyk7XG52YXIgZWNwYXJhbXMgPSBlYy5jdXJ2ZTtcblxuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIGQgPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gIGlmIChkLnVjbXAoZWNwYXJhbXMubikgPj0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY291bGRuXFwndCBleHBvcnQgdG8gREVSIGZvcm1hdCcpO1xuICB9XG5cbiAgdmFyIHBvaW50ID0gZWMuZy5tdWwoZCk7XG4gIHJldHVybiB0b1B1YmxpY0tleShwb2ludC5nZXRYKCksIHBvaW50LmdldFkoKSwgY29tcHJlc3NlZCk7XG59O1xuXG5leHBvcnRzLnByaXZhdGVLZXlNb2RJbnZlcnNlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgdmFyIGJuID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICBpZiAoYm4udWNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGJuLmlzWmVybygpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcml2YXRlIGtleSByYW5nZSBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gYm4uaW52bShlY3BhcmFtcy5uKS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKTtcbn07XG5cbmV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0ID0gZnVuY3Rpb24gKHNpZ09iaikge1xuICB2YXIgciA9IG5ldyBCTihzaWdPYmoucik7XG4gIGlmIChyLnVjbXAoZWNwYXJhbXMubikgPj0gMCkge1xuICAgIHIgPSBuZXcgQk4oMCk7XG4gIH1cblxuICB2YXIgcyA9IG5ldyBCTihzaWdPYmoucyk7XG4gIGlmIChzLnVjbXAoZWNwYXJhbXMubikgPj0gMCkge1xuICAgIHMgPSBuZXcgQk4oMCk7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbci50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKSwgcy50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKV0pO1xufTtcblxuZXhwb3J0cy5lY2RoVW5zYWZlID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcG9pbnQgPSBlYy5rZXlGcm9tUHVibGljKHB1YmxpY0tleSk7XG5cbiAgdmFyIHNjYWxhciA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgaWYgKHNjYWxhci51Y21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2NhbGFyLmlzWmVybygpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzY2FsYXIgd2FzIGludmFsaWQgKHplcm8gb3Igb3ZlcmZsb3cpJyk7XG4gIH1cblxuICB2YXIgc2hhcmVkID0gcG9pbnQucHViLm11bChzY2FsYXIpO1xuICByZXR1cm4gdG9QdWJsaWNLZXkoc2hhcmVkLmdldFgoKSwgc2hhcmVkLmdldFkoKSwgY29tcHJlc3NlZCk7XG59O1xuXG52YXIgdG9QdWJsaWNLZXkgPSBmdW5jdGlvbiB0b1B1YmxpY0tleSh4LCB5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBwdWJsaWNLZXkgPSB2b2lkIDA7XG5cbiAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICBwdWJsaWNLZXkgPSBCdWZmZXIuYWxsb2MoMzMpO1xuICAgIHB1YmxpY0tleVswXSA9IHkuaXNPZGQoKSA/IDB4MDMgOiAweDAyO1xuICAgIHgudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikuY29weShwdWJsaWNLZXksIDEpO1xuICB9IGVsc2Uge1xuICAgIHB1YmxpY0tleSA9IEJ1ZmZlci5hbGxvYyg2NSk7XG4gICAgcHVibGljS2V5WzBdID0gMHgwNDtcbiAgICB4LnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocHVibGljS2V5LCAxKTtcbiAgICB5LnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocHVibGljS2V5LCAzMyk7XG4gIH1cblxuICByZXR1cm4gcHVibGljS2V5O1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0hleFByZWZpeGVkID0gcmVxdWlyZSgnaXMtaGV4LXByZWZpeGVkJyk7XG52YXIgc3RyaXBIZXhQcmVmaXggPSByZXF1aXJlKCdzdHJpcC1oZXgtcHJlZml4Jyk7XG5cbi8qKlxuICogUGFkcyBhIGBTdHJpbmdgIHRvIGhhdmUgYW4gZXZlbiBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKHZhbHVlKSB7XG4gIHZhciBhID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgcGFkZGluZyB0byBldmVuLCB2YWx1ZSBtdXN0IGJlIHN0cmluZywgaXMgY3VycmVudGx5ICcgKyB0eXBlb2YgYSArICcsIHdoaWxlIHBhZFRvRXZlbi4nKTtcbiAgfVxuXG4gIGlmIChhLmxlbmd0aCAlIDIpIHtcbiAgICBhID0gJzAnICsgYTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaW50VG9IZXgoaSkge1xuICB2YXIgaGV4ID0gaS50b1N0cmluZygxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBgTnVtYmVyYCB0byBhIGBCdWZmZXJgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihpKSB7XG4gIHZhciBoZXggPSBpbnRUb0hleChpKTtcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oaGV4LnNsaWNlKDIpKSwgJ2hleCcpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYmluYXJ5IHNpemUgb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5U2l6ZShzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgZ2V0dGluZyBiaW5hcnkgc2l6ZSwgbWV0aG9kIGdldEJpbmFyeVNpemUgcmVxdWlyZXMgaW5wdXQgXFwnc3RyXFwnIHRvIGJlIHR5cGUgU3RyaW5nLCBnb3QgXFwnJyArIHR5cGVvZiBzdHIgKyAnXFwnLicpO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGZpcnN0IHNwZWNpZmllZCBhcnJheSBjb250YWlucyBhbGwgZWxlbWVudHNcbiAqIGZyb20gdGhlIHNlY29uZCBvbmUuIEZBTFNFIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBzdXBlcnNldFxuICogQHBhcmFtIHthcnJheX0gc3Vic2V0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnNBcnJheShzdXBlcnNldCwgc3Vic2V0LCBzb21lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN1cGVyc2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3VwZXJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdXBlcnNldCArICdcXCcnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdWJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdWJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdWJzZXQgKyAnXFwnJyk7XG4gIH1cblxuICByZXR1cm4gc3Vic2V0W0Jvb2xlYW4oc29tZSkgJiYgJ3NvbWUnIHx8ICdldmVyeSddKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlcnNldC5pbmRleE9mKHZhbHVlKSA+PSAwO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCB1dGY4IGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9VdGY4KGhleCkge1xuICB2YXIgYnVmZmVyVmFsdWUgPSBuZXcgQnVmZmVyKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeChoZXgpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpKSwgJ2hleCcpO1xuXG4gIHJldHVybiBidWZmZXJWYWx1ZS50b1N0cmluZygndXRmOCcpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQXNjaWkoaGV4KSB7XG4gIHZhciBzdHIgPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgaSA9IDAsXG4gICAgICBsID0gaGV4Lmxlbmd0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgaSA9IDI7XG4gIH1cblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHZhciBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbVV0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21VdGY4KHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBzdHIgPSBuZXcgQnVmZmVyKHN0cmluZ1ZhbHVlLCAndXRmOCcpO1xuXG4gIHJldHVybiAnMHgnICsgcGFkVG9FdmVuKHN0ci50b1N0cmluZygnaGV4JykpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbUFzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tQXNjaWkoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIGhleCA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIGNvZGUgPSBzdHJpbmdWYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICB9XG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogZ2V0S2V5cyhbe2E6IDEsIGI6IDJ9LCB7YTogMywgYjogNH1dLCAnYScpID0+IFsxLCAzXVxuICpcbiAqIEBtZXRob2QgZ2V0S2V5cyBnZXQgc3BlY2lmaWMga2V5IGZyb20gaW5uZXIgb2JqZWN0IGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dFbXB0eVxuICogQHJldHVybnMge0FycmF5fSBvdXRwdXQganVzdCBhIHNpbXBsZSBhcnJheSBvZiBvdXRwdXQga2V5c1xuICovXG5mdW5jdGlvbiBnZXRLZXlzKHBhcmFtcywga2V5LCBhbGxvd0VtcHR5KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgQXJyYXkgYXMgXFwncGFyYW1zXFwnIGlucHV0LCBnb3QgXFwnJyArIHR5cGVvZiBwYXJhbXMgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgU3RyaW5nIGZvciBpbnB1dCBcXCdrZXlcXCcgZ290IFxcJycgKyB0eXBlb2Yga2V5ICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciB2YWx1ZSA9IHBhcmFtc1tpXVtrZXldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKGFsbG93RW1wdHkgJiYgIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFiaScpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIElzIHRoZSBzdHJpbmcgYSBoZXggc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgY2hlY2sgaWYgc3RyaW5nIGlzIGhleCBzdHJpbmcgb2Ygc3BlY2lmaWMgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm5zIHtCb29sZWFufSBvdXRwdXQgdGhlIHN0cmluZyBpcyBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJyYXlDb250YWluc0FycmF5OiBhcnJheUNvbnRhaW5zQXJyYXksXG4gIGludFRvQnVmZmVyOiBpbnRUb0J1ZmZlcixcbiAgZ2V0QmluYXJ5U2l6ZTogZ2V0QmluYXJ5U2l6ZSxcbiAgaXNIZXhQcmVmaXhlZDogaXNIZXhQcmVmaXhlZCxcbiAgc3RyaXBIZXhQcmVmaXg6IHN0cmlwSGV4UHJlZml4LFxuICBwYWRUb0V2ZW46IHBhZFRvRXZlbixcbiAgaW50VG9IZXg6IGludFRvSGV4LFxuICBmcm9tQXNjaWk6IGZyb21Bc2NpaSxcbiAgZnJvbVV0Zjg6IGZyb21VdGY4LFxuICB0b0FzY2lpOiB0b0FzY2lpLFxuICB0b1V0Zjg6IHRvVXRmOCxcbiAgZ2V0S2V5czogZ2V0S2V5cyxcbiAgaXNIZXhTdHJpbmc6IGlzSGV4U3RyaW5nXG59OyIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5cbmZ1bmN0aW9uIHRocm93SWZOb3RTdHJpbmdPckJ1ZmZlciAodmFsLCBwcmVmaXgpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsKSAmJiB0eXBlb2YgdmFsICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocHJlZml4ICsgJyBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgYnVmZmVyJylcbiAgfVxufVxuXG5mdW5jdGlvbiBIYXNoQmFzZSAoYmxvY2tTaXplKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMpXG5cbiAgdGhpcy5fYmxvY2sgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYmxvY2tTaXplKVxuICB0aGlzLl9ibG9ja1NpemUgPSBibG9ja1NpemVcbiAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXG4gIHRoaXMuX2xlbmd0aCA9IFswLCAwLCAwLCAwXVxuXG4gIHRoaXMuX2ZpbmFsaXplZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKEhhc2hCYXNlLCBUcmFuc2Zvcm0pXG5cbkhhc2hCYXNlLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgdmFyIGVycm9yID0gbnVsbFxuICB0cnkge1xuICAgIHRoaXMudXBkYXRlKGNodW5rLCBlbmNvZGluZylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IgPSBlcnJcbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9yKVxufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciBlcnJvciA9IG51bGxcbiAgdHJ5IHtcbiAgICB0aGlzLnB1c2godGhpcy5kaWdlc3QoKSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IgPSBlcnJcbiAgfVxuXG4gIGNhbGxiYWNrKGVycm9yKVxufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nKSB7XG4gIHRocm93SWZOb3RTdHJpbmdPckJ1ZmZlcihkYXRhLCAnRGF0YScpXG4gIGlmICh0aGlzLl9maW5hbGl6ZWQpIHRocm93IG5ldyBFcnJvcignRGlnZXN0IGFscmVhZHkgY2FsbGVkJylcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmNvZGluZylcblxuICAvLyBjb25zdW1lIGRhdGFcbiAgdmFyIGJsb2NrID0gdGhpcy5fYmxvY2tcbiAgdmFyIG9mZnNldCA9IDBcbiAgd2hpbGUgKHRoaXMuX2Jsb2NrT2Zmc2V0ICsgZGF0YS5sZW5ndGggLSBvZmZzZXQgPj0gdGhpcy5fYmxvY2tTaXplKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX2Jsb2NrT2Zmc2V0OyBpIDwgdGhpcy5fYmxvY2tTaXplOykgYmxvY2tbaSsrXSA9IGRhdGFbb2Zmc2V0KytdXG4gICAgdGhpcy5fdXBkYXRlKClcbiAgICB0aGlzLl9ibG9ja09mZnNldCA9IDBcbiAgfVxuICB3aGlsZSAob2Zmc2V0IDwgZGF0YS5sZW5ndGgpIGJsb2NrW3RoaXMuX2Jsb2NrT2Zmc2V0KytdID0gZGF0YVtvZmZzZXQrK11cblxuICAvLyB1cGRhdGUgbGVuZ3RoXG4gIGZvciAodmFyIGogPSAwLCBjYXJyeSA9IGRhdGEubGVuZ3RoICogODsgY2FycnkgPiAwOyArK2opIHtcbiAgICB0aGlzLl9sZW5ndGhbal0gKz0gY2FycnlcbiAgICBjYXJyeSA9ICh0aGlzLl9sZW5ndGhbal0gLyAweDAxMDAwMDAwMDApIHwgMFxuICAgIGlmIChjYXJyeSA+IDApIHRoaXMuX2xlbmd0aFtqXSAtPSAweDAxMDAwMDAwMDAgKiBjYXJyeVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuSGFzaEJhc2UucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBpcyBub3QgaW1wbGVtZW50ZWQnKVxufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGlmICh0aGlzLl9maW5hbGl6ZWQpIHRocm93IG5ldyBFcnJvcignRGlnZXN0IGFscmVhZHkgY2FsbGVkJylcbiAgdGhpcy5fZmluYWxpemVkID0gdHJ1ZVxuXG4gIHZhciBkaWdlc3QgPSB0aGlzLl9kaWdlc3QoKVxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgZGlnZXN0ID0gZGlnZXN0LnRvU3RyaW5nKGVuY29kaW5nKVxuXG4gIC8vIHJlc2V0IHN0YXRlXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMClcbiAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB0aGlzLl9sZW5ndGhbaV0gPSAwXG5cbiAgcmV0dXJuIGRpZ2VzdFxufVxuXG5IYXNoQmFzZS5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfZGlnZXN0IGlzIG5vdCBpbXBsZW1lbnRlZCcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaEJhc2VcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBjb2RlcyA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICBpZiAoIUJhc2UpIHtcbiAgICBCYXNlID0gRXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIE5vZGVFcnJvciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9CYXNlKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTm9kZUVycm9yLCBfQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBOb2RlRXJyb3IoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgcmV0dXJuIF9CYXNlLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkgfHwgdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTm9kZUVycm9yO1xuICB9KEJhc2UpO1xuXG4gIE5vZGVFcnJvci5wcm90b3R5cGUubmFtZSA9IEJhc2UubmFtZTtcbiAgTm9kZUVycm9yLnByb3RvdHlwZS5jb2RlID0gY29kZTtcbiAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC44LjAvbGliL2ludGVybmFsL2Vycm9ycy5qc1xuXG5cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdLCBcIiBvciBcIikuY29uY2F0KGV4cGVjdGVkWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KFN0cmluZyhleHBlY3RlZCkpO1xuICB9XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXG5cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5cblxuZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcbiAgfVxufVxuXG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX09QVF9WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gJ1RoZSB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCInICsgbmFtZSArICdcIic7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG4gIHZhciBkZXRlcm1pbmVyO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cblxuICB2YXIgbXNnO1xuXG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gXCJUaGUgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gXCJUaGUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgXCIpLmNvbmNhdCh0eXBlLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9XG5cbiAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdCh0eXBlb2YgYWN0dWFsKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YnLCAnc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ1RoZSAnICsgbmFtZSArICcgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnLCAnUHJlbWF0dXJlIGNsb3NlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fREVTVFJPWUVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdDYW5ub3QgY2FsbCAnICsgbmFtZSArICcgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0NBTk5PVF9QSVBFJywgJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnLCAnd3JpdGUgYWZ0ZXIgZW5kJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fTlVMTF9WQUxVRVMnLCAnTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfVU5LTk9XTl9FTkNPRElORycsIGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuICdVbmtub3duIGVuY29kaW5nOiAnICsgYXJnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCcsICdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xubW9kdWxlLmV4cG9ydHMuY29kZXMgPSBjb2RlcztcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cbid1c2Ugc3RyaWN0Jztcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcblxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gQWxsb3cgdGhlIGtleXMgYXJyYXkgdG8gYmUgR0MnZWQuXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuXG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcblxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIElmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLCB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuOyAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuXG4gIHByb2Nlc3MubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIEVFbGlzdGVuZXJDb3VudChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBkZWJ1ZztcblxuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QnKTtcblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVDsgLy8gTGF6eSBsb2FkZWQgdG8gaW1wcm92ZSB0aGUgc3RhcnR1cCBwZXJmb3JtYW5jZS5cblxuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTsgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcblxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB0aGlzLnBhdXNlZCA9IHRydWU7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG5cbiAgdGhpcy5hd2FpdERyYWluID0gMDsgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3lcblxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsgLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cblxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59OyAvLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuXG4gICAgaWYgKGVyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCgpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRigpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IC8vIFdlIGNhbiBwdXNoIG1vcmUgZGF0YSBpZiB3ZSBhcmUgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmsuXG4gIC8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lIG1vcmUgYnl0ZXMuXG4gIC8vIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsIHN1Y2ggYXMgdGhlIHJlcGwuXG5cblxuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cblxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcblxuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKTtcbiAgfVxuXG4gIHJldHVybiBlcjtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyOyAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7IC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG5cbiAgdmFyIHAgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5oZWFkO1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIHdoaWxlIChwICE9PSBudWxsKSB7XG4gICAgY29udGVudCArPSBkZWNvZGVyLndyaXRlKHAuZGF0YSk7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG5cbiAgaWYgKGNvbnRlbnQgIT09ICcnKSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5wdXNoKGNvbnRlbnQpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xuICByZXR1cm4gdGhpcztcbn07IC8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxR0JcblxuXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5cbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIC8vIFRPRE8ocm9uYWcpOiBUaHJvdyBFUlJfVkFMVUVfT1VUX09GX1JBTkdFLlxuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cblxuICByZXR1cm4gbjtcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcblxuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfSAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cblxuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOyAvLyBEb24ndCBoYXZlIGVub3VnaFxuXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn0gLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoKHN0YXRlLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayA6IHN0YXRlLmxlbmd0aCA+IDApIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuXG5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpOyAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9IC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cblxuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7IC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG5cbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuXG4gICAgc3RhdGUuc3luYyA9IGZhbHNlOyAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cblxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cblxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcblxuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnN5bmMpIHtcbiAgICAvLyBpZiB3ZSBhcmUgc3luYywgd2FpdCB1bnRpbCBuZXh0IHRpY2sgdG8gZW1pdCB0aGUgZGF0YS5cbiAgICAvLyBPdGhlcndpc2Ugd2UgcmlzayBlbWl0dGluZyBkYXRhIGluIHRoZSBmbG93KClcbiAgICAvLyB0aGUgcmVhZGFibGUgY29kZSB0cmlnZ2VycyBkdXJpbmcgYSByZWFkKCkgY2FsbFxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfVxuICB9XG59IC8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5uZWVkUmVhZGFibGUsIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSk7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuXG4gIGlmICghc3RhdGUuZGVzdHJveWVkICYmIChzdGF0ZS5sZW5ndGggfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIH0gLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuXG5cbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBmbG93KHN0cmVhbSk7XG59IC8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuXG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHRoZSBzdHJlYW0gaGFzIGNhbGxlZCB0aGUgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBfcmVhZCgpXG4gIC8vICAgbWV0aG9kLCBidXQgdGhleSBhcmUgcHJvY2Vzc2luZyB0aGUgY2FsbCBhc3luY2hyb25vdXNseSBhbmQgaGF2ZSBfbm90X1xuICAvLyAgIGNhbGxlZCBwdXNoKCkgd2l0aCBuZXcgZGF0YS4gSW4gdGhpcyBjYXNlIHdlIHNraXAgcGVyZm9ybWluZyBtb3JlXG4gIC8vICAgcmVhZCgpcy4gVGhlIGV4ZWN1dGlvbiBlbmRzIGluIHRoaXMgbWV0aG9kIGFnYWluIGFmdGVyIHRoZSBfcmVhZCgpIGVuZHNcbiAgLy8gICB1cCBjYWxsaW5nIHB1c2goKSB3aXRoIG1vcmUgZGF0YS5cbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn0gLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcblxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH0gLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG5cblxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7IC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgY2xlYW5lZFVwID0gdHJ1ZTsgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBkZWJ1ZygnZGVzdC53cml0ZScsIHJldCk7XG5cbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cblxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9IC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG5cblxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBlcnJvck9yRGVzdHJveShkZXN0LCBlcik7XG4gIH0gLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuXG5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpOyAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH0gLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cblxuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7IC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gcGlwZU9uRHJhaW5GdW5jdGlvblJlc3VsdCgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07IC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7IC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlczsgLy8gZ290IGEgbWF0Y2guXG5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuXG5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07IC8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5cblxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7IC8vIFRyeSBzdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcblxuICAgIGlmIChzdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKTtcblxuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgaWYgKHN0YXRlLnJlc3VtZVNjaGVkdWxlZCAmJiAhc3RhdGUucGF1c2VkKSB7XG4gICAgLy8gZmxvd2luZyBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZSBub3csIG90aGVyd2lzZVxuICAgIC8vIHRoZSB1cGNvbWluZyByZXN1bWUgd2lsbCBub3QgZmxvdy5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsgLy8gY3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWVcbiAgfSBlbHNlIGlmIChzZWxmLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICBzZWxmLnJlc3VtZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn0gLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpOyAvLyB3ZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpXG5cbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuXG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnBhdXNlZCA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHtcbiAgICA7XG4gIH1cbn0gLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOyAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcblxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcblxuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTsgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cblxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9IC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cblxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH0gLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cblxuXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG5cbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUZsb3dpbmcnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IHN0YXRlO1xuICAgIH1cbiAgfVxufSk7IC8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZScsIHN0YXRlLmVuZEVtaXR0ZWQpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7IC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgIC8vIGlmIHRoZSB3cml0YWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuXG4gICAgICBpZiAoIXdTdGF0ZSB8fCB3U3RhdGUuYXV0b0Rlc3Ryb3kgJiYgd1N0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbShSZWFkYWJsZSwgaXRlcmFibGUsIG9wdHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HLFxuICAgIEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMDtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcbiAgY2IoZXIpO1xuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07IC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH0gLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuXG5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59OyAvLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3RyYW5zZm9ybSgpJykpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcblxuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07IC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG5cbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7IC8vIFRPRE8oQnJpZGdlQVIpOiBXcml0ZSBhIHRlc3QgZm9yIHRoZXNlIHR3byBlcnJvciBjYXNlc1xuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wKCk7XG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcoKTtcbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuLyogPHJlcGxhY2VtZW50PiAqL1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59IC8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5cblxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0NBTk5PVF9QSVBFLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gICAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXG4gICAgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCxcbiAgICBFUlJfVU5LTk9XTl9FTkNPRElORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9VTktOT1dOX0VOQ09ESU5HO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcbiAgLy8gZS5nLiBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSB2cy4gb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUsIGV0Yy5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcblxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7IC8vIGRyYWluIGV2ZW50IGZsYWcuXG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTsgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcblxuICB0aGlzLmVuZGluZyA9IGZhbHNlOyAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG5cbiAgdGhpcy5lbmRlZCA9IGZhbHNlOyAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcblxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cblxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG5cbiAgdGhpcy5sZW5ndGggPSAwOyAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlOyAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG5cbiAgdGhpcy5jb3JrZWQgPSAwOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOyAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG5cbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG5cblxuICB0aGlzLndyaXRlY2IgPSBudWxsOyAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG5cbiAgdGhpcy5wZW5kaW5nY2IgPSAwOyAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG5cbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZmluaXNoJyAoYW5kIHBvdGVudGlhbGx5ICdlbmQnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7IC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuXG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTsgLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG5cblxudmFyIHJlYWxIYXNJbnN0YW5jZTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gcmVhbEhhc0luc3RhbmNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7IC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICBpZiAoIWlzRHVwbGV4ICYmICFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeS5cblxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59IC8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cblxuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUoKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7IC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG5cbiAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbn0gLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuXG5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciBlcjtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlciddLCBjaHVuayk7XG4gIH1cblxuICBpZiAoZXIpIHtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuICBpZiAoc3RhdGUuZW5kaW5nKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cblxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pOyAvLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7IC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLmRlc3Ryb3llZCkgc3RhdGUub253cml0ZShuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3dyaXRlJykpO2Vsc2UgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcblxuICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTtcbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpIHx8IHN0cmVhbS5kZXN0cm95ZWQ7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufSAvLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cblxuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59IC8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5cblxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7IC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG5cbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07IC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7IC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfSAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG5cblxuICBpZiAoIXN0YXRlLmVuZGluZykgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nICYmICFzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcblxuICAgICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgICAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAgICAgICBpZiAoIXJTdGF0ZSB8fCByU3RhdGUuYXV0b0Rlc3Ryb3kgJiYgclN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuXG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzcy5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcblxuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfSAvLyByZXVzZSB0aGUgZnJlZSBjb3JrUmVxLlxuXG5cbiAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgZmluaXNoZWQgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcblxudmFyIGtMYXN0UmVzb2x2ZSA9IFN5bWJvbCgnbGFzdFJlc29sdmUnKTtcbnZhciBrTGFzdFJlamVjdCA9IFN5bWJvbCgnbGFzdFJlamVjdCcpO1xudmFyIGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcbnZhciBrRW5kZWQgPSBTeW1ib2woJ2VuZGVkJyk7XG52YXIga0xhc3RQcm9taXNlID0gU3ltYm9sKCdsYXN0UHJvbWlzZScpO1xudmFyIGtIYW5kbGVQcm9taXNlID0gU3ltYm9sKCdoYW5kbGVQcm9taXNlJyk7XG52YXIga1N0cmVhbSA9IFN5bWJvbCgnc3RyZWFtJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZG9uZTogZG9uZVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWFkQW5kUmVzb2x2ZShpdGVyKSB7XG4gIHZhciByZXNvbHZlID0gaXRlcltrTGFzdFJlc29sdmVdO1xuXG4gIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgdmFyIGRhdGEgPSBpdGVyW2tTdHJlYW1dLnJlYWQoKTsgLy8gd2UgZGVmZXIgaWYgZGF0YSBpcyBudWxsXG4gICAgLy8gd2UgY2FuIGJlIGV4cGVjdGluZyBlaXRoZXIgJ2VuZCcgb3JcbiAgICAvLyAnZXJyb3InXG5cbiAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgaXRlcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25SZWFkYWJsZShpdGVyKSB7XG4gIC8vIHdlIHdhaXQgZm9yIHRoZSBuZXh0IHRpY2ssIGJlY2F1c2UgaXQgbWlnaHRcbiAgLy8gZW1pdCBhbiBlcnJvciB3aXRoIHByb2Nlc3MubmV4dFRpY2tcbiAgcHJvY2Vzcy5uZXh0VGljayhyZWFkQW5kUmVzb2x2ZSwgaXRlcik7XG59XG5cbmZ1bmN0aW9uIHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCBpdGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGFzdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXRlcltrRW5kZWRdKSB7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpdGVyW2tIYW5kbGVQcm9taXNlXShyZXNvbHZlLCByZWplY3QpO1xuICAgIH0sIHJlamVjdCk7XG4gIH07XG59XG5cbnZhciBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uICgpIHt9KTtcbnZhciBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YoKF9PYmplY3Qkc2V0UHJvdG90eXBlTyA9IHtcbiAgZ2V0IHN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpc1trU3RyZWFtXTtcbiAgfSxcblxuICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGRldGVjdGVkIGFuIGVycm9yIGluIHRoZSBtZWFud2hpbGVcbiAgICAvLyByZWplY3Qgc3RyYWlnaHQgYXdheVxuICAgIHZhciBlcnJvciA9IHRoaXNba0Vycm9yXTtcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRW5kZWRdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba1N0cmVhbV0uZGVzdHJveWVkKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGRlZmVyIHZpYSBuZXh0VGljayBiZWNhdXNlIGlmIC5kZXN0cm95KGVycikgaXNcbiAgICAgIC8vIGNhbGxlZCwgdGhlIGVycm9yIHdpbGwgYmUgZW1pdHRlZCB2aWEgbmV4dFRpY2ssIGFuZFxuICAgICAgLy8gd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IHRoZXJlIGlzIG5vIGVycm9yIGxpbmdlcmluZyBhcm91bmRcbiAgICAgIC8vIHdhaXRpbmcgdG8gYmUgZW1pdHRlZC5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpc1trRXJyb3JdKSB7XG4gICAgICAgICAgICByZWplY3QoX3RoaXNba0Vycm9yXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSAvLyBpZiB3ZSBoYXZlIG11bHRpcGxlIG5leHQoKSBjYWxsc1xuICAgIC8vIHdlIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIFByb21pc2UgdG8gZmluaXNoXG4gICAgLy8gdGhpcyBsb2dpYyBpcyBvcHRpbWl6ZWQgdG8gc3VwcG9ydCBmb3IgYXdhaXQgbG9vcHMsXG4gICAgLy8gd2hlcmUgbmV4dCgpIGlzIG9ubHkgY2FsbGVkIG9uY2UgYXQgYSB0aW1lXG5cblxuICAgIHZhciBsYXN0UHJvbWlzZSA9IHRoaXNba0xhc3RQcm9taXNlXTtcbiAgICB2YXIgcHJvbWlzZTtcblxuICAgIGlmIChsYXN0UHJvbWlzZSkge1xuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhc3QgcGF0aCBuZWVkZWQgdG8gc3VwcG9ydCBtdWx0aXBsZSB0aGlzLnB1c2goKVxuICAgICAgLy8gd2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBuZXh0KCkgcXVldWVcbiAgICAgIHZhciBkYXRhID0gdGhpc1trU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2UodGhpc1trSGFuZGxlUHJvbWlzZV0pO1xuICAgIH1cblxuICAgIHRoaXNba0xhc3RQcm9taXNlXSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn0sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFwicmV0dXJuXCIsIGZ1bmN0aW9uIF9yZXR1cm4oKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIC8vIGRlc3Ryb3koZXJyLCBjYikgaXMgYSBwcml2YXRlIEFQSVxuICAvLyB3ZSBjYW4gZ3VhcmFudGVlIHdlIGhhdmUgdGhhdCBoZXJlLCBiZWNhdXNlIHdlIGNvbnRyb2wgdGhlXG4gIC8vIFJlYWRhYmxlIGNsYXNzIHRoaXMgaXMgYXR0YWNoZWQgdG9cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBfdGhpczJba1N0cmVhbV0uZGVzdHJveShudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9KTtcbiAgfSk7XG59KSwgX09iamVjdCRzZXRQcm90b3R5cGVPKSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG5cbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtKSB7XG4gIHZhciBfT2JqZWN0JGNyZWF0ZTtcblxuICB2YXIgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgKF9PYmplY3QkY3JlYXRlID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga1N0cmVhbSwge1xuICAgIHZhbHVlOiBzdHJlYW0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZXNvbHZlLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZWplY3QsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRXJyb3IsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRW5kZWQsIHtcbiAgICB2YWx1ZTogc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0hhbmRsZVByb21pc2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZGF0YSA9IGl0ZXJhdG9yW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSByZXNvbHZlO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSByZWplY3Q7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX09iamVjdCRjcmVhdGUpKTtcbiAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gIGZpbmlzaGVkKHN0cmVhbSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScpIHtcbiAgICAgIHZhciByZWplY3QgPSBpdGVyYXRvcltrTGFzdFJlamVjdF07IC8vIHJlamVjdCBpZiB3ZSBhcmUgd2FpdGluZyBmb3IgZGF0YSBpbiB0aGUgUHJvbWlzZVxuICAgICAgLy8gcmV0dXJuZWQgYnkgbmV4dCgpIGFuZCBzdG9yZSB0aGUgZXJyb3JcblxuICAgICAgaWYgKHJlamVjdCAhPT0gbnVsbCkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRvcltrRXJyb3JdID0gZXJyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlID0gaXRlcmF0b3Jba0xhc3RSZXNvbHZlXTtcblxuICAgIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpdGVyYXRvcltrRW5kZWRdID0gdHJ1ZTtcbiAgfSk7XG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBvblJlYWRhYmxlLmJpbmQobnVsbCwgaXRlcmF0b3IpKTtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgICBCdWZmZXIgPSBfcmVxdWlyZS5CdWZmZXI7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xuXG52YXIgY3VzdG9tID0gaW5zcGVjdCAmJiBpbnNwZWN0LmN1c3RvbSB8fCAnaW5zcGVjdCc7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbChzcmMsIHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQnVmZmVyTGlzdCwgW3tcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogdGhpcy5oZWFkXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgLS10aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiam9pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25jYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBvciBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25zdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN1bWUobiwgaGFzU3RyaW5ncykge1xuICAgICAgdmFyIHJldDtcblxuICAgICAgaWYgKG4gPCB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gYHNsaWNlYCBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgICAgcmV0ID0gdGhpcy5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgICAgIHRoaXMuaGVhZC5kYXRhID0gdGhpcy5oZWFkLmRhdGEuc2xpY2Uobik7XG4gICAgICB9IGVsc2UgaWYgKG4gPT09IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBGaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2guXG4gICAgICAgIHJldCA9IHRoaXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlci5cbiAgICAgICAgcmV0ID0gaGFzU3RyaW5ncyA/IHRoaXMuX2dldFN0cmluZyhuKSA6IHRoaXMuX2dldEJ1ZmZlcihuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RyaW5nKG4pIHtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgdmFyIHJldCA9IHAuZGF0YTtcbiAgICAgIG4gLT0gcmV0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCdWZmZXIobikge1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgcC5kYXRhLmNvcHkocmV0KTtcbiAgICAgIG4gLT0gcC5kYXRhLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICAgICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBNYWtlIHN1cmUgdGhlIGxpbmtlZCBsaXN0IG9ubHkgc2hvd3MgdGhlIG1pbmltYWwgbmVjZXNzYXJ5IGluZm9ybWF0aW9uLlxuXG4gIH0sIHtcbiAgICBrZXk6IGN1c3RvbSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoXywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAvLyBPbmx5IGluc3BlY3Qgb25lIGxldmVsLlxuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgLy8gSXQgc2hvdWxkIG5vdCByZWN1cnNlLlxuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpOyIsIid1c2Ugc3RyaWN0JzsgLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH0gLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuXG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZU5UKHNlbGYsIGVycikge1xuICBlbWl0RXJyb3JOVChzZWxmLCBlcnIpO1xuICBlbWl0Q2xvc2VOVChzZWxmKTtcbn1cblxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xuICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZSAmJiAhc2VsZi5fd3JpdGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgaWYgKHNlbGYuX3JlYWRhYmxlU3RhdGUgJiYgIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5mdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycikge1xuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxuICAvLyBpbiB0aGUgc2FtZSB0aWNrLCBzbyBjaGFuZ2luZyB0aGlzIGlzIHNlbXZlciBtYWpvci5cbiAgLy8gRm9yIG5vdyB3aGVuIHlvdSBvcHQtaW4gdG8gYXV0b0Rlc3Ryb3kgd2UgYWxsb3dcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXG4gIC8vIHNlbXZlciBtYWpvciB1cGRhdGUgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgZGVmYXVsdCB0byB0aGlzLlxuICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICBpZiAoclN0YXRlICYmIHJTdGF0ZS5hdXRvRGVzdHJveSB8fCB3U3RhdGUgJiYgd1N0YXRlLmF1dG9EZXN0cm95KSBzdHJlYW0uZGVzdHJveShlcnIpO2Vsc2Ugc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95LFxuICBlcnJvck9yRGVzdHJveTogZXJyb3JPckRlc3Ryb3lcbn07IiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9lbmQtb2Ytc3RyZWFtIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTtcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGVvcyhzdHJlYW0sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpO1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICB2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZTtcbiAgdmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCBvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGU7XG5cbiAgdmFyIG9ubGVnYWN5ZmluaXNoID0gZnVuY3Rpb24gb25sZWdhY3lmaW5pc2goKSB7XG4gICAgaWYgKCFzdHJlYW0ud3JpdGFibGUpIG9uZmluaXNoKCk7XG4gIH07XG5cbiAgdmFyIHdyaXRhYmxlRW5kZWQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkO1xuXG4gIHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgd3JpdGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciByZWFkYWJsZUVuZGVkID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkO1xuXG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgcmVhZGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgfTtcblxuICB2YXIgb25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgdmFyIGVycjtcblxuICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgaWYgKHdyaXRhYmxlICYmICF3cml0YWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSB8fCAhc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uIG9ucmVxdWVzdCgpIHtcbiAgICBzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIH07XG5cbiAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO2Vsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlKSB7XG4gICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICBzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICB9XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG4gIHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICBpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW9zOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWRhYmxlLmZyb20gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3NlcicpXG59O1xuIiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9wdW1wIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW9zO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7XG5cbmZ1bmN0aW9uIG5vb3AoZXJyKSB7XG4gIC8vIFJldGhyb3cgdGhlIGVycm9yIGlmIGl0IGV4aXN0cyB0byBhdm9pZCBzd2FsbG93aW5nIGl0XG4gIGlmIChlcnIpIHRocm93IGVycjtcbn1cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChlb3MgPT09IHVuZGVmaW5lZCkgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG4gIGVvcyhzdHJlYW0sIHtcbiAgICByZWFkYWJsZTogcmVhZGluZyxcbiAgICB3cml0YWJsZTogd3JpdGluZ1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjbG9zZWQpIHJldHVybjtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTsgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnRcblxuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpO1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpO1xuICAgIGNhbGxiYWNrKGVyciB8fCBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3BpcGUnKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGwoZm4pIHtcbiAgZm4oKTtcbn1cblxuZnVuY3Rpb24gcGlwZShmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS5waXBlKHRvKTtcbn1cblxuZnVuY3Rpb24gcG9wQ2FsbGJhY2soc3RyZWFtcykge1xuICBpZiAoIXN0cmVhbXMubGVuZ3RoKSByZXR1cm4gbm9vcDtcbiAgaWYgKHR5cGVvZiBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gIT09ICdmdW5jdGlvbicpIHJldHVybiBub29wO1xuICByZXR1cm4gc3RyZWFtcy5wb3AoKTtcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0cmVhbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgY2FsbGJhY2sgPSBwb3BDYWxsYmFjayhzdHJlYW1zKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpIHN0cmVhbXMgPSBzdHJlYW1zWzBdO1xuXG4gIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnc3RyZWFtcycpO1xuICB9XG5cbiAgdmFyIGVycm9yO1xuICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7XG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxO1xuICAgIHZhciB3cml0aW5nID0gaSA+IDA7XG4gICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm47XG4gICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9JTlZBTElEX09QVF9WQUxVRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9JTlZBTElEX09QVF9WQUxVRTtcblxuZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkge1xuICByZXR1cm4gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrICE9IG51bGwgPyBvcHRpb25zLmhpZ2hXYXRlck1hcmsgOiBpc0R1cGxleCA/IG9wdGlvbnNbZHVwbGV4S2V5XSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hXYXRlck1hcmsoc3RhdGUsIG9wdGlvbnMsIGR1cGxleEtleSwgaXNEdXBsZXgpIHtcbiAgdmFyIGh3bSA9IGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpO1xuXG4gIGlmIChod20gIT0gbnVsbCkge1xuICAgIGlmICghKGlzRmluaXRlKGh3bSkgJiYgTWF0aC5mbG9vcihod20pID09PSBod20pIHx8IGh3bSA8IDApIHtcbiAgICAgIHZhciBuYW1lID0gaXNEdXBsZXggPyBkdXBsZXhLZXkgOiAnaGlnaFdhdGVyTWFyayc7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfT1BUX1ZBTFVFKG5hbWUsIGh3bSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaHdtKTtcbiAgfSAvLyBEZWZhdWx0IHZhbHVlXG5cblxuICByZXR1cm4gc3RhdGUub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0SGlnaFdhdGVyTWFyazogZ2V0SGlnaFdhdGVyTWFya1xufTsiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuZXhwb3J0cy5maW5pc2hlZCA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcycpO1xuZXhwb3J0cy5waXBlbGluZSA9IHJlcXVpcmUoJy4vbGliL2ludGVybmFsL3N0cmVhbXMvcGlwZWxpbmUuanMnKTtcbiIsInZhciBoYXNoID0gZXhwb3J0cztcblxuaGFzaC51dGlscyA9IHJlcXVpcmUoJy4vaGFzaC91dGlscycpO1xuaGFzaC5jb21tb24gPSByZXF1aXJlKCcuL2hhc2gvY29tbW9uJyk7XG5oYXNoLnNoYSA9IHJlcXVpcmUoJy4vaGFzaC9zaGEnKTtcbmhhc2gucmlwZW1kID0gcmVxdWlyZSgnLi9oYXNoL3JpcGVtZCcpO1xuaGFzaC5obWFjID0gcmVxdWlyZSgnLi9oYXNoL2htYWMnKTtcblxuLy8gUHJveHkgaGFzaCBmdW5jdGlvbnMgdG8gdGhlIG1haW4gb2JqZWN0XG5oYXNoLnNoYTEgPSBoYXNoLnNoYS5zaGExO1xuaGFzaC5zaGEyNTYgPSBoYXNoLnNoYS5zaGEyNTY7XG5oYXNoLnNoYTIyNCA9IGhhc2guc2hhLnNoYTIyNDtcbmhhc2guc2hhMzg0ID0gaGFzaC5zaGEuc2hhMzg0O1xuaGFzaC5zaGE1MTIgPSBoYXNoLnNoYS5zaGE1MTI7XG5oYXNoLnJpcGVtZDE2MCA9IGhhc2gucmlwZW1kLnJpcGVtZDE2MDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gQmxvY2tIYXNoKCkge1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdUb3RhbCA9IDA7XG4gIHRoaXMuYmxvY2tTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5ibG9ja1NpemU7XG4gIHRoaXMub3V0U2l6ZSA9IHRoaXMuY29uc3RydWN0b3Iub3V0U2l6ZTtcbiAgdGhpcy5obWFjU3RyZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLmhtYWNTdHJlbmd0aDtcbiAgdGhpcy5wYWRMZW5ndGggPSB0aGlzLmNvbnN0cnVjdG9yLnBhZExlbmd0aCAvIDg7XG4gIHRoaXMuZW5kaWFuID0gJ2JpZyc7XG5cbiAgdGhpcy5fZGVsdGE4ID0gdGhpcy5ibG9ja1NpemUgLyA4O1xuICB0aGlzLl9kZWx0YTMyID0gdGhpcy5ibG9ja1NpemUgLyAzMjtcbn1cbmV4cG9ydHMuQmxvY2tIYXNoID0gQmxvY2tIYXNoO1xuXG5CbG9ja0hhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICAvLyBDb252ZXJ0IG1lc3NhZ2UgdG8gYXJyYXksIHBhZCBpdCwgYW5kIGpvaW4gaW50byAzMmJpdCBibG9ja3NcbiAgbXNnID0gdXRpbHMudG9BcnJheShtc2csIGVuYyk7XG4gIGlmICghdGhpcy5wZW5kaW5nKVxuICAgIHRoaXMucGVuZGluZyA9IG1zZztcbiAgZWxzZVxuICAgIHRoaXMucGVuZGluZyA9IHRoaXMucGVuZGluZy5jb25jYXQobXNnKTtcbiAgdGhpcy5wZW5kaW5nVG90YWwgKz0gbXNnLmxlbmd0aDtcblxuICAvLyBFbm91Z2ggZGF0YSwgdHJ5IHVwZGF0aW5nXG4gIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID49IHRoaXMuX2RlbHRhOCkge1xuICAgIG1zZyA9IHRoaXMucGVuZGluZztcblxuICAgIC8vIFByb2Nlc3MgcGVuZGluZyBkYXRhIGluIGJsb2Nrc1xuICAgIHZhciByID0gbXNnLmxlbmd0aCAlIHRoaXMuX2RlbHRhODtcbiAgICB0aGlzLnBlbmRpbmcgPSBtc2cuc2xpY2UobXNnLmxlbmd0aCAtIHIsIG1zZy5sZW5ndGgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5wZW5kaW5nID0gbnVsbDtcblxuICAgIG1zZyA9IHV0aWxzLmpvaW4zMihtc2csIDAsIG1zZy5sZW5ndGggLSByLCB0aGlzLmVuZGlhbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IHRoaXMuX2RlbHRhMzIpXG4gICAgICB0aGlzLl91cGRhdGUobXNnLCBpLCBpICsgdGhpcy5fZGVsdGEzMik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLnVwZGF0ZSh0aGlzLl9wYWQoKSk7XG4gIGFzc2VydCh0aGlzLnBlbmRpbmcgPT09IG51bGwpO1xuXG4gIHJldHVybiB0aGlzLl9kaWdlc3QoZW5jKTtcbn07XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUuX3BhZCA9IGZ1bmN0aW9uIHBhZCgpIHtcbiAgdmFyIGxlbiA9IHRoaXMucGVuZGluZ1RvdGFsO1xuICB2YXIgYnl0ZXMgPSB0aGlzLl9kZWx0YTg7XG4gIHZhciBrID0gYnl0ZXMgLSAoKGxlbiArIHRoaXMucGFkTGVuZ3RoKSAlIGJ5dGVzKTtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShrICsgdGhpcy5wYWRMZW5ndGgpO1xuICByZXNbMF0gPSAweDgwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGs7IGkrKylcbiAgICByZXNbaV0gPSAwO1xuXG4gIC8vIEFwcGVuZCBsZW5ndGhcbiAgbGVuIDw8PSAzO1xuICBpZiAodGhpcy5lbmRpYW4gPT09ICdiaWcnKSB7XG4gICAgZm9yICh2YXIgdCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuXG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiA4KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICB9IGVsc2Uge1xuICAgIHJlc1tpKytdID0gbGVuICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDE2KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcblxuICAgIGZvciAodCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuICAgICAgcmVzW2krK10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbmZ1bmN0aW9uIEhtYWMoaGFzaCwga2V5LCBlbmMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhtYWMpKVxuICAgIHJldHVybiBuZXcgSG1hYyhoYXNoLCBrZXksIGVuYyk7XG4gIHRoaXMuSGFzaCA9IGhhc2g7XG4gIHRoaXMuYmxvY2tTaXplID0gaGFzaC5ibG9ja1NpemUgLyA4O1xuICB0aGlzLm91dFNpemUgPSBoYXNoLm91dFNpemUgLyA4O1xuICB0aGlzLmlubmVyID0gbnVsbDtcbiAgdGhpcy5vdXRlciA9IG51bGw7XG5cbiAgdGhpcy5faW5pdCh1dGlscy50b0FycmF5KGtleSwgZW5jKSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEhtYWM7XG5cbkhtYWMucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChrZXkpIHtcbiAgLy8gU2hvcnRlbiBrZXksIGlmIG5lZWRlZFxuICBpZiAoa2V5Lmxlbmd0aCA+IHRoaXMuYmxvY2tTaXplKVxuICAgIGtleSA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KS5kaWdlc3QoKTtcbiAgYXNzZXJ0KGtleS5sZW5ndGggPD0gdGhpcy5ibG9ja1NpemUpO1xuXG4gIC8vIEFkZCBwYWRkaW5nIHRvIGtleVxuICBmb3IgKHZhciBpID0ga2V5Lmxlbmd0aDsgaSA8IHRoaXMuYmxvY2tTaXplOyBpKyspXG4gICAga2V5LnB1c2goMCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcbiAgICBrZXlbaV0gXj0gMHgzNjtcbiAgdGhpcy5pbm5lciA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KTtcblxuICAvLyAweDM2IF4gMHg1YyA9IDB4NmFcbiAgZm9yIChpID0gMDsgaSA8IGtleS5sZW5ndGg7IGkrKylcbiAgICBrZXlbaV0gXj0gMHg2YTtcbiAgdGhpcy5vdXRlciA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KTtcbn07XG5cbkhtYWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuICB0aGlzLmlubmVyLnVwZGF0ZShtc2csIGVuYyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuSG1hYy5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICB0aGlzLm91dGVyLnVwZGF0ZSh0aGlzLmlubmVyLmRpZ2VzdCgpKTtcbiAgcmV0dXJuIHRoaXMub3V0ZXIuZGlnZXN0KGVuYyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxudmFyIHJvdGwzMiA9IHV0aWxzLnJvdGwzMjtcbnZhciBzdW0zMiA9IHV0aWxzLnN1bTMyO1xudmFyIHN1bTMyXzMgPSB1dGlscy5zdW0zMl8zO1xudmFyIHN1bTMyXzQgPSB1dGlscy5zdW0zMl80O1xudmFyIEJsb2NrSGFzaCA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cbmZ1bmN0aW9uIFJJUEVNRDE2MCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJJUEVNRDE2MCkpXG4gICAgcmV0dXJuIG5ldyBSSVBFTUQxNjAoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcblxuICB0aGlzLmggPSBbIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjAgXTtcbiAgdGhpcy5lbmRpYW4gPSAnbGl0dGxlJztcbn1cbnV0aWxzLmluaGVyaXRzKFJJUEVNRDE2MCwgQmxvY2tIYXNoKTtcbmV4cG9ydHMucmlwZW1kMTYwID0gUklQRU1EMTYwO1xuXG5SSVBFTUQxNjAuYmxvY2tTaXplID0gNTEyO1xuUklQRU1EMTYwLm91dFNpemUgPSAxNjA7XG5SSVBFTUQxNjAuaG1hY1N0cmVuZ3RoID0gMTkyO1xuUklQRU1EMTYwLnBhZExlbmd0aCA9IDY0O1xuXG5SSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUobXNnLCBzdGFydCkge1xuICB2YXIgQSA9IHRoaXMuaFswXTtcbiAgdmFyIEIgPSB0aGlzLmhbMV07XG4gIHZhciBDID0gdGhpcy5oWzJdO1xuICB2YXIgRCA9IHRoaXMuaFszXTtcbiAgdmFyIEUgPSB0aGlzLmhbNF07XG4gIHZhciBBaCA9IEE7XG4gIHZhciBCaCA9IEI7XG4gIHZhciBDaCA9IEM7XG4gIHZhciBEaCA9IEQ7XG4gIHZhciBFaCA9IEU7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7IGorKykge1xuICAgIHZhciBUID0gc3VtMzIoXG4gICAgICByb3RsMzIoXG4gICAgICAgIHN1bTMyXzQoQSwgZihqLCBCLCBDLCBEKSwgbXNnW3Jbal0gKyBzdGFydF0sIEsoaikpLFxuICAgICAgICBzW2pdKSxcbiAgICAgIEUpO1xuICAgIEEgPSBFO1xuICAgIEUgPSBEO1xuICAgIEQgPSByb3RsMzIoQywgMTApO1xuICAgIEMgPSBCO1xuICAgIEIgPSBUO1xuICAgIFQgPSBzdW0zMihcbiAgICAgIHJvdGwzMihcbiAgICAgICAgc3VtMzJfNChBaCwgZig3OSAtIGosIEJoLCBDaCwgRGgpLCBtc2dbcmhbal0gKyBzdGFydF0sIEtoKGopKSxcbiAgICAgICAgc2hbal0pLFxuICAgICAgRWgpO1xuICAgIEFoID0gRWg7XG4gICAgRWggPSBEaDtcbiAgICBEaCA9IHJvdGwzMihDaCwgMTApO1xuICAgIENoID0gQmg7XG4gICAgQmggPSBUO1xuICB9XG4gIFQgPSBzdW0zMl8zKHRoaXMuaFsxXSwgQywgRGgpO1xuICB0aGlzLmhbMV0gPSBzdW0zMl8zKHRoaXMuaFsyXSwgRCwgRWgpO1xuICB0aGlzLmhbMl0gPSBzdW0zMl8zKHRoaXMuaFszXSwgRSwgQWgpO1xuICB0aGlzLmhbM10gPSBzdW0zMl8zKHRoaXMuaFs0XSwgQSwgQmgpO1xuICB0aGlzLmhbNF0gPSBzdW0zMl8zKHRoaXMuaFswXSwgQiwgQ2gpO1xuICB0aGlzLmhbMF0gPSBUO1xufTtcblxuUklQRU1EMTYwLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdsaXR0bGUnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2xpdHRsZScpO1xufTtcblxuZnVuY3Rpb24gZihqLCB4LCB5LCB6KSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiB4IF4geSBeIHo7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuICh4ICYgeSkgfCAoKH54KSAmIHopO1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAoeCB8ICh+eSkpIF4gejtcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgKH56KSk7XG4gIGVsc2VcbiAgICByZXR1cm4geCBeICh5IHwgKH56KSk7XG59XG5cbmZ1bmN0aW9uIEsoaikge1xuICBpZiAoaiA8PSAxNSlcbiAgICByZXR1cm4gMHgwMDAwMDAwMDtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gMHg1YTgyNzk5OTtcbiAgZWxzZSBpZiAoaiA8PSA0NylcbiAgICByZXR1cm4gMHg2ZWQ5ZWJhMTtcbiAgZWxzZSBpZiAoaiA8PSA2MylcbiAgICByZXR1cm4gMHg4ZjFiYmNkYztcbiAgZWxzZVxuICAgIHJldHVybiAweGE5NTNmZDRlO1xufVxuXG5mdW5jdGlvbiBLaChqKSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiAweDUwYTI4YmU2O1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAweDVjNGRkMTI0O1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAweDZkNzAzZWYzO1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAweDdhNmQ3NmU5O1xuICBlbHNlXG4gICAgcmV0dXJuIDB4MDAwMDAwMDA7XG59XG5cbnZhciByID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuICAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyLFxuICAxLCA5LCAxMSwgMTAsIDAsIDgsIDEyLCA0LCAxMywgMywgNywgMTUsIDE0LCA1LCA2LCAyLFxuICA0LCAwLCA1LCA5LCA3LCAxMiwgMiwgMTAsIDE0LCAxLCAzLCA4LCAxMSwgNiwgMTUsIDEzXG5dO1xuXG52YXIgcmggPSBbXG4gIDUsIDE0LCA3LCAwLCA5LCAyLCAxMSwgNCwgMTMsIDYsIDE1LCA4LCAxLCAxMCwgMywgMTIsXG4gIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG4gIDE1LCA1LCAxLCAzLCA3LCAxNCwgNiwgOSwgMTEsIDgsIDEyLCAyLCAxMCwgMCwgNCwgMTMsXG4gIDgsIDYsIDQsIDEsIDMsIDExLCAxNSwgMCwgNSwgMTIsIDIsIDEzLCA5LCA3LCAxMCwgMTQsXG4gIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcbl07XG5cbnZhciBzID0gW1xuICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG4gIDcsIDYsIDgsIDEzLCAxMSwgOSwgNywgMTUsIDcsIDEyLCAxNSwgOSwgMTEsIDcsIDEzLCAxMixcbiAgMTEsIDEzLCA2LCA3LCAxNCwgOSwgMTMsIDE1LCAxNCwgOCwgMTMsIDYsIDUsIDEyLCA3LCA1LFxuICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG4gIDksIDE1LCA1LCAxMSwgNiwgOCwgMTMsIDEyLCA1LCAxMiwgMTMsIDE0LCAxMSwgOCwgNSwgNlxuXTtcblxudmFyIHNoID0gW1xuICA4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsXG4gIDksIDEzLCAxNSwgNywgMTIsIDgsIDksIDExLCA3LCA3LCAxMiwgNywgNiwgMTUsIDEzLCAxMSxcbiAgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LFxuICAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsXG4gIDgsIDUsIDEyLCA5LCAxMiwgNSwgMTQsIDYsIDgsIDEzLCA2LCA1LCAxNSwgMTMsIDExLCAxMVxuXTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5zaGExID0gcmVxdWlyZSgnLi9zaGEvMScpO1xuZXhwb3J0cy5zaGEyMjQgPSByZXF1aXJlKCcuL3NoYS8yMjQnKTtcbmV4cG9ydHMuc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEvMjU2Jyk7XG5leHBvcnRzLnNoYTM4NCA9IHJlcXVpcmUoJy4vc2hhLzM4NCcpO1xuZXhwb3J0cy5zaGE1MTIgPSByZXF1aXJlKCcuL3NoYS81MTInKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBzaGFDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG52YXIgcm90bDMyID0gdXRpbHMucm90bDMyO1xudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfNSA9IHV0aWxzLnN1bTMyXzU7XG52YXIgZnRfMSA9IHNoYUNvbW1vbi5mdF8xO1xudmFyIEJsb2NrSGFzaCA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cbnZhciBzaGExX0sgPSBbXG4gIDB4NUE4Mjc5OTksIDB4NkVEOUVCQTEsXG4gIDB4OEYxQkJDREMsIDB4Q0E2MkMxRDZcbl07XG5cbmZ1bmN0aW9uIFNIQTEoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEExKSlcbiAgICByZXR1cm4gbmV3IFNIQTEoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsXG4gICAgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCBdO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoODApO1xufVxuXG51dGlscy5pbmhlcml0cyhTSEExLCBCbG9ja0hhc2gpO1xubW9kdWxlLmV4cG9ydHMgPSBTSEExO1xuXG5TSEExLmJsb2NrU2l6ZSA9IDUxMjtcblNIQTEub3V0U2l6ZSA9IDE2MDtcblNIQTEuaG1hY1N0cmVuZ3RoID0gODA7XG5TSEExLnBhZExlbmd0aCA9IDY0O1xuXG5TSEExLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG5cbiAgZm9yKDsgaSA8IFcubGVuZ3RoOyBpKyspXG4gICAgV1tpXSA9IHJvdGwzMihXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdLCAxKTtcblxuICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgdmFyIGIgPSB0aGlzLmhbMV07XG4gIHZhciBjID0gdGhpcy5oWzJdO1xuICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgdmFyIGUgPSB0aGlzLmhbNF07XG5cbiAgZm9yIChpID0gMDsgaSA8IFcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcyA9IH5+KGkgLyAyMCk7XG4gICAgdmFyIHQgPSBzdW0zMl81KHJvdGwzMihhLCA1KSwgZnRfMShzLCBiLCBjLCBkKSwgZSwgV1tpXSwgc2hhMV9LW3NdKTtcbiAgICBlID0gZDtcbiAgICBkID0gYztcbiAgICBjID0gcm90bDMyKGIsIDMwKTtcbiAgICBiID0gYTtcbiAgICBhID0gdDtcbiAgfVxuXG4gIHRoaXMuaFswXSA9IHN1bTMyKHRoaXMuaFswXSwgYSk7XG4gIHRoaXMuaFsxXSA9IHN1bTMyKHRoaXMuaFsxXSwgYik7XG4gIHRoaXMuaFsyXSA9IHN1bTMyKHRoaXMuaFsyXSwgYyk7XG4gIHRoaXMuaFszXSA9IHN1bTMyKHRoaXMuaFszXSwgZCk7XG4gIHRoaXMuaFs0XSA9IHN1bTMyKHRoaXMuaFs0XSwgZSk7XG59O1xuXG5TSEExLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBTSEEyNTYgPSByZXF1aXJlKCcuLzI1NicpO1xuXG5mdW5jdGlvbiBTSEEyMjQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEyMjQpKVxuICAgIHJldHVybiBuZXcgU0hBMjI0KCk7XG5cbiAgU0hBMjU2LmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LFxuICAgIDB4ZmZjMDBiMzEsIDB4Njg1ODE1MTEsIDB4NjRmOThmYTcsIDB4YmVmYTRmYTQgXTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTIyNCwgU0hBMjU2KTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMjI0O1xuXG5TSEEyMjQuYmxvY2tTaXplID0gNTEyO1xuU0hBMjI0Lm91dFNpemUgPSAyMjQ7XG5TSEEyMjQuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMjI0LnBhZExlbmd0aCA9IDY0O1xuXG5TSEEyMjQucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIC8vIEp1c3QgdHJ1bmNhdGUgb3V0cHV0XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaC5zbGljZSgwLCA3KSwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgc2hhQ29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbnZhciBzdW0zMiA9IHV0aWxzLnN1bTMyO1xudmFyIHN1bTMyXzQgPSB1dGlscy5zdW0zMl80O1xudmFyIHN1bTMyXzUgPSB1dGlscy5zdW0zMl81O1xudmFyIGNoMzIgPSBzaGFDb21tb24uY2gzMjtcbnZhciBtYWozMiA9IHNoYUNvbW1vbi5tYWozMjtcbnZhciBzMF8yNTYgPSBzaGFDb21tb24uczBfMjU2O1xudmFyIHMxXzI1NiA9IHNoYUNvbW1vbi5zMV8yNTY7XG52YXIgZzBfMjU2ID0gc2hhQ29tbW9uLmcwXzI1NjtcbnZhciBnMV8yNTYgPSBzaGFDb21tb24uZzFfMjU2O1xuXG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTI1Nl9LID0gW1xuICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LFxuICAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLFxuICAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLFxuICAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LFxuICAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLFxuICAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLFxuICAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LFxuICAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LFxuICAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dO1xuXG5mdW5jdGlvbiBTSEEyNTYoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEyNTYpKVxuICAgIHJldHVybiBuZXcgU0hBMjU2KCk7XG5cbiAgQmxvY2tIYXNoLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLFxuICAgIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbiAgXTtcbiAgdGhpcy5rID0gc2hhMjU2X0s7XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg2NCk7XG59XG51dGlscy5pbmhlcml0cyhTSEEyNTYsIEJsb2NrSGFzaCk7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTI1NjtcblxuU0hBMjU2LmJsb2NrU2l6ZSA9IDUxMjtcblNIQTI1Ni5vdXRTaXplID0gMjU2O1xuU0hBMjU2LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTI1Ni5wYWRMZW5ndGggPSA2NDtcblxuU0hBMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBXID0gdGhpcy5XO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG4gIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gc3VtMzJfNChnMV8yNTYoV1tpIC0gMl0pLCBXW2kgLSA3XSwgZzBfMjU2KFdbaSAtIDE1XSksIFdbaSAtIDE2XSk7XG5cbiAgdmFyIGEgPSB0aGlzLmhbMF07XG4gIHZhciBiID0gdGhpcy5oWzFdO1xuICB2YXIgYyA9IHRoaXMuaFsyXTtcbiAgdmFyIGQgPSB0aGlzLmhbM107XG4gIHZhciBlID0gdGhpcy5oWzRdO1xuICB2YXIgZiA9IHRoaXMuaFs1XTtcbiAgdmFyIGcgPSB0aGlzLmhbNl07XG4gIHZhciBoID0gdGhpcy5oWzddO1xuXG4gIGFzc2VydCh0aGlzLmsubGVuZ3RoID09PSBXLmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIFQxID0gc3VtMzJfNShoLCBzMV8yNTYoZSksIGNoMzIoZSwgZiwgZyksIHRoaXMua1tpXSwgV1tpXSk7XG4gICAgdmFyIFQyID0gc3VtMzIoczBfMjU2KGEpLCBtYWozMihhLCBiLCBjKSk7XG4gICAgaCA9IGc7XG4gICAgZyA9IGY7XG4gICAgZiA9IGU7XG4gICAgZSA9IHN1bTMyKGQsIFQxKTtcbiAgICBkID0gYztcbiAgICBjID0gYjtcbiAgICBiID0gYTtcbiAgICBhID0gc3VtMzIoVDEsIFQyKTtcbiAgfVxuXG4gIHRoaXMuaFswXSA9IHN1bTMyKHRoaXMuaFswXSwgYSk7XG4gIHRoaXMuaFsxXSA9IHN1bTMyKHRoaXMuaFsxXSwgYik7XG4gIHRoaXMuaFsyXSA9IHN1bTMyKHRoaXMuaFsyXSwgYyk7XG4gIHRoaXMuaFszXSA9IHN1bTMyKHRoaXMuaFszXSwgZCk7XG4gIHRoaXMuaFs0XSA9IHN1bTMyKHRoaXMuaFs0XSwgZSk7XG4gIHRoaXMuaFs1XSA9IHN1bTMyKHRoaXMuaFs1XSwgZik7XG4gIHRoaXMuaFs2XSA9IHN1bTMyKHRoaXMuaFs2XSwgZyk7XG4gIHRoaXMuaFs3XSA9IHN1bTMyKHRoaXMuaFs3XSwgaCk7XG59O1xuXG5TSEEyNTYucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG52YXIgU0hBNTEyID0gcmVxdWlyZSgnLi81MTInKTtcblxuZnVuY3Rpb24gU0hBMzg0KCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBMzg0KSlcbiAgICByZXR1cm4gbmV3IFNIQTM4NCgpO1xuXG4gIFNIQTUxMi5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCxcbiAgICAweDYyOWEyOTJhLCAweDM2N2NkNTA3LFxuICAgIDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcsXG4gICAgMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSxcbiAgICAweDY3MzMyNjY3LCAweGZmYzAwYjMxLFxuICAgIDB4OGViNDRhODcsIDB4Njg1ODE1MTEsXG4gICAgMHhkYjBjMmUwZCwgMHg2NGY5OGZhNyxcbiAgICAweDQ3YjU0ODFkLCAweGJlZmE0ZmE0IF07XG59XG51dGlscy5pbmhlcml0cyhTSEEzODQsIFNIQTUxMik7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTM4NDtcblxuU0hBMzg0LmJsb2NrU2l6ZSA9IDEwMjQ7XG5TSEEzODQub3V0U2l6ZSA9IDM4NDtcblNIQTM4NC5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEzODQucGFkTGVuZ3RoID0gMTI4O1xuXG5TSEEzODQucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaC5zbGljZSgwLCAxMiksICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaC5zbGljZSgwLCAxMiksICdiaWcnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgY29tbW9uID0gcmVxdWlyZSgnLi4vY29tbW9uJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG52YXIgcm90cjY0X2hpID0gdXRpbHMucm90cjY0X2hpO1xudmFyIHJvdHI2NF9sbyA9IHV0aWxzLnJvdHI2NF9sbztcbnZhciBzaHI2NF9oaSA9IHV0aWxzLnNocjY0X2hpO1xudmFyIHNocjY0X2xvID0gdXRpbHMuc2hyNjRfbG87XG52YXIgc3VtNjQgPSB1dGlscy5zdW02NDtcbnZhciBzdW02NF9oaSA9IHV0aWxzLnN1bTY0X2hpO1xudmFyIHN1bTY0X2xvID0gdXRpbHMuc3VtNjRfbG87XG52YXIgc3VtNjRfNF9oaSA9IHV0aWxzLnN1bTY0XzRfaGk7XG52YXIgc3VtNjRfNF9sbyA9IHV0aWxzLnN1bTY0XzRfbG87XG52YXIgc3VtNjRfNV9oaSA9IHV0aWxzLnN1bTY0XzVfaGk7XG52YXIgc3VtNjRfNV9sbyA9IHV0aWxzLnN1bTY0XzVfbG87XG5cbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG52YXIgc2hhNTEyX0sgPSBbXG4gIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG4gIDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYsIDB4ZTliNWRiYTUsIDB4ODE4OWRiYmMsXG4gIDB4Mzk1NmMyNWIsIDB4ZjM0OGI1MzgsIDB4NTlmMTExZjEsIDB4YjYwNWQwMTksXG4gIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG4gIDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIsIDB4MTI4MzViMDEsIDB4NDU3MDZmYmUsXG4gIDB4MjQzMTg1YmUsIDB4NGVlNGIyOGMsIDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIsXG4gIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG4gIDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUsIDB4YzE5YmYxNzQsIDB4Y2Y2OTI2OTQsXG4gIDB4ZTQ5YjY5YzEsIDB4OWVmMTRhZDIsIDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMsXG4gIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG4gIDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUsIDB4NGE3NDg0YWEsIDB4NmVhNmU0ODMsXG4gIDB4NWNiMGE5ZGMsIDB4YmQ0MWZiZDQsIDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUsXG4gIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG4gIDB4YjAwMzI3YzgsIDB4OThmYjIxM2YsIDB4YmY1OTdmYzcsIDB4YmVlZjBlZTQsXG4gIDB4YzZlMDBiZjMsIDB4M2RhODhmYzIsIDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUsXG4gIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG4gIDB4MjdiNzBhODUsIDB4NDZkMjJmZmMsIDB4MmUxYjIxMzgsIDB4NWMyNmM5MjYsXG4gIDB4NGQyYzZkZmMsIDB4NWFjNDJhZWQsIDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYsXG4gIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG4gIDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYsIDB4OTI3MjJjODUsIDB4MTQ4MjM1M2IsXG4gIDB4YTJiZmU4YTEsIDB4NGNmMTAzNjQsIDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEsXG4gIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG4gIDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgsIDB4ZDY5OTA2MjQsIDB4NTU2NWE5MTAsXG4gIDB4ZjQwZTM1ODUsIDB4NTc3MTIwMmEsIDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgsXG4gIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG4gIDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTksIDB4MzRiMGJjYjUsIDB4ZTE5YjQ4YTgsXG4gIDB4MzkxYzBjYjMsIDB4YzVjOTVhNjMsIDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IsXG4gIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG4gIDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMsIDB4NzhhNTYzNmYsIDB4NDMxNzJmNjAsXG4gIDB4ODRjODc4MTQsIDB4YTFmMGFiNzIsIDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMsXG4gIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG4gIDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUsIDB4YzY3MTc4ZjIsIDB4ZTM3MjUzMmIsXG4gIDB4Y2EyNzNlY2UsIDB4ZWEyNjYxOWMsIDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcsXG4gIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG4gIDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEsIDB4MGE2MzdkYzUsIDB4YTJjODk4YTYsXG4gIDB4MTEzZjk4MDQsIDB4YmVmOTBkYWUsIDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIsXG4gIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG4gIDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMsIDB4NDMxZDY3YzQsIDB4OWMxMDBkNGMsXG4gIDB4NGNjNWQ0YmUsIDB4Y2IzZTQyYjYsIDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEsXG4gIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcbl07XG5cbmZ1bmN0aW9uIFNIQTUxMigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTUxMikpXG4gICAgcmV0dXJuIG5ldyBTSEE1MTIoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgsXG4gICAgMHhiYjY3YWU4NSwgMHg4NGNhYTczYixcbiAgICAweDNjNmVmMzcyLCAweGZlOTRmODJiLFxuICAgIDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEsXG4gICAgMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSxcbiAgICAweDliMDU2ODhjLCAweDJiM2U2YzFmLFxuICAgIDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIsXG4gICAgMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSBdO1xuICB0aGlzLmsgPSBzaGE1MTJfSztcbiAgdGhpcy5XID0gbmV3IEFycmF5KDE2MCk7XG59XG51dGlscy5pbmhlcml0cyhTSEE1MTIsIEJsb2NrSGFzaCk7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTUxMjtcblxuU0hBNTEyLmJsb2NrU2l6ZSA9IDEwMjQ7XG5TSEE1MTIub3V0U2l6ZSA9IDUxMjtcblNIQTUxMi5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEE1MTIucGFkTGVuZ3RoID0gMTI4O1xuXG5TSEE1MTIucHJvdG90eXBlLl9wcmVwYXJlQmxvY2sgPSBmdW5jdGlvbiBfcHJlcGFyZUJsb2NrKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgLy8gMzIgeCAzMmJpdCB3b3Jkc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspXG4gICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuICBmb3IgKDsgaSA8IFcubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgYzBfaGkgPSBnMV81MTJfaGkoV1tpIC0gNF0sIFdbaSAtIDNdKTsgIC8vIGkgLSAyXG4gICAgdmFyIGMwX2xvID0gZzFfNTEyX2xvKFdbaSAtIDRdLCBXW2kgLSAzXSk7XG4gICAgdmFyIGMxX2hpID0gV1tpIC0gMTRdOyAgLy8gaSAtIDdcbiAgICB2YXIgYzFfbG8gPSBXW2kgLSAxM107XG4gICAgdmFyIGMyX2hpID0gZzBfNTEyX2hpKFdbaSAtIDMwXSwgV1tpIC0gMjldKTsgIC8vIGkgLSAxNVxuICAgIHZhciBjMl9sbyA9IGcwXzUxMl9sbyhXW2kgLSAzMF0sIFdbaSAtIDI5XSk7XG4gICAgdmFyIGMzX2hpID0gV1tpIC0gMzJdOyAgLy8gaSAtIDE2XG4gICAgdmFyIGMzX2xvID0gV1tpIC0gMzFdO1xuXG4gICAgV1tpXSA9IHN1bTY0XzRfaGkoXG4gICAgICBjMF9oaSwgYzBfbG8sXG4gICAgICBjMV9oaSwgYzFfbG8sXG4gICAgICBjMl9oaSwgYzJfbG8sXG4gICAgICBjM19oaSwgYzNfbG8pO1xuICAgIFdbaSArIDFdID0gc3VtNjRfNF9sbyhcbiAgICAgIGMwX2hpLCBjMF9sbyxcbiAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgIGMzX2hpLCBjM19sbyk7XG4gIH1cbn07XG5cblNIQTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuICB0aGlzLl9wcmVwYXJlQmxvY2sobXNnLCBzdGFydCk7XG5cbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgdmFyIGFoID0gdGhpcy5oWzBdO1xuICB2YXIgYWwgPSB0aGlzLmhbMV07XG4gIHZhciBiaCA9IHRoaXMuaFsyXTtcbiAgdmFyIGJsID0gdGhpcy5oWzNdO1xuICB2YXIgY2ggPSB0aGlzLmhbNF07XG4gIHZhciBjbCA9IHRoaXMuaFs1XTtcbiAgdmFyIGRoID0gdGhpcy5oWzZdO1xuICB2YXIgZGwgPSB0aGlzLmhbN107XG4gIHZhciBlaCA9IHRoaXMuaFs4XTtcbiAgdmFyIGVsID0gdGhpcy5oWzldO1xuICB2YXIgZmggPSB0aGlzLmhbMTBdO1xuICB2YXIgZmwgPSB0aGlzLmhbMTFdO1xuICB2YXIgZ2ggPSB0aGlzLmhbMTJdO1xuICB2YXIgZ2wgPSB0aGlzLmhbMTNdO1xuICB2YXIgaGggPSB0aGlzLmhbMTRdO1xuICB2YXIgaGwgPSB0aGlzLmhbMTVdO1xuXG4gIGFzc2VydCh0aGlzLmsubGVuZ3RoID09PSBXLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBjMF9oaSA9IGhoO1xuICAgIHZhciBjMF9sbyA9IGhsO1xuICAgIHZhciBjMV9oaSA9IHMxXzUxMl9oaShlaCwgZWwpO1xuICAgIHZhciBjMV9sbyA9IHMxXzUxMl9sbyhlaCwgZWwpO1xuICAgIHZhciBjMl9oaSA9IGNoNjRfaGkoZWgsIGVsLCBmaCwgZmwsIGdoLCBnbCk7XG4gICAgdmFyIGMyX2xvID0gY2g2NF9sbyhlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICB2YXIgYzNfaGkgPSB0aGlzLmtbaV07XG4gICAgdmFyIGMzX2xvID0gdGhpcy5rW2kgKyAxXTtcbiAgICB2YXIgYzRfaGkgPSBXW2ldO1xuICAgIHZhciBjNF9sbyA9IFdbaSArIDFdO1xuXG4gICAgdmFyIFQxX2hpID0gc3VtNjRfNV9oaShcbiAgICAgIGMwX2hpLCBjMF9sbyxcbiAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgIGMzX2hpLCBjM19sbyxcbiAgICAgIGM0X2hpLCBjNF9sbyk7XG4gICAgdmFyIFQxX2xvID0gc3VtNjRfNV9sbyhcbiAgICAgIGMwX2hpLCBjMF9sbyxcbiAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgIGMzX2hpLCBjM19sbyxcbiAgICAgIGM0X2hpLCBjNF9sbyk7XG5cbiAgICBjMF9oaSA9IHMwXzUxMl9oaShhaCwgYWwpO1xuICAgIGMwX2xvID0gczBfNTEyX2xvKGFoLCBhbCk7XG4gICAgYzFfaGkgPSBtYWo2NF9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsKTtcbiAgICBjMV9sbyA9IG1hajY0X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuXG4gICAgdmFyIFQyX2hpID0gc3VtNjRfaGkoYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuICAgIHZhciBUMl9sbyA9IHN1bTY0X2xvKGMwX2hpLCBjMF9sbywgYzFfaGksIGMxX2xvKTtcblxuICAgIGhoID0gZ2g7XG4gICAgaGwgPSBnbDtcblxuICAgIGdoID0gZmg7XG4gICAgZ2wgPSBmbDtcblxuICAgIGZoID0gZWg7XG4gICAgZmwgPSBlbDtcblxuICAgIGVoID0gc3VtNjRfaGkoZGgsIGRsLCBUMV9oaSwgVDFfbG8pO1xuICAgIGVsID0gc3VtNjRfbG8oZGwsIGRsLCBUMV9oaSwgVDFfbG8pO1xuXG4gICAgZGggPSBjaDtcbiAgICBkbCA9IGNsO1xuXG4gICAgY2ggPSBiaDtcbiAgICBjbCA9IGJsO1xuXG4gICAgYmggPSBhaDtcbiAgICBibCA9IGFsO1xuXG4gICAgYWggPSBzdW02NF9oaShUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG4gICAgYWwgPSBzdW02NF9sbyhUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG4gIH1cblxuICBzdW02NCh0aGlzLmgsIDAsIGFoLCBhbCk7XG4gIHN1bTY0KHRoaXMuaCwgMiwgYmgsIGJsKTtcbiAgc3VtNjQodGhpcy5oLCA0LCBjaCwgY2wpO1xuICBzdW02NCh0aGlzLmgsIDYsIGRoLCBkbCk7XG4gIHN1bTY0KHRoaXMuaCwgOCwgZWgsIGVsKTtcbiAgc3VtNjQodGhpcy5oLCAxMCwgZmgsIGZsKTtcbiAgc3VtNjQodGhpcy5oLCAxMiwgZ2gsIGdsKTtcbiAgc3VtNjQodGhpcy5oLCAxNCwgaGgsIGhsKTtcbn07XG5cblNIQTUxMi5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG5cbmZ1bmN0aW9uIGNoNjRfaGkoeGgsIHhsLCB5aCwgeWwsIHpoKSB7XG4gIHZhciByID0gKHhoICYgeWgpIF4gKCh+eGgpICYgemgpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGNoNjRfbG8oeGgsIHhsLCB5aCwgeWwsIHpoLCB6bCkge1xuICB2YXIgciA9ICh4bCAmIHlsKSBeICgofnhsKSAmIHpsKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBtYWo2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgpIHtcbiAgdmFyIHIgPSAoeGggJiB5aCkgXiAoeGggJiB6aCkgXiAoeWggJiB6aCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gbWFqNjRfbG8oeGgsIHhsLCB5aCwgeWwsIHpoLCB6bCkge1xuICB2YXIgciA9ICh4bCAmIHlsKSBeICh4bCAmIHpsKSBeICh5bCAmIHpsKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMF81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDI4KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgMik7ICAvLyAzNFxuICB2YXIgYzJfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCA3KTsgIC8vIDM5XG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczBfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAyOCk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDIpOyAgLy8gMzRcbiAgdmFyIGMyX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgNyk7ICAvLyAzOVxuXG4gIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMxXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMTQpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxOCk7XG4gIHZhciBjMl9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDkpOyAgLy8gNDFcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMV81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE0KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTgpO1xuICB2YXIgYzJfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCA5KTsgIC8vIDQxXG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzBfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxKTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgOCk7XG4gIHZhciBjMl9oaSA9IHNocjY0X2hpKHhoLCB4bCwgNyk7XG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzBfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxKTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgOCk7XG4gIHZhciBjMl9sbyA9IHNocjY0X2xvKHhoLCB4bCwgNyk7XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzFfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxOSk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDI5KTsgIC8vIDYxXG4gIHZhciBjMl9oaSA9IHNocjY0X2hpKHhoLCB4bCwgNik7XG5cbiAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gZzFfNTEyX2xvKHhoLCB4bCkge1xuICB2YXIgYzBfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxOSk7XG4gIHZhciBjMV9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDI5KTsgIC8vIDYxXG4gIHZhciBjMl9sbyA9IHNocjY0X2xvKHhoLCB4bCwgNik7XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciByb3RyMzIgPSB1dGlscy5yb3RyMzI7XG5cbmZ1bmN0aW9uIGZ0XzEocywgeCwgeSwgeikge1xuICBpZiAocyA9PT0gMClcbiAgICByZXR1cm4gY2gzMih4LCB5LCB6KTtcbiAgaWYgKHMgPT09IDEgfHwgcyA9PT0gMylcbiAgICByZXR1cm4gcDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMilcbiAgICByZXR1cm4gbWFqMzIoeCwgeSwgeik7XG59XG5leHBvcnRzLmZ0XzEgPSBmdF8xO1xuXG5mdW5jdGlvbiBjaDMyKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgXiAoKH54KSAmIHopO1xufVxuZXhwb3J0cy5jaDMyID0gY2gzMjtcblxuZnVuY3Rpb24gbWFqMzIoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopO1xufVxuZXhwb3J0cy5tYWozMiA9IG1hajMyO1xuXG5mdW5jdGlvbiBwMzIoeCwgeSwgeikge1xuICByZXR1cm4geCBeIHkgXiB6O1xufVxuZXhwb3J0cy5wMzIgPSBwMzI7XG5cbmZ1bmN0aW9uIHMwXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgMikgXiByb3RyMzIoeCwgMTMpIF4gcm90cjMyKHgsIDIyKTtcbn1cbmV4cG9ydHMuczBfMjU2ID0gczBfMjU2O1xuXG5mdW5jdGlvbiBzMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDYpIF4gcm90cjMyKHgsIDExKSBeIHJvdHIzMih4LCAyNSk7XG59XG5leHBvcnRzLnMxXzI1NiA9IHMxXzI1NjtcblxuZnVuY3Rpb24gZzBfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCA3KSBeIHJvdHIzMih4LCAxOCkgXiAoeCA+Pj4gMyk7XG59XG5leHBvcnRzLmcwXzI1NiA9IGcwXzI1NjtcblxuZnVuY3Rpb24gZzFfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAxNykgXiByb3RyMzIoeCwgMTkpIF4gKHggPj4+IDEwKTtcbn1cbmV4cG9ydHMuZzFfMjU2ID0gZzFfMjU2O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5pbmhlcml0cyA9IGluaGVyaXRzO1xuXG5mdW5jdGlvbiBpc1N1cnJvZ2F0ZVBhaXIobXNnLCBpKSB7XG4gIGlmICgobXNnLmNoYXJDb2RlQXQoaSkgJiAweEZDMDApICE9PSAweEQ4MDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGkgPCAwIHx8IGkgKyAxID49IG1zZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChtc2cuY2hhckNvZGVBdChpICsgMSkgJiAweEZDMDApID09PSAweERDMDA7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkobXNnLCBlbmMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcbiAgICByZXR1cm4gbXNnLnNsaWNlKCk7XG4gIGlmICghbXNnKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHJlcyA9IFtdO1xuICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIWVuYykge1xuICAgICAgLy8gSW5zcGlyZWQgYnkgc3RyaW5nVG9VdGY4Qnl0ZUFycmF5KCkgaW4gY2xvc3VyZS1saWJyYXJ5IGJ5IEdvb2dsZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi84NTk4ZDg3MjQyYWY1OWFhYzIzMzI3MDc0MmM4OTg0ZTJiMmJkYmUwL2Nsb3N1cmUvZ29vZy9jcnlwdC9jcnlwdC5qcyNMMTE3LUwxNDNcbiAgICAgIC8vIEFwYWNoZSBMaWNlbnNlIDIuMFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWxpYnJhcnkvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICAgICAgdmFyIHAgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICByZXNbcCsrXSA9IGM7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgICAgICByZXNbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xuICAgICAgICAgIHJlc1twKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdXJyb2dhdGVQYWlyKG1zZywgaSkpIHtcbiAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAmIDB4MDNGRikgPDwgMTApICsgKG1zZy5jaGFyQ29kZUF0KCsraSkgJiAweDAzRkYpO1xuICAgICAgICAgIHJlc1twKytdID0gKGMgPj4gMTgpIHwgMjQwO1xuICAgICAgICAgIHJlc1twKytdID0gKChjID4+IDEyKSAmIDYzKSB8IDEyODtcbiAgICAgICAgICByZXNbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICByZXNbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc1twKytdID0gKGMgPj4gMTIpIHwgMjI0O1xuICAgICAgICAgIHJlc1twKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgIHJlc1twKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bXmEtejAtOV0rL2lnLCAnJyk7XG4gICAgICBpZiAobXNnLmxlbmd0aCAlIDIgIT09IDApXG4gICAgICAgIG1zZyA9ICcwJyArIG1zZztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5mdW5jdGlvbiB0b0hleChtc2cpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5cbmZ1bmN0aW9uIGh0b25sKHcpIHtcbiAgdmFyIHJlcyA9ICh3ID4+PiAyNCkgfFxuICAgICAgICAgICAgKCh3ID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICAgICAgICAgKCh3IDw8IDgpICYgMHhmZjAwMDApIHxcbiAgICAgICAgICAgICgodyAmIDB4ZmYpIDw8IDI0KTtcbiAgcmV0dXJuIHJlcyA+Pj4gMDtcbn1cbmV4cG9ydHMuaHRvbmwgPSBodG9ubDtcblxuZnVuY3Rpb24gdG9IZXgzMihtc2csIGVuZGlhbikge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHcgPSBtc2dbaV07XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2xpdHRsZScpXG4gICAgICB3ID0gaHRvbmwodyk7XG4gICAgcmVzICs9IHplcm84KHcudG9TdHJpbmcoMTYpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy50b0hleDMyID0gdG9IZXgzMjtcblxuZnVuY3Rpb24gemVybzIod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbmV4cG9ydHMuemVybzIgPSB6ZXJvMjtcblxuZnVuY3Rpb24gemVybzgod29yZCkge1xuICBpZiAod29yZC5sZW5ndGggPT09IDcpXG4gICAgcmV0dXJuICcwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA2KVxuICAgIHJldHVybiAnMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDUpXG4gICAgcmV0dXJuICcwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDQpXG4gICAgcmV0dXJuICcwMDAwJyArIHdvcmQ7XG4gIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAzKVxuICAgIHJldHVybiAnMDAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDIpXG4gICAgcmV0dXJuICcwMDAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDEpXG4gICAgcmV0dXJuICcwMDAwMDAwJyArIHdvcmQ7XG4gIGVsc2VcbiAgICByZXR1cm4gd29yZDtcbn1cbmV4cG9ydHMuemVybzggPSB6ZXJvODtcblxuZnVuY3Rpb24gam9pbjMyKG1zZywgc3RhcnQsIGVuZCwgZW5kaWFuKSB7XG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgYXNzZXJ0KGxlbiAlIDQgPT09IDApO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbiAvIDQpO1xuICBmb3IgKHZhciBpID0gMCwgayA9IHN0YXJ0OyBpIDwgcmVzLmxlbmd0aDsgaSsrLCBrICs9IDQpIHtcbiAgICB2YXIgdztcbiAgICBpZiAoZW5kaWFuID09PSAnYmlnJylcbiAgICAgIHcgPSAobXNnW2tdIDw8IDI0KSB8IChtc2dbayArIDFdIDw8IDE2KSB8IChtc2dbayArIDJdIDw8IDgpIHwgbXNnW2sgKyAzXTtcbiAgICBlbHNlXG4gICAgICB3ID0gKG1zZ1trICsgM10gPDwgMjQpIHwgKG1zZ1trICsgMl0gPDwgMTYpIHwgKG1zZ1trICsgMV0gPDwgOCkgfCBtc2dba107XG4gICAgcmVzW2ldID0gdyA+Pj4gMDtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5qb2luMzIgPSBqb2luMzI7XG5cbmZ1bmN0aW9uIHNwbGl0MzIobXNnLCBlbmRpYW4pIHtcbiAgdmFyIHJlcyA9IG5ldyBBcnJheShtc2cubGVuZ3RoICogNCk7XG4gIGZvciAodmFyIGkgPSAwLCBrID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKywgayArPSA0KSB7XG4gICAgdmFyIG0gPSBtc2dbaV07XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpIHtcbiAgICAgIHJlc1trXSA9IG0gPj4+IDI0O1xuICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiAxNikgJiAweGZmO1xuICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiA4KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDNdID0gbSAmIDB4ZmY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1trICsgM10gPSBtID4+PiAyNDtcbiAgICAgIHJlc1trICsgMl0gPSAobSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gOCkgJiAweGZmO1xuICAgICAgcmVzW2tdID0gbSAmIDB4ZmY7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLnNwbGl0MzIgPSBzcGxpdDMyO1xuXG5mdW5jdGlvbiByb3RyMzIodywgYikge1xuICByZXR1cm4gKHcgPj4+IGIpIHwgKHcgPDwgKDMyIC0gYikpO1xufVxuZXhwb3J0cy5yb3RyMzIgPSByb3RyMzI7XG5cbmZ1bmN0aW9uIHJvdGwzMih3LCBiKSB7XG4gIHJldHVybiAodyA8PCBiKSB8ICh3ID4+PiAoMzIgLSBiKSk7XG59XG5leHBvcnRzLnJvdGwzMiA9IHJvdGwzMjtcblxuZnVuY3Rpb24gc3VtMzIoYSwgYikge1xuICByZXR1cm4gKGEgKyBiKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzIgPSBzdW0zMjtcblxuZnVuY3Rpb24gc3VtMzJfMyhhLCBiLCBjKSB7XG4gIHJldHVybiAoYSArIGIgKyBjKSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtMzJfMyA9IHN1bTMyXzM7XG5cbmZ1bmN0aW9uIHN1bTMyXzQoYSwgYiwgYywgZCkge1xuICByZXR1cm4gKGEgKyBiICsgYyArIGQpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMl80ID0gc3VtMzJfNDtcblxuZnVuY3Rpb24gc3VtMzJfNShhLCBiLCBjLCBkLCBlKSB7XG4gIHJldHVybiAoYSArIGIgKyBjICsgZCArIGUpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMl81ID0gc3VtMzJfNTtcblxuZnVuY3Rpb24gc3VtNjQoYnVmLCBwb3MsIGFoLCBhbCkge1xuICB2YXIgYmggPSBidWZbcG9zXTtcbiAgdmFyIGJsID0gYnVmW3BvcyArIDFdO1xuXG4gIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcbiAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuICBidWZbcG9zXSA9IGhpID4+PiAwO1xuICBidWZbcG9zICsgMV0gPSBsbztcbn1cbmV4cG9ydHMuc3VtNjQgPSBzdW02NDtcblxuZnVuY3Rpb24gc3VtNjRfaGkoYWgsIGFsLCBiaCwgYmwpIHtcbiAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfaGkgPSBzdW02NF9oaTtcblxuZnVuY3Rpb24gc3VtNjRfbG8oYWgsIGFsLCBiaCwgYmwpIHtcbiAgdmFyIGxvID0gYWwgKyBibDtcbiAgcmV0dXJuIGxvID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF9sbyA9IHN1bTY0X2xvO1xuXG5mdW5jdGlvbiBzdW02NF80X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCkge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgbG8gPSBhbDtcbiAgbG8gPSAobG8gKyBibCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgYWwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBjbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgY2wgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBkbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZGwgPyAxIDogMDtcblxuICB2YXIgaGkgPSBhaCArIGJoICsgY2ggKyBkaCArIGNhcnJ5O1xuICByZXR1cm4gaGkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzRfaGkgPSBzdW02NF80X2hpO1xuXG5mdW5jdGlvbiBzdW02NF80X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCkge1xuICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbDtcbiAgcmV0dXJuIGxvID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF80X2xvID0gc3VtNjRfNF9sbztcblxuZnVuY3Rpb24gc3VtNjRfNV9oaShhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuICB2YXIgY2FycnkgPSAwO1xuICB2YXIgbG8gPSBhbDtcbiAgbG8gPSAobG8gKyBibCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgYWwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBjbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgY2wgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBkbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZGwgPyAxIDogMDtcbiAgbG8gPSAobG8gKyBlbCkgPj4+IDA7XG4gIGNhcnJ5ICs9IGxvIDwgZWwgPyAxIDogMDtcblxuICB2YXIgaGkgPSBhaCArIGJoICsgY2ggKyBkaCArIGVoICsgY2Fycnk7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNV9oaSA9IHN1bTY0XzVfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0XzVfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcbiAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGwgKyBlbDtcblxuICByZXR1cm4gbG8gPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzVfbG8gPSBzdW02NF81X2xvO1xuXG5mdW5jdGlvbiByb3RyNjRfaGkoYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWwgPDwgKDMyIC0gbnVtKSkgfCAoYWggPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufVxuZXhwb3J0cy5yb3RyNjRfaGkgPSByb3RyNjRfaGk7XG5cbmZ1bmN0aW9uIHJvdHI2NF9sbyhhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59XG5leHBvcnRzLnJvdHI2NF9sbyA9IHJvdHI2NF9sbztcblxuZnVuY3Rpb24gc2hyNjRfaGkoYWgsIGFsLCBudW0pIHtcbiAgcmV0dXJuIGFoID4+PiBudW07XG59XG5leHBvcnRzLnNocjY0X2hpID0gc2hyNjRfaGk7XG5cbmZ1bmN0aW9uIHNocjY0X2xvKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn1cbmV4cG9ydHMuc2hyNjRfbG8gPSBzaHI2NF9sbztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhc2ggPSByZXF1aXJlKCdoYXNoLmpzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtY3J5cHRvLXV0aWxzJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG5mdW5jdGlvbiBIbWFjRFJCRyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBIbWFjRFJCRykpXG4gICAgcmV0dXJuIG5ldyBIbWFjRFJCRyhvcHRpb25zKTtcbiAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuICB0aGlzLnByZWRSZXNpc3QgPSAhIW9wdGlvbnMucHJlZFJlc2lzdDtcblxuICB0aGlzLm91dExlbiA9IHRoaXMuaGFzaC5vdXRTaXplO1xuICB0aGlzLm1pbkVudHJvcHkgPSBvcHRpb25zLm1pbkVudHJvcHkgfHwgdGhpcy5oYXNoLmhtYWNTdHJlbmd0aDtcblxuICB0aGlzLl9yZXNlZWQgPSBudWxsO1xuICB0aGlzLnJlc2VlZEludGVydmFsID0gbnVsbDtcbiAgdGhpcy5LID0gbnVsbDtcbiAgdGhpcy5WID0gbnVsbDtcblxuICB2YXIgZW50cm9weSA9IHV0aWxzLnRvQXJyYXkob3B0aW9ucy5lbnRyb3B5LCBvcHRpb25zLmVudHJvcHlFbmMgfHwgJ2hleCcpO1xuICB2YXIgbm9uY2UgPSB1dGlscy50b0FycmF5KG9wdGlvbnMubm9uY2UsIG9wdGlvbnMubm9uY2VFbmMgfHwgJ2hleCcpO1xuICB2YXIgcGVycyA9IHV0aWxzLnRvQXJyYXkob3B0aW9ucy5wZXJzLCBvcHRpb25zLnBlcnNFbmMgfHwgJ2hleCcpO1xuICBhc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuICB0aGlzLl9pbml0KGVudHJvcHksIG5vbmNlLCBwZXJzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hY0RSQkc7XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpIHtcbiAgdmFyIHNlZWQgPSBlbnRyb3B5LmNvbmNhdChub25jZSkuY29uY2F0KHBlcnMpO1xuXG4gIHRoaXMuSyA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuICB0aGlzLlYgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLlYubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLktbaV0gPSAweDAwO1xuICAgIHRoaXMuVltpXSA9IDB4MDE7XG4gIH1cblxuICB0aGlzLl91cGRhdGUoc2VlZCk7XG4gIHRoaXMuX3Jlc2VlZCA9IDE7XG4gIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSAweDEwMDAwMDAwMDAwMDA7ICAvLyAyXjQ4XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX2htYWMgPSBmdW5jdGlvbiBobWFjKCkge1xuICByZXR1cm4gbmV3IGhhc2guaG1hYyh0aGlzLmhhc2gsIHRoaXMuSyk7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVkKSB7XG4gIHZhciBrbWFjID0gdGhpcy5faG1hYygpXG4gICAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuICAgICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMCBdKTtcbiAgaWYgKHNlZWQpXG4gICAga21hYyA9IGttYWMudXBkYXRlKHNlZWQpO1xuICB0aGlzLksgPSBrbWFjLmRpZ2VzdCgpO1xuICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG4gIGlmICghc2VlZClcbiAgICByZXR1cm47XG5cbiAgdGhpcy5LID0gdGhpcy5faG1hYygpXG4gICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcbiAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAxIF0pXG4gICAgICAgICAgICAgICAudXBkYXRlKHNlZWQpXG4gICAgICAgICAgICAgICAuZGlnZXN0KCk7XG4gIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5yZXNlZWQgPSBmdW5jdGlvbiByZXNlZWQoZW50cm9weSwgZW50cm9weUVuYywgYWRkLCBhZGRFbmMpIHtcbiAgLy8gT3B0aW9uYWwgZW50cm9weSBlbmNcbiAgaWYgKHR5cGVvZiBlbnRyb3B5RW5jICE9PSAnc3RyaW5nJykge1xuICAgIGFkZEVuYyA9IGFkZDtcbiAgICBhZGQgPSBlbnRyb3B5RW5jO1xuICAgIGVudHJvcHlFbmMgPSBudWxsO1xuICB9XG5cbiAgZW50cm9weSA9IHV0aWxzLnRvQXJyYXkoZW50cm9weSwgZW50cm9weUVuYyk7XG4gIGFkZCA9IHV0aWxzLnRvQXJyYXkoYWRkLCBhZGRFbmMpO1xuXG4gIGFzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG4gICAgICAgICAnTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiAnICsgdGhpcy5taW5FbnRyb3B5ICsgJyBiaXRzJyk7XG5cbiAgdGhpcy5fdXBkYXRlKGVudHJvcHkuY29uY2F0KGFkZCB8fCBbXSkpO1xuICB0aGlzLl9yZXNlZWQgPSAxO1xufTtcblxuSG1hY0RSQkcucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUobGVuLCBlbmMsIGFkZCwgYWRkRW5jKSB7XG4gIGlmICh0aGlzLl9yZXNlZWQgPiB0aGlzLnJlc2VlZEludGVydmFsKVxuICAgIHRocm93IG5ldyBFcnJvcignUmVzZWVkIGlzIHJlcXVpcmVkJyk7XG5cbiAgLy8gT3B0aW9uYWwgZW5jb2RpbmdcbiAgaWYgKHR5cGVvZiBlbmMgIT09ICdzdHJpbmcnKSB7XG4gICAgYWRkRW5jID0gYWRkO1xuICAgIGFkZCA9IGVuYztcbiAgICBlbmMgPSBudWxsO1xuICB9XG5cbiAgLy8gT3B0aW9uYWwgYWRkaXRpb25hbCBkYXRhXG4gIGlmIChhZGQpIHtcbiAgICBhZGQgPSB1dGlscy50b0FycmF5KGFkZCwgYWRkRW5jIHx8ICdoZXgnKTtcbiAgICB0aGlzLl91cGRhdGUoYWRkKTtcbiAgfVxuXG4gIHZhciB0ZW1wID0gW107XG4gIHdoaWxlICh0ZW1wLmxlbmd0aCA8IGxlbikge1xuICAgIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbiAgICB0ZW1wID0gdGVtcC5jb25jYXQodGhpcy5WKTtcbiAgfVxuXG4gIHZhciByZXMgPSB0ZW1wLnNsaWNlKDAsIGxlbik7XG4gIHRoaXMuX3VwZGF0ZShhZGQpO1xuICB0aGlzLl9yZXNlZWQrKztcbiAgcmV0dXJuIHV0aWxzLmVuY29kZShyZXMsIGVuYyk7XG59O1xuIiwiLyoqXG4gKiBSZXR1cm5zIGEgYEJvb2xlYW5gIG9uIHdoZXRoZXIgb3Igbm90IHRoZSBhIGBTdHJpbmdgIHN0YXJ0cyB3aXRoICcweCdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyBpbnB1dCB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn0gYSBib29sZWFuIGlmIGl0IGlzIG9yIGlzIG5vdCBoZXggcHJlZml4ZWRcbiAqIEB0aHJvd3MgaWYgdGhlIHN0ciBpbnB1dCBpcyBub3QgYSBzdHJpbmdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0hleFByZWZpeGVkKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbaXMtaGV4LXByZWZpeGVkXSB2YWx1ZSBtdXN0IGJlIHR5cGUgJ3N0cmluZycsIGlzIGN1cnJlbnRseSB0eXBlIFwiICsgKHR5cGVvZiBzdHIpICsgXCIsIHdoaWxlIGNoZWNraW5nIGlzSGV4UHJlZml4ZWQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zbGljZSgwLCAyKSA9PT0gJzB4Jztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXBpJykocmVxdWlyZSgnLi9saWIva2VjY2FrJykpXG4iLCJjb25zdCBjcmVhdGVLZWNjYWsgPSByZXF1aXJlKCcuL2tlY2NhaycpXG5jb25zdCBjcmVhdGVTaGFrZSA9IHJlcXVpcmUoJy4vc2hha2UnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLZWNjYWtTdGF0ZSkge1xuICBjb25zdCBLZWNjYWsgPSBjcmVhdGVLZWNjYWsoS2VjY2FrU3RhdGUpXG4gIGNvbnN0IFNoYWtlID0gY3JlYXRlU2hha2UoS2VjY2FrU3RhdGUpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhbGdvcml0aG0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBoYXNoID0gdHlwZW9mIGFsZ29yaXRobSA9PT0gJ3N0cmluZycgPyBhbGdvcml0aG0udG9Mb3dlckNhc2UoKSA6IGFsZ29yaXRobVxuICAgIHN3aXRjaCAoaGFzaCkge1xuICAgICAgY2FzZSAna2VjY2FrMjI0JzogcmV0dXJuIG5ldyBLZWNjYWsoMTE1MiwgNDQ4LCBudWxsLCAyMjQsIG9wdGlvbnMpXG4gICAgICBjYXNlICdrZWNjYWsyNTYnOiByZXR1cm4gbmV3IEtlY2NhaygxMDg4LCA1MTIsIG51bGwsIDI1Niwgb3B0aW9ucylcbiAgICAgIGNhc2UgJ2tlY2NhazM4NCc6IHJldHVybiBuZXcgS2VjY2FrKDgzMiwgNzY4LCBudWxsLCAzODQsIG9wdGlvbnMpXG4gICAgICBjYXNlICdrZWNjYWs1MTInOiByZXR1cm4gbmV3IEtlY2Nhayg1NzYsIDEwMjQsIG51bGwsIDUxMiwgb3B0aW9ucylcblxuICAgICAgY2FzZSAnc2hhMy0yMjQnOiByZXR1cm4gbmV3IEtlY2NhaygxMTUyLCA0NDgsIDB4MDYsIDIyNCwgb3B0aW9ucylcbiAgICAgIGNhc2UgJ3NoYTMtMjU2JzogcmV0dXJuIG5ldyBLZWNjYWsoMTA4OCwgNTEyLCAweDA2LCAyNTYsIG9wdGlvbnMpXG4gICAgICBjYXNlICdzaGEzLTM4NCc6IHJldHVybiBuZXcgS2VjY2FrKDgzMiwgNzY4LCAweDA2LCAzODQsIG9wdGlvbnMpXG4gICAgICBjYXNlICdzaGEzLTUxMic6IHJldHVybiBuZXcgS2VjY2FrKDU3NiwgMTAyNCwgMHgwNiwgNTEyLCBvcHRpb25zKVxuXG4gICAgICBjYXNlICdzaGFrZTEyOCc6IHJldHVybiBuZXcgU2hha2UoMTM0NCwgMjU2LCAweDFmLCBvcHRpb25zKVxuICAgICAgY2FzZSAnc2hha2UyNTYnOiByZXR1cm4gbmV3IFNoYWtlKDEwODgsIDUxMiwgMHgxZiwgb3B0aW9ucylcblxuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdJbnZhbGQgYWxnb3JpdGhtOiAnICsgYWxnb3JpdGhtKVxuICAgIH1cbiAgfVxufVxuIiwiY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbm1vZHVsZS5leHBvcnRzID0gKEtlY2Nha1N0YXRlKSA9PiBjbGFzcyBLZWNjYWsgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICBjb25zdHJ1Y3RvciAocmF0ZSwgY2FwYWNpdHksIGRlbGltaXRlZFN1ZmZpeCwgaGFzaEJpdExlbmd0aCwgb3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpXG5cbiAgICB0aGlzLl9yYXRlID0gcmF0ZVxuICAgIHRoaXMuX2NhcGFjaXR5ID0gY2FwYWNpdHlcbiAgICB0aGlzLl9kZWxpbWl0ZWRTdWZmaXggPSBkZWxpbWl0ZWRTdWZmaXhcbiAgICB0aGlzLl9oYXNoQml0TGVuZ3RoID0gaGFzaEJpdExlbmd0aFxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG5cbiAgICB0aGlzLl9zdGF0ZSA9IG5ldyBLZWNjYWtTdGF0ZSgpXG4gICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZShyYXRlLCBjYXBhY2l0eSlcbiAgICB0aGlzLl9maW5hbGl6ZWQgPSBmYWxzZVxuICB9XG5cbiAgX3RyYW5zZm9ybSAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGxldCBlcnJvciA9IG51bGxcbiAgICB0cnkge1xuICAgICAgdGhpcy51cGRhdGUoY2h1bmssIGVuY29kaW5nKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3IgPSBlcnJcbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnJvcilcbiAgfVxuXG4gIF9mbHVzaCAoY2FsbGJhY2spIHtcbiAgICBsZXQgZXJyb3IgPSBudWxsXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucHVzaCh0aGlzLmRpZ2VzdCgpKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3IgPSBlcnJcbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnJvcilcbiAgfVxuXG4gIHVwZGF0ZSAoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSAmJiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGEgbXVzdCBiZSBhIHN0cmluZyBvciBhIGJ1ZmZlcicpXG4gICAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgdGhyb3cgbmV3IEVycm9yKCdEaWdlc3QgYWxyZWFkeSBjYWxsZWQnKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgZW5jb2RpbmcpXG5cbiAgICB0aGlzLl9zdGF0ZS5hYnNvcmIoZGF0YSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBkaWdlc3QgKGVuY29kaW5nKSB7XG4gICAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgdGhyb3cgbmV3IEVycm9yKCdEaWdlc3QgYWxyZWFkeSBjYWxsZWQnKVxuICAgIHRoaXMuX2ZpbmFsaXplZCA9IHRydWVcblxuICAgIGlmICh0aGlzLl9kZWxpbWl0ZWRTdWZmaXgpIHRoaXMuX3N0YXRlLmFic29yYkxhc3RGZXdCaXRzKHRoaXMuX2RlbGltaXRlZFN1ZmZpeClcbiAgICBsZXQgZGlnZXN0ID0gdGhpcy5fc3RhdGUuc3F1ZWV6ZSh0aGlzLl9oYXNoQml0TGVuZ3RoIC8gOClcbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgZGlnZXN0ID0gZGlnZXN0LnRvU3RyaW5nKGVuY29kaW5nKVxuXG4gICAgdGhpcy5fcmVzZXRTdGF0ZSgpXG5cbiAgICByZXR1cm4gZGlnZXN0XG4gIH1cblxuICAvLyByZW1vdmUgcmVzdWx0IGZyb20gbWVtb3J5XG4gIF9yZXNldFN0YXRlICgpIHtcbiAgICB0aGlzLl9zdGF0ZS5pbml0aWFsaXplKHRoaXMuX3JhdGUsIHRoaXMuX2NhcGFjaXR5KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBiZWNhdXNlIHNvbWV0aW1lcyB3ZSBuZWVkIGhhc2ggcmlnaHQgbm93IGFuZCBsaXR0bGUgbGF0ZXJcbiAgX2Nsb25lICgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBLZWNjYWsodGhpcy5fcmF0ZSwgdGhpcy5fY2FwYWNpdHksIHRoaXMuX2RlbGltaXRlZFN1ZmZpeCwgdGhpcy5faGFzaEJpdExlbmd0aCwgdGhpcy5fb3B0aW9ucylcbiAgICB0aGlzLl9zdGF0ZS5jb3B5KGNsb25lLl9zdGF0ZSlcbiAgICBjbG9uZS5fZmluYWxpemVkID0gdGhpcy5fZmluYWxpemVkXG5cbiAgICByZXR1cm4gY2xvbmVcbiAgfVxufVxuIiwiY29uc3QgeyBUcmFuc2Zvcm0gfSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbm1vZHVsZS5leHBvcnRzID0gKEtlY2Nha1N0YXRlKSA9PiBjbGFzcyBTaGFrZSBleHRlbmRzIFRyYW5zZm9ybSB7XG4gIGNvbnN0cnVjdG9yIChyYXRlLCBjYXBhY2l0eSwgZGVsaW1pdGVkU3VmZml4LCBvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucylcblxuICAgIHRoaXMuX3JhdGUgPSByYXRlXG4gICAgdGhpcy5fY2FwYWNpdHkgPSBjYXBhY2l0eVxuICAgIHRoaXMuX2RlbGltaXRlZFN1ZmZpeCA9IGRlbGltaXRlZFN1ZmZpeFxuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zXG5cbiAgICB0aGlzLl9zdGF0ZSA9IG5ldyBLZWNjYWtTdGF0ZSgpXG4gICAgdGhpcy5fc3RhdGUuaW5pdGlhbGl6ZShyYXRlLCBjYXBhY2l0eSlcbiAgICB0aGlzLl9maW5hbGl6ZWQgPSBmYWxzZVxuICB9XG5cbiAgX3RyYW5zZm9ybSAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGxldCBlcnJvciA9IG51bGxcbiAgICB0cnkge1xuICAgICAgdGhpcy51cGRhdGUoY2h1bmssIGVuY29kaW5nKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3IgPSBlcnJcbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnJvcilcbiAgfVxuXG4gIF9mbHVzaCAoKSB7fVxuXG4gIF9yZWFkIChzaXplKSB7XG4gICAgdGhpcy5wdXNoKHRoaXMuc3F1ZWV6ZShzaXplKSlcbiAgfVxuXG4gIHVwZGF0ZSAoZGF0YSwgZW5jb2RpbmcpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSAmJiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0RhdGEgbXVzdCBiZSBhIHN0cmluZyBvciBhIGJ1ZmZlcicpXG4gICAgaWYgKHRoaXMuX2ZpbmFsaXplZCkgdGhyb3cgbmV3IEVycm9yKCdTcXVlZXplIGFscmVhZHkgY2FsbGVkJylcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKVxuXG4gICAgdGhpcy5fc3RhdGUuYWJzb3JiKGRhdGEpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3F1ZWV6ZSAoZGF0YUJ5dGVMZW5ndGgsIGVuY29kaW5nKSB7XG4gICAgaWYgKCF0aGlzLl9maW5hbGl6ZWQpIHtcbiAgICAgIHRoaXMuX2ZpbmFsaXplZCA9IHRydWVcbiAgICAgIHRoaXMuX3N0YXRlLmFic29yYkxhc3RGZXdCaXRzKHRoaXMuX2RlbGltaXRlZFN1ZmZpeClcbiAgICB9XG5cbiAgICBsZXQgZGF0YSA9IHRoaXMuX3N0YXRlLnNxdWVlemUoZGF0YUJ5dGVMZW5ndGgpXG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKGVuY29kaW5nKVxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIF9yZXNldFN0YXRlICgpIHtcbiAgICB0aGlzLl9zdGF0ZS5pbml0aWFsaXplKHRoaXMuX3JhdGUsIHRoaXMuX2NhcGFjaXR5KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBfY2xvbmUgKCkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IFNoYWtlKHRoaXMuX3JhdGUsIHRoaXMuX2NhcGFjaXR5LCB0aGlzLl9kZWxpbWl0ZWRTdWZmaXgsIHRoaXMuX29wdGlvbnMpXG4gICAgdGhpcy5fc3RhdGUuY29weShjbG9uZS5fc3RhdGUpXG4gICAgY2xvbmUuX2ZpbmFsaXplZCA9IHRoaXMuX2ZpbmFsaXplZFxuXG4gICAgcmV0dXJuIGNsb25lXG4gIH1cbn1cbiIsImNvbnN0IFAxNjAwX1JPVU5EX0NPTlNUQU5UUyA9IFsxLCAwLCAzMjg5OCwgMCwgMzI5MDYsIDIxNDc0ODM2NDgsIDIxNDc1MTY0MTYsIDIxNDc0ODM2NDgsIDMyOTA3LCAwLCAyMTQ3NDgzNjQ5LCAwLCAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjc3NywgMjE0NzQ4MzY0OCwgMTM4LCAwLCAxMzYsIDAsIDIxNDc1MTY0MjUsIDAsIDIxNDc0ODM2NTgsIDAsIDIxNDc1MTY1NTUsIDAsIDEzOSwgMjE0NzQ4MzY0OCwgMzI5MDUsIDIxNDc0ODM2NDgsIDMyNzcxLCAyMTQ3NDgzNjQ4LCAzMjc3MCwgMjE0NzQ4MzY0OCwgMTI4LCAyMTQ3NDgzNjQ4LCAzMjc3OCwgMCwgMjE0NzQ4MzY1OCwgMjE0NzQ4MzY0OCwgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI4OTYsIDIxNDc0ODM2NDgsIDIxNDc0ODM2NDksIDAsIDIxNDc1MTY0MjQsIDIxNDc0ODM2NDhdXG5cbmV4cG9ydHMucDE2MDAgPSBmdW5jdGlvbiAocykge1xuICBmb3IgKGxldCByb3VuZCA9IDA7IHJvdW5kIDwgMjQ7ICsrcm91bmQpIHtcbiAgICAvLyB0aGV0YVxuICAgIGNvbnN0IGxvMCA9IHNbMF0gXiBzWzEwXSBeIHNbMjBdIF4gc1szMF0gXiBzWzQwXVxuICAgIGNvbnN0IGhpMCA9IHNbMV0gXiBzWzExXSBeIHNbMjFdIF4gc1szMV0gXiBzWzQxXVxuICAgIGNvbnN0IGxvMSA9IHNbMl0gXiBzWzEyXSBeIHNbMjJdIF4gc1szMl0gXiBzWzQyXVxuICAgIGNvbnN0IGhpMSA9IHNbM10gXiBzWzEzXSBeIHNbMjNdIF4gc1szM10gXiBzWzQzXVxuICAgIGNvbnN0IGxvMiA9IHNbNF0gXiBzWzE0XSBeIHNbMjRdIF4gc1szNF0gXiBzWzQ0XVxuICAgIGNvbnN0IGhpMiA9IHNbNV0gXiBzWzE1XSBeIHNbMjVdIF4gc1szNV0gXiBzWzQ1XVxuICAgIGNvbnN0IGxvMyA9IHNbNl0gXiBzWzE2XSBeIHNbMjZdIF4gc1szNl0gXiBzWzQ2XVxuICAgIGNvbnN0IGhpMyA9IHNbN10gXiBzWzE3XSBeIHNbMjddIF4gc1szN10gXiBzWzQ3XVxuICAgIGNvbnN0IGxvNCA9IHNbOF0gXiBzWzE4XSBeIHNbMjhdIF4gc1szOF0gXiBzWzQ4XVxuICAgIGNvbnN0IGhpNCA9IHNbOV0gXiBzWzE5XSBeIHNbMjldIF4gc1szOV0gXiBzWzQ5XVxuXG4gICAgbGV0IGxvID0gbG80IF4gKGxvMSA8PCAxIHwgaGkxID4+PiAzMSlcbiAgICBsZXQgaGkgPSBoaTQgXiAoaGkxIDw8IDEgfCBsbzEgPj4+IDMxKVxuICAgIGNvbnN0IHQxc2xvMCA9IHNbMF0gXiBsb1xuICAgIGNvbnN0IHQxc2hpMCA9IHNbMV0gXiBoaVxuICAgIGNvbnN0IHQxc2xvNSA9IHNbMTBdIF4gbG9cbiAgICBjb25zdCB0MXNoaTUgPSBzWzExXSBeIGhpXG4gICAgY29uc3QgdDFzbG8xMCA9IHNbMjBdIF4gbG9cbiAgICBjb25zdCB0MXNoaTEwID0gc1syMV0gXiBoaVxuICAgIGNvbnN0IHQxc2xvMTUgPSBzWzMwXSBeIGxvXG4gICAgY29uc3QgdDFzaGkxNSA9IHNbMzFdIF4gaGlcbiAgICBjb25zdCB0MXNsbzIwID0gc1s0MF0gXiBsb1xuICAgIGNvbnN0IHQxc2hpMjAgPSBzWzQxXSBeIGhpXG4gICAgbG8gPSBsbzAgXiAobG8yIDw8IDEgfCBoaTIgPj4+IDMxKVxuICAgIGhpID0gaGkwIF4gKGhpMiA8PCAxIHwgbG8yID4+PiAzMSlcbiAgICBjb25zdCB0MXNsbzEgPSBzWzJdIF4gbG9cbiAgICBjb25zdCB0MXNoaTEgPSBzWzNdIF4gaGlcbiAgICBjb25zdCB0MXNsbzYgPSBzWzEyXSBeIGxvXG4gICAgY29uc3QgdDFzaGk2ID0gc1sxM10gXiBoaVxuICAgIGNvbnN0IHQxc2xvMTEgPSBzWzIyXSBeIGxvXG4gICAgY29uc3QgdDFzaGkxMSA9IHNbMjNdIF4gaGlcbiAgICBjb25zdCB0MXNsbzE2ID0gc1szMl0gXiBsb1xuICAgIGNvbnN0IHQxc2hpMTYgPSBzWzMzXSBeIGhpXG4gICAgY29uc3QgdDFzbG8yMSA9IHNbNDJdIF4gbG9cbiAgICBjb25zdCB0MXNoaTIxID0gc1s0M10gXiBoaVxuICAgIGxvID0gbG8xIF4gKGxvMyA8PCAxIHwgaGkzID4+PiAzMSlcbiAgICBoaSA9IGhpMSBeIChoaTMgPDwgMSB8IGxvMyA+Pj4gMzEpXG4gICAgY29uc3QgdDFzbG8yID0gc1s0XSBeIGxvXG4gICAgY29uc3QgdDFzaGkyID0gc1s1XSBeIGhpXG4gICAgY29uc3QgdDFzbG83ID0gc1sxNF0gXiBsb1xuICAgIGNvbnN0IHQxc2hpNyA9IHNbMTVdIF4gaGlcbiAgICBjb25zdCB0MXNsbzEyID0gc1syNF0gXiBsb1xuICAgIGNvbnN0IHQxc2hpMTIgPSBzWzI1XSBeIGhpXG4gICAgY29uc3QgdDFzbG8xNyA9IHNbMzRdIF4gbG9cbiAgICBjb25zdCB0MXNoaTE3ID0gc1szNV0gXiBoaVxuICAgIGNvbnN0IHQxc2xvMjIgPSBzWzQ0XSBeIGxvXG4gICAgY29uc3QgdDFzaGkyMiA9IHNbNDVdIF4gaGlcbiAgICBsbyA9IGxvMiBeIChsbzQgPDwgMSB8IGhpNCA+Pj4gMzEpXG4gICAgaGkgPSBoaTIgXiAoaGk0IDw8IDEgfCBsbzQgPj4+IDMxKVxuICAgIGNvbnN0IHQxc2xvMyA9IHNbNl0gXiBsb1xuICAgIGNvbnN0IHQxc2hpMyA9IHNbN10gXiBoaVxuICAgIGNvbnN0IHQxc2xvOCA9IHNbMTZdIF4gbG9cbiAgICBjb25zdCB0MXNoaTggPSBzWzE3XSBeIGhpXG4gICAgY29uc3QgdDFzbG8xMyA9IHNbMjZdIF4gbG9cbiAgICBjb25zdCB0MXNoaTEzID0gc1syN10gXiBoaVxuICAgIGNvbnN0IHQxc2xvMTggPSBzWzM2XSBeIGxvXG4gICAgY29uc3QgdDFzaGkxOCA9IHNbMzddIF4gaGlcbiAgICBjb25zdCB0MXNsbzIzID0gc1s0Nl0gXiBsb1xuICAgIGNvbnN0IHQxc2hpMjMgPSBzWzQ3XSBeIGhpXG4gICAgbG8gPSBsbzMgXiAobG8wIDw8IDEgfCBoaTAgPj4+IDMxKVxuICAgIGhpID0gaGkzIF4gKGhpMCA8PCAxIHwgbG8wID4+PiAzMSlcbiAgICBjb25zdCB0MXNsbzQgPSBzWzhdIF4gbG9cbiAgICBjb25zdCB0MXNoaTQgPSBzWzldIF4gaGlcbiAgICBjb25zdCB0MXNsbzkgPSBzWzE4XSBeIGxvXG4gICAgY29uc3QgdDFzaGk5ID0gc1sxOV0gXiBoaVxuICAgIGNvbnN0IHQxc2xvMTQgPSBzWzI4XSBeIGxvXG4gICAgY29uc3QgdDFzaGkxNCA9IHNbMjldIF4gaGlcbiAgICBjb25zdCB0MXNsbzE5ID0gc1szOF0gXiBsb1xuICAgIGNvbnN0IHQxc2hpMTkgPSBzWzM5XSBeIGhpXG4gICAgY29uc3QgdDFzbG8yNCA9IHNbNDhdIF4gbG9cbiAgICBjb25zdCB0MXNoaTI0ID0gc1s0OV0gXiBoaVxuXG4gICAgLy8gcmhvICYgcGlcbiAgICBjb25zdCB0MnNsbzAgPSB0MXNsbzBcbiAgICBjb25zdCB0MnNoaTAgPSB0MXNoaTBcbiAgICBjb25zdCB0MnNsbzE2ID0gKHQxc2hpNSA8PCA0IHwgdDFzbG81ID4+PiAyOClcbiAgICBjb25zdCB0MnNoaTE2ID0gKHQxc2xvNSA8PCA0IHwgdDFzaGk1ID4+PiAyOClcbiAgICBjb25zdCB0MnNsbzcgPSAodDFzbG8xMCA8PCAzIHwgdDFzaGkxMCA+Pj4gMjkpXG4gICAgY29uc3QgdDJzaGk3ID0gKHQxc2hpMTAgPDwgMyB8IHQxc2xvMTAgPj4+IDI5KVxuICAgIGNvbnN0IHQyc2xvMjMgPSAodDFzaGkxNSA8PCA5IHwgdDFzbG8xNSA+Pj4gMjMpXG4gICAgY29uc3QgdDJzaGkyMyA9ICh0MXNsbzE1IDw8IDkgfCB0MXNoaTE1ID4+PiAyMylcbiAgICBjb25zdCB0MnNsbzE0ID0gKHQxc2xvMjAgPDwgMTggfCB0MXNoaTIwID4+PiAxNClcbiAgICBjb25zdCB0MnNoaTE0ID0gKHQxc2hpMjAgPDwgMTggfCB0MXNsbzIwID4+PiAxNClcbiAgICBjb25zdCB0MnNsbzEwID0gKHQxc2xvMSA8PCAxIHwgdDFzaGkxID4+PiAzMSlcbiAgICBjb25zdCB0MnNoaTEwID0gKHQxc2hpMSA8PCAxIHwgdDFzbG8xID4+PiAzMSlcbiAgICBjb25zdCB0MnNsbzEgPSAodDFzaGk2IDw8IDEyIHwgdDFzbG82ID4+PiAyMClcbiAgICBjb25zdCB0MnNoaTEgPSAodDFzbG82IDw8IDEyIHwgdDFzaGk2ID4+PiAyMClcbiAgICBjb25zdCB0MnNsbzE3ID0gKHQxc2xvMTEgPDwgMTAgfCB0MXNoaTExID4+PiAyMilcbiAgICBjb25zdCB0MnNoaTE3ID0gKHQxc2hpMTEgPDwgMTAgfCB0MXNsbzExID4+PiAyMilcbiAgICBjb25zdCB0MnNsbzggPSAodDFzaGkxNiA8PCAxMyB8IHQxc2xvMTYgPj4+IDE5KVxuICAgIGNvbnN0IHQyc2hpOCA9ICh0MXNsbzE2IDw8IDEzIHwgdDFzaGkxNiA+Pj4gMTkpXG4gICAgY29uc3QgdDJzbG8yNCA9ICh0MXNsbzIxIDw8IDIgfCB0MXNoaTIxID4+PiAzMClcbiAgICBjb25zdCB0MnNoaTI0ID0gKHQxc2hpMjEgPDwgMiB8IHQxc2xvMjEgPj4+IDMwKVxuICAgIGNvbnN0IHQyc2xvMjAgPSAodDFzaGkyIDw8IDMwIHwgdDFzbG8yID4+PiAyKVxuICAgIGNvbnN0IHQyc2hpMjAgPSAodDFzbG8yIDw8IDMwIHwgdDFzaGkyID4+PiAyKVxuICAgIGNvbnN0IHQyc2xvMTEgPSAodDFzbG83IDw8IDYgfCB0MXNoaTcgPj4+IDI2KVxuICAgIGNvbnN0IHQyc2hpMTEgPSAodDFzaGk3IDw8IDYgfCB0MXNsbzcgPj4+IDI2KVxuICAgIGNvbnN0IHQyc2xvMiA9ICh0MXNoaTEyIDw8IDExIHwgdDFzbG8xMiA+Pj4gMjEpXG4gICAgY29uc3QgdDJzaGkyID0gKHQxc2xvMTIgPDwgMTEgfCB0MXNoaTEyID4+PiAyMSlcbiAgICBjb25zdCB0MnNsbzE4ID0gKHQxc2xvMTcgPDwgMTUgfCB0MXNoaTE3ID4+PiAxNylcbiAgICBjb25zdCB0MnNoaTE4ID0gKHQxc2hpMTcgPDwgMTUgfCB0MXNsbzE3ID4+PiAxNylcbiAgICBjb25zdCB0MnNsbzkgPSAodDFzaGkyMiA8PCAyOSB8IHQxc2xvMjIgPj4+IDMpXG4gICAgY29uc3QgdDJzaGk5ID0gKHQxc2xvMjIgPDwgMjkgfCB0MXNoaTIyID4+PiAzKVxuICAgIGNvbnN0IHQyc2xvNSA9ICh0MXNsbzMgPDwgMjggfCB0MXNoaTMgPj4+IDQpXG4gICAgY29uc3QgdDJzaGk1ID0gKHQxc2hpMyA8PCAyOCB8IHQxc2xvMyA+Pj4gNClcbiAgICBjb25zdCB0MnNsbzIxID0gKHQxc2hpOCA8PCAyMyB8IHQxc2xvOCA+Pj4gOSlcbiAgICBjb25zdCB0MnNoaTIxID0gKHQxc2xvOCA8PCAyMyB8IHQxc2hpOCA+Pj4gOSlcbiAgICBjb25zdCB0MnNsbzEyID0gKHQxc2xvMTMgPDwgMjUgfCB0MXNoaTEzID4+PiA3KVxuICAgIGNvbnN0IHQyc2hpMTIgPSAodDFzaGkxMyA8PCAyNSB8IHQxc2xvMTMgPj4+IDcpXG4gICAgY29uc3QgdDJzbG8zID0gKHQxc2xvMTggPDwgMjEgfCB0MXNoaTE4ID4+PiAxMSlcbiAgICBjb25zdCB0MnNoaTMgPSAodDFzaGkxOCA8PCAyMSB8IHQxc2xvMTggPj4+IDExKVxuICAgIGNvbnN0IHQyc2xvMTkgPSAodDFzaGkyMyA8PCAyNCB8IHQxc2xvMjMgPj4+IDgpXG4gICAgY29uc3QgdDJzaGkxOSA9ICh0MXNsbzIzIDw8IDI0IHwgdDFzaGkyMyA+Pj4gOClcbiAgICBjb25zdCB0MnNsbzE1ID0gKHQxc2xvNCA8PCAyNyB8IHQxc2hpNCA+Pj4gNSlcbiAgICBjb25zdCB0MnNoaTE1ID0gKHQxc2hpNCA8PCAyNyB8IHQxc2xvNCA+Pj4gNSlcbiAgICBjb25zdCB0MnNsbzYgPSAodDFzbG85IDw8IDIwIHwgdDFzaGk5ID4+PiAxMilcbiAgICBjb25zdCB0MnNoaTYgPSAodDFzaGk5IDw8IDIwIHwgdDFzbG85ID4+PiAxMilcbiAgICBjb25zdCB0MnNsbzIyID0gKHQxc2hpMTQgPDwgNyB8IHQxc2xvMTQgPj4+IDI1KVxuICAgIGNvbnN0IHQyc2hpMjIgPSAodDFzbG8xNCA8PCA3IHwgdDFzaGkxNCA+Pj4gMjUpXG4gICAgY29uc3QgdDJzbG8xMyA9ICh0MXNsbzE5IDw8IDggfCB0MXNoaTE5ID4+PiAyNClcbiAgICBjb25zdCB0MnNoaTEzID0gKHQxc2hpMTkgPDwgOCB8IHQxc2xvMTkgPj4+IDI0KVxuICAgIGNvbnN0IHQyc2xvNCA9ICh0MXNsbzI0IDw8IDE0IHwgdDFzaGkyNCA+Pj4gMTgpXG4gICAgY29uc3QgdDJzaGk0ID0gKHQxc2hpMjQgPDwgMTQgfCB0MXNsbzI0ID4+PiAxOClcblxuICAgIC8vIGNoaVxuICAgIHNbMF0gPSB0MnNsbzAgXiAofnQyc2xvMSAmIHQyc2xvMilcbiAgICBzWzFdID0gdDJzaGkwIF4gKH50MnNoaTEgJiB0MnNoaTIpXG4gICAgc1sxMF0gPSB0MnNsbzUgXiAofnQyc2xvNiAmIHQyc2xvNylcbiAgICBzWzExXSA9IHQyc2hpNSBeICh+dDJzaGk2ICYgdDJzaGk3KVxuICAgIHNbMjBdID0gdDJzbG8xMCBeICh+dDJzbG8xMSAmIHQyc2xvMTIpXG4gICAgc1syMV0gPSB0MnNoaTEwIF4gKH50MnNoaTExICYgdDJzaGkxMilcbiAgICBzWzMwXSA9IHQyc2xvMTUgXiAofnQyc2xvMTYgJiB0MnNsbzE3KVxuICAgIHNbMzFdID0gdDJzaGkxNSBeICh+dDJzaGkxNiAmIHQyc2hpMTcpXG4gICAgc1s0MF0gPSB0MnNsbzIwIF4gKH50MnNsbzIxICYgdDJzbG8yMilcbiAgICBzWzQxXSA9IHQyc2hpMjAgXiAofnQyc2hpMjEgJiB0MnNoaTIyKVxuICAgIHNbMl0gPSB0MnNsbzEgXiAofnQyc2xvMiAmIHQyc2xvMylcbiAgICBzWzNdID0gdDJzaGkxIF4gKH50MnNoaTIgJiB0MnNoaTMpXG4gICAgc1sxMl0gPSB0MnNsbzYgXiAofnQyc2xvNyAmIHQyc2xvOClcbiAgICBzWzEzXSA9IHQyc2hpNiBeICh+dDJzaGk3ICYgdDJzaGk4KVxuICAgIHNbMjJdID0gdDJzbG8xMSBeICh+dDJzbG8xMiAmIHQyc2xvMTMpXG4gICAgc1syM10gPSB0MnNoaTExIF4gKH50MnNoaTEyICYgdDJzaGkxMylcbiAgICBzWzMyXSA9IHQyc2xvMTYgXiAofnQyc2xvMTcgJiB0MnNsbzE4KVxuICAgIHNbMzNdID0gdDJzaGkxNiBeICh+dDJzaGkxNyAmIHQyc2hpMTgpXG4gICAgc1s0Ml0gPSB0MnNsbzIxIF4gKH50MnNsbzIyICYgdDJzbG8yMylcbiAgICBzWzQzXSA9IHQyc2hpMjEgXiAofnQyc2hpMjIgJiB0MnNoaTIzKVxuICAgIHNbNF0gPSB0MnNsbzIgXiAofnQyc2xvMyAmIHQyc2xvNClcbiAgICBzWzVdID0gdDJzaGkyIF4gKH50MnNoaTMgJiB0MnNoaTQpXG4gICAgc1sxNF0gPSB0MnNsbzcgXiAofnQyc2xvOCAmIHQyc2xvOSlcbiAgICBzWzE1XSA9IHQyc2hpNyBeICh+dDJzaGk4ICYgdDJzaGk5KVxuICAgIHNbMjRdID0gdDJzbG8xMiBeICh+dDJzbG8xMyAmIHQyc2xvMTQpXG4gICAgc1syNV0gPSB0MnNoaTEyIF4gKH50MnNoaTEzICYgdDJzaGkxNClcbiAgICBzWzM0XSA9IHQyc2xvMTcgXiAofnQyc2xvMTggJiB0MnNsbzE5KVxuICAgIHNbMzVdID0gdDJzaGkxNyBeICh+dDJzaGkxOCAmIHQyc2hpMTkpXG4gICAgc1s0NF0gPSB0MnNsbzIyIF4gKH50MnNsbzIzICYgdDJzbG8yNClcbiAgICBzWzQ1XSA9IHQyc2hpMjIgXiAofnQyc2hpMjMgJiB0MnNoaTI0KVxuICAgIHNbNl0gPSB0MnNsbzMgXiAofnQyc2xvNCAmIHQyc2xvMClcbiAgICBzWzddID0gdDJzaGkzIF4gKH50MnNoaTQgJiB0MnNoaTApXG4gICAgc1sxNl0gPSB0MnNsbzggXiAofnQyc2xvOSAmIHQyc2xvNSlcbiAgICBzWzE3XSA9IHQyc2hpOCBeICh+dDJzaGk5ICYgdDJzaGk1KVxuICAgIHNbMjZdID0gdDJzbG8xMyBeICh+dDJzbG8xNCAmIHQyc2xvMTApXG4gICAgc1syN10gPSB0MnNoaTEzIF4gKH50MnNoaTE0ICYgdDJzaGkxMClcbiAgICBzWzM2XSA9IHQyc2xvMTggXiAofnQyc2xvMTkgJiB0MnNsbzE1KVxuICAgIHNbMzddID0gdDJzaGkxOCBeICh+dDJzaGkxOSAmIHQyc2hpMTUpXG4gICAgc1s0Nl0gPSB0MnNsbzIzIF4gKH50MnNsbzI0ICYgdDJzbG8yMClcbiAgICBzWzQ3XSA9IHQyc2hpMjMgXiAofnQyc2hpMjQgJiB0MnNoaTIwKVxuICAgIHNbOF0gPSB0MnNsbzQgXiAofnQyc2xvMCAmIHQyc2xvMSlcbiAgICBzWzldID0gdDJzaGk0IF4gKH50MnNoaTAgJiB0MnNoaTEpXG4gICAgc1sxOF0gPSB0MnNsbzkgXiAofnQyc2xvNSAmIHQyc2xvNilcbiAgICBzWzE5XSA9IHQyc2hpOSBeICh+dDJzaGk1ICYgdDJzaGk2KVxuICAgIHNbMjhdID0gdDJzbG8xNCBeICh+dDJzbG8xMCAmIHQyc2xvMTEpXG4gICAgc1syOV0gPSB0MnNoaTE0IF4gKH50MnNoaTEwICYgdDJzaGkxMSlcbiAgICBzWzM4XSA9IHQyc2xvMTkgXiAofnQyc2xvMTUgJiB0MnNsbzE2KVxuICAgIHNbMzldID0gdDJzaGkxOSBeICh+dDJzaGkxNSAmIHQyc2hpMTYpXG4gICAgc1s0OF0gPSB0MnNsbzI0IF4gKH50MnNsbzIwICYgdDJzbG8yMSlcbiAgICBzWzQ5XSA9IHQyc2hpMjQgXiAofnQyc2hpMjAgJiB0MnNoaTIxKVxuXG4gICAgLy8gaW90YVxuICAgIHNbMF0gXj0gUDE2MDBfUk9VTkRfQ09OU1RBTlRTW3JvdW5kICogMl1cbiAgICBzWzFdIF49IFAxNjAwX1JPVU5EX0NPTlNUQU5UU1tyb3VuZCAqIDIgKyAxXVxuICB9XG59XG4iLCJjb25zdCBrZWNjYWtTdGF0ZSA9IHJlcXVpcmUoJy4va2VjY2FrLXN0YXRlLXVucm9sbCcpXG5cbmZ1bmN0aW9uIEtlY2NhayAoKSB7XG4gIC8vIG11Y2ggZmFzdGVyIHRoYW4gYG5ldyBBcnJheSg1MClgXG4gIHRoaXMuc3RhdGUgPSBbXG4gICAgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwXG4gIF1cblxuICB0aGlzLmJsb2NrU2l6ZSA9IG51bGxcbiAgdGhpcy5jb3VudCA9IDBcbiAgdGhpcy5zcXVlZXppbmcgPSBmYWxzZVxufVxuXG5LZWNjYWsucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAocmF0ZSwgY2FwYWNpdHkpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgKytpKSB0aGlzLnN0YXRlW2ldID0gMFxuICB0aGlzLmJsb2NrU2l6ZSA9IHJhdGUgLyA4XG4gIHRoaXMuY291bnQgPSAwXG4gIHRoaXMuc3F1ZWV6aW5nID0gZmFsc2Vcbn1cblxuS2VjY2FrLnByb3RvdHlwZS5hYnNvcmIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB0aGlzLnN0YXRlW35+KHRoaXMuY291bnQgLyA0KV0gXj0gZGF0YVtpXSA8PCAoOCAqICh0aGlzLmNvdW50ICUgNCkpXG4gICAgdGhpcy5jb3VudCArPSAxXG4gICAgaWYgKHRoaXMuY291bnQgPT09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICBrZWNjYWtTdGF0ZS5wMTYwMCh0aGlzLnN0YXRlKVxuICAgICAgdGhpcy5jb3VudCA9IDBcbiAgICB9XG4gIH1cbn1cblxuS2VjY2FrLnByb3RvdHlwZS5hYnNvcmJMYXN0RmV3Qml0cyA9IGZ1bmN0aW9uIChiaXRzKSB7XG4gIHRoaXMuc3RhdGVbfn4odGhpcy5jb3VudCAvIDQpXSBePSBiaXRzIDw8ICg4ICogKHRoaXMuY291bnQgJSA0KSlcbiAgaWYgKChiaXRzICYgMHg4MCkgIT09IDAgJiYgdGhpcy5jb3VudCA9PT0gKHRoaXMuYmxvY2tTaXplIC0gMSkpIGtlY2Nha1N0YXRlLnAxNjAwKHRoaXMuc3RhdGUpXG4gIHRoaXMuc3RhdGVbfn4oKHRoaXMuYmxvY2tTaXplIC0gMSkgLyA0KV0gXj0gMHg4MCA8PCAoOCAqICgodGhpcy5ibG9ja1NpemUgLSAxKSAlIDQpKVxuICBrZWNjYWtTdGF0ZS5wMTYwMCh0aGlzLnN0YXRlKVxuICB0aGlzLmNvdW50ID0gMFxuICB0aGlzLnNxdWVlemluZyA9IHRydWVcbn1cblxuS2VjY2FrLnByb3RvdHlwZS5zcXVlZXplID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICBpZiAoIXRoaXMuc3F1ZWV6aW5nKSB0aGlzLmFic29yYkxhc3RGZXdCaXRzKDB4MDEpXG5cbiAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIG91dHB1dFtpXSA9ICh0aGlzLnN0YXRlW35+KHRoaXMuY291bnQgLyA0KV0gPj4+ICg4ICogKHRoaXMuY291bnQgJSA0KSkpICYgMHhmZlxuICAgIHRoaXMuY291bnQgKz0gMVxuICAgIGlmICh0aGlzLmNvdW50ID09PSB0aGlzLmJsb2NrU2l6ZSkge1xuICAgICAga2VjY2FrU3RhdGUucDE2MDAodGhpcy5zdGF0ZSlcbiAgICAgIHRoaXMuY291bnQgPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5LZWNjYWsucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoZGVzdCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDUwOyArK2kpIGRlc3Quc3RhdGVbaV0gPSB0aGlzLnN0YXRlW2ldXG4gIGRlc3QuYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemVcbiAgZGVzdC5jb3VudCA9IHRoaXMuY291bnRcbiAgZGVzdC5zcXVlZXppbmcgPSB0aGlzLnNxdWVlemluZ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEtlY2Nha1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuJ3VzZSBzdHJpY3QnO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xuXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5cbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgfVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gSWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47IC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFkYWJsZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgZGVidWc7XG5cbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0Jyk7XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7IC8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG5cblxudmFyIFN0cmluZ0RlY29kZXI7XG52YXIgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yO1xudmFyIGZyb207XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7IC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpOyAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG5cbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTsgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlOyAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlOyAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2VuZCcgKGFuZCBwb3RlbnRpYWxseSAnZmluaXNoJylcblxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95OyAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcblxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlOyAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOyAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7IC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcblxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuXG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7IC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFJlYWRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG5cbiAgdmFyIGlzRHVwbGV4ID0gdGhpcyBpbnN0YW5jZW9mIER1cGxleDtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5XG5cbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IC8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTsgLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgZGVidWcoJ3JlYWRhYmxlQWRkQ2h1bmsnLCBjaHVuayk7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcblxuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQoKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgbmV3IEVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YoKSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSAvLyBXZSBjYW4gcHVzaCBtb3JlIGRhdGEgaWYgd2UgYXJlIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLlxuICAvLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZSBtb3JlIGJ5dGVzLlxuICAvLyBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLCBzdWNoIGFzIHRoZSByZXBsLlxuXG5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG5cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG5cbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBFUlJfSU5WQUxJRF9BUkdfVFlQRSgnY2h1bmsnLCBbJ3N0cmluZycsICdCdWZmZXInLCAnVWludDhBcnJheSddLCBjaHVuayk7XG4gIH1cblxuICByZXR1cm4gZXI7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59OyAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHZhciBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gZGVjb2RlcjsgLy8gSWYgc2V0RW5jb2RpbmcobnVsbCksIGRlY29kZXIuZW5jb2RpbmcgZXF1YWxzIHV0ZjhcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nOyAvLyBJdGVyYXRlIG92ZXIgY3VycmVudCBidWZmZXIgdG8gY29udmVydCBhbHJlYWR5IHN0b3JlZCBCdWZmZXJzOlxuXG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICB3aGlsZSAocCAhPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgKz0gZGVjb2Rlci53cml0ZShwLmRhdGEpO1xuICAgIHAgPSBwLm5leHQ7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuXG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG5cblxudmFyIE1BWF9IV00gPSAweDQwMDAwMDAwO1xuXG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG5cbiAgcmV0dXJuIG47XG59IC8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG5cbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH0gLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG5cblxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjsgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcblxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59IC8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7IC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKChzdGF0ZS5oaWdoV2F0ZXJNYXJrICE9PSAwID8gc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgOiBzdGF0ZS5sZW5ndGggPiAwKSB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7IC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cblxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cblxuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfSAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG5cblxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlOyAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcblxuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTsgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1Zygnb25Fb2ZDaHVuaycpO1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcblxuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG5cbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAgIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH1cbiAgfVxufSAvLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuXG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGVfJywgc3RhdGUuZGVzdHJveWVkLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcblxuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9IC8vIFRoZSBzdHJlYW0gbmVlZHMgYW5vdGhlciByZWFkYWJsZSBldmVudCBpZlxuICAvLyAxLiBJdCBpcyBub3QgZmxvd2luZywgYXMgdGhlIGZsb3cgbWVjaGFuaXNtIHdpbGwgdGFrZVxuICAvLyAgICBjYXJlIG9mIGl0LlxuICAvLyAyLiBJdCBpcyBub3QgZW5kZWQuXG4gIC8vIDMuIEl0IGlzIGJlbG93IHRoZSBoaWdoV2F0ZXJNYXJrLCBzbyB3ZSBjYW4gc2NoZWR1bGVcbiAgLy8gICAgYW5vdGhlciByZWFkYWJsZSBsYXRlci5cblxuXG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9ICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgZmxvdyhzdHJlYW0pO1xufSAvLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cblxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIEF0dGVtcHQgdG8gcmVhZCBtb3JlIGRhdGEgaWYgd2Ugc2hvdWxkLlxuICAvL1xuICAvLyBUaGUgY29uZGl0aW9ucyBmb3IgcmVhZGluZyBtb3JlIGRhdGEgYXJlIChvbmUgb2YpOlxuICAvLyAtIE5vdCBlbm91Z2ggZGF0YSBidWZmZXJlZCAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykuIFRoZSBsb29wXG4gIC8vICAgaXMgcmVzcG9uc2libGUgZm9yIGZpbGxpbmcgdGhlIGJ1ZmZlciB3aXRoIGVub3VnaCBkYXRhIGlmIHN1Y2ggZGF0YVxuICAvLyAgIGlzIGF2YWlsYWJsZS4gSWYgaGlnaFdhdGVyTWFyayBpcyAwIGFuZCB3ZSBhcmUgbm90IGluIHRoZSBmbG93aW5nIG1vZGVcbiAgLy8gICB3ZSBzaG91bGQgX25vdF8gYXR0ZW1wdCB0byBidWZmZXIgYW55IGV4dHJhIGRhdGEuIFdlJ2xsIGdldCBtb3JlIGRhdGFcbiAgLy8gICB3aGVuIHRoZSBzdHJlYW0gY29uc3VtZXIgY2FsbHMgcmVhZCgpIGluc3RlYWQuXG4gIC8vIC0gTm8gZGF0YSBpbiB0aGUgYnVmZmVyLCBhbmQgdGhlIHN0cmVhbSBpcyBpbiBmbG93aW5nIG1vZGUuIEluIHRoaXMgbW9kZVxuICAvLyAgIHRoZSBsb29wIGJlbG93IGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyByZWFkKCkgaXMgY2FsbGVkLiBGYWlsaW5nIHRvXG4gIC8vICAgY2FsbCByZWFkIGhlcmUgd291bGQgYWJvcnQgdGhlIGZsb3cgYW5kIHRoZXJlJ3Mgbm8gb3RoZXIgbWVjaGFuaXNtIGZvclxuICAvLyAgIGNvbnRpbnVpbmcgdGhlIGZsb3cgaWYgdGhlIHN0cmVhbSBjb25zdW1lciBoYXMganVzdCBzdWJzY3JpYmVkIHRvIHRoZVxuICAvLyAgICdkYXRhJyBldmVudC5cbiAgLy9cbiAgLy8gSW4gYWRkaXRpb24gdG8gdGhlIGFib3ZlIGNvbmRpdGlvbnMgdG8ga2VlcCByZWFkaW5nIGRhdGEsIHRoZSBmb2xsb3dpbmdcbiAgLy8gY29uZGl0aW9ucyBwcmV2ZW50IHRoZSBkYXRhIGZyb20gYmVpbmcgcmVhZDpcbiAgLy8gLSBUaGUgc3RyZWFtIGhhcyBlbmRlZCAoc3RhdGUuZW5kZWQpLlxuICAvLyAtIFRoZXJlIGlzIGFscmVhZHkgYSBwZW5kaW5nICdyZWFkJyBvcGVyYXRpb24gKHN0YXRlLnJlYWRpbmcpLiBUaGlzIGlzIGFcbiAgLy8gICBjYXNlIHdoZXJlIHRoZSB0aGUgc3RyZWFtIGhhcyBjYWxsZWQgdGhlIGltcGxlbWVudGF0aW9uIGRlZmluZWQgX3JlYWQoKVxuICAvLyAgIG1ldGhvZCwgYnV0IHRoZXkgYXJlIHByb2Nlc3NpbmcgdGhlIGNhbGwgYXN5bmNocm9ub3VzbHkgYW5kIGhhdmUgX25vdF9cbiAgLy8gICBjYWxsZWQgcHVzaCgpIHdpdGggbmV3IGRhdGEuIEluIHRoaXMgY2FzZSB3ZSBza2lwIHBlcmZvcm1pbmcgbW9yZVxuICAvLyAgIHJlYWQoKXMuIFRoZSBleGVjdXRpb24gZW5kcyBpbiB0aGlzIG1ldGhvZCBhZ2FpbiBhZnRlciB0aGUgX3JlYWQoKSBlbmRzXG4gIC8vICAgdXAgY2FsbGluZyBwdXNoKCkgd2l0aCBtb3JlIGRhdGEuXG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDApKSB7XG4gICAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59IC8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGVycm9yT3JEZXN0cm95KHRoaXMsIG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3JlYWQoKScpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzcy5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG5cbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcblxuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9IC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuXG5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpOyAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7IC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgZGVidWcoJ2Rlc3Qud3JpdGUnLCByZXQpO1xuXG4gICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICB9XG5cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfSAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuXG5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZXJyb3JPckRlc3Ryb3koZGVzdCwgZXIpO1xuICB9IC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cblxuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTsgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcblxuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9IC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG5cblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpOyAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHtcbiAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICB9OyAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzOyAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7IC8vIGdvdCBhIG1hdGNoLlxuXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywge1xuICAgICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cblxuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gdXBkYXRlIHJlYWRhYmxlTGlzdGVuaW5nIHNvIHRoYXQgcmVzdW1lKCkgbWF5IGJlIGEgbm8tb3BcbiAgICAvLyBhIGZldyBsaW5lcyBkb3duLiBUaGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJykuXG4gICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSB0aGlzLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwOyAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG5cbiAgICBpZiAoc3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGRlYnVnKCdvbiByZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUucmVhZGluZyk7XG5cbiAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfSBlbHNlIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2KSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nKHNlbGYpIHtcbiAgdmFyIHN0YXRlID0gc2VsZi5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzZWxmLmxpc3RlbmVyQ291bnQoJ3JlYWRhYmxlJykgPiAwO1xuXG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7IC8vIGNydWRlIHdheSB0byBjaGVjayBpZiB3ZSBzaG91bGQgcmVzdW1lXG4gIH0gZWxzZSBpZiAoc2VsZi5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwKSB7XG4gICAgc2VsZi5yZXN1bWUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59IC8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTsgLy8gd2UgZmxvdyBvbmx5IGlmIHRoZXJlIGlzIG5vIG9uZSBsaXN0ZW5pbmdcbiAgICAvLyBmb3IgcmVhZGFibGUsIGJ1dCB3ZSBzdGlsbCBoYXZlIHRvIGNhbGxcbiAgICAvLyByZXN1bWUoKVxuXG4gICAgc3RhdGUuZmxvd2luZyA9ICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZztcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG5cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdyZXN1bWUnLCBzdGF0ZS5yZWFkaW5nKTtcblxuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5wYXVzZWQgPSB0cnVlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcblxuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7XG4gICAgO1xuICB9XG59IC8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG5cbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gX3RoaXMucHVzaChjaHVuayk7XG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7IC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiBtZXRob2RXcmFwKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfSAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG5cblxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9IC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG5cblxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuXG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvcicpO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcyk7XG4gIH07XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pOyAvLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pOyAvLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmZpcnN0KCk7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBzdGF0ZS5idWZmZXIuY29uc3VtZShuLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlTlQnLCBzdGF0ZS5lbmRFbWl0dGVkLCBzdGF0ZS5sZW5ndGgpOyAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuXG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcblxuICAgICAgaWYgKCF3U3RhdGUgfHwgd1N0YXRlLmF1dG9EZXN0cm95ICYmIHdTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5mcm9tID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBvcHRzKSB7XG4gICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9mcm9tJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cblxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn0gLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cblxuXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgICBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICAgIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsgLy8gZHJhaW4gZXZlbnQgZmxhZy5cblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOyAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7IC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcblxuICB0aGlzLmVuZGVkID0gZmFsc2U7IC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cblxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcblxuICB0aGlzLmNvcmtlZCA9IDA7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7IC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcblxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9OyAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcblxuXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7IC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cblxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOyAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcblxuICB0aGlzLnBlbmRpbmdjYiA9IDA7IC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcblxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG5cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpOyAvLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cblxuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTsgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5LlxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn0gLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuXG5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKTsgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcblxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufSAvLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5cblxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIGVyO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuXG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7IC8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG5cbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59IC8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuXG5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn0gLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcblxuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG5cbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcblxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cblxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTsgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9IC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cblxuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuXG4gICAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuXG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9IC8vIHJldXNlIHRoZSBmcmVlIGNvcmtSZXEuXG5cblxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU87XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBmaW5pc2hlZCA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuXG52YXIga0xhc3RSZXNvbHZlID0gU3ltYm9sKCdsYXN0UmVzb2x2ZScpO1xudmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCdsYXN0UmVqZWN0Jyk7XG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xudmFyIGtFbmRlZCA9IFN5bWJvbCgnZW5kZWQnKTtcbnZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woJ2xhc3RQcm9taXNlJyk7XG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcbnZhciBrU3RyZWFtID0gU3ltYm9sKCdzdHJlYW0nKTtcblxuZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiBkb25lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGl0ZXIpIHtcbiAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG5cbiAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpOyAvLyB3ZSBkZWZlciBpZiBkYXRhIGlzIG51bGxcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxuICAgIC8vICdlcnJvcidcblxuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcbiAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgdGljaywgYmVjYXVzZSBpdCBtaWdodFxuICAvLyBlbWl0IGFuIGVycm9yIHdpdGggcHJvY2Vzcy5uZXh0VGlja1xuICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTtcbn1cblxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfTtcbn1cblxudmFyIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24gKCkge30pO1xudmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZigoX09iamVjdCRzZXRQcm90b3R5cGVPID0ge1xuICBnZXQgc3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzW2tTdHJlYW1dO1xuICB9LFxuXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIGlmIHdlIGhhdmUgZGV0ZWN0ZWQgYW4gZXJyb3IgaW4gdGhlIG1lYW53aGlsZVxuICAgIC8vIHJlamVjdCBzdHJhaWdodCBhd2F5XG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdmlhIG5leHRUaWNrIGJlY2F1c2UgaWYgLmRlc3Ryb3koZXJyKSBpc1xuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXG4gICAgICAvLyB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgbm8gZXJyb3IgbGluZ2VyaW5nIGFyb3VuZFxuICAgICAgLy8gd2FpdGluZyB0byBiZSBlbWl0dGVkLlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHtcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIGlmIHdlIGhhdmUgbXVsdGlwbGUgbmV4dCgpIGNhbGxzXG4gICAgLy8gd2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgUHJvbWlzZSB0byBmaW5pc2hcbiAgICAvLyB0aGlzIGxvZ2ljIGlzIG9wdGltaXplZCB0byBzdXBwb3J0IGZvciBhd2FpdCBsb29wcyxcbiAgICAvLyB3aGVyZSBuZXh0KCkgaXMgb25seSBjYWxsZWQgb25jZSBhdCBhIHRpbWVcblxuXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xuICAgIHZhciBwcm9taXNlO1xuXG4gICAgaWYgKGxhc3RQcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFzdCBwYXRoIG5lZWRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHRoaXMucHVzaCgpXG4gICAgICAvLyB3aXRob3V0IHRyaWdnZXJpbmcgdGhlIG5leHQoKSBxdWV1ZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzW2tIYW5kbGVQcm9taXNlXSk7XG4gICAgfVxuXG4gICAgdGhpc1trTGFzdFByb21pc2VdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgXCJyZXR1cm5cIiwgZnVuY3Rpb24gX3JldHVybigpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgLy8gZGVzdHJveShlcnIsIGNiKSBpcyBhIHByaXZhdGUgQVBJXG4gIC8vIHdlIGNhbiBndWFyYW50ZWUgd2UgaGF2ZSB0aGF0IGhlcmUsIGJlY2F1c2Ugd2UgY29udHJvbCB0aGVcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcbn0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcblxudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0pIHtcbiAgdmFyIF9PYmplY3QkY3JlYXRlO1xuXG4gIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgdmFsdWU6IHN0cmVhbSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfT2JqZWN0JGNyZWF0ZSkpO1xuICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTsgLy8gcmVqZWN0IGlmIHdlIGFyZSB3YWl0aW5nIGZvciBkYXRhIGluIHRoZSBQcm9taXNlXG4gICAgICAvLyByZXR1cm5lZCBieSBuZXh0KCkgYW5kIHN0b3JlIHRoZSBlcnJvclxuXG4gICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmUgPSBpdGVyYXRvcltrTGFzdFJlc29sdmVdO1xuXG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICByZXR1cm4gaXRlcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjsiLCIndXNlIHN0cmljdCc7IC8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcblxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIpIHtcbiAgICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9IC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcblxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGVtaXRDbG9zZU5UKHNlbGYpIHtcbiAgaWYgKHNlbGYuX3dyaXRhYmxlU3RhdGUgJiYgIXNlbGYuX3dyaXRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIGlmIChzZWxmLl9yZWFkYWJsZVN0YXRlICYmICFzZWxmLl9yZWFkYWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBzZWxmLmVtaXQoJ2Nsb3NlJyk7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxuZnVuY3Rpb24gZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpIHtcbiAgLy8gV2UgaGF2ZSB0ZXN0cyB0aGF0IHJlbHkgb24gZXJyb3JzIGJlaW5nIGVtaXR0ZWRcbiAgLy8gaW4gdGhlIHNhbWUgdGljaywgc28gY2hhbmdpbmcgdGhpcyBpcyBzZW12ZXIgbWFqb3IuXG4gIC8vIEZvciBub3cgd2hlbiB5b3Ugb3B0LWluIHRvIGF1dG9EZXN0cm95IHdlIGFsbG93XG4gIC8vIHRoZSBlcnJvciB0byBiZSBlbWl0dGVkIG5leHRUaWNrLiBJbiBhIGZ1dHVyZVxuICAvLyBzZW12ZXIgbWFqb3IgdXBkYXRlIHdlIHNob3VsZCBjaGFuZ2UgdGhlIGRlZmF1bHQgdG8gdGhpcy5cbiAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHJTdGF0ZSAmJiByU3RhdGUuYXV0b0Rlc3Ryb3kgfHwgd1N0YXRlICYmIHdTdGF0ZS5hdXRvRGVzdHJveSkgc3RyZWFtLmRlc3Ryb3koZXJyKTtlbHNlIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveSxcbiAgZXJyb3JPckRlc3Ryb3k6IGVycm9yT3JEZXN0cm95XG59OyIsIid1c2Ugc3RyaWN0J1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2hCYXNlID0gcmVxdWlyZSgnaGFzaC1iYXNlJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgQVJSQVkxNiA9IG5ldyBBcnJheSgxNilcblxuZnVuY3Rpb24gTUQ1ICgpIHtcbiAgSGFzaEJhc2UuY2FsbCh0aGlzLCA2NClcblxuICAvLyBzdGF0ZVxuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxufVxuXG5pbmhlcml0cyhNRDUsIEhhc2hCYXNlKVxuXG5NRDUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBNID0gQVJSQVkxNlxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIE1baV0gPSB0aGlzLl9ibG9jay5yZWFkSW50MzJMRShpICogNClcblxuICB2YXIgYSA9IHRoaXMuX2FcbiAgdmFyIGIgPSB0aGlzLl9iXG4gIHZhciBjID0gdGhpcy5fY1xuICB2YXIgZCA9IHRoaXMuX2RcblxuICBhID0gZm5GKGEsIGIsIGMsIGQsIE1bMF0sIDB4ZDc2YWE0NzgsIDcpXG4gIGQgPSBmbkYoZCwgYSwgYiwgYywgTVsxXSwgMHhlOGM3Yjc1NiwgMTIpXG4gIGMgPSBmbkYoYywgZCwgYSwgYiwgTVsyXSwgMHgyNDIwNzBkYiwgMTcpXG4gIGIgPSBmbkYoYiwgYywgZCwgYSwgTVszXSwgMHhjMWJkY2VlZSwgMjIpXG4gIGEgPSBmbkYoYSwgYiwgYywgZCwgTVs0XSwgMHhmNTdjMGZhZiwgNylcbiAgZCA9IGZuRihkLCBhLCBiLCBjLCBNWzVdLCAweDQ3ODdjNjJhLCAxMilcbiAgYyA9IGZuRihjLCBkLCBhLCBiLCBNWzZdLCAweGE4MzA0NjEzLCAxNylcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzddLCAweGZkNDY5NTAxLCAyMilcbiAgYSA9IGZuRihhLCBiLCBjLCBkLCBNWzhdLCAweDY5ODA5OGQ4LCA3KVxuICBkID0gZm5GKGQsIGEsIGIsIGMsIE1bOV0sIDB4OGI0NGY3YWYsIDEyKVxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bMTBdLCAweGZmZmY1YmIxLCAxNylcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzExXSwgMHg4OTVjZDdiZSwgMjIpXG4gIGEgPSBmbkYoYSwgYiwgYywgZCwgTVsxMl0sIDB4NmI5MDExMjIsIDcpXG4gIGQgPSBmbkYoZCwgYSwgYiwgYywgTVsxM10sIDB4ZmQ5ODcxOTMsIDEyKVxuICBjID0gZm5GKGMsIGQsIGEsIGIsIE1bMTRdLCAweGE2Nzk0MzhlLCAxNylcbiAgYiA9IGZuRihiLCBjLCBkLCBhLCBNWzE1XSwgMHg0OWI0MDgyMSwgMjIpXG5cbiAgYSA9IGZuRyhhLCBiLCBjLCBkLCBNWzFdLCAweGY2MWUyNTYyLCA1KVxuICBkID0gZm5HKGQsIGEsIGIsIGMsIE1bNl0sIDB4YzA0MGIzNDAsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVsxMV0sIDB4MjY1ZTVhNTEsIDE0KVxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bMF0sIDB4ZTliNmM3YWEsIDIwKVxuICBhID0gZm5HKGEsIGIsIGMsIGQsIE1bNV0sIDB4ZDYyZjEwNWQsIDUpXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVsxMF0sIDB4MDI0NDE0NTMsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVsxNV0sIDB4ZDhhMWU2ODEsIDE0KVxuICBiID0gZm5HKGIsIGMsIGQsIGEsIE1bNF0sIDB4ZTdkM2ZiYzgsIDIwKVxuICBhID0gZm5HKGEsIGIsIGMsIGQsIE1bOV0sIDB4MjFlMWNkZTYsIDUpXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVsxNF0sIDB4YzMzNzA3ZDYsIDkpXG4gIGMgPSBmbkcoYywgZCwgYSwgYiwgTVszXSwgMHhmNGQ1MGQ4NywgMTQpXG4gIGIgPSBmbkcoYiwgYywgZCwgYSwgTVs4XSwgMHg0NTVhMTRlZCwgMjApXG4gIGEgPSBmbkcoYSwgYiwgYywgZCwgTVsxM10sIDB4YTllM2U5MDUsIDUpXG4gIGQgPSBmbkcoZCwgYSwgYiwgYywgTVsyXSwgMHhmY2VmYTNmOCwgOSlcbiAgYyA9IGZuRyhjLCBkLCBhLCBiLCBNWzddLCAweDY3NmYwMmQ5LCAxNClcbiAgYiA9IGZuRyhiLCBjLCBkLCBhLCBNWzEyXSwgMHg4ZDJhNGM4YSwgMjApXG5cbiAgYSA9IGZuSChhLCBiLCBjLCBkLCBNWzVdLCAweGZmZmEzOTQyLCA0KVxuICBkID0gZm5IKGQsIGEsIGIsIGMsIE1bOF0sIDB4ODc3MWY2ODEsIDExKVxuICBjID0gZm5IKGMsIGQsIGEsIGIsIE1bMTFdLCAweDZkOWQ2MTIyLCAxNilcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzE0XSwgMHhmZGU1MzgwYywgMjMpXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVsxXSwgMHhhNGJlZWE0NCwgNClcbiAgZCA9IGZuSChkLCBhLCBiLCBjLCBNWzRdLCAweDRiZGVjZmE5LCAxMSlcbiAgYyA9IGZuSChjLCBkLCBhLCBiLCBNWzddLCAweGY2YmI0YjYwLCAxNilcbiAgYiA9IGZuSChiLCBjLCBkLCBhLCBNWzEwXSwgMHhiZWJmYmM3MCwgMjMpXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVsxM10sIDB4Mjg5YjdlYzYsIDQpXG4gIGQgPSBmbkgoZCwgYSwgYiwgYywgTVswXSwgMHhlYWExMjdmYSwgMTEpXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVszXSwgMHhkNGVmMzA4NSwgMTYpXG4gIGIgPSBmbkgoYiwgYywgZCwgYSwgTVs2XSwgMHgwNDg4MWQwNSwgMjMpXG4gIGEgPSBmbkgoYSwgYiwgYywgZCwgTVs5XSwgMHhkOWQ0ZDAzOSwgNClcbiAgZCA9IGZuSChkLCBhLCBiLCBjLCBNWzEyXSwgMHhlNmRiOTllNSwgMTEpXG4gIGMgPSBmbkgoYywgZCwgYSwgYiwgTVsxNV0sIDB4MWZhMjdjZjgsIDE2KVxuICBiID0gZm5IKGIsIGMsIGQsIGEsIE1bMl0sIDB4YzRhYzU2NjUsIDIzKVxuXG4gIGEgPSBmbkkoYSwgYiwgYywgZCwgTVswXSwgMHhmNDI5MjI0NCwgNilcbiAgZCA9IGZuSShkLCBhLCBiLCBjLCBNWzddLCAweDQzMmFmZjk3LCAxMClcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzE0XSwgMHhhYjk0MjNhNywgMTUpXG4gIGIgPSBmbkkoYiwgYywgZCwgYSwgTVs1XSwgMHhmYzkzYTAzOSwgMjEpXG4gIGEgPSBmbkkoYSwgYiwgYywgZCwgTVsxMl0sIDB4NjU1YjU5YzMsIDYpXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVszXSwgMHg4ZjBjY2M5MiwgMTApXG4gIGMgPSBmbkkoYywgZCwgYSwgYiwgTVsxMF0sIDB4ZmZlZmY0N2QsIDE1KVxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bMV0sIDB4ODU4NDVkZDEsIDIxKVxuICBhID0gZm5JKGEsIGIsIGMsIGQsIE1bOF0sIDB4NmZhODdlNGYsIDYpXG4gIGQgPSBmbkkoZCwgYSwgYiwgYywgTVsxNV0sIDB4ZmUyY2U2ZTAsIDEwKVxuICBjID0gZm5JKGMsIGQsIGEsIGIsIE1bNl0sIDB4YTMwMTQzMTQsIDE1KVxuICBiID0gZm5JKGIsIGMsIGQsIGEsIE1bMTNdLCAweDRlMDgxMWExLCAyMSlcbiAgYSA9IGZuSShhLCBiLCBjLCBkLCBNWzRdLCAweGY3NTM3ZTgyLCA2KVxuICBkID0gZm5JKGQsIGEsIGIsIGMsIE1bMTFdLCAweGJkM2FmMjM1LCAxMClcbiAgYyA9IGZuSShjLCBkLCBhLCBiLCBNWzJdLCAweDJhZDdkMmJiLCAxNSlcbiAgYiA9IGZuSShiLCBjLCBkLCBhLCBNWzldLCAweGViODZkMzkxLCAyMSlcblxuICB0aGlzLl9hID0gKHRoaXMuX2EgKyBhKSB8IDBcbiAgdGhpcy5fYiA9ICh0aGlzLl9iICsgYikgfCAwXG4gIHRoaXMuX2MgPSAodGhpcy5fYyArIGMpIHwgMFxuICB0aGlzLl9kID0gKHRoaXMuX2QgKyBkKSB8IDBcbn1cblxuTUQ1LnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBjcmVhdGUgcGFkZGluZyBhbmQgaGFuZGxlIGJsb2Nrc1xuICB0aGlzLl9ibG9ja1t0aGlzLl9ibG9ja09mZnNldCsrXSA9IDB4ODBcbiAgaWYgKHRoaXMuX2Jsb2NrT2Zmc2V0ID4gNTYpIHtcbiAgICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2Jsb2NrT2Zmc2V0LCA2NClcbiAgICB0aGlzLl91cGRhdGUoKVxuICAgIHRoaXMuX2Jsb2NrT2Zmc2V0ID0gMFxuICB9XG5cbiAgdGhpcy5fYmxvY2suZmlsbCgwLCB0aGlzLl9ibG9ja09mZnNldCwgNTYpXG4gIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyTEUodGhpcy5fbGVuZ3RoWzBdLCA1NilcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMV0sIDYwKVxuICB0aGlzLl91cGRhdGUoKVxuXG4gIC8vIHByb2R1Y2UgcmVzdWx0XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMTYpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYSwgMClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9iLCA0KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2MsIDgpXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fZCwgMTIpXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gcm90bCAoeCwgbikge1xuICByZXR1cm4gKHggPDwgbikgfCAoeCA+Pj4gKDMyIC0gbikpXG59XG5cbmZ1bmN0aW9uIGZuRiAoYSwgYiwgYywgZCwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgJiBjKSB8ICgofmIpICYgZCkpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxuZnVuY3Rpb24gZm5HIChhLCBiLCBjLCBkLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYiAmIGQpIHwgKGMgJiAofmQpKSkgKyBtICsgaykgfCAwLCBzKSArIGIpIHwgMFxufVxuXG5mdW5jdGlvbiBmbkggKGEsIGIsIGMsIGQsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKGIgXiBjIF4gZCkgKyBtICsgaykgfCAwLCBzKSArIGIpIHwgMFxufVxuXG5mdW5jdGlvbiBmbkkgKGEsIGIsIGMsIGQsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChjIF4gKGIgfCAofmQpKSkpICsgbSArIGspIHwgMCwgcykgKyBiKSB8IDBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNRDVcbiIsIm1vZHVsZS5leHBvcnRzID0gYXNzZXJ0O1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcbiAgaWYgKCF2YWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xufVxuXG5hc3NlcnQuZXF1YWwgPSBmdW5jdGlvbiBhc3NlcnRFcXVhbChsLCByLCBtc2cpIHtcbiAgaWYgKGwgIT0gcilcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIGwgKyAnICE9ICcgKyByKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBleHBvcnRzO1xuXG5mdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuICBpZiAoIW1zZylcbiAgICByZXR1cm4gW107XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBtc2cgIT09ICdzdHJpbmcnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgIG1zZyA9ICcwJyArIG1zZztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaGkgPSBjID4+IDg7XG4gICAgICB2YXIgbG8gPSBjICYgMHhmZjtcbiAgICAgIGlmIChoaSlcbiAgICAgICAgcmVzLnB1c2goaGksIGxvKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVzLnB1c2gobG8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9BcnJheSA9IHRvQXJyYXk7XG5cbmZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG51dGlscy56ZXJvMiA9IHplcm8yO1xuXG5mdW5jdGlvbiB0b0hleChtc2cpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0hleCA9IHRvSGV4O1xuXG51dGlscy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYXJyLCBlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRvSGV4KGFycik7XG4gIGVsc2VcbiAgICByZXR1cm4gYXJyO1xufTtcbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBsaW1pdCBvZiBDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKClcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcnlwdG8vZ2V0UmFuZG9tVmFsdWVzXG52YXIgTUFYX0JZVEVTID0gNjU1MzZcblxuLy8gTm9kZSBzdXBwb3J0cyByZXF1ZXN0aW5nIHVwIHRvIHRoaXMgbnVtYmVyIG9mIGJ5dGVzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9tYXN0ZXIvbGliL2ludGVybmFsL2NyeXB0by9yYW5kb20uanMjTDQ4XG52YXIgTUFYX1VJTlQzMiA9IDQyOTQ5NjcyOTVcblxuZnVuY3Rpb24gb2xkQnJvd3NlciAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignU2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgYnJvd3Nlci5cXG5Vc2UgQ2hyb21lLCBGaXJlZm94IG9yIEludGVybmV0IEV4cGxvcmVyIDExJylcbn1cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgY3J5cHRvID0gZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG9cblxuaWYgKGNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmFuZG9tQnl0ZXNcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gb2xkQnJvd3NlclxufVxuXG5mdW5jdGlvbiByYW5kb21CeXRlcyAoc2l6ZSwgY2IpIHtcbiAgLy8gcGhhbnRvbWpzIG5lZWRzIHRvIHRocm93XG4gIGlmIChzaXplID4gTUFYX1VJTlQzMikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JlcXVlc3RlZCB0b28gbWFueSByYW5kb20gYnl0ZXMnKVxuXG4gIHZhciBieXRlcyA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShzaXplKVxuXG4gIGlmIChzaXplID4gMCkgeyAgLy8gZ2V0UmFuZG9tVmFsdWVzIGZhaWxzIG9uIElFIGlmIHNpemUgPT0gMFxuICAgIGlmIChzaXplID4gTUFYX0JZVEVTKSB7IC8vIHRoaXMgaXMgdGhlIG1heCBieXRlcyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXG4gICAgICAvLyBjYW4gZG8gYXQgb25jZSBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL3dpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXG4gICAgICBmb3IgKHZhciBnZW5lcmF0ZWQgPSAwOyBnZW5lcmF0ZWQgPCBzaXplOyBnZW5lcmF0ZWQgKz0gTUFYX0JZVEVTKSB7XG4gICAgICAgIC8vIGJ1ZmZlci5zbGljZSBhdXRvbWF0aWNhbGx5IGNoZWNrcyBpZiB0aGUgZW5kIGlzIHBhc3QgdGhlIGVuZCBvZlxuICAgICAgICAvLyB0aGUgYnVmZmVyIHNvIHdlIGRvbid0IGhhdmUgdG8gaGVyZVxuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzLnNsaWNlKGdlbmVyYXRlZCwgZ2VuZXJhdGVkICsgTUFYX0JZVEVTKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcylcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgY2IobnVsbCwgYnl0ZXMpXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaEJhc2UgPSByZXF1aXJlKCdoYXNoLWJhc2UnKVxuXG52YXIgQVJSQVkxNiA9IG5ldyBBcnJheSgxNilcblxudmFyIHpsID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuICAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyLFxuICAxLCA5LCAxMSwgMTAsIDAsIDgsIDEyLCA0LCAxMywgMywgNywgMTUsIDE0LCA1LCA2LCAyLFxuICA0LCAwLCA1LCA5LCA3LCAxMiwgMiwgMTAsIDE0LCAxLCAzLCA4LCAxMSwgNiwgMTUsIDEzXG5dXG5cbnZhciB6ciA9IFtcbiAgNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMixcbiAgNiwgMTEsIDMsIDcsIDAsIDEzLCA1LCAxMCwgMTQsIDE1LCA4LCAxMiwgNCwgOSwgMSwgMixcbiAgMTUsIDUsIDEsIDMsIDcsIDE0LCA2LCA5LCAxMSwgOCwgMTIsIDIsIDEwLCAwLCA0LCAxMyxcbiAgOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNCxcbiAgMTIsIDE1LCAxMCwgNCwgMSwgNSwgOCwgNywgNiwgMiwgMTMsIDE0LCAwLCAzLCA5LCAxMVxuXVxuXG52YXIgc2wgPSBbXG4gIDExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOCxcbiAgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLFxuICAxMSwgMTMsIDYsIDcsIDE0LCA5LCAxMywgMTUsIDE0LCA4LCAxMywgNiwgNSwgMTIsIDcsIDUsXG4gIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMixcbiAgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XG5dXG5cbnZhciBzciA9IFtcbiAgOCwgOSwgOSwgMTEsIDEzLCAxNSwgMTUsIDUsIDcsIDcsIDgsIDExLCAxNCwgMTQsIDEyLCA2LFxuICA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsXG4gIDksIDcsIDE1LCAxMSwgOCwgNiwgNiwgMTQsIDEyLCAxMywgNSwgMTQsIDEzLCAxMywgNywgNSxcbiAgMTUsIDUsIDgsIDExLCAxNCwgMTQsIDYsIDE0LCA2LCA5LCAxMiwgOSwgMTIsIDUsIDE1LCA4LFxuICA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcbl1cblxudmFyIGhsID0gWzB4MDAwMDAwMDAsIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4YTk1M2ZkNGVdXG52YXIgaHIgPSBbMHg1MGEyOGJlNiwgMHg1YzRkZDEyNCwgMHg2ZDcwM2VmMywgMHg3YTZkNzZlOSwgMHgwMDAwMDAwMF1cblxuZnVuY3Rpb24gUklQRU1EMTYwICgpIHtcbiAgSGFzaEJhc2UuY2FsbCh0aGlzLCA2NClcblxuICAvLyBzdGF0ZVxuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxufVxuXG5pbmhlcml0cyhSSVBFTUQxNjAsIEhhc2hCYXNlKVxuXG5SSVBFTUQxNjAucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB3b3JkcyA9IEFSUkFZMTZcbiAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB3b3Jkc1tqXSA9IHRoaXMuX2Jsb2NrLnJlYWRJbnQzMkxFKGogKiA0KVxuXG4gIHZhciBhbCA9IHRoaXMuX2EgfCAwXG4gIHZhciBibCA9IHRoaXMuX2IgfCAwXG4gIHZhciBjbCA9IHRoaXMuX2MgfCAwXG4gIHZhciBkbCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlbCA9IHRoaXMuX2UgfCAwXG5cbiAgdmFyIGFyID0gdGhpcy5fYSB8IDBcbiAgdmFyIGJyID0gdGhpcy5fYiB8IDBcbiAgdmFyIGNyID0gdGhpcy5fYyB8IDBcbiAgdmFyIGRyID0gdGhpcy5fZCB8IDBcbiAgdmFyIGVyID0gdGhpcy5fZSB8IDBcblxuICAvLyBjb21wdXRhdGlvblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcbiAgICB2YXIgdGxcbiAgICB2YXIgdHJcbiAgICBpZiAoaSA8IDE2KSB7XG4gICAgICB0bCA9IGZuMShhbCwgYmwsIGNsLCBkbCwgZWwsIHdvcmRzW3psW2ldXSwgaGxbMF0sIHNsW2ldKVxuICAgICAgdHIgPSBmbjUoYXIsIGJyLCBjciwgZHIsIGVyLCB3b3Jkc1t6cltpXV0sIGhyWzBdLCBzcltpXSlcbiAgICB9IGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgdGwgPSBmbjIoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzFdLCBzbFtpXSlcbiAgICAgIHRyID0gZm40KGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBoclsxXSwgc3JbaV0pXG4gICAgfSBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgIHRsID0gZm4zKGFsLCBibCwgY2wsIGRsLCBlbCwgd29yZHNbemxbaV1dLCBobFsyXSwgc2xbaV0pXG4gICAgICB0ciA9IGZuMyhhciwgYnIsIGNyLCBkciwgZXIsIHdvcmRzW3pyW2ldXSwgaHJbMl0sIHNyW2ldKVxuICAgIH0gZWxzZSBpZiAoaSA8IDY0KSB7XG4gICAgICB0bCA9IGZuNChhbCwgYmwsIGNsLCBkbCwgZWwsIHdvcmRzW3psW2ldXSwgaGxbM10sIHNsW2ldKVxuICAgICAgdHIgPSBmbjIoYXIsIGJyLCBjciwgZHIsIGVyLCB3b3Jkc1t6cltpXV0sIGhyWzNdLCBzcltpXSlcbiAgICB9IGVsc2UgeyAvLyBpZiAoaTw4MCkge1xuICAgICAgdGwgPSBmbjUoYWwsIGJsLCBjbCwgZGwsIGVsLCB3b3Jkc1t6bFtpXV0sIGhsWzRdLCBzbFtpXSlcbiAgICAgIHRyID0gZm4xKGFyLCBiciwgY3IsIGRyLCBlciwgd29yZHNbenJbaV1dLCBocls0XSwgc3JbaV0pXG4gICAgfVxuXG4gICAgYWwgPSBlbFxuICAgIGVsID0gZGxcbiAgICBkbCA9IHJvdGwoY2wsIDEwKVxuICAgIGNsID0gYmxcbiAgICBibCA9IHRsXG5cbiAgICBhciA9IGVyXG4gICAgZXIgPSBkclxuICAgIGRyID0gcm90bChjciwgMTApXG4gICAgY3IgPSBiclxuICAgIGJyID0gdHJcbiAgfVxuXG4gIC8vIHVwZGF0ZSBzdGF0ZVxuICB2YXIgdCA9ICh0aGlzLl9iICsgY2wgKyBkcikgfCAwXG4gIHRoaXMuX2IgPSAodGhpcy5fYyArIGRsICsgZXIpIHwgMFxuICB0aGlzLl9jID0gKHRoaXMuX2QgKyBlbCArIGFyKSB8IDBcbiAgdGhpcy5fZCA9ICh0aGlzLl9lICsgYWwgKyBicikgfCAwXG4gIHRoaXMuX2UgPSAodGhpcy5fYSArIGJsICsgY3IpIHwgMFxuICB0aGlzLl9hID0gdFxufVxuXG5SSVBFTUQxNjAucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGNyZWF0ZSBwYWRkaW5nIGFuZCBoYW5kbGUgYmxvY2tzXG4gIHRoaXMuX2Jsb2NrW3RoaXMuX2Jsb2NrT2Zmc2V0KytdID0gMHg4MFxuICBpZiAodGhpcy5fYmxvY2tPZmZzZXQgPiA1Nikge1xuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMCwgdGhpcy5fYmxvY2tPZmZzZXQsIDY0KVxuICAgIHRoaXMuX3VwZGF0ZSgpXG4gICAgdGhpcy5fYmxvY2tPZmZzZXQgPSAwXG4gIH1cblxuICB0aGlzLl9ibG9jay5maWxsKDAsIHRoaXMuX2Jsb2NrT2Zmc2V0LCA1NilcbiAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJMRSh0aGlzLl9sZW5ndGhbMF0sIDU2KVxuICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkxFKHRoaXMuX2xlbmd0aFsxXSwgNjApXG4gIHRoaXMuX3VwZGF0ZSgpXG5cbiAgLy8gcHJvZHVjZSByZXN1bHRcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyA/IEJ1ZmZlci5hbGxvYygyMCkgOiBuZXcgQnVmZmVyKDIwKVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2EsIDApXG4gIGJ1ZmZlci53cml0ZUludDMyTEUodGhpcy5fYiwgNClcbiAgYnVmZmVyLndyaXRlSW50MzJMRSh0aGlzLl9jLCA4KVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2QsIDEyKVxuICBidWZmZXIud3JpdGVJbnQzMkxFKHRoaXMuX2UsIDE2KVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIHJvdGwgKHgsIG4pIHtcbiAgcmV0dXJuICh4IDw8IG4pIHwgKHggPj4+ICgzMiAtIG4pKVxufVxuXG5mdW5jdGlvbiBmbjEgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKGIgXiBjIF4gZCkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5mdW5jdGlvbiBmbjIgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKChiICYgYykgfCAoKH5iKSAmIGQpKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbmZ1bmN0aW9uIGZuMyAoYSwgYiwgYywgZCwgZSwgbSwgaywgcykge1xuICByZXR1cm4gKHJvdGwoKGEgKyAoKGIgfCAofmMpKSBeIGQpICsgbSArIGspIHwgMCwgcykgKyBlKSB8IDBcbn1cblxuZnVuY3Rpb24gZm40IChhLCBiLCBjLCBkLCBlLCBtLCBrLCBzKSB7XG4gIHJldHVybiAocm90bCgoYSArICgoYiAmIGQpIHwgKGMgJiAofmQpKSkgKyBtICsgaykgfCAwLCBzKSArIGUpIHwgMFxufVxuXG5mdW5jdGlvbiBmbjUgKGEsIGIsIGMsIGQsIGUsIG0sIGssIHMpIHtcbiAgcmV0dXJuIChyb3RsKChhICsgKGIgXiAoYyB8ICh+ZCkpKSArIG0gKyBrKSB8IDAsIHMpICsgZSkgfCAwXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUklQRU1EMTYwXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0TGVuZ3RoID0gZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcbnZhciBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG4vKipcbiAqIFJMUCBFbmNvZGluZyBiYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS8lNUJFbmdsaXNoJTVELVJMUFxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBpbiBhIGRhdGEsIGNvbnZlcnQgaXQgdG8gYnVmZmVyIGlmIG5vdCwgYW5kIGEgbGVuZ3RoIGZvciByZWN1cnNpb25cbiAqIEBwYXJhbSBpbnB1dCAtIHdpbGwgYmUgY29udmVydGVkIHRvIGJ1ZmZlclxuICogQHJldHVybnMgcmV0dXJucyBidWZmZXIgb2YgZW5jb2RlZCBkYXRhXG4gKiovXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChlbmNvZGUoaW5wdXRbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChvdXRwdXQpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZW5jb2RlTGVuZ3RoKGJ1Zi5sZW5ndGgsIDE5MiksIGJ1Zl0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGlucHV0QnVmID0gdG9CdWZmZXIoaW5wdXQpO1xuICAgICAgICByZXR1cm4gaW5wdXRCdWYubGVuZ3RoID09PSAxICYmIGlucHV0QnVmWzBdIDwgMTI4XG4gICAgICAgICAgICA/IGlucHV0QnVmXG4gICAgICAgICAgICA6IEJ1ZmZlci5jb25jYXQoW2VuY29kZUxlbmd0aChpbnB1dEJ1Zi5sZW5ndGgsIDEyOCksIGlucHV0QnVmXSk7XG4gICAgfVxufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFBhcnNlIGludGVnZXJzLiBDaGVjayBpZiB0aGVyZSBpcyBubyBsZWFkaW5nIHplcm9zXG4gKiBAcGFyYW0gdiBUaGUgdmFsdWUgdG8gcGFyc2VcbiAqIEBwYXJhbSBiYXNlIFRoZSBiYXNlIHRvIHBhcnNlIHRoZSBpbnRlZ2VyIGludG9cbiAqL1xuZnVuY3Rpb24gc2FmZVBhcnNlSW50KHYsIGJhc2UpIHtcbiAgICBpZiAodlswXSA9PT0gJzAnICYmIHZbMV0gPT09ICcwJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBleHRyYSB6ZXJvcycpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQodiwgYmFzZSk7XG59XG5mdW5jdGlvbiBlbmNvZGVMZW5ndGgobGVuLCBvZmZzZXQpIHtcbiAgICBpZiAobGVuIDwgNTYpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtsZW4gKyBvZmZzZXRdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBoZXhMZW5ndGggPSBpbnRUb0hleChsZW4pO1xuICAgICAgICB2YXIgbExlbmd0aCA9IGhleExlbmd0aC5sZW5ndGggLyAyO1xuICAgICAgICB2YXIgZmlyc3RCeXRlID0gaW50VG9IZXgob2Zmc2V0ICsgNTUgKyBsTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGZpcnN0Qnl0ZSArIGhleExlbmd0aCwgJ2hleCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCwgc3RyZWFtKSB7XG4gICAgaWYgKHN0cmVhbSA9PT0gdm9pZCAwKSB7IHN0cmVhbSA9IGZhbHNlOyB9XG4gICAgaWYgKCFpbnB1dCB8fCBpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtdKTtcbiAgICB9XG4gICAgdmFyIGlucHV0QnVmZmVyID0gdG9CdWZmZXIoaW5wdXQpO1xuICAgIHZhciBkZWNvZGVkID0gX2RlY29kZShpbnB1dEJ1ZmZlcik7XG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICB9XG4gICAgaWYgKGRlY29kZWQucmVtYWluZGVyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmVtYWluZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkLmRhdGE7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIFJMUCBpbnB1dFxuICogQHBhcmFtIGlucHV0XG4gKiBAcmV0dXJucyBUaGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBvciBhbiBlbXB0eSBCdWZmZXIgaWYgbm8gaW5wdXRcbiAqL1xuZnVuY3Rpb24gZ2V0TGVuZ3RoKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCB8fCBpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFtdKTtcbiAgICB9XG4gICAgdmFyIGlucHV0QnVmZmVyID0gdG9CdWZmZXIoaW5wdXQpO1xuICAgIHZhciBmaXJzdEJ5dGUgPSBpbnB1dEJ1ZmZlclswXTtcbiAgICBpZiAoZmlyc3RCeXRlIDw9IDB4N2YpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0QnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YjcpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Qnl0ZSAtIDB4N2Y7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGJmKSB7XG4gICAgICAgIHJldHVybiBmaXJzdEJ5dGUgLSAweGI2O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhmNykge1xuICAgICAgICAvLyBhIGxpc3QgYmV0d2VlbiAgMC01NSBieXRlcyBsb25nXG4gICAgICAgIHJldHVybiBmaXJzdEJ5dGUgLSAweGJmO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gYSBsaXN0ICBvdmVyIDU1IGJ5dGVzIGxvbmdcbiAgICAgICAgdmFyIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGY2O1xuICAgICAgICB2YXIgbGVuZ3RoXzEgPSBzYWZlUGFyc2VJbnQoaW5wdXRCdWZmZXIuc2xpY2UoMSwgbGxlbmd0aCkudG9TdHJpbmcoJ2hleCcpLCAxNik7XG4gICAgICAgIHJldHVybiBsbGVuZ3RoICsgbGVuZ3RoXzE7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRMZW5ndGggPSBnZXRMZW5ndGg7XG4vKiogRGVjb2RlIGFuIGlucHV0IHdpdGggUkxQICovXG5mdW5jdGlvbiBfZGVjb2RlKGlucHV0KSB7XG4gICAgdmFyIGxlbmd0aCwgbGxlbmd0aCwgZGF0YSwgaW5uZXJSZW1haW5kZXIsIGQ7XG4gICAgdmFyIGRlY29kZWQgPSBbXTtcbiAgICB2YXIgZmlyc3RCeXRlID0gaW5wdXRbMF07XG4gICAgaWYgKGZpcnN0Qnl0ZSA8PSAweDdmKSB7XG4gICAgICAgIC8vIGEgc2luZ2xlIGJ5dGUgd2hvc2UgdmFsdWUgaXMgaW4gdGhlIFsweDAwLCAweDdmXSByYW5nZSwgdGhhdCBieXRlIGlzIGl0cyBvd24gUkxQIGVuY29kaW5nLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogaW5wdXQuc2xpY2UoMCwgMSksXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKDEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiNykge1xuICAgICAgICAvLyBzdHJpbmcgaXMgMC01NSBieXRlcyBsb25nLiBBIHNpbmdsZSBieXRlIHdpdGggdmFsdWUgMHg4MCBwbHVzIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyBmb2xsb3dlZCBieSB0aGUgc3RyaW5nXG4gICAgICAgIC8vIFRoZSByYW5nZSBvZiB0aGUgZmlyc3QgYnl0ZSBpcyBbMHg4MCwgMHhiN11cbiAgICAgICAgbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHg3ZjtcbiAgICAgICAgLy8gc2V0IDB4ODAgbnVsbCB0byAwXG4gICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDB4ODApIHtcbiAgICAgICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gaW5wdXQuc2xpY2UoMSwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID09PSAyICYmIGRhdGFbMF0gPCAweDgwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmxwIGVuY29kaW5nOiBieXRlIG11c3QgYmUgbGVzcyAweDgwJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGJmKSB7XG4gICAgICAgIC8vIHN0cmluZyBpcyBncmVhdGVyIHRoYW4gNTUgYnl0ZXMgbG9uZy4gQSBzaW5nbGUgYnl0ZSB3aXRoIHRoZSB2YWx1ZSAoMHhiNyBwbHVzIHRoZSBsZW5ndGggb2YgdGhlIGxlbmd0aCksXG4gICAgICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSBsZW5ndGgsIGZvbGxvd2VkIGJ5IHRoZSBzdHJpbmdcbiAgICAgICAgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4YjY7XG4gICAgICAgIGlmIChpbnB1dC5sZW5ndGggLSAxIDwgbGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogbm90IGVub3VnaCBieXRlcyBmb3Igc3RyaW5nIGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IHNhZmVQYXJzZUludChpbnB1dC5zbGljZSgxLCBsbGVuZ3RoKS50b1N0cmluZygnaGV4JyksIDE2KTtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZXhwZWN0ZWQgc3RyaW5nIGxlbmd0aCB0byBiZSBncmVhdGVyIHRoYW4gNTUnKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gaW5wdXQuc2xpY2UobGxlbmd0aCwgbGVuZ3RoICsgbGxlbmd0aCk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogbm90IGVub3VnaCBieXRlcyBmb3Igc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCArIGxsZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhmNykge1xuICAgICAgICAvLyBhIGxpc3QgYmV0d2VlbiAgMC01NSBieXRlcyBsb25nXG4gICAgICAgIGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4YmY7XG4gICAgICAgIGlubmVyUmVtYWluZGVyID0gaW5wdXQuc2xpY2UoMSwgbGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGlubmVyUmVtYWluZGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgZCA9IF9kZWNvZGUoaW5uZXJSZW1haW5kZXIpO1xuICAgICAgICAgICAgZGVjb2RlZC5wdXNoKGQuZGF0YSk7XG4gICAgICAgICAgICBpbm5lclJlbWFpbmRlciA9IGQucmVtYWluZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkZWNvZGVkLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gYSBsaXN0ICBvdmVyIDU1IGJ5dGVzIGxvbmdcbiAgICAgICAgbGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4ZjY7XG4gICAgICAgIGxlbmd0aCA9IHNhZmVQYXJzZUludChpbnB1dC5zbGljZSgxLCBsbGVuZ3RoKS50b1N0cmluZygnaGV4JyksIDE2KTtcbiAgICAgICAgdmFyIHRvdGFsTGVuZ3RoID0gbGxlbmd0aCArIGxlbmd0aDtcbiAgICAgICAgaWYgKHRvdGFsTGVuZ3RoID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmxwOiB0b3RhbCBsZW5ndGggaXMgbGFyZ2VyIHRoYW4gdGhlIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lclJlbWFpbmRlciA9IGlucHV0LnNsaWNlKGxsZW5ndGgsIHRvdGFsTGVuZ3RoKTtcbiAgICAgICAgaWYgKGlubmVyUmVtYWluZGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJscCwgTGlzdCBoYXMgYSBpbnZhbGlkIGxlbmd0aCcpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpbm5lclJlbWFpbmRlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGQgPSBfZGVjb2RlKGlubmVyUmVtYWluZGVyKTtcbiAgICAgICAgICAgIGRlY29kZWQucHVzaChkLmRhdGEpO1xuICAgICAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBkLnJlbWFpbmRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGVjb2RlZCxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UodG90YWxMZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKiBDaGVjayBpZiBhIHN0cmluZyBpcyBwcmVmaXhlZCBieSAweCAqL1xuZnVuY3Rpb24gaXNIZXhQcmVmaXhlZChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIDIpID09PSAnMHgnO1xufVxuLyoqIFJlbW92ZXMgMHggZnJvbSBhIGdpdmVuIFN0cmluZyAqL1xuZnVuY3Rpb24gc3RyaXBIZXhQcmVmaXgoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHI7XG59XG4vKiogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBpdHMgaGV4YWRlY2ltYWwgdmFsdWUgKi9cbmZ1bmN0aW9uIGludFRvSGV4KGludGVnZXIpIHtcbiAgICBpZiAoaW50ZWdlciA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXIgYXMgYXJndW1lbnQsIG11c3QgYmUgdW5zaWduZWQhJyk7XG4gICAgfVxuICAgIHZhciBoZXggPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAlIDIgPyBcIjBcIiArIGhleCA6IGhleDtcbn1cbi8qKiBQYWQgYSBzdHJpbmcgdG8gYmUgZXZlbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKGEpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggJSAyID8gXCIwXCIgKyBhIDogYTtcbn1cbi8qKiBUcmFuc2Zvcm0gYW4gaW50ZWdlciBpbnRvIGEgQnVmZmVyICovXG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihpbnRlZ2VyKSB7XG4gICAgdmFyIGhleCA9IGludFRvSGV4KGludGVnZXIpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShoZXgsICdoZXgnKTtcbn1cbi8qKiBUcmFuc2Zvcm0gYW55dGhpbmcgaW50byBhIEJ1ZmZlciAqL1xuZnVuY3Rpb24gdG9CdWZmZXIodikge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChpc0hleFByZWZpeGVkKHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeCh2KSksICdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHYgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludFRvQnVmZmVyKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm5fanNfMS5kZWZhdWx0LmlzQk4odikpIHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnRzIGEgQk4gdG8gYSBCdWZmZXJcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2LnRvQXJyYXkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxzXG4gIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcbiAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cbiAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICAvLyBCTlxuXG4gIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQk4gPSBCTjtcbiAgfVxuXG4gIEJOLkJOID0gQk47XG4gIEJOLndvcmRTaXplID0gMjY7XG5cbiAgdmFyIEJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5CdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBCdWZmZXIgPSB3aW5kb3cuQnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gIH1cblxuICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgfTtcblxuICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBiYXNlID0gMTY7XG4gICAgfVxuICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICBzdGFydCsrO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgbnVtYmVyLmxlbmd0aCkge1xuICAgICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQsIGVuZGlhbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG4gICAgICAgIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgICAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtudW1iZXIgJiAweDNmZmZmZmZdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFswXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgKyAxXSA8PCA4KSB8IChudW1iZXJbaSArIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUhleDRCaXRzIChzdHJpbmcsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG4gICAgLy8gJzAnIC0gJzknXG4gICAgaWYgKGMgPj0gNDggJiYgYyA8PSA1Nykge1xuICAgICAgcmV0dXJuIGMgLSA0ODtcbiAgICAvLyAnQScgLSAnRidcbiAgICB9IGVsc2UgaWYgKGMgPj0gNjUgJiYgYyA8PSA3MCkge1xuICAgICAgcmV0dXJuIGMgLSA1NTtcbiAgICAvLyAnYScgLSAnZidcbiAgICB9IGVsc2UgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMDIpIHtcbiAgICAgIHJldHVybiBjIC0gODc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ0ludmFsaWQgY2hhcmFjdGVyIGluICcgKyBzdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4Qnl0ZSAoc3RyaW5nLCBsb3dlckJvdW5kLCBpbmRleCkge1xuICAgIHZhciByID0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4KTtcbiAgICBpZiAoaW5kZXggLSAxID49IGxvd2VyQm91bmQpIHtcbiAgICAgIHIgfD0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4IC0gMSkgPDwgNDtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pIHtcbiAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICAvLyAyNC1iaXRzIGNodW5rc1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHZhciBqID0gMDtcblxuICAgIHZhciB3O1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyBpIC09IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyc2VMZW5ndGggPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICBmb3IgKGkgPSBwYXJzZUxlbmd0aCAlIDIgPT09IDAgPyBzdGFydCArIDEgOiBzdGFydDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ICYgMHgzZmZmZmZmO1xuICAgICAgICBpZiAob2ZmID49IDE4KSB7XG4gICAgICAgICAgb2ZmIC09IDE4O1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgPj4+IDI2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBiID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByICo9IG11bDtcblxuICAgICAgLy8gJ2EnXG4gICAgICBpZiAoYyA+PSA0OSkge1xuICAgICAgICBiID0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICBiID0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIgPSBjO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGMgPj0gMCAmJiBiIDwgbXVsLCAnSW52YWxpZCBjaGFyYWN0ZXInKTtcbiAgICAgIHIgKz0gYjtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UgKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcbiAgICAvLyBJbml0aWFsaXplIGFzIHplcm9cbiAgICB0aGlzLndvcmRzID0gWzBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcbiAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIH1cbiAgICBkZXN0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gbW92ZSAoZGVzdCwgc3JjKSB7XG4gICAgZGVzdC53b3JkcyA9IHNyYy53b3JkcztcbiAgICBkZXN0Lmxlbmd0aCA9IHNyYy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHNyYy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHNyYy5yZWQ7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX21vdmUgPSBmdW5jdGlvbiBfbW92ZSAoZGVzdCkge1xuICAgIG1vdmUoZGVzdCwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciByID0gbmV3IEJOKG51bGwpO1xuICAgIHRoaXMuY29weShyKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQgKHNpemUpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGxlYWRpbmcgYDBgIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5fc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCAoKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24gKCkge1xuICAgIC8vIC0wID0gMFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQ2hlY2sgU3ltYm9sLmZvciBiZWNhdXNlIG5vdCBldmVyeXdoZXJlIHdoZXJlIFN5bWJvbCBkZWZpbmVkXG4gIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TeW1ib2wjQnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBCTi5wcm90b3R5cGVbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBpbnNwZWN0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBpbnNwZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH1cblxuICAvKlxuXG4gIHZhciB6ZXJvcyA9IFtdO1xuICB2YXIgZ3JvdXBTaXplcyA9IFtdO1xuICB2YXIgZ3JvdXBCYXNlcyA9IFtdO1xuXG4gIHZhciBzID0gJyc7XG4gIHZhciBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBCTi53b3JkU2l6ZSkge1xuICAgIHplcm9zW2ldID0gcztcbiAgICBzICs9ICcwJztcbiAgfVxuICBncm91cFNpemVzWzBdID0gMDtcbiAgZ3JvdXBTaXplc1sxXSA9IDA7XG4gIGdyb3VwQmFzZXNbMF0gPSAwO1xuICBncm91cEJhc2VzWzFdID0gMDtcbiAgdmFyIGJhc2UgPSAyIC0gMTtcbiAgd2hpbGUgKCsrYmFzZSA8IDM2ICsgMSkge1xuICAgIHZhciBncm91cFNpemUgPSAwO1xuICAgIHZhciBncm91cEJhc2UgPSAxO1xuICAgIHdoaWxlIChncm91cEJhc2UgPCAoMSA8PCBCTi53b3JkU2l6ZSkgLyBiYXNlKSB7XG4gICAgICBncm91cEJhc2UgKj0gYmFzZTtcbiAgICAgIGdyb3VwU2l6ZSArPSAxO1xuICAgIH1cbiAgICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuICAgIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG4gIH1cblxuICAqL1xuXG4gIHZhciB6ZXJvcyA9IFtcbiAgICAnJyxcbiAgICAnMCcsXG4gICAgJzAwJyxcbiAgICAnMDAwJyxcbiAgICAnMDAwMCcsXG4gICAgJzAwMDAwJyxcbiAgICAnMDAwMDAwJyxcbiAgICAnMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgXTtcblxuICB2YXIgZ3JvdXBTaXplcyA9IFtcbiAgICAwLCAwLFxuICAgIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcbiAgICA4LCA3LCA3LCA3LCA3LCA2LCA2LFxuICAgIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1XG4gIF07XG5cbiAgdmFyIGdyb3VwQmFzZXMgPSBbXG4gICAgMCwgMCxcbiAgICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcbiAgICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuICAgIDE2Nzc3MjE2LCAyNDEzNzU2OSwgMzQwMTIyMjQsIDQ3MDQ1ODgxLCA2NDAwMDAwMCwgNDA4NDEwMSwgNTE1MzYzMixcbiAgICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcbiAgICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuICBdO1xuXG4gIEJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChiYXNlLCBwYWRkaW5nKSB7XG4gICAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gICAgcGFkZGluZyA9IHBhZGRpbmcgfCAwIHx8IDE7XG5cbiAgICB2YXIgb3V0O1xuICAgIGlmIChiYXNlID09PSAxNiB8fCBiYXNlID09PSAnaGV4Jykge1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgb2ZmID0gMDtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuICAgICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIGNhcnJ5ID0gKHcgPj4+ICgyNCAtIG9mZikpICYgMHhmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG4gICAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XG4gICAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcbiAgICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGMubmVnYXRpdmUgPSAwO1xuICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG4gICAgICAgIHZhciByID0gYy5tb2Rybihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNiwgMik7XG4gIH07XG5cbiAgaWYgKEJ1ZmZlcikge1xuICAgIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyLCBlbmRpYW4sIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIGFsbG9jYXRlIChBcnJheVR5cGUsIHNpemUpIHtcbiAgICBpZiAoQXJyYXlUeXBlLmFsbG9jVW5zYWZlKSB7XG4gICAgICByZXR1cm4gQXJyYXlUeXBlLmFsbG9jVW5zYWZlKHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5VHlwZShzaXplKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHRoaXMuX3N0cmlwKCk7XG5cbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aCgpO1xuICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG4gICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuICAgIGFzc2VydChyZXFMZW5ndGggPiAwLCAnUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwJyk7XG5cbiAgICB2YXIgcmVzID0gYWxsb2NhdGUoQXJyYXlUeXBlLCByZXFMZW5ndGgpO1xuICAgIHZhciBwb3N0Zml4ID0gZW5kaWFuID09PSAnbGUnID8gJ0xFJyA6ICdCRSc7XG4gICAgdGhpc1snX3RvQXJyYXlMaWtlJyArIHBvc3RmaXhdKHJlcywgYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3RvQXJyYXlMaWtlTEUgPSBmdW5jdGlvbiBfdG9BcnJheUxpa2VMRSAocmVzLCBieXRlTGVuZ3RoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHNoaWZ0ID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3b3JkID0gKHRoaXMud29yZHNbaV0gPDwgc2hpZnQpIHwgY2Fycnk7XG5cbiAgICAgIHJlc1twb3NpdGlvbisrXSA9IHdvcmQgJiAweGZmO1xuICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiA4KSAmIDB4ZmY7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDE2KSAmIDB4ZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGlmdCA9PT0gNikge1xuICAgICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gd29yZCA+Pj4gMjQ7XG4gICAgICAgIHNoaWZ0ICs9IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgcmVzW3Bvc2l0aW9uKytdID0gY2Fycnk7XG5cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl90b0FycmF5TGlrZUJFID0gZnVuY3Rpb24gX3RvQXJyYXlMaWtlQkUgKHJlcywgYnl0ZUxlbmd0aCkge1xuICAgIHZhciBwb3NpdGlvbiA9IHJlcy5sZW5ndGggLSAxO1xuICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgc2hpZnQgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdvcmQgPSAodGhpcy53b3Jkc1tpXSA8PCBzaGlmdCkgfCBjYXJyeTtcblxuICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gd29yZCAmIDB4ZmY7XG4gICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiA4KSAmIDB4ZmY7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiAxNikgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hpZnQgPT09IDYpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiAyNCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3b3JkID4+PiAyNDtcbiAgICAgICAgc2hpZnQgKz0gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gY2Fycnk7XG5cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbi0tXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSA+Pj4gd2JpdCkgJiAweDAxO1xuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG5cbiAgLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuICBCTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cyAoKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAwO1xuXG4gICAgdmFyIHIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGIgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtcbiAgICAgIHIgKz0gYjtcbiAgICAgIGlmIChiICE9PSAyNikgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gYnl0ZUxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvVHdvcyA9IGZ1bmN0aW9uIHRvVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzKCkuaW5vdG4od2lkdGgpLmlhZGRuKDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uIGZyb21Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLnRlc3RuKHdpZHRoIC0gMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiBpc05lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmluZWcoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcgKCkge1xuICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdW9yID0gZnVuY3Rpb24gaXVvciAobnVtKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldIHwgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZCAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1YW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuICAgIH1cblxuICAgIGlmICh0aGlzICE9PSBhKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXV4b3IobnVtKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5peG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbiB1eG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIE5vdCBgYHRoaXNgYCB3aXRoIGBgd2lkdGhgYCBiaXR3aWR0aFxuICBCTi5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbiBpbm90biAod2lkdGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyAmJiB3aWR0aCA+PSAwKTtcblxuICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG4gICAgdmFyIGJpdHNMZWZ0ID0gd2lkdGggJSAyNjtcblxuICAgIC8vIEV4dGVuZCB0aGUgYnVmZmVyIHdpdGggbGVhZGluZyB6ZXJvZXNcbiAgICB0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO1xuXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgYnl0ZXNOZWVkZWQtLTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY29tcGxldGUgd29yZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzTmVlZGVkOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIHJlc2lkdWVcbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAoMHgzZmZmZmZmID4+ICgyNiAtIGJpdHNMZWZ0KSk7XG4gICAgfVxuXG4gICAgLy8gQW5kIHJlbW92ZSBsZWFkaW5nIHplcm9lc1xuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChudW0pIHtcbiAgICB2YXIgcjtcblxuICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cbiAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSBudW0uc3ViKHRoaXMpO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcbiAgICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZChudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmVcbiAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuICAgIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gYSA+IGJcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoY21wID4gMCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgICBpZiAoY2FycnkgPT09IDAgJiYgaSA8IGEubGVuZ3RoICYmIGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICAgIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBzbWFsbE11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgdmFyIGxlbiA9IChzZWxmLmxlbmd0aCArIG51bS5sZW5ndGgpIHwgMDtcbiAgICBvdXQubGVuZ3RoID0gbGVuO1xuICAgIGxlbiA9IChsZW4gLSAxKSB8IDA7XG5cbiAgICAvLyBQZWVsIG9uZSBpdGVyYXRpb24gKGNvbXBpbGVyIGNhbid0IGRvIGl0LCBiZWNhdXNlIG9mIGNvZGUgY29tcGxleGl0eSlcbiAgICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuICAgIHZhciBiID0gbnVtLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICB2YXIgY2FycnkgPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgIG91dC53b3Jkc1swXSA9IGxvO1xuXG4gICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IChrIC0gaikgfCAwO1xuICAgICAgICBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICByID0gYSAqIGIgKyByd29yZDtcbiAgICAgICAgbmNhcnJ5ICs9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkIHwgMDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBqdW1ib011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIC8vIFRlbXBvcmFyeSBkaXNhYmxlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvaXNzdWVzLzIxMVxuICAgIC8vIHZhciBmZnRtID0gbmV3IEZGVE0oKTtcbiAgICAvLyByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcbiAgICByZXR1cm4gYmlnTXVsVG8oc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG4gIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGVtcGxveWluZyBGRlRcbiAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBNdWx0aXBsaWNhdGlvblxuICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG4gICAgdmFyIGlzTmVnTnVtID0gbnVtIDwgMDtcbiAgICBpZiAoaXNOZWdOdW0pIG51bSA9IC1udW07XG5cbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cblxuICAgIHJldHVybiBpc05lZ051bSA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcbiAgfTtcblxuICAvLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuICBCTi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChudW0pIHtcbiAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcbiAgICBpZiAody5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQk4oMSk7XG5cbiAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXG4gICAgdmFyIHJlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpIHtcbiAgICAgIGlmICh3W2ldICE9PSAwKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIHEgPSByZXMuc3FyKCk7IGkgPCB3Lmxlbmd0aDsgaSsrLCBxID0gcS5zcXIoKSkge1xuICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gcmVzLm11bChxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uIGl1c2hsbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcbiAgICB2YXIgY2FycnlNYXNrID0gKDB4M2ZmZmZmZiA+Pj4gKDI2IC0gcikpIDw8ICgyNiAtIHIpO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG4gICAgICAgIHZhciBjID0gKCh0aGlzLndvcmRzW2ldIHwgMCkgLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcbiAgICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMgIT09IDApIHtcbiAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuIChiaXRzKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuICAvLyBOT1RFOiBgaGludGAgaXMgYSBsb3dlc3QgYml0IGJlZm9yZSB0cmFpbGluZyB6ZXJvZXNcbiAgLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuICBCTi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgaDtcbiAgICBpZiAoaGludCkge1xuICAgICAgaCA9IChoaW50IC0gKGhpbnQgJSAyNikpIC8gMjY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cbiAgICBoIC09IHM7XG4gICAgaCA9IE1hdGgubWF4KDAsIGgpO1xuXG4gICAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuICAgIGlmIChtYXNrZWRXb3Jkcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuICAgICAgbWFza2VkV29yZHMubGVuZ3RoID0gcztcbiAgICB9XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgLy8gTm8tb3AsIHdlIHNob3VsZCBub3QgbW92ZSBhbnl0aGluZyBhdCBhbGxcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuICAgICAgdGhpcy5sZW5ndGggLT0gcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG4gICAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuICAgIH1cblxuICAgIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuICAgIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMCkge1xuICAgICAgbWFza2VkV29yZHMud29yZHNbbWFza2VkV29yZHMubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG4gIH07XG5cbiAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gICAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2VcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPD0gbnVtKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSAodGhpcy53b3Jkc1swXSB8IDApO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pc3VibihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aG91dCBjaGVja3NcbiAgICByZXR1cm4gdGhpcy5faWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24gX2lhZGRuIChudW0pIHtcbiAgICB0aGlzLndvcmRzWzBdICs9IG51bTtcblxuICAgIC8vIENhcnJ5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldIC09IDB4NDAwMDAwMDtcbiAgICAgIGlmIChpID09PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSArIDEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgcGxhaW4gbnVtYmVyIGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZG4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy53b3Jkc1swXSAtPSBudW07XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYXJyeVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldIDwgMDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuXG4gICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcbiAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYgKG51bSwgbW9kZSkge1xuICAgIHZhciBzaGlmdCA9IHRoaXMubGVuZ3RoIC0gbnVtLmxlbmd0aDtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgdmFyIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcbiAgICBzaGlmdCA9IDI2IC0gYmhpQml0cztcbiAgICBpZiAoc2hpZnQgIT09IDApIHtcbiAgICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcbiAgICAgIGEuaXVzaGxuKHNoaWZ0KTtcbiAgICAgIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBxdW90aWVudFxuICAgIHZhciBtID0gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICB2YXIgcTtcblxuICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgcSA9IG5ldyBCTihudWxsKTtcbiAgICAgIHEubGVuZ3RoID0gbSArIDE7XG4gICAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xuICAgICAgICBxLndvcmRzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG4gICAgaWYgKGRpZmYubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIGEgPSBkaWZmO1xuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1ttXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgdmFyIHFqID0gKGEud29yZHNbYi5sZW5ndGggKyBqXSB8IDApICogMHg0MDAwMDAwICtcbiAgICAgICAgKGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV0gfCAwKTtcblxuICAgICAgLy8gTk9URTogKHFqIC8gYmhpKSBpcyAoMHgzZmZmZmZmICogMHg0MDAwMDAwICsgMHgzZmZmZmZmKSAvIDB4MjAwMDAwMCBtYXhcbiAgICAgIC8vICgweDdmZmZmZmYpXG4gICAgICBxaiA9IE1hdGgubWluKChxaiAvIGJoaSkgfCAwLCAweDNmZmZmZmYpO1xuXG4gICAgICBhLl9pc2hsbnN1Ym11bChiLCBxaiwgaik7XG4gICAgICB3aGlsZSAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBxai0tO1xuICAgICAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XG4gICAgICAgIGlmICghYS5pc1plcm8oKSkge1xuICAgICAgICAgIGEubmVnYXRpdmUgXj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocSkge1xuICAgICAgcS5fc3RyaXAoKTtcbiAgICB9XG4gICAgYS5fc3RyaXAoKTtcblxuICAgIC8vIERlbm9ybWFsaXplXG4gICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG4gICAgICBhLml1c2hybihzaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogcSB8fCBudWxsLFxuICAgICAgbW9kOiBhXG4gICAgfTtcbiAgfTtcblxuICAvLyBOT1RFOiAxKSBgbW9kZWAgY2FuIGJlIHNldCB0byBgbW9kYCB0byByZXF1ZXN0IG1vZCBvbmx5LFxuICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cbiAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuICAvLyAgICAgICAyKSBgcG9zaXRpdmVgIGlzIHRydWUgaWYgdW5zaWduZWQgbW9kIGlzIHJlcXVlc3RlZFxuICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG4gICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IG5ldyBCTigwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGl2LCBtb2QsIHJlcztcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IHJlcy5tb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaXN1YihudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogcmVzLmRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cbiAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiB0aGlzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFZlcnkgc2hvcnQgcmVkdWN0aW9uXG4gICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZHJuKG51bS53b3Jkc1swXSkpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kcm4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgKHIyID09PSAxICYmIGNtcCA9PT0gMCkpIHJldHVybiBkbS5kaXY7XG5cbiAgICAvLyBSb3VuZCB1cFxuICAgIHJldHVybiBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5kaXYuaXN1Ym4oMSkgOiBkbS5kaXYuaWFkZG4oMSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm1vZHJuID0gZnVuY3Rpb24gbW9kcm4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzTmVnTnVtID8gLWFjYyA6IGFjYztcbiAgfTtcblxuICAvLyBXQVJOSU5HOiBERVBSRUNBVEVEXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kcm4obnVtKTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICsgY2FycnkgKiAweDQwMDAwMDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcbiAgICAgIGNhcnJ5ID0gdyAlIG51bTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuICAgIHJldHVybiBpc05lZ051bSA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbnVtID0gLW51bTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4gIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG4gIC8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbiAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcblxuICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuICBCTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAgKG51bSkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHJldHVybiAtMTtcblxuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG4gICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG4gICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmVzID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24gZ3RlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24gbHRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gbHRlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbiBlcW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG4gIH07XG5cbiAgLy9cbiAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbiAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG4gIC8vXG4gIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuICAgIHRoaXMucmVkID0gY3R4O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNobCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICB9O1xuXG4gIC8vIFNxdWFyZSByb290IG92ZXIgcFxuICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcbiAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG4gIH07XG5cbiAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cbiAgdmFyIHByaW1lcyA9IHtcbiAgICBrMjU2OiBudWxsLFxuICAgIHAyMjQ6IG51bGwsXG4gICAgcDE5MjogbnVsbCxcbiAgICBwMjU1MTk6IG51bGxcbiAgfTtcblxuICAvLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbiAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG4gICAgLy8gUCA9IDIgXiBOIC0gS1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gICAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gIH1cblxuICBNUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wICgpIHtcbiAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcbiAgICByZXR1cm4gdG1wO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuICAgIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcbiAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG4gICAgdmFyIHIgPSBudW07XG4gICAgdmFyIHJsZW47XG5cbiAgICBkbyB7XG4gICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByLndvcmRzWzBdID0gMDtcbiAgICAgIHIubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIHIuaXN1Yih0aGlzLnApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoci5zdHJpcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHIgaXMgYSBCTiB2NCBpbnN0YW5jZVxuICAgICAgICByLnN0cmlwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByIGlzIGEgQk4gdjUgaW5zdGFuY2VcbiAgICAgICAgci5fc3RyaXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXQpIHtcbiAgICBpbnB1dC5pdXNocm4odGhpcy5uLCAwLCBvdXQpO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSzI1NiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ2syNTYnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG4gIH1cbiAgaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcblxuICBLMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0cHV0KSB7XG4gICAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykge1xuICAgICAgb3V0cHV0LndvcmRzW2ldID0gaW5wdXQud29yZHNbaV07XG4gICAgfVxuICAgIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XG5cbiAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICAgIGlucHV0Lmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuICAgIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG4gICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICAgIGZvciAoaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuICAgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcbiAgICAgIHByZXYgPSBuZXh0O1xuICAgIH1cbiAgICBwcmV2ID4+Pj0gMjI7XG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXY7XG4gICAgaWYgKHByZXYgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMTApIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDk7XG4gICAgfVxuICB9O1xuXG4gIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gICAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG4gICAgbnVtLmxlbmd0aCArPSAyO1xuXG4gICAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcbiAgICB2YXIgbG8gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG4gICAgICBsbyArPSB3ICogMHgzZDE7XG4gICAgICBudW0ud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIGxvID0gdyAqIDB4NDAgKyAoKGxvIC8gMHg0MDAwMDAwKSB8IDApO1xuICAgIH1cblxuICAgIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICBudW0ubGVuZ3RoLS07XG4gICAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICBudW0ubGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgZnVuY3Rpb24gUDIyNCAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AyMjQnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMTkyICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDE5MicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbiAgfVxuICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAyNTUxOSAoKSB7XG4gICAgLy8gMiBeIDI1NSAtIDE5XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJzI1NTE5JyxcbiAgICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG4gIFAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTNcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG4gICAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcbiAgICAgIGhpID4+Pj0gMjY7XG5cbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuICAgICAgY2FycnkgPSBoaTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIC8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuICBCTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZSAobmFtZSkge1xuICAgIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gICAgaWYgKHByaW1lc1tuYW1lXSkgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICAgIHZhciBwcmltZTtcbiAgICBpZiAobmFtZSA9PT0gJ2syNTYnKSB7XG4gICAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyMjQoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJykge1xuICAgICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuICAgIHJldHVybiBwcmltZTtcbiAgfTtcblxuICAvL1xuICAvLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbiAgLy9cbiAgZnVuY3Rpb24gUmVkIChtKSB7XG4gICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgICAgdGhpcy5tID0gcHJpbWUucDtcbiAgICAgIHRoaXMucHJpbWUgPSBwcmltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG0uZ3RuKDEpLCAnbW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxIChhKSB7XG4gICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIgKGEsIGIpIHtcbiAgICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZCAoYSkge1xuICAgIGlmICh0aGlzLnByaW1lKSByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIG1vdmUoYSwgYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpKTtcbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcbiIsIi8qISBzYWZlLWJ1ZmZlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSlcblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJykocmVxdWlyZSgnLi9saWIvZWxsaXB0aWMnKSlcbiIsImNvbnN0IEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lY1xuXG5jb25zdCBlYyA9IG5ldyBFQygnc2VjcDI1NmsxJylcbmNvbnN0IGVjcGFyYW1zID0gZWMuY3VydmVcblxuLy8gSGFjaywgd2UgY2FuIG5vdCB1c2UgYm4uanNANSwgd2hpbGUgZWxsaXB0aWMgdXNlcyBibi5qc0A0XG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvZWxsaXB0aWMvaXNzdWVzLzE5MSNpc3N1ZWNvbW1lbnQtNTY5ODg4NzU4XG5jb25zdCBCTiA9IGVjcGFyYW1zLm4uY29uc3RydWN0b3JcblxuZnVuY3Rpb24gbG9hZENvbXByZXNzZWRQdWJsaWNLZXkgKGZpcnN0LCB4YnVmKSB7XG4gIGxldCB4ID0gbmV3IEJOKHhidWYpXG5cbiAgLy8gb3ZlcmZsb3dcbiAgaWYgKHguY21wKGVjcGFyYW1zLnApID49IDApIHJldHVybiBudWxsXG4gIHggPSB4LnRvUmVkKGVjcGFyYW1zLnJlZClcblxuICAvLyBjb21wdXRlIGNvcnJlc3BvbmRpbmcgWVxuICBsZXQgeSA9IHgucmVkU3FyKCkucmVkSU11bCh4KS5yZWRJQWRkKGVjcGFyYW1zLmIpLnJlZFNxcnQoKVxuICBpZiAoKGZpcnN0ID09PSAweDAzKSAhPT0geS5pc09kZCgpKSB5ID0geS5yZWROZWcoKVxuXG4gIHJldHVybiBlYy5rZXlQYWlyKHsgcHViOiB7IHg6IHgsIHk6IHkgfSB9KVxufVxuXG5mdW5jdGlvbiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5IChmaXJzdCwgeGJ1ZiwgeWJ1Zikge1xuICBsZXQgeCA9IG5ldyBCTih4YnVmKVxuICBsZXQgeSA9IG5ldyBCTih5YnVmKVxuXG4gIC8vIG92ZXJmbG93XG4gIGlmICh4LmNtcChlY3BhcmFtcy5wKSA+PSAwIHx8IHkuY21wKGVjcGFyYW1zLnApID49IDApIHJldHVybiBudWxsXG5cbiAgeCA9IHgudG9SZWQoZWNwYXJhbXMucmVkKVxuICB5ID0geS50b1JlZChlY3BhcmFtcy5yZWQpXG5cbiAgLy8gaXMgb2RkIGZsYWdcbiAgaWYgKChmaXJzdCA9PT0gMHgwNiB8fCBmaXJzdCA9PT0gMHgwNykgJiYgeS5pc09kZCgpICE9PSAoZmlyc3QgPT09IDB4MDcpKSByZXR1cm4gbnVsbFxuXG4gIC8vIHgqeCp4ICsgYiA9IHkqeVxuICBjb25zdCB4MyA9IHgucmVkU3FyKCkucmVkSU11bCh4KVxuICBpZiAoIXkucmVkU3FyKCkucmVkSVN1Yih4My5yZWRJQWRkKGVjcGFyYW1zLmIpKS5pc1plcm8oKSkgcmV0dXJuIG51bGxcblxuICByZXR1cm4gZWMua2V5UGFpcih7IHB1YjogeyB4OiB4LCB5OiB5IH0gfSlcbn1cblxuZnVuY3Rpb24gbG9hZFB1YmxpY0tleSAocHVia2V5KSB7XG4gIC8vIGxlbmd0aCBzaG91bGQgYmUgdmFsaWRhdGVkIGluIGludGVyZmFjZVxuICBjb25zdCBmaXJzdCA9IHB1YmtleVswXVxuICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgY2FzZSAweDAyOlxuICAgIGNhc2UgMHgwMzpcbiAgICAgIGlmIChwdWJrZXkubGVuZ3RoICE9PSAzMykgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBsb2FkQ29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgcHVia2V5LnN1YmFycmF5KDEsIDMzKSlcbiAgICBjYXNlIDB4MDQ6XG4gICAgY2FzZSAweDA2OlxuICAgIGNhc2UgMHgwNzpcbiAgICAgIGlmIChwdWJrZXkubGVuZ3RoICE9PSA2NSkgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCBwdWJrZXkuc3ViYXJyYXkoMSwgMzMpLCBwdWJrZXkuc3ViYXJyYXkoMzMsIDY1KSlcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBzYXZlUHVibGljS2V5IChvdXRwdXQsIHBvaW50KSB7XG4gIGNvbnN0IHB1YmtleSA9IHBvaW50LmVuY29kZShudWxsLCBvdXRwdXQubGVuZ3RoID09PSAzMylcbiAgLy8gTG9vcCBzaG91bGQgYmUgZmFzdGVyIGJlY2F1c2Ugd2UgZG8gbm90IG5lZWQgY3JlYXRlIGV4dHJhIFVpbnQ4QXJyYXlcbiAgLy8gb3V0cHV0LnNldChuZXcgVWludDhBcnJheShwdWJrZXkpKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7ICsraSkgb3V0cHV0W2ldID0gcHVia2V5W2ldXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb250ZXh0UmFuZG9taXplICgpIHtcbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHByaXZhdGVLZXlWZXJpZnkgKHNlY2tleSkge1xuICAgIGNvbnN0IGJuID0gbmV3IEJOKHNlY2tleSlcbiAgICByZXR1cm4gYm4uY21wKGVjcGFyYW1zLm4pIDwgMCAmJiAhYm4uaXNaZXJvKCkgPyAwIDogMVxuICB9LFxuXG4gIHByaXZhdGVLZXlOZWdhdGUgKHNlY2tleSkge1xuICAgIGNvbnN0IGJuID0gbmV3IEJOKHNlY2tleSlcbiAgICBjb25zdCBuZWdhdGUgPSBlY3BhcmFtcy5uLnN1YihibikudW1vZChlY3BhcmFtcy5uKS50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMilcbiAgICBzZWNrZXkuc2V0KG5lZ2F0ZSlcbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHByaXZhdGVLZXlUd2Vha0FkZCAoc2Vja2V5LCB0d2Vhaykge1xuICAgIGNvbnN0IGJuID0gbmV3IEJOKHR3ZWFrKVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcblxuICAgIGJuLmlhZGQobmV3IEJOKHNlY2tleSkpXG4gICAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwKSBibi5pc3ViKGVjcGFyYW1zLm4pXG4gICAgaWYgKGJuLmlzWmVybygpKSByZXR1cm4gMVxuXG4gICAgY29uc3QgdHdlYWtlZCA9IGJuLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKVxuICAgIHNlY2tleS5zZXQodHdlYWtlZClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHJpdmF0ZUtleVR3ZWFrTXVsIChzZWNrZXksIHR3ZWFrKSB7XG4gICAgbGV0IGJuID0gbmV3IEJOKHR3ZWFrKVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkgcmV0dXJuIDFcblxuICAgIGJuLmltdWwobmV3IEJOKHNlY2tleSkpXG4gICAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwKSBibiA9IGJuLnVtb2QoZWNwYXJhbXMubilcblxuICAgIGNvbnN0IHR3ZWFrZWQgPSBibi50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMilcbiAgICBzZWNrZXkuc2V0KHR3ZWFrZWQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleVZlcmlmeSAocHVia2V5KSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIHJldHVybiBwYWlyID09PSBudWxsID8gMSA6IDBcbiAgfSxcblxuICBwdWJsaWNLZXlDcmVhdGUgKG91dHB1dCwgc2Vja2V5KSB7XG4gICAgY29uc3QgYm4gPSBuZXcgQk4oc2Vja2V5KVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHBvaW50ID0gZWMua2V5RnJvbVByaXZhdGUoc2Vja2V5KS5nZXRQdWJsaWMoKVxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5Q29udmVydCAob3V0cHV0LCBwdWJrZXkpIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKClcbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleU5lZ2F0ZSAob3V0cHV0LCBwdWJrZXkpIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKClcbiAgICBwb2ludC55ID0gcG9pbnQueS5yZWROZWcoKVxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5Q29tYmluZSAob3V0cHV0LCBwdWJrZXlzKSB7XG4gICAgY29uc3QgcGFpcnMgPSBuZXcgQXJyYXkocHVia2V5cy5sZW5ndGgpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdWJrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICBwYWlyc1tpXSA9IGxvYWRQdWJsaWNLZXkocHVia2V5c1tpXSlcbiAgICAgIGlmIChwYWlyc1tpXSA9PT0gbnVsbCkgcmV0dXJuIDFcbiAgICB9XG5cbiAgICBsZXQgcG9pbnQgPSBwYWlyc1swXS5nZXRQdWJsaWMoKVxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGFpcnMubGVuZ3RoOyArK2kpIHBvaW50ID0gcG9pbnQuYWRkKHBhaXJzW2ldLnB1YilcbiAgICBpZiAocG9pbnQuaXNJbmZpbml0eSgpKSByZXR1cm4gMlxuXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlUd2Vha0FkZCAob3V0cHV0LCBwdWJrZXksIHR3ZWFrKSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgdHdlYWsgPSBuZXcgQk4odHdlYWspXG4gICAgaWYgKHR3ZWFrLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMlxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpLmFkZChlY3BhcmFtcy5nLm11bCh0d2VhaykpXG4gICAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSkgcmV0dXJuIDJcblxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5VHdlYWtNdWwgKG91dHB1dCwgcHVia2V5LCB0d2Vhaykge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDFcblxuICAgIHR3ZWFrID0gbmV3IEJOKHR3ZWFrKVxuICAgIGlmICh0d2Vhay5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCB0d2Vhay5pc1plcm8oKSkgcmV0dXJuIDJcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKS5tdWwodHdlYWspXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBzaWduYXR1cmVOb3JtYWxpemUgKHNpZykge1xuICAgIGNvbnN0IHIgPSBuZXcgQk4oc2lnLnN1YmFycmF5KDAsIDMyKSlcbiAgICBjb25zdCBzID0gbmV3IEJOKHNpZy5zdWJhcnJheSgzMiwgNjQpKVxuICAgIGlmIChyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHMuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG5cbiAgICBpZiAocy5jbXAoZWMubmgpID09PSAxKSB7XG4gICAgICBzaWcuc2V0KGVjcGFyYW1zLm4uc3ViKHMpLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMzIpXG4gICAgfVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICAvLyBDb3BpZWQgMS10by0xIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXA2Ni9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAvLyBBZGFwdGVkIGZvciBVaW50OEFycmF5IGluc3RlYWQgQnVmZmVyXG4gIHNpZ25hdHVyZUV4cG9ydCAob2JqLCBzaWcpIHtcbiAgICBjb25zdCBzaWdSID0gc2lnLnN1YmFycmF5KDAsIDMyKVxuICAgIGNvbnN0IHNpZ1MgPSBzaWcuc3ViYXJyYXkoMzIsIDY0KVxuICAgIGlmIChuZXcgQk4oc2lnUikuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG4gICAgaWYgKG5ldyBCTihzaWdTKS5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHsgb3V0cHV0IH0gPSBvYmpcblxuICAgIC8vIFByZXBhcmUgUlxuICAgIGxldCByID0gb3V0cHV0LnN1YmFycmF5KDQsIDQgKyAzMylcbiAgICByWzBdID0gMHgwMFxuICAgIHIuc2V0KHNpZ1IsIDEpXG5cbiAgICBsZXQgbGVuUiA9IDMzXG4gICAgbGV0IHBvc1IgPSAwXG4gICAgZm9yICg7IGxlblIgPiAxICYmIHJbcG9zUl0gPT09IDB4MDAgJiYgIShyW3Bvc1IgKyAxXSAmIDB4ODApOyAtLWxlblIsICsrcG9zUik7XG5cbiAgICByID0gci5zdWJhcnJheShwb3NSKVxuICAgIGlmIChyWzBdICYgMHg4MCkgcmV0dXJuIDFcbiAgICBpZiAobGVuUiA+IDEgJiYgKHJbMF0gPT09IDB4MDApICYmICEoclsxXSAmIDB4ODApKSByZXR1cm4gMVxuXG4gICAgLy8gUHJlcGFyZSBTXG4gICAgbGV0IHMgPSBvdXRwdXQuc3ViYXJyYXkoNiArIDMzLCA2ICsgMzMgKyAzMylcbiAgICBzWzBdID0gMHgwMFxuICAgIHMuc2V0KHNpZ1MsIDEpXG5cbiAgICBsZXQgbGVuUyA9IDMzXG4gICAgbGV0IHBvc1MgPSAwXG4gICAgZm9yICg7IGxlblMgPiAxICYmIHNbcG9zU10gPT09IDB4MDAgJiYgIShzW3Bvc1MgKyAxXSAmIDB4ODApOyAtLWxlblMsICsrcG9zUyk7XG5cbiAgICBzID0gcy5zdWJhcnJheShwb3NTKVxuICAgIGlmIChzWzBdICYgMHg4MCkgcmV0dXJuIDFcbiAgICBpZiAobGVuUyA+IDEgJiYgKHNbMF0gPT09IDB4MDApICYmICEoc1sxXSAmIDB4ODApKSByZXR1cm4gMVxuXG4gICAgLy8gU2V0IG91dHB1dCBsZW5ndGggZm9yIHJldHVyblxuICAgIG9iai5vdXRwdXRsZW4gPSA2ICsgbGVuUiArIGxlblNcblxuICAgIC8vIE91dHB1dCBpbiBzcGVjaWZpZWQgZm9ybWF0XG4gICAgLy8gMHgzMCBbdG90YWwtbGVuZ3RoXSAweDAyIFtSLWxlbmd0aF0gW1JdIDB4MDIgW1MtbGVuZ3RoXSBbU11cbiAgICBvdXRwdXRbMF0gPSAweDMwXG4gICAgb3V0cHV0WzFdID0gb2JqLm91dHB1dGxlbiAtIDJcbiAgICBvdXRwdXRbMl0gPSAweDAyXG4gICAgb3V0cHV0WzNdID0gci5sZW5ndGhcbiAgICBvdXRwdXQuc2V0KHIsIDQpXG4gICAgb3V0cHV0WzQgKyBsZW5SXSA9IDB4MDJcbiAgICBvdXRwdXRbNSArIGxlblJdID0gcy5sZW5ndGhcbiAgICBvdXRwdXQuc2V0KHMsIDYgKyBsZW5SKVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICAvLyBDb3BpZWQgMS10by0xIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW5qcy9iaXA2Ni9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAvLyBBZGFwdGVkIGZvciBVaW50OEFycmF5IGluc3RlYWQgQnVmZmVyXG4gIHNpZ25hdHVyZUltcG9ydCAob3V0cHV0LCBzaWcpIHtcbiAgICBpZiAoc2lnLmxlbmd0aCA8IDgpIHJldHVybiAxXG4gICAgaWYgKHNpZy5sZW5ndGggPiA3MikgcmV0dXJuIDFcbiAgICBpZiAoc2lnWzBdICE9PSAweDMwKSByZXR1cm4gMVxuICAgIGlmIChzaWdbMV0gIT09IHNpZy5sZW5ndGggLSAyKSByZXR1cm4gMVxuICAgIGlmIChzaWdbMl0gIT09IDB4MDIpIHJldHVybiAxXG5cbiAgICBjb25zdCBsZW5SID0gc2lnWzNdXG4gICAgaWYgKGxlblIgPT09IDApIHJldHVybiAxXG4gICAgaWYgKDUgKyBsZW5SID49IHNpZy5sZW5ndGgpIHJldHVybiAxXG4gICAgaWYgKHNpZ1s0ICsgbGVuUl0gIT09IDB4MDIpIHJldHVybiAxXG5cbiAgICBjb25zdCBsZW5TID0gc2lnWzUgKyBsZW5SXVxuICAgIGlmIChsZW5TID09PSAwKSByZXR1cm4gMVxuICAgIGlmICgoNiArIGxlblIgKyBsZW5TKSAhPT0gc2lnLmxlbmd0aCkgcmV0dXJuIDFcblxuICAgIGlmIChzaWdbNF0gJiAweDgwKSByZXR1cm4gMVxuICAgIGlmIChsZW5SID4gMSAmJiAoc2lnWzRdID09PSAweDAwKSAmJiAhKHNpZ1s1XSAmIDB4ODApKSByZXR1cm4gMVxuXG4gICAgaWYgKHNpZ1tsZW5SICsgNl0gJiAweDgwKSByZXR1cm4gMVxuICAgIGlmIChsZW5TID4gMSAmJiAoc2lnW2xlblIgKyA2XSA9PT0gMHgwMCkgJiYgIShzaWdbbGVuUiArIDddICYgMHg4MCkpIHJldHVybiAxXG5cbiAgICBsZXQgc2lnUiA9IHNpZy5zdWJhcnJheSg0LCA0ICsgbGVuUilcbiAgICBpZiAoc2lnUi5sZW5ndGggPT09IDMzICYmIHNpZ1JbMF0gPT09IDB4MDApIHNpZ1IgPSBzaWdSLnN1YmFycmF5KDEpXG4gICAgaWYgKHNpZ1IubGVuZ3RoID4gMzIpIHJldHVybiAxXG5cbiAgICBsZXQgc2lnUyA9IHNpZy5zdWJhcnJheSg2ICsgbGVuUilcbiAgICBpZiAoc2lnUy5sZW5ndGggPT09IDMzICYmIHNpZ1NbMF0gPT09IDB4MDApIHNpZ1MgPSBzaWdTLnNsaWNlKDEpXG4gICAgaWYgKHNpZ1MubGVuZ3RoID4gMzIpIHRocm93IG5ldyBFcnJvcignUyBsZW5ndGggaXMgdG9vIGxvbmcnKVxuXG4gICAgbGV0IHIgPSBuZXcgQk4oc2lnUilcbiAgICBpZiAoci5jbXAoZWNwYXJhbXMubikgPj0gMCkgciA9IG5ldyBCTigwKVxuXG4gICAgbGV0IHMgPSBuZXcgQk4oc2lnLnN1YmFycmF5KDYgKyBsZW5SKSlcbiAgICBpZiAocy5jbXAoZWNwYXJhbXMubikgPj0gMCkgcyA9IG5ldyBCTigwKVxuXG4gICAgb3V0cHV0LnNldChyLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMClcbiAgICBvdXRwdXQuc2V0KHMudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAzMilcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgZWNkc2FTaWduIChvYmosIG1lc3NhZ2UsIHNlY2tleSwgZGF0YSwgbm9uY2Vmbikge1xuICAgIGlmIChub25jZWZuKSB7XG4gICAgICBjb25zdCBfbm9uY2VmbiA9IG5vbmNlZm5cbiAgICAgIG5vbmNlZm4gPSAoY291bnRlcikgPT4ge1xuICAgICAgICBjb25zdCBub25jZSA9IF9ub25jZWZuKG1lc3NhZ2UsIHNlY2tleSwgbnVsbCwgZGF0YSwgY291bnRlcilcblxuICAgICAgICBjb25zdCBpc1ZhbGlkID0gbm9uY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIG5vbmNlLmxlbmd0aCA9PT0gMzJcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgaXMgdGhlIHdheScpXG5cbiAgICAgICAgcmV0dXJuIG5ldyBCTihub25jZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkID0gbmV3IEJOKHNlY2tleSlcbiAgICBpZiAoZC5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBkLmlzWmVybygpKSByZXR1cm4gMVxuXG4gICAgbGV0IHNpZ1xuICAgIHRyeSB7XG4gICAgICBzaWcgPSBlYy5zaWduKG1lc3NhZ2UsIHNlY2tleSwgeyBjYW5vbmljYWw6IHRydWUsIGs6IG5vbmNlZm4sIHBlcnM6IGRhdGEgfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgb2JqLnNpZ25hdHVyZS5zZXQoc2lnLnIudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpLCAwKVxuICAgIG9iai5zaWduYXR1cmUuc2V0KHNpZy5zLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMzIpXG4gICAgb2JqLnJlY2lkID0gc2lnLnJlY292ZXJ5UGFyYW1cblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgZWNkc2FWZXJpZnkgKHNpZywgbXNnMzIsIHB1YmtleSkge1xuICAgIGNvbnN0IHNpZ09iaiA9IHsgcjogc2lnLnN1YmFycmF5KDAsIDMyKSwgczogc2lnLnN1YmFycmF5KDMyLCA2NCkgfVxuXG4gICAgY29uc3Qgc2lnciA9IG5ldyBCTihzaWdPYmoucilcbiAgICBjb25zdCBzaWdzID0gbmV3IEJOKHNpZ09iai5zKVxuICAgIGlmIChzaWdyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNpZ3MuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG4gICAgaWYgKHNpZ3MuY21wKGVjLm5oKSA9PT0gMSB8fCBzaWdyLmlzWmVybygpIHx8IHNpZ3MuaXNaZXJvKCkpIHJldHVybiAzXG5cbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAyXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKClcbiAgICBjb25zdCBpc1ZhbGlkID0gZWMudmVyaWZ5KG1zZzMyLCBzaWdPYmosIHBvaW50KVxuICAgIHJldHVybiBpc1ZhbGlkID8gMCA6IDNcbiAgfSxcblxuICBlY2RzYVJlY292ZXIgKG91dHB1dCwgc2lnLCByZWNpZCwgbXNnMzIpIHtcbiAgICBjb25zdCBzaWdPYmogPSB7IHI6IHNpZy5zbGljZSgwLCAzMiksIHM6IHNpZy5zbGljZSgzMiwgNjQpIH1cblxuICAgIGNvbnN0IHNpZ3IgPSBuZXcgQk4oc2lnT2JqLnIpXG4gICAgY29uc3Qgc2lncyA9IG5ldyBCTihzaWdPYmoucylcbiAgICBpZiAoc2lnci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzaWdzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuXG4gICAgaWYgKHNpZ3IuaXNaZXJvKCkgfHwgc2lncy5pc1plcm8oKSkgcmV0dXJuIDJcblxuICAgIC8vIENhbiB0aHJvdyBgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtgXG4gICAgbGV0IHBvaW50XG4gICAgdHJ5IHtcbiAgICAgIHBvaW50ID0gZWMucmVjb3ZlclB1YktleShtc2czMiwgc2lnT2JqLCByZWNpZClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiAyXG4gICAgfVxuXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBlY2RoIChvdXRwdXQsIHB1YmtleSwgc2Vja2V5LCBkYXRhLCBoYXNoZm4sIHhidWYsIHlidWYpIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICBjb25zdCBzY2FsYXIgPSBuZXcgQk4oc2Vja2V5KVxuICAgIGlmIChzY2FsYXIuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2NhbGFyLmlzWmVybygpKSByZXR1cm4gMlxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpLm11bChzY2FsYXIpXG5cbiAgICBpZiAoaGFzaGZuID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBwb2ludC5lbmNvZGUobnVsbCwgdHJ1ZSlcbiAgICAgIGNvbnN0IHNoYTI1NiA9IGVjLmhhc2goKS51cGRhdGUoZGF0YSkuZGlnZXN0KClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSkgb3V0cHV0W2ldID0gc2hhMjU2W2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgheGJ1ZikgeGJ1ZiA9IG5ldyBVaW50OEFycmF5KDMyKVxuICAgICAgY29uc3QgeCA9IHBvaW50LmdldFgoKS50b0FycmF5KCdiZScsIDMyKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgKytpKSB4YnVmW2ldID0geFtpXVxuXG4gICAgICBpZiAoIXlidWYpIHlidWYgPSBuZXcgVWludDhBcnJheSgzMilcbiAgICAgIGNvbnN0IHkgPSBwb2ludC5nZXRZKCkudG9BcnJheSgnYmUnLCAzMilcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSkgeWJ1ZltpXSA9IHlbaV1cblxuICAgICAgY29uc3QgaGFzaCA9IGhhc2hmbih4YnVmLCB5YnVmLCBkYXRhKVxuXG4gICAgICBjb25zdCBpc1ZhbGlkID0gaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgaGFzaC5sZW5ndGggPT09IG91dHB1dC5sZW5ndGhcbiAgICAgIGlmICghaXNWYWxpZCkgcmV0dXJuIDJcblxuICAgICAgb3V0cHV0LnNldChoYXNoKVxuICAgIH1cblxuICAgIHJldHVybiAwXG4gIH1cbn1cbiIsImNvbnN0IGVycm9ycyA9IHtcbiAgSU1QT1NTSUJMRV9DQVNFOiAnSW1wb3NzaWJsZSBjYXNlLiBQbGVhc2UgY3JlYXRlIGlzc3VlLicsXG4gIFRXRUFLX0FERDpcbiAgICAnVGhlIHR3ZWFrIHdhcyBvdXQgb2YgcmFuZ2Ugb3IgdGhlIHJlc3VsdGVkIHByaXZhdGUga2V5IGlzIGludmFsaWQnLFxuICBUV0VBS19NVUw6ICdUaGUgdHdlYWsgd2FzIG91dCBvZiByYW5nZSBvciBlcXVhbCB0byB6ZXJvJyxcbiAgQ09OVEVYVF9SQU5ET01JWkVfVU5LTk9XOiAnVW5rbm93IGVycm9yIG9uIGNvbnRleHQgcmFuZG9taXphdGlvbicsXG4gIFNFQ0tFWV9JTlZBTElEOiAnUHJpdmF0ZSBLZXkgaXMgaW52YWxpZCcsXG4gIFBVQktFWV9QQVJTRTogJ1B1YmxpYyBLZXkgY291bGQgbm90IGJlIHBhcnNlZCcsXG4gIFBVQktFWV9TRVJJQUxJWkU6ICdQdWJsaWMgS2V5IHNlcmlhbGl6YXRpb24gZXJyb3InLFxuICBQVUJLRVlfQ09NQklORTogJ1RoZSBzdW0gb2YgdGhlIHB1YmxpYyBrZXlzIGlzIG5vdCB2YWxpZCcsXG4gIFNJR19QQVJTRTogJ1NpZ25hdHVyZSBjb3VsZCBub3QgYmUgcGFyc2VkJyxcbiAgU0lHTjogJ1RoZSBub25jZSBnZW5lcmF0aW9uIGZ1bmN0aW9uIGZhaWxlZCwgb3IgdGhlIHByaXZhdGUga2V5IHdhcyBpbnZhbGlkJyxcbiAgUkVDT1ZFUjogJ1B1YmxpYyBrZXkgY291bGQgbm90IGJlIHJlY292ZXInLFxuICBFQ0RIOiAnU2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KSdcbn1cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKSB0aHJvdyBuZXcgRXJyb3IobXNnKVxufVxuXG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXkgKG5hbWUsIHZhbHVlLCBsZW5ndGgpIHtcbiAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSwgYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgYW4gVWludDhBcnJheWApXG5cbiAgaWYgKGxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGVuZ3RoKSkge1xuICAgICAgY29uc3QgbnVtYmVycyA9IGxlbmd0aC5qb2luKCcsICcpXG4gICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgJHtuYW1lfSB0byBiZSBhbiBVaW50OEFycmF5IHdpdGggbGVuZ3RoIFske251bWJlcnN9XWBcbiAgICAgIGFzc2VydChsZW5ndGguaW5jbHVkZXModmFsdWUubGVuZ3RoKSwgbXNnKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtc2cgPSBgRXhwZWN0ZWQgJHtuYW1lfSB0byBiZSBhbiBVaW50OEFycmF5IHdpdGggbGVuZ3RoICR7bGVuZ3RofWBcbiAgICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggPT09IGxlbmd0aCwgbXNnKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbXByZXNzZWQgKHZhbHVlKSB7XG4gIGFzc2VydCh0b1R5cGVTdHJpbmcodmFsdWUpID09PSAnQm9vbGVhbicsICdFeHBlY3RlZCBjb21wcmVzc2VkIHRvIGJlIGEgQm9vbGVhbicpXG59XG5cbmZ1bmN0aW9uIGdldEFzc2VydGVkT3V0cHV0IChvdXRwdXQgPSAobGVuKSA9PiBuZXcgVWludDhBcnJheShsZW4pLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicpIG91dHB1dCA9IG91dHB1dChsZW5ndGgpXG4gIGlzVWludDhBcnJheSgnb3V0cHV0Jywgb3V0cHV0LCBsZW5ndGgpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuZnVuY3Rpb24gdG9UeXBlU3RyaW5nICh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoc2VjcDI1NmsxKSA9PiB7XG4gIHJldHVybiB7XG4gICAgY29udGV4dFJhbmRvbWl6ZSAoc2VlZCkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBzZWVkID09PSBudWxsIHx8IHNlZWQgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgICAgICAnRXhwZWN0ZWQgc2VlZCB0byBiZSBhbiBVaW50OEFycmF5IG9yIG51bGwnXG4gICAgICApXG4gICAgICBpZiAoc2VlZCAhPT0gbnVsbCkgaXNVaW50OEFycmF5KCdzZWVkJywgc2VlZCwgMzIpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmNvbnRleHRSYW5kb21pemUoc2VlZCkpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuQ09OVEVYVF9SQU5ET01JWkVfVU5LTk9XKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VmVyaWZ5IChzZWNrZXkpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHJpdmF0ZSBrZXknLCBzZWNrZXksIDMyKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkoc2Vja2V5KSA9PT0gMFxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5TmVnYXRlIChzZWNrZXkpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHJpdmF0ZSBrZXknLCBzZWNrZXksIDMyKVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wcml2YXRlS2V5TmVnYXRlKHNlY2tleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBzZWNrZXlcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VHdlYWtBZGQgKHNlY2tleSwgdHdlYWspIHtcbiAgICAgIGlzVWludDhBcnJheSgncHJpdmF0ZSBrZXknLCBzZWNrZXksIDMyKVxuICAgICAgaXNVaW50OEFycmF5KCd0d2VhaycsIHR3ZWFrLCAzMilcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKHNlY2tleSwgdHdlYWspKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gc2Vja2V5XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlRXRUFLX0FERClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleVR3ZWFrTXVsIChzZWNrZXksIHR3ZWFrKSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGlzVWludDhBcnJheSgndHdlYWsnLCB0d2VhaywgMzIpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha011bChzZWNrZXksIHR3ZWFrKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHNlY2tleVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5UV0VBS19NVUwpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleVZlcmlmeSAocHVia2V5KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJrZXkpID09PSAwXG4gICAgfSxcblxuICAgIHB1YmxpY0tleUNyZWF0ZSAoc2Vja2V5LCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKG91dHB1dCwgc2Vja2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TRUNLRVlfSU5WQUxJRClcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1NFUklBTElaRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5Q29udmVydCAocHVia2V5LCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KG91dHB1dCwgcHVia2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9TRVJJQUxJWkUpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleU5lZ2F0ZSAocHVia2V5LCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlOZWdhdGUob3V0cHV0LCBwdWJrZXkpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfU0VSSUFMSVpFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDb21iaW5lIChwdWJrZXlzLCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShwdWJrZXlzKSwgJ0V4cGVjdGVkIHB1YmxpYyBrZXlzIHRvIGJlIGFuIEFycmF5JylcbiAgICAgIGFzc2VydChwdWJrZXlzLmxlbmd0aCA+IDAsICdFeHBlY3RlZCBwdWJsaWMga2V5cyBhcnJheSB3aWxsIGhhdmUgbW9yZSB0aGFuIHplcm8gaXRlbXMnKVxuICAgICAgZm9yIChjb25zdCBwdWJrZXkgb2YgcHVia2V5cykge1xuICAgICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgfVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlDb21iaW5lKG91dHB1dCwgcHVia2V5cykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfQ09NQklORSlcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1NFUklBTElaRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5VHdlYWtBZGQgKHB1YmtleSwgdHdlYWssIGNvbXByZXNzZWQgPSB0cnVlLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3R3ZWFrJywgdHdlYWssIDMyKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChvdXRwdXQsIHB1YmtleSwgdHdlYWspKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVFdFQUtfQUREKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlUd2Vha011bCAocHVia2V5LCB0d2VhaywgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIGlzVWludDhBcnJheSgndHdlYWsnLCB0d2VhaywgMzIpXG4gICAgICBpc0NvbXByZXNzZWQoY29tcHJlc3NlZClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgY29tcHJlc3NlZCA/IDMzIDogNjUpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrTXVsKG91dHB1dCwgcHVia2V5LCB0d2VhaykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5UV0VBS19NVUwpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpZ25hdHVyZU5vcm1hbGl6ZSAoc2lnKSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3NpZ25hdHVyZScsIHNpZywgNjQpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnNpZ25hdHVyZU5vcm1hbGl6ZShzaWcpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gc2lnXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR19QQVJTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlRXhwb3J0IChzaWcsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCA3MilcblxuICAgICAgY29uc3Qgb2JqID0geyBvdXRwdXQsIG91dHB1dGxlbjogNzIgfVxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuc2lnbmF0dXJlRXhwb3J0KG9iaiwgc2lnKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dC5zbGljZSgwLCBvYmoub3V0cHV0bGVuKVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlSW1wb3J0IChzaWcsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIDY0KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5zaWduYXR1cmVJbXBvcnQob3V0cHV0LCBzaWcpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR19QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlY2RzYVNpZ24gKG1zZzMyLCBzZWNrZXksIG9wdGlvbnMgPSB7fSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ21lc3NhZ2UnLCBtc2czMiwgMzIpXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucykgPT09ICdPYmplY3QnLCAnRXhwZWN0ZWQgb3B0aW9ucyB0byBiZSBhbiBPYmplY3QnKVxuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkKSBpc1VpbnQ4QXJyYXkoJ29wdGlvbnMuZGF0YScsIG9wdGlvbnMuZGF0YSlcbiAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4gIT09IHVuZGVmaW5lZCkgYXNzZXJ0KHRvVHlwZVN0cmluZyhvcHRpb25zLm5vbmNlZm4pID09PSAnRnVuY3Rpb24nLCAnRXhwZWN0ZWQgb3B0aW9ucy5ub25jZWZuIHRvIGJlIGEgRnVuY3Rpb24nKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCA2NClcblxuICAgICAgY29uc3Qgb2JqID0geyBzaWduYXR1cmU6IG91dHB1dCwgcmVjaWQ6IG51bGwgfVxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkc2FTaWduKG9iaiwgbXNnMzIsIHNlY2tleSwgb3B0aW9ucy5kYXRhLCBvcHRpb25zLm5vbmNlZm4pKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR04pXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkc2FWZXJpZnkgKHNpZywgbXNnMzIsIHB1YmtleSkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuICAgICAgaXNVaW50OEFycmF5KCdtZXNzYWdlJywgbXNnMzIsIDMyKVxuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkc2FWZXJpZnkoc2lnLCBtc2czMiwgcHVia2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkc2FSZWNvdmVyIChzaWcsIHJlY2lkLCBtc2czMiwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuICAgICAgYXNzZXJ0KFxuICAgICAgICB0b1R5cGVTdHJpbmcocmVjaWQpID09PSAnTnVtYmVyJyAmJlxuICAgICAgICAgIHJlY2lkID49IDAgJiZcbiAgICAgICAgICByZWNpZCA8PSAzLFxuICAgICAgICAnRXhwZWN0ZWQgcmVjb3ZlcnkgaWQgdG8gYmUgYSBOdW1iZXIgd2l0aGluIGludGVydmFsIFswLCAzXSdcbiAgICAgIClcbiAgICAgIGlzVWludDhBcnJheSgnbWVzc2FnZScsIG1zZzMyLCAzMilcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkc2FSZWNvdmVyKG91dHB1dCwgc2lnLCByZWNpZCwgbXNnMzIpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlNJR19QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUkVDT1ZFUilcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuSU1QT1NTSUJMRV9DQVNFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBlY2RoIChwdWJrZXksIHNlY2tleSwgb3B0aW9ucyA9IHt9LCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucykgPT09ICdPYmplY3QnLCAnRXhwZWN0ZWQgb3B0aW9ucyB0byBiZSBhbiBPYmplY3QnKVxuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkKSBpc1VpbnQ4QXJyYXkoJ29wdGlvbnMuZGF0YScsIG9wdGlvbnMuZGF0YSlcbiAgICAgIGlmIChvcHRpb25zLmhhc2hmbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucy5oYXNoZm4pID09PSAnRnVuY3Rpb24nLCAnRXhwZWN0ZWQgb3B0aW9ucy5oYXNoZm4gdG8gYmUgYSBGdW5jdGlvbicpXG4gICAgICAgIGlmIChvcHRpb25zLnhidWYgIT09IHVuZGVmaW5lZCkgaXNVaW50OEFycmF5KCdvcHRpb25zLnhidWYnLCBvcHRpb25zLnhidWYsIDMyKVxuICAgICAgICBpZiAob3B0aW9ucy55YnVmICE9PSB1bmRlZmluZWQpIGlzVWludDhBcnJheSgnb3B0aW9ucy55YnVmJywgb3B0aW9ucy55YnVmLCAzMilcbiAgICAgICAgaXNVaW50OEFycmF5KCdvdXRwdXQnLCBvdXRwdXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIDMyKVxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5lY2RoKG91dHB1dCwgcHVia2V5LCBzZWNrZXksIG9wdGlvbnMuZGF0YSwgb3B0aW9ucy5oYXNoZm4sIG9wdGlvbnMueGJ1Ziwgb3B0aW9ucy55YnVmKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLkVDREgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuLy8gcHJvdG90eXBlIGNsYXNzIGZvciBoYXNoIGZ1bmN0aW9uc1xuZnVuY3Rpb24gSGFzaCAoYmxvY2tTaXplLCBmaW5hbFNpemUpIHtcbiAgdGhpcy5fYmxvY2sgPSBCdWZmZXIuYWxsb2MoYmxvY2tTaXplKVxuICB0aGlzLl9maW5hbFNpemUgPSBmaW5hbFNpemVcbiAgdGhpcy5fYmxvY2tTaXplID0gYmxvY2tTaXplXG4gIHRoaXMuX2xlbiA9IDBcbn1cblxuSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuYykge1xuICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gZW5jIHx8ICd1dGY4J1xuICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhLCBlbmMpXG4gIH1cblxuICB2YXIgYmxvY2sgPSB0aGlzLl9ibG9ja1xuICB2YXIgYmxvY2tTaXplID0gdGhpcy5fYmxvY2tTaXplXG4gIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aFxuICB2YXIgYWNjdW0gPSB0aGlzLl9sZW5cblxuICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBsZW5ndGg7KSB7XG4gICAgdmFyIGFzc2lnbmVkID0gYWNjdW0gJSBibG9ja1NpemVcbiAgICB2YXIgcmVtYWluZGVyID0gTWF0aC5taW4obGVuZ3RoIC0gb2Zmc2V0LCBibG9ja1NpemUgLSBhc3NpZ25lZClcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVtYWluZGVyOyBpKyspIHtcbiAgICAgIGJsb2NrW2Fzc2lnbmVkICsgaV0gPSBkYXRhW29mZnNldCArIGldXG4gICAgfVxuXG4gICAgYWNjdW0gKz0gcmVtYWluZGVyXG4gICAgb2Zmc2V0ICs9IHJlbWFpbmRlclxuXG4gICAgaWYgKChhY2N1bSAlIGJsb2NrU2l6ZSkgPT09IDApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShibG9jaylcbiAgICB9XG4gIH1cblxuICB0aGlzLl9sZW4gKz0gbGVuZ3RoXG4gIHJldHVybiB0aGlzXG59XG5cbkhhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgdmFyIHJlbSA9IHRoaXMuX2xlbiAlIHRoaXMuX2Jsb2NrU2l6ZVxuXG4gIHRoaXMuX2Jsb2NrW3JlbV0gPSAweDgwXG5cbiAgLy8gemVybyAocmVtICsgMSkgdHJhaWxpbmcgYml0cywgd2hlcmUgKHJlbSArIDEpIGlzIHRoZSBzbWFsbGVzdFxuICAvLyBub24tbmVnYXRpdmUgc29sdXRpb24gdG8gdGhlIGVxdWF0aW9uIChsZW5ndGggKyAxICsgKHJlbSArIDEpKSA9PT0gZmluYWxTaXplIG1vZCBibG9ja1NpemVcbiAgdGhpcy5fYmxvY2suZmlsbCgwLCByZW0gKyAxKVxuXG4gIGlmIChyZW0gPj0gdGhpcy5fZmluYWxTaXplKSB7XG4gICAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICAgIHRoaXMuX2Jsb2NrLmZpbGwoMClcbiAgfVxuXG4gIHZhciBiaXRzID0gdGhpcy5fbGVuICogOFxuXG4gIC8vIHVpbnQzMlxuICBpZiAoYml0cyA8PSAweGZmZmZmZmZmKSB7XG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShiaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuXG4gIC8vIHVpbnQ2NFxuICB9IGVsc2Uge1xuICAgIHZhciBsb3dCaXRzID0gKGJpdHMgJiAweGZmZmZmZmZmKSA+Pj4gMFxuICAgIHZhciBoaWdoQml0cyA9IChiaXRzIC0gbG93Qml0cykgLyAweDEwMDAwMDAwMFxuXG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShoaWdoQml0cywgdGhpcy5fYmxvY2tTaXplIC0gOClcbiAgICB0aGlzLl9ibG9jay53cml0ZVVJbnQzMkJFKGxvd0JpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDQpXG4gIH1cblxuICB0aGlzLl91cGRhdGUodGhpcy5fYmxvY2spXG4gIHZhciBoYXNoID0gdGhpcy5faGFzaCgpXG5cbiAgcmV0dXJuIGVuYyA/IGhhc2gudG9TdHJpbmcoZW5jKSA6IGhhc2hcbn1cblxuSGFzaC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdXBkYXRlIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3MnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hcbiIsInZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBTSEEgKGFsZ29yaXRobSkge1xuICBhbGdvcml0aG0gPSBhbGdvcml0aG0udG9Mb3dlckNhc2UoKVxuXG4gIHZhciBBbGdvcml0aG0gPSBleHBvcnRzW2FsZ29yaXRobV1cbiAgaWYgKCFBbGdvcml0aG0pIHRocm93IG5ldyBFcnJvcihhbGdvcml0aG0gKyAnIGlzIG5vdCBzdXBwb3J0ZWQgKHdlIGFjY2VwdCBwdWxsIHJlcXVlc3RzKScpXG5cbiAgcmV0dXJuIG5ldyBBbGdvcml0aG0oKVxufVxuXG5leHBvcnRzLnNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbmV4cG9ydHMuc2hhMSA9IHJlcXVpcmUoJy4vc2hhMScpXG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhMjI0JylcbmV4cG9ydHMuc2hhMjU2ID0gcmVxdWlyZSgnLi9zaGEyNTYnKVxuZXhwb3J0cy5zaGEzODQgPSByZXF1aXJlKCcuL3NoYTM4NCcpXG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTAsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGRlcml2ZWQgZnJvbSBzaGExLmpzIG9mIHRoZSBzYW1lIHJlcG9zaXRvcnkuXG4gKiBUaGUgZGlmZmVyZW5jZSBiZXR3ZWVuIFNIQS0wIGFuZCBTSEEtMSBpcyBqdXN0IGEgYml0d2lzZSByb3RhdGUgbGVmdFxuICogb3BlcmF0aW9uIHdhcyBhZGRlZC5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGEsIEhhc2gpXG5cblNoYS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsNSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDUpIHwgKG51bSA+Pj4gMjcpXG59XG5cbmZ1bmN0aW9uIHJvdGwzMCAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDMwKSB8IChudW0gPj4+IDIpXG59XG5cbmZ1bmN0aW9uIGZ0IChzLCBiLCBjLCBkKSB7XG4gIGlmIChzID09PSAwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZClcbiAgaWYgKHMgPT09IDIpIHJldHVybiAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZClcbiAgcmV0dXJuIGIgXiBjIF4gZFxufVxuXG5TaGEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhLnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjApXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSB8IDAsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IgfCAwLCA0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9jIHwgMCwgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCB8IDAsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lIHwgMCwgMTYpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFcbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgSyA9IFtcbiAgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYyB8IDAsIDB4Y2E2MmMxZDYgfCAwXG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDgwKVxuXG5mdW5jdGlvbiBTaGExICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgNjQsIDU2KVxufVxuXG5pbmhlcml0cyhTaGExLCBIYXNoKVxuXG5TaGExLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2NzQ1MjMwMVxuICB0aGlzLl9iID0gMHhlZmNkYWI4OVxuICB0aGlzLl9jID0gMHg5OGJhZGNmZVxuICB0aGlzLl9kID0gMHgxMDMyNTQ3NlxuICB0aGlzLl9lID0gMHhjM2QyZTFmMFxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIHJvdGwxIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMSkgfCAobnVtID4+PiAzMSlcbn1cblxuZnVuY3Rpb24gcm90bDUgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCA1KSB8IChudW0gPj4+IDI3KVxufVxuXG5mdW5jdGlvbiByb3RsMzAgKG51bSkge1xuICByZXR1cm4gKG51bSA8PCAzMCkgfCAobnVtID4+PiAyKVxufVxuXG5mdW5jdGlvbiBmdCAocywgYiwgYywgZCkge1xuICBpZiAocyA9PT0gMCkgcmV0dXJuIChiICYgYykgfCAoKH5iKSAmIGQpXG4gIGlmIChzID09PSAyKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpXG4gIHJldHVybiBiIF4gYyBeIGRcbn1cblxuU2hhMS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhID0gdGhpcy5fYSB8IDBcbiAgdmFyIGIgPSB0aGlzLl9iIHwgMFxuICB2YXIgYyA9IHRoaXMuX2MgfCAwXG4gIHZhciBkID0gdGhpcy5fZCB8IDBcbiAgdmFyIGUgPSB0aGlzLl9lIHwgMFxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gIGZvciAoOyBpIDwgODA7ICsraSkgV1tpXSA9IHJvdGwxKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0pXG5cbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgKytqKSB7XG4gICAgdmFyIHMgPSB+fihqIC8gMjApXG4gICAgdmFyIHQgPSAocm90bDUoYSkgKyBmdChzLCBiLCBjLCBkKSArIGUgKyBXW2pdICsgS1tzXSkgfCAwXG5cbiAgICBlID0gZFxuICAgIGQgPSBjXG4gICAgYyA9IHJvdGwzMChiKVxuICAgIGIgPSBhXG4gICAgYSA9IHRcbiAgfVxuXG4gIHRoaXMuX2EgPSAoYSArIHRoaXMuX2EpIHwgMFxuICB0aGlzLl9iID0gKGIgKyB0aGlzLl9iKSB8IDBcbiAgdGhpcy5fYyA9IChjICsgdGhpcy5fYykgfCAwXG4gIHRoaXMuX2QgPSAoZCArIHRoaXMuX2QpIHwgMFxuICB0aGlzLl9lID0gKGUgKyB0aGlzLl9lKSB8IDBcbn1cblxuU2hhMS5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIwKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EgfCAwLCAwKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9iIHwgMCwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYyB8IDAsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QgfCAwLCAxMilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZSB8IDAsIDE2KVxuXG4gIHJldHVybiBIXG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhMVxuIiwiLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBTaGEyNTYgPSByZXF1aXJlKCcuL3NoYTI1NicpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTIyNCAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTIyNCwgU2hhMjU2KVxuXG5TaGEyMjQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2EgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2IgPSAweDM2N2NkNTA3XG4gIHRoaXMuX2MgPSAweDMwNzBkZDE3XG4gIHRoaXMuX2QgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2UgPSAweGZmYzAwYjMxXG4gIHRoaXMuX2YgPSAweDY4NTgxNTExXG4gIHRoaXMuX2cgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2ggPSAweGJlZmE0ZmE0XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuU2hhMjI0LnByb3RvdHlwZS5faGFzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEggPSBCdWZmZXIuYWxsb2NVbnNhZmUoMjgpXG5cbiAgSC53cml0ZUludDMyQkUodGhpcy5fYSwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiwgNClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYywgOClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UsIDE2KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9mLCAyMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZywgMjQpXG5cbiAgcmV0dXJuIEhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGEyMjRcbiIsIi8qKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0yNTYsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgMTgwLTJcbiAqIFZlcnNpb24gMi4yLWJldGEgQ29weXJpZ2h0IEFuZ2VsIE1hcmluLCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDA5LlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICpcbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NDI4QTJGOTgsIDB4NzEzNzQ0OTEsIDB4QjVDMEZCQ0YsIDB4RTlCNURCQTUsXG4gIDB4Mzk1NkMyNUIsIDB4NTlGMTExRjEsIDB4OTIzRjgyQTQsIDB4QUIxQzVFRDUsXG4gIDB4RDgwN0FBOTgsIDB4MTI4MzVCMDEsIDB4MjQzMTg1QkUsIDB4NTUwQzdEQzMsXG4gIDB4NzJCRTVENzQsIDB4ODBERUIxRkUsIDB4OUJEQzA2QTcsIDB4QzE5QkYxNzQsXG4gIDB4RTQ5QjY5QzEsIDB4RUZCRTQ3ODYsIDB4MEZDMTlEQzYsIDB4MjQwQ0ExQ0MsXG4gIDB4MkRFOTJDNkYsIDB4NEE3NDg0QUEsIDB4NUNCMEE5REMsIDB4NzZGOTg4REEsXG4gIDB4OTgzRTUxNTIsIDB4QTgzMUM2NkQsIDB4QjAwMzI3QzgsIDB4QkY1OTdGQzcsXG4gIDB4QzZFMDBCRjMsIDB4RDVBNzkxNDcsIDB4MDZDQTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdCNzBBODUsIDB4MkUxQjIxMzgsIDB4NEQyQzZERkMsIDB4NTMzODBEMTMsXG4gIDB4NjUwQTczNTQsIDB4NzY2QTBBQkIsIDB4ODFDMkM5MkUsIDB4OTI3MjJDODUsXG4gIDB4QTJCRkU4QTEsIDB4QTgxQTY2NEIsIDB4QzI0QjhCNzAsIDB4Qzc2QzUxQTMsXG4gIDB4RDE5MkU4MTksIDB4RDY5OTA2MjQsIDB4RjQwRTM1ODUsIDB4MTA2QUEwNzAsXG4gIDB4MTlBNEMxMTYsIDB4MUUzNzZDMDgsIDB4Mjc0ODc3NEMsIDB4MzRCMEJDQjUsXG4gIDB4MzkxQzBDQjMsIDB4NEVEOEFBNEEsIDB4NUI5Q0NBNEYsIDB4NjgyRTZGRjMsXG4gIDB4NzQ4RjgyRUUsIDB4NzhBNTYzNkYsIDB4ODRDODc4MTQsIDB4OENDNzAyMDgsXG4gIDB4OTBCRUZGRkEsIDB4QTQ1MDZDRUIsIDB4QkVGOUEzRjcsIDB4QzY3MTc4RjJcbl1cblxudmFyIFcgPSBuZXcgQXJyYXkoNjQpXG5cbmZ1bmN0aW9uIFNoYTI1NiAoKSB7XG4gIHRoaXMuaW5pdCgpXG5cbiAgdGhpcy5fdyA9IFcgLy8gbmV3IEFycmF5KDY0KVxuXG4gIEhhc2guY2FsbCh0aGlzLCA2NCwgNTYpXG59XG5cbmluaGVyaXRzKFNoYTI1NiwgSGFzaClcblxuU2hhMjU2LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9hID0gMHg2YTA5ZTY2N1xuICB0aGlzLl9iID0gMHhiYjY3YWU4NVxuICB0aGlzLl9jID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kID0gMHhhNTRmZjUzYVxuICB0aGlzLl9lID0gMHg1MTBlNTI3ZlxuICB0aGlzLl9mID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9nID0gMHgxZjgzZDlhYlxuICB0aGlzLl9oID0gMHg1YmUwY2QxOVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGNoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDIgfCB4IDw8IDMwKSBeICh4ID4+PiAxMyB8IHggPDwgMTkpIF4gKHggPj4+IDIyIHwgeCA8PCAxMClcbn1cblxuZnVuY3Rpb24gc2lnbWExICh4KSB7XG4gIHJldHVybiAoeCA+Pj4gNiB8IHggPDwgMjYpIF4gKHggPj4+IDExIHwgeCA8PCAyMSkgXiAoeCA+Pj4gMjUgfCB4IDw8IDcpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMCAoeCkge1xuICByZXR1cm4gKHggPj4+IDcgfCB4IDw8IDI1KSBeICh4ID4+PiAxOCB8IHggPDwgMTQpIF4gKHggPj4+IDMpXG59XG5cbmZ1bmN0aW9uIGdhbW1hMSAoeCkge1xuICByZXR1cm4gKHggPj4+IDE3IHwgeCA8PCAxNSkgXiAoeCA+Pj4gMTkgfCB4IDw8IDEzKSBeICh4ID4+PiAxMClcbn1cblxuU2hhMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKE0pIHtcbiAgdmFyIFcgPSB0aGlzLl93XG5cbiAgdmFyIGEgPSB0aGlzLl9hIHwgMFxuICB2YXIgYiA9IHRoaXMuX2IgfCAwXG4gIHZhciBjID0gdGhpcy5fYyB8IDBcbiAgdmFyIGQgPSB0aGlzLl9kIHwgMFxuICB2YXIgZSA9IHRoaXMuX2UgfCAwXG4gIHZhciBmID0gdGhpcy5fZiB8IDBcbiAgdmFyIGcgPSB0aGlzLl9nIHwgMFxuICB2YXIgaCA9IHRoaXMuX2ggfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSBXW2ldID0gTS5yZWFkSW50MzJCRShpICogNClcbiAgZm9yICg7IGkgPCA2NDsgKytpKSBXW2ldID0gKGdhbW1hMShXW2kgLSAyXSkgKyBXW2kgLSA3XSArIGdhbW1hMChXW2kgLSAxNV0pICsgV1tpIC0gMTZdKSB8IDBcblxuICBmb3IgKHZhciBqID0gMDsgaiA8IDY0OyArK2opIHtcbiAgICB2YXIgVDEgPSAoaCArIHNpZ21hMShlKSArIGNoKGUsIGYsIGcpICsgS1tqXSArIFdbal0pIHwgMFxuICAgIHZhciBUMiA9IChzaWdtYTAoYSkgKyBtYWooYSwgYiwgYykpIHwgMFxuXG4gICAgaCA9IGdcbiAgICBnID0gZlxuICAgIGYgPSBlXG4gICAgZSA9IChkICsgVDEpIHwgMFxuICAgIGQgPSBjXG4gICAgYyA9IGJcbiAgICBiID0gYVxuICAgIGEgPSAoVDEgKyBUMikgfCAwXG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG4gIHRoaXMuX2YgPSAoZiArIHRoaXMuX2YpIHwgMFxuICB0aGlzLl9nID0gKGcgKyB0aGlzLl9nKSB8IDBcbiAgdGhpcy5faCA9IChoICsgdGhpcy5faCkgfCAwXG59XG5cblNoYTI1Ni5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDMyKVxuXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2EsIDApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2IsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MsIDgpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2QsIDEyKVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9lLCAxNilcbiAgSC53cml0ZUludDMyQkUodGhpcy5fZiwgMjApXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2csIDI0KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9oLCAyOClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTI1NlxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIFNIQTUxMiA9IHJlcXVpcmUoJy4vc2hhNTEyJylcbnZhciBIYXNoID0gcmVxdWlyZSgnLi9oYXNoJylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuXG52YXIgVyA9IG5ldyBBcnJheSgxNjApXG5cbmZ1bmN0aW9uIFNoYTM4NCAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDEyOCwgMTEyKVxufVxuXG5pbmhlcml0cyhTaGEzODQsIFNIQTUxMilcblxuU2hhMzg0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4Y2JiYjlkNWRcbiAgdGhpcy5fYmggPSAweDYyOWEyOTJhXG4gIHRoaXMuX2NoID0gMHg5MTU5MDE1YVxuICB0aGlzLl9kaCA9IDB4MTUyZmVjZDhcbiAgdGhpcy5fZWggPSAweDY3MzMyNjY3XG4gIHRoaXMuX2ZoID0gMHg4ZWI0NGE4N1xuICB0aGlzLl9naCA9IDB4ZGIwYzJlMGRcbiAgdGhpcy5faGggPSAweDQ3YjU0ODFkXG5cbiAgdGhpcy5fYWwgPSAweGMxMDU5ZWQ4XG4gIHRoaXMuX2JsID0gMHgzNjdjZDUwN1xuICB0aGlzLl9jbCA9IDB4MzA3MGRkMTdcbiAgdGhpcy5fZGwgPSAweGY3MGU1OTM5XG4gIHRoaXMuX2VsID0gMHhmZmMwMGIzMVxuICB0aGlzLl9mbCA9IDB4Njg1ODE1MTFcbiAgdGhpcy5fZ2wgPSAweDY0Zjk4ZmE3XG4gIHRoaXMuX2hsID0gMHhiZWZhNGZhNFxuXG4gIHJldHVybiB0aGlzXG59XG5cblNoYTM4NC5wcm90b3R5cGUuX2hhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBIID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQ4KVxuXG4gIGZ1bmN0aW9uIHdyaXRlSW50NjRCRSAoaCwgbCwgb2Zmc2V0KSB7XG4gICAgSC53cml0ZUludDMyQkUoaCwgb2Zmc2V0KVxuICAgIEgud3JpdGVJbnQzMkJFKGwsIG9mZnNldCArIDQpXG4gIH1cblxuICB3cml0ZUludDY0QkUodGhpcy5fYWgsIHRoaXMuX2FsLCAwKVxuICB3cml0ZUludDY0QkUodGhpcy5fYmgsIHRoaXMuX2JsLCA4KVxuICB3cml0ZUludDY0QkUodGhpcy5fY2gsIHRoaXMuX2NsLCAxNilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2RoLCB0aGlzLl9kbCwgMjQpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9laCwgdGhpcy5fZWwsIDMyKVxuICB3cml0ZUludDY0QkUodGhpcy5fZmgsIHRoaXMuX2ZsLCA0MClcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTM4NFxuIiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIEhhc2ggPSByZXF1aXJlKCcuL2hhc2gnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbnZhciBLID0gW1xuICAweDQyOGEyZjk4LCAweGQ3MjhhZTIyLCAweDcxMzc0NDkxLCAweDIzZWY2NWNkLFxuICAweGI1YzBmYmNmLCAweGVjNGQzYjJmLCAweGU5YjVkYmE1LCAweDgxODlkYmJjLFxuICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuICAweDkyM2Y4MmE0LCAweGFmMTk0ZjliLCAweGFiMWM1ZWQ1LCAweGRhNmQ4MTE4LFxuICAweGQ4MDdhYTk4LCAweGEzMDMwMjQyLCAweDEyODM1YjAxLCAweDQ1NzA2ZmJlLFxuICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuICAweDcyYmU1ZDc0LCAweGYyN2I4OTZmLCAweDgwZGViMWZlLCAweDNiMTY5NmIxLFxuICAweDliZGMwNmE3LCAweDI1YzcxMjM1LCAweGMxOWJmMTc0LCAweGNmNjkyNjk0LFxuICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuICAweDBmYzE5ZGM2LCAweDhiOGNkNWI1LCAweDI0MGNhMWNjLCAweDc3YWM5YzY1LFxuICAweDJkZTkyYzZmLCAweDU5MmIwMjc1LCAweDRhNzQ4NGFhLCAweDZlYTZlNDgzLFxuICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuICAweDk4M2U1MTUyLCAweGVlNjZkZmFiLCAweGE4MzFjNjZkLCAweDJkYjQzMjEwLFxuICAweGIwMDMyN2M4LCAweDk4ZmIyMTNmLCAweGJmNTk3ZmM3LCAweGJlZWYwZWU0LFxuICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuICAweDA2Y2E2MzUxLCAweGUwMDM4MjZmLCAweDE0MjkyOTY3LCAweDBhMGU2ZTcwLFxuICAweDI3YjcwYTg1LCAweDQ2ZDIyZmZjLCAweDJlMWIyMTM4LCAweDVjMjZjOTI2LFxuICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuICAweDY1MGE3MzU0LCAweDhiYWY2M2RlLCAweDc2NmEwYWJiLCAweDNjNzdiMmE4LFxuICAweDgxYzJjOTJlLCAweDQ3ZWRhZWU2LCAweDkyNzIyYzg1LCAweDE0ODIzNTNiLFxuICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuICAweGMyNGI4YjcwLCAweGQwZjg5NzkxLCAweGM3NmM1MWEzLCAweDA2NTRiZTMwLFxuICAweGQxOTJlODE5LCAweGQ2ZWY1MjE4LCAweGQ2OTkwNjI0LCAweDU1NjVhOTEwLFxuICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuICAweDE5YTRjMTE2LCAweGI4ZDJkMGM4LCAweDFlMzc2YzA4LCAweDUxNDFhYjUzLFxuICAweDI3NDg3NzRjLCAweGRmOGVlYjk5LCAweDM0YjBiY2I1LCAweGUxOWI0OGE4LFxuICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuICAweDViOWNjYTRmLCAweDc3NjNlMzczLCAweDY4MmU2ZmYzLCAweGQ2YjJiOGEzLFxuICAweDc0OGY4MmVlLCAweDVkZWZiMmZjLCAweDc4YTU2MzZmLCAweDQzMTcyZjYwLFxuICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuICAweDkwYmVmZmZhLCAweDIzNjMxZTI4LCAweGE0NTA2Y2ViLCAweGRlODJiZGU5LFxuICAweGJlZjlhM2Y3LCAweGIyYzY3OTE1LCAweGM2NzE3OGYyLCAweGUzNzI1MzJiLFxuICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuICAweGVhZGE3ZGQ2LCAweGNkZTBlYjFlLCAweGY1N2Q0ZjdmLCAweGVlNmVkMTc4LFxuICAweDA2ZjA2N2FhLCAweDcyMTc2ZmJhLCAweDBhNjM3ZGM1LCAweGEyYzg5OGE2LFxuICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuICAweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0LCAweDMyY2FhYjdiLCAweDQwYzcyNDkzLFxuICAweDNjOWViZTBhLCAweDE1YzliZWJjLCAweDQzMWQ2N2M0LCAweDljMTAwZDRjLFxuICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuICAweDVmY2I2ZmFiLCAweDNhZDZmYWVjLCAweDZjNDQxOThjLCAweDRhNDc1ODE3XG5dXG5cbnZhciBXID0gbmV3IEFycmF5KDE2MClcblxuZnVuY3Rpb24gU2hhNTEyICgpIHtcbiAgdGhpcy5pbml0KClcbiAgdGhpcy5fdyA9IFdcblxuICBIYXNoLmNhbGwodGhpcywgMTI4LCAxMTIpXG59XG5cbmluaGVyaXRzKFNoYTUxMiwgSGFzaClcblxuU2hhNTEyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9haCA9IDB4NmEwOWU2NjdcbiAgdGhpcy5fYmggPSAweGJiNjdhZTg1XG4gIHRoaXMuX2NoID0gMHgzYzZlZjM3MlxuICB0aGlzLl9kaCA9IDB4YTU0ZmY1M2FcbiAgdGhpcy5fZWggPSAweDUxMGU1MjdmXG4gIHRoaXMuX2ZoID0gMHg5YjA1Njg4Y1xuICB0aGlzLl9naCA9IDB4MWY4M2Q5YWJcbiAgdGhpcy5faGggPSAweDViZTBjZDE5XG5cbiAgdGhpcy5fYWwgPSAweGYzYmNjOTA4XG4gIHRoaXMuX2JsID0gMHg4NGNhYTczYlxuICB0aGlzLl9jbCA9IDB4ZmU5NGY4MmJcbiAgdGhpcy5fZGwgPSAweDVmMWQzNmYxXG4gIHRoaXMuX2VsID0gMHhhZGU2ODJkMVxuICB0aGlzLl9mbCA9IDB4MmIzZTZjMWZcbiAgdGhpcy5fZ2wgPSAweGZiNDFiZDZiXG4gIHRoaXMuX2hsID0gMHgxMzdlMjE3OVxuXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIENoICh4LCB5LCB6KSB7XG4gIHJldHVybiB6IF4gKHggJiAoeSBeIHopKVxufVxuXG5mdW5jdGlvbiBtYWogKHgsIHksIHopIHtcbiAgcmV0dXJuICh4ICYgeSkgfCAoeiAmICh4IHwgeSkpXG59XG5cbmZ1bmN0aW9uIHNpZ21hMCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAyOCB8IHhsIDw8IDQpIF4gKHhsID4+PiAyIHwgeCA8PCAzMCkgXiAoeGwgPj4+IDcgfCB4IDw8IDI1KVxufVxuXG5mdW5jdGlvbiBzaWdtYTEgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMTQgfCB4bCA8PCAxOCkgXiAoeCA+Pj4gMTggfCB4bCA8PCAxNCkgXiAoeGwgPj4+IDkgfCB4IDw8IDIzKVxufVxuXG5mdW5jdGlvbiBHYW1tYTAgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcpXG59XG5cbmZ1bmN0aW9uIEdhbW1hMGwgKHgsIHhsKSB7XG4gIHJldHVybiAoeCA+Pj4gMSB8IHhsIDw8IDMxKSBeICh4ID4+PiA4IHwgeGwgPDwgMjQpIF4gKHggPj4+IDcgfCB4bCA8PCAyNSlcbn1cblxuZnVuY3Rpb24gR2FtbWExICh4LCB4bCkge1xuICByZXR1cm4gKHggPj4+IDE5IHwgeGwgPDwgMTMpIF4gKHhsID4+PiAyOSB8IHggPDwgMykgXiAoeCA+Pj4gNilcbn1cblxuZnVuY3Rpb24gR2FtbWExbCAoeCwgeGwpIHtcbiAgcmV0dXJuICh4ID4+PiAxOSB8IHhsIDw8IDEzKSBeICh4bCA+Pj4gMjkgfCB4IDw8IDMpIF4gKHggPj4+IDYgfCB4bCA8PCAyNilcbn1cblxuZnVuY3Rpb24gZ2V0Q2FycnkgKGEsIGIpIHtcbiAgcmV0dXJuIChhID4+PiAwKSA8IChiID4+PiAwKSA/IDEgOiAwXG59XG5cblNoYTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIChNKSB7XG4gIHZhciBXID0gdGhpcy5fd1xuXG4gIHZhciBhaCA9IHRoaXMuX2FoIHwgMFxuICB2YXIgYmggPSB0aGlzLl9iaCB8IDBcbiAgdmFyIGNoID0gdGhpcy5fY2ggfCAwXG4gIHZhciBkaCA9IHRoaXMuX2RoIHwgMFxuICB2YXIgZWggPSB0aGlzLl9laCB8IDBcbiAgdmFyIGZoID0gdGhpcy5fZmggfCAwXG4gIHZhciBnaCA9IHRoaXMuX2doIHwgMFxuICB2YXIgaGggPSB0aGlzLl9oaCB8IDBcblxuICB2YXIgYWwgPSB0aGlzLl9hbCB8IDBcbiAgdmFyIGJsID0gdGhpcy5fYmwgfCAwXG4gIHZhciBjbCA9IHRoaXMuX2NsIHwgMFxuICB2YXIgZGwgPSB0aGlzLl9kbCB8IDBcbiAgdmFyIGVsID0gdGhpcy5fZWwgfCAwXG4gIHZhciBmbCA9IHRoaXMuX2ZsIHwgMFxuICB2YXIgZ2wgPSB0aGlzLl9nbCB8IDBcbiAgdmFyIGhsID0gdGhpcy5faGwgfCAwXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSArPSAyKSB7XG4gICAgV1tpXSA9IE0ucmVhZEludDMyQkUoaSAqIDQpXG4gICAgV1tpICsgMV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0ICsgNClcbiAgfVxuICBmb3IgKDsgaSA8IDE2MDsgaSArPSAyKSB7XG4gICAgdmFyIHhoID0gV1tpIC0gMTUgKiAyXVxuICAgIHZhciB4bCA9IFdbaSAtIDE1ICogMiArIDFdXG4gICAgdmFyIGdhbW1hMCA9IEdhbW1hMCh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMGwgPSBHYW1tYTBsKHhsLCB4aClcblxuICAgIHhoID0gV1tpIC0gMiAqIDJdXG4gICAgeGwgPSBXW2kgLSAyICogMiArIDFdXG4gICAgdmFyIGdhbW1hMSA9IEdhbW1hMSh4aCwgeGwpXG4gICAgdmFyIGdhbW1hMWwgPSBHYW1tYTFsKHhsLCB4aClcblxuICAgIC8vIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XVxuICAgIHZhciBXaTdoID0gV1tpIC0gNyAqIDJdXG4gICAgdmFyIFdpN2wgPSBXW2kgLSA3ICogMiArIDFdXG5cbiAgICB2YXIgV2kxNmggPSBXW2kgLSAxNiAqIDJdXG4gICAgdmFyIFdpMTZsID0gV1tpIC0gMTYgKiAyICsgMV1cblxuICAgIHZhciBXaWwgPSAoZ2FtbWEwbCArIFdpN2wpIHwgMFxuICAgIHZhciBXaWggPSAoZ2FtbWEwICsgV2k3aCArIGdldENhcnJ5KFdpbCwgZ2FtbWEwbCkpIHwgMFxuICAgIFdpbCA9IChXaWwgKyBnYW1tYTFsKSB8IDBcbiAgICBXaWggPSAoV2loICsgZ2FtbWExICsgZ2V0Q2FycnkoV2lsLCBnYW1tYTFsKSkgfCAwXG4gICAgV2lsID0gKFdpbCArIFdpMTZsKSB8IDBcbiAgICBXaWggPSAoV2loICsgV2kxNmggKyBnZXRDYXJyeShXaWwsIFdpMTZsKSkgfCAwXG5cbiAgICBXW2ldID0gV2loXG4gICAgV1tpICsgMV0gPSBXaWxcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgMTYwOyBqICs9IDIpIHtcbiAgICBXaWggPSBXW2pdXG4gICAgV2lsID0gV1tqICsgMV1cblxuICAgIHZhciBtYWpoID0gbWFqKGFoLCBiaCwgY2gpXG4gICAgdmFyIG1hamwgPSBtYWooYWwsIGJsLCBjbClcblxuICAgIHZhciBzaWdtYTBoID0gc2lnbWEwKGFoLCBhbClcbiAgICB2YXIgc2lnbWEwbCA9IHNpZ21hMChhbCwgYWgpXG4gICAgdmFyIHNpZ21hMWggPSBzaWdtYTEoZWgsIGVsKVxuICAgIHZhciBzaWdtYTFsID0gc2lnbWExKGVsLCBlaClcblxuICAgIC8vIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tqXSArIFdbal1cbiAgICB2YXIgS2loID0gS1tqXVxuICAgIHZhciBLaWwgPSBLW2ogKyAxXVxuXG4gICAgdmFyIGNoaCA9IENoKGVoLCBmaCwgZ2gpXG4gICAgdmFyIGNobCA9IENoKGVsLCBmbCwgZ2wpXG5cbiAgICB2YXIgdDFsID0gKGhsICsgc2lnbWExbCkgfCAwXG4gICAgdmFyIHQxaCA9IChoaCArIHNpZ21hMWggKyBnZXRDYXJyeSh0MWwsIGhsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIGNobCkgfCAwXG4gICAgdDFoID0gKHQxaCArIGNoaCArIGdldENhcnJ5KHQxbCwgY2hsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIEtpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIEtpaCArIGdldENhcnJ5KHQxbCwgS2lsKSkgfCAwXG4gICAgdDFsID0gKHQxbCArIFdpbCkgfCAwXG4gICAgdDFoID0gKHQxaCArIFdpaCArIGdldENhcnJ5KHQxbCwgV2lsKSkgfCAwXG5cbiAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuICAgIHZhciB0MmwgPSAoc2lnbWEwbCArIG1hamwpIHwgMFxuICAgIHZhciB0MmggPSAoc2lnbWEwaCArIG1hamggKyBnZXRDYXJyeSh0MmwsIHNpZ21hMGwpKSB8IDBcblxuICAgIGhoID0gZ2hcbiAgICBobCA9IGdsXG4gICAgZ2ggPSBmaFxuICAgIGdsID0gZmxcbiAgICBmaCA9IGVoXG4gICAgZmwgPSBlbFxuICAgIGVsID0gKGRsICsgdDFsKSB8IDBcbiAgICBlaCA9IChkaCArIHQxaCArIGdldENhcnJ5KGVsLCBkbCkpIHwgMFxuICAgIGRoID0gY2hcbiAgICBkbCA9IGNsXG4gICAgY2ggPSBiaFxuICAgIGNsID0gYmxcbiAgICBiaCA9IGFoXG4gICAgYmwgPSBhbFxuICAgIGFsID0gKHQxbCArIHQybCkgfCAwXG4gICAgYWggPSAodDFoICsgdDJoICsgZ2V0Q2FycnkoYWwsIHQxbCkpIHwgMFxuICB9XG5cbiAgdGhpcy5fYWwgPSAodGhpcy5fYWwgKyBhbCkgfCAwXG4gIHRoaXMuX2JsID0gKHRoaXMuX2JsICsgYmwpIHwgMFxuICB0aGlzLl9jbCA9ICh0aGlzLl9jbCArIGNsKSB8IDBcbiAgdGhpcy5fZGwgPSAodGhpcy5fZGwgKyBkbCkgfCAwXG4gIHRoaXMuX2VsID0gKHRoaXMuX2VsICsgZWwpIHwgMFxuICB0aGlzLl9mbCA9ICh0aGlzLl9mbCArIGZsKSB8IDBcbiAgdGhpcy5fZ2wgPSAodGhpcy5fZ2wgKyBnbCkgfCAwXG4gIHRoaXMuX2hsID0gKHRoaXMuX2hsICsgaGwpIHwgMFxuXG4gIHRoaXMuX2FoID0gKHRoaXMuX2FoICsgYWggKyBnZXRDYXJyeSh0aGlzLl9hbCwgYWwpKSB8IDBcbiAgdGhpcy5fYmggPSAodGhpcy5fYmggKyBiaCArIGdldENhcnJ5KHRoaXMuX2JsLCBibCkpIHwgMFxuICB0aGlzLl9jaCA9ICh0aGlzLl9jaCArIGNoICsgZ2V0Q2FycnkodGhpcy5fY2wsIGNsKSkgfCAwXG4gIHRoaXMuX2RoID0gKHRoaXMuX2RoICsgZGggKyBnZXRDYXJyeSh0aGlzLl9kbCwgZGwpKSB8IDBcbiAgdGhpcy5fZWggPSAodGhpcy5fZWggKyBlaCArIGdldENhcnJ5KHRoaXMuX2VsLCBlbCkpIHwgMFxuICB0aGlzLl9maCA9ICh0aGlzLl9maCArIGZoICsgZ2V0Q2FycnkodGhpcy5fZmwsIGZsKSkgfCAwXG4gIHRoaXMuX2doID0gKHRoaXMuX2doICsgZ2ggKyBnZXRDYXJyeSh0aGlzLl9nbCwgZ2wpKSB8IDBcbiAgdGhpcy5faGggPSAodGhpcy5faGggKyBoaCArIGdldENhcnJ5KHRoaXMuX2hsLCBobCkpIHwgMFxufVxuXG5TaGE1MTIucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg2NClcblxuICBmdW5jdGlvbiB3cml0ZUludDY0QkUgKGgsIGwsIG9mZnNldCkge1xuICAgIEgud3JpdGVJbnQzMkJFKGgsIG9mZnNldClcbiAgICBILndyaXRlSW50MzJCRShsLCBvZmZzZXQgKyA0KVxuICB9XG5cbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2FoLCB0aGlzLl9hbCwgMClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2JoLCB0aGlzLl9ibCwgOClcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2NoLCB0aGlzLl9jbCwgMTYpXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9kaCwgdGhpcy5fZGwsIDI0KVxuICB3cml0ZUludDY0QkUodGhpcy5fZWgsIHRoaXMuX2VsLCAzMilcbiAgd3JpdGVJbnQ2NEJFKHRoaXMuX2ZoLCB0aGlzLl9mbCwgNDApXG4gIHdyaXRlSW50NjRCRSh0aGlzLl9naCwgdGhpcy5fZ2wsIDQ4KVxuICB3cml0ZUludDY0QkUodGhpcy5faGgsIHRoaXMuX2hsLCA1NilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTUxMlxuIiwidmFyIGlzSGV4UHJlZml4ZWQgPSByZXF1aXJlKCdpcy1oZXgtcHJlZml4ZWQnKTtcblxuLyoqXG4gKiBSZW1vdmVzICcweCcgZnJvbSBhIGdpdmVuIGBTdHJpbmdgIGlzIHByZXNlbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfE9wdGlvbmFsfSBhIHN0cmluZyBieSBwYXNzIGlmIG5lY2Vzc2FyeVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0cjtcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsImNvbnN0IGNvZGVzID0ge1xuICAvLyAweDAgcmFuZ2UgLSBhcml0aG1ldGljIG9wc1xuICAvLyBuYW1lLCBiYXNlQ29zdCwgb2ZmIHN0YWNrLCBvbiBzdGFja1xuICAweDAwOiBbJ1NUT1AnLCAwLCAwLCAwXSxcbiAgMHgwMTogWydBREQnLCAzLCAyLCAxXSxcbiAgMHgwMjogWydNVUwnLCA1LCAyLCAxXSxcbiAgMHgwMzogWydTVUInLCAzLCAyLCAxXSxcbiAgMHgwNDogWydESVYnLCA1LCAyLCAxXSxcbiAgMHgwNTogWydTRElWJywgNSwgMiwgMV0sXG4gIDB4MDY6IFsnTU9EJywgNSwgMiwgMV0sXG4gIDB4MDc6IFsnU01PRCcsIDUsIDIsIDFdLFxuICAweDA4OiBbJ0FERE1PRCcsIDgsIDMsIDFdLFxuICAweDA5OiBbJ01VTE1PRCcsIDgsIDMsIDFdLFxuICAweDBhOiBbJ0VYUCcsIDEwLCAyLCAxXSxcbiAgMHgwYjogWydTSUdORVhURU5EJywgNSwgMiwgMV0sXG5cbiAgLy8gMHgxMCByYW5nZSAtIGJpdCBvcHNcbiAgMHgxMDogWydMVCcsIDMsIDIsIDFdLFxuICAweDExOiBbJ0dUJywgMywgMiwgMV0sXG4gIDB4MTI6IFsnU0xUJywgMywgMiwgMV0sXG4gIDB4MTM6IFsnU0dUJywgMywgMiwgMV0sXG4gIDB4MTQ6IFsnRVEnLCAzLCAyLCAxXSxcbiAgMHgxNTogWydJU1pFUk8nLCAzLCAxLCAxXSxcbiAgMHgxNjogWydBTkQnLCAzLCAyLCAxXSxcbiAgMHgxNzogWydPUicsIDMsIDIsIDFdLFxuICAweDE4OiBbJ1hPUicsIDMsIDIsIDFdLFxuICAweDE5OiBbJ05PVCcsIDMsIDEsIDFdLFxuICAweDFhOiBbJ0JZVEUnLCAzLCAyLCAxXSxcbiAgMHgxYjogWydTSEwnLCAzLCAyLCAxXSxcbiAgMHgxYzogWydTSFInLCAzLCAyLCAxXSxcbiAgMHgxZDogWydTQVInLCAzLCAyLCAxXSxcblxuICAvLyAweDIwIHJhbmdlIC0gY3J5cHRvXG4gIDB4MjA6IFsnU0hBMycsIDMwLCAyLCAxXSxcblxuICAvLyAweDMwIHJhbmdlIC0gY2xvc3VyZSBzdGF0ZVxuICAweDMwOiBbJ0FERFJFU1MnLCAwLCAwLCAxXSxcbiAgMHgzMTogWydCQUxBTkNFJywgMCwgMSwgMV0sXG4gIDB4MzI6IFsnT1JJR0lOJywgMCwgMCwgMV0sXG4gIDB4MzM6IFsnQ0FMTEVSJywgMCwgMCwgMV0sXG4gIDB4MzQ6IFsnQ0FMTFZBTFVFJywgMCwgMCwgMV0sXG4gIDB4MzU6IFsnQ0FMTERBVEFMT0FEJywgMCwgMSwgMV0sXG4gIDB4MzY6IFsnQ0FMTERBVEFTSVpFJywgMCwgMCwgMV0sXG4gIDB4Mzc6IFsnQ0FMTERBVEFDT1BZJywgMCwgMywgMF0sXG4gIDB4Mzg6IFsnQ09ERVNJWkUnLCAwLCAwLCAxXSxcbiAgMHgzOTogWydDT0RFQ09QWScsIDAsIDMsIDBdLFxuICAweDNhOiBbJ0dBU1BSSUNFJywgMCwgMCwgMV0sXG4gIDB4M2I6IFsnRVhUQ09ERVNJWkUnLCAwLCAxLCAxXSxcbiAgMHgzYzogWydFWFRDT0RFQ09QWScsIDAsIDQsIDBdLFxuICAweDNkOiBbJ1JFVFVSTkRBVEFTSVpFJywgMCwgMCwgMV0sXG4gIDB4M2U6IFsnUkVUVVJOREFUQUNPUFknLCAwLCAzLCAwXSxcblxuICAvLyAnMHg0MCcgcmFuZ2UgLSBibG9jayBvcGVyYXRpb25zXG4gIDB4M2Y6IFsnRVhUQ09ERUhBU0gnLCAwLCAxLCAxXSxcbiAgMHg0MDogWydCTE9DS0hBU0gnLCAwLCAxLCAxXSxcbiAgMHg0MTogWydDT0lOQkFTRScsIDAsIDAsIDFdLFxuICAweDQyOiBbJ1RJTUVTVEFNUCcsIDAsIDAsIDFdLFxuICAweDQzOiBbJ05VTUJFUicsIDAsIDAsIDFdLFxuICAweDQ0OiBbJ0RJRkZJQ1VMVFknLCAwLCAwLCAxXSxcbiAgMHg0NTogWydHQVNMSU1JVCcsIDAsIDAsIDFdLFxuICAweDQ2OiBbJ0NIQUlOSUQnLCAyLCAwLCAxXSxcbiAgMHg0NzogWydTRUxGQkFMQU5DRScsIDUsIDAsIDFdLFxuICAweDQ4OiBbJ0JBU0VGRUUnLCAyLCAwLCAxXSxcblxuICAvLyAweDUwIHJhbmdlIC0gJ3N0b3JhZ2UnIGFuZCBleGVjdXRpb25cbiAgMHg1MDogWydQT1AnLCAyLCAxLCAwXSxcbiAgMHg1MTogWydNTE9BRCcsIDMsIDEsIDFdLFxuICAweDUyOiBbJ01TVE9SRScsIDMsIDIsIDBdLFxuICAweDUzOiBbJ01TVE9SRTgnLCAzLCAyLCAwXSxcbiAgMHg1NDogWydTTE9BRCcsIDAsIDEsIDFdLFxuICAweDU1OiBbJ1NTVE9SRScsIDAsIDIsIDBdLFxuICAweDU2OiBbJ0pVTVAnLCA4LCAwLCAwXSxcbiAgMHg1NzogWydKVU1QSScsIDEwLCAwLCAwXSxcbiAgMHg1ODogWydQQycsIDIsIDAsIDFdLFxuICAweDU5OiBbJ01TSVpFJywgMiwgMCwgMV0sXG4gIDB4NWE6IFsnR0FTJywgMCwgMCwgMV0sXG4gIDB4NWI6IFsnSlVNUERFU1QnLCAwLCAwLCAwXSxcblxuICAvLyAweDYwLCByYW5nZVxuICAweDYwOiBbJ1BVU0gnLCAzLCAwLCAxXSxcbiAgMHg2MTogWydQVVNIJywgMywgMCwgMV0sXG4gIDB4NjI6IFsnUFVTSCcsIDMsIDAsIDFdLFxuICAweDYzOiBbJ1BVU0gnLCAzLCAwLCAxXSxcbiAgMHg2NDogWydQVVNIJywgMywgMCwgMV0sXG4gIDB4NjU6IFsnUFVTSCcsIDMsIDAsIDFdLFxuICAweDY2OiBbJ1BVU0gnLCAzLCAwLCAxXSxcbiAgMHg2NzogWydQVVNIJywgMywgMCwgMV0sXG4gIDB4Njg6IFsnUFVTSCcsIDMsIDAsIDFdLFxuICAweDY5OiBbJ1BVU0gnLCAzLCAwLCAxXSxcbiAgMHg2YTogWydQVVNIJywgMywgMCwgMV0sXG4gIDB4NmI6IFsnUFVTSCcsIDMsIDAsIDFdLFxuICAweDZjOiBbJ1BVU0gnLCAzLCAwLCAxXSxcbiAgMHg2ZDogWydQVVNIJywgMywgMCwgMV0sXG4gIDB4NmU6IFsnUFVTSCcsIDMsIDAsIDFdLFxuICAweDZmOiBbJ1BVU0gnLCAzLCAwLCAxXSxcbiAgMHg3MDogWydQVVNIJywgMywgMCwgMV0sXG4gIDB4NzE6IFsnUFVTSCcsIDMsIDAsIDFdLFxuICAweDcyOiBbJ1BVU0gnLCAzLCAwLCAxXSxcbiAgMHg3MzogWydQVVNIJywgMywgMCwgMV0sXG4gIDB4NzQ6IFsnUFVTSCcsIDMsIDAsIDFdLFxuICAweDc1OiBbJ1BVU0gnLCAzLCAwLCAxXSxcbiAgMHg3NjogWydQVVNIJywgMywgMCwgMV0sXG4gIDB4Nzc6IFsnUFVTSCcsIDMsIDAsIDFdLFxuICAweDc4OiBbJ1BVU0gnLCAzLCAwLCAxXSxcbiAgMHg3OTogWydQVVNIJywgMywgMCwgMV0sXG4gIDB4N2E6IFsnUFVTSCcsIDMsIDAsIDFdLFxuICAweDdiOiBbJ1BVU0gnLCAzLCAwLCAxXSxcbiAgMHg3YzogWydQVVNIJywgMywgMCwgMV0sXG4gIDB4N2Q6IFsnUFVTSCcsIDMsIDAsIDFdLFxuICAweDdlOiBbJ1BVU0gnLCAzLCAwLCAxXSxcbiAgMHg3ZjogWydQVVNIJywgMywgMCwgMV0sXG5cbiAgMHg4MDogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4MTogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4MjogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4MzogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4NDogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4NTogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4NjogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4NzogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4ODogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4OTogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4YTogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4YjogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4YzogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4ZDogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4ZTogWydEVVAnLCAzLCAwLCAxXSxcbiAgMHg4ZjogWydEVVAnLCAzLCAwLCAxXSxcblxuICAweDkwOiBbJ1NXQVAnLCAzLCAwLCAwXSxcbiAgMHg5MTogWydTV0FQJywgMywgMCwgMF0sXG4gIDB4OTI6IFsnU1dBUCcsIDMsIDAsIDBdLFxuICAweDkzOiBbJ1NXQVAnLCAzLCAwLCAwXSxcbiAgMHg5NDogWydTV0FQJywgMywgMCwgMF0sXG4gIDB4OTU6IFsnU1dBUCcsIDMsIDAsIDBdLFxuICAweDk2OiBbJ1NXQVAnLCAzLCAwLCAwXSxcbiAgMHg5NzogWydTV0FQJywgMywgMCwgMF0sXG4gIDB4OTg6IFsnU1dBUCcsIDMsIDAsIDBdLFxuICAweDk5OiBbJ1NXQVAnLCAzLCAwLCAwXSxcbiAgMHg5YTogWydTV0FQJywgMywgMCwgMF0sXG4gIDB4OWI6IFsnU1dBUCcsIDMsIDAsIDBdLFxuICAweDljOiBbJ1NXQVAnLCAzLCAwLCAwXSxcbiAgMHg5ZDogWydTV0FQJywgMywgMCwgMF0sXG4gIDB4OWU6IFsnU1dBUCcsIDMsIDAsIDBdLFxuICAweDlmOiBbJ1NXQVAnLCAzLCAwLCAwXSxcblxuICAweGEwOiBbJ0xPRycsIDAsIDIsIDBdLFxuICAweGExOiBbJ0xPRycsIDAsIDMsIDBdLFxuICAweGEyOiBbJ0xPRycsIDAsIDQsIDBdLFxuICAweGEzOiBbJ0xPRycsIDAsIDUsIDBdLFxuICAweGE0OiBbJ0xPRycsIDAsIDYsIDBdLFxuXG4gIC8vICcweGYwJyByYW5nZSAtIGNsb3N1cmVzXG4gIDB4ZjA6IFsnQ1JFQVRFJywgMCwgMywgMV0sXG4gIDB4ZjE6IFsnQ0FMTCcsIDAsIDcsIDFdLFxuICAweGYyOiBbJ0NBTExDT0RFJywgMCwgNywgMV0sXG4gIDB4ZjM6IFsnUkVUVVJOJywgMCwgMiwgMF0sXG4gIDB4ZjQ6IFsnREVMRUdBVEVDQUxMJywgMCwgNiwgMV0sXG4gIDB4ZjU6IFsnQ1JFQVRFMicsIDAsIDQsIDFdLFxuICAweGZhOiBbJ1NUQVRJQ0NBTEwnLCAwLCA2LCAxXSxcblxuICAvLyAnMHg3MCcsIHJhbmdlIC0gb3RoZXJcbiAgMHhmZDogWydSRVZFUlQnLCAwLCAyLCAwXSxcbiAgMHhmZTogWydJTlZBTElEJywgMCwgMCwgMF0sXG4gIDB4ZmY6IFsnU0VMRkRFU1RSVUNUJywgMCwgMSwgMF1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3ApIHtcbiAgLy8gTWFwIGludmFsaWQgb3Bjb2RlcyB0byB0aGUgSU5WQUxJRCBvcGNvZGVcbiAgaWYgKCFjb2Rlc1tvcF0gJiYgb3AgIT0gMHhmZSkge1xuICAgIGNvbnNvbGUuaW5mbyhcIk9wY29kZSBub3Qgc3VwcG9ydGVkIG9yIHBhcnQgb2YgdGhlIG1ldGFkYXRhIHRhaWw6IFwiLCBvcC50b1N0cmluZygxNikpO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBjb2Rlc1tvcF0gPyBjb2Rlc1tvcF0gOiBjb2Rlc1sweGZlXVxuICBsZXQgb3Bjb2RlID0gY29kZVswXVxuICBsZXQgbnVtYmVyXG5cbiAgc3dpdGNoIChvcGNvZGUpIHtcbiAgICBjYXNlICdMT0cnOlxuICAgICAgbnVtYmVyID0gb3AgLSAweGEwXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnUFVTSCc6XG4gICAgICBudW1iZXIgPSBvcCAtIDB4NWZcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlICdEVVAnOlxuICAgICAgbnVtYmVyID0gb3AgLSAweDdmXG4gICAgICBicmVha1xuXG4gICAgY2FzZSAnU1dBUCc6XG4gICAgICBudW1iZXIgPSBvcCAtIDB4OGZcbiAgICAgIGJyZWFrXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5hbWU6IG9wY29kZSxcbiAgICBmZWU6IGNvZGVbMV0sXG4gICAgb2ZmOiBjb2RlWzJdLFxuICAgIG9uOiBjb2RlWzNdLFxuICAgIG51bWJlcjogbnVtYmVyXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJMT0dcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRMT0dcXG4gIChwYXJhbSAkbnVtYmVyIGkzMilcXG5cXG4gIChsb2NhbCAkb2Zmc2V0IGkzMilcXG4gIChsb2NhbCAkb2Zmc2V0MCBpNjQpXFxuICAobG9jYWwgJG9mZnNldDEgaTY0KVxcbiAgKGxvY2FsICRvZmZzZXQyIGk2NClcXG4gIChsb2NhbCAkb2Zmc2V0MyBpNjQpXFxuXFxuICAobG9jYWwgJGxlbmd0aCBpMzIpXFxuICAobG9jYWwgJGxlbmd0aDAgaTY0KVxcbiAgKGxvY2FsICRsZW5ndGgxIGk2NClcXG4gIChsb2NhbCAkbGVuZ3RoMiBpNjQpXFxuICAobG9jYWwgJGxlbmd0aDMgaTY0KVxcblxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MCAoaTY0LmxvYWQgICAgICAgICAgKGdsb2JhbC5nZXQgJHNwKSkpXFxuICAobG9jYWwuc2V0ICRvZmZzZXQxIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkpXFxuICAobG9jYWwuc2V0ICRvZmZzZXQyIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRvZmZzZXQzIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuXFxuICAobG9jYWwuc2V0ICRsZW5ndGgwIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkpXFxuICAobG9jYWwuc2V0ICRsZW5ndGgxIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRsZW5ndGgyIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRsZW5ndGgzIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkpXFxuXFxuICAobG9jYWwuc2V0ICRvZmZzZXRcXG4gICAgICAgICAgICAgKGNhbGwgJGNoZWNrX292ZXJmbG93IChsb2NhbC5nZXQgJG9mZnNldDApXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRvZmZzZXQxKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0MilcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJG9mZnNldDMpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGxlbmd0aFxcbiAgICAgICAgICAgICAoY2FsbCAkY2hlY2tfb3ZlcmZsb3cgKGxvY2FsLmdldCAkbGVuZ3RoMClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGxlbmd0aDEpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRsZW5ndGgyKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkbGVuZ3RoMykpKVxcblxcbiAgKGNhbGwgJG1lbXVzZWdhcyAobG9jYWwuZ2V0ICRvZmZzZXQpIChsb2NhbC5nZXQgJGxlbmd0aCkpXFxuXFxuICAoaWYgKGkzMi5lcSAobG9jYWwuZ2V0ICRudW1iZXIpIChpMzIuY29uc3QgMCkpXFxuICAgICh0aGVuXFxuICAgICAgKGNhbGwgJGxvZ1xcbiAgICAgICAgICAgICAobG9jYWwuZ2V0ICRvZmZzZXQpXFxuICAgICAgICAgICAgIChsb2NhbC5nZXQgJGxlbmd0aClcXG4gICAgICAgICAgICAgKGxvY2FsLmdldCAkbnVtYmVyKVxcbiAgICAgICAgICAgICAoaTMyLmNvbnN0ICAwKVxcbiAgICAgICAgICAgICAoaTMyLmNvbnN0ICAwKVxcbiAgICAgICAgICAgICAoaTMyLmNvbnN0ICAwKVxcbiAgICAgICAgICAgICAoaTMyLmNvbnN0ICAwKSlcXG4gICAgKVxcbiAgKVxcbiAgKGlmIChpMzIuZXEgKGxvY2FsLmdldCAkbnVtYmVyKSAoaTMyLmNvbnN0IDEpKVxcbiAgICAodGhlblxcbiAgICAoY2FsbCAkbG9nXFxuICAgICAgICAgICAgIChsb2NhbC5nZXQgJG9mZnNldClcXG4gICAgICAgICAgICAgKGxvY2FsLmdldCAkbGVuZ3RoKVxcbiAgICAgICAgICAgICAobG9jYWwuZ2V0ICRudW1iZXIpXFxuICAgICAgICAgICAgIChjYWxsICRic3dhcF9tMjU2IChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgNjQpKSlcXG4gICAgICAgICAgICAgKGkzMi5jb25zdCAgMClcXG4gICAgICAgICAgICAgKGkzMi5jb25zdCAgMClcXG4gICAgICAgICAgICAgKGkzMi5jb25zdCAgMCkpXFxuICAgIClcXG4gIClcXG4gIChpZiAoaTMyLmVxIChsb2NhbC5nZXQgJG51bWJlcikgKGkzMi5jb25zdCAyKSlcXG4gICAgKHRoZW5cXG4gICAgKGNhbGwgJGxvZ1xcbiAgICAgICAgICAgICAobG9jYWwuZ2V0ICRvZmZzZXQpXFxuICAgICAgICAgICAgIChsb2NhbC5nZXQgJGxlbmd0aClcXG4gICAgICAgICAgICAgKGxvY2FsLmdldCAkbnVtYmVyKVxcbiAgICAgICAgICAgICAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDY0KSkpXFxuICAgICAgICAgICAgIChjYWxsICRic3dhcF9tMjU2IChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOTYpKSlcXG4gICAgICAgICAgICAgKGkzMi5jb25zdCAgMClcXG4gICAgICAgICAgICAgKGkzMi5jb25zdCAgMCkpXFxuICAgIClcXG4gIClcXG4gIChpZiAoaTMyLmVxIChsb2NhbC5nZXQgJG51bWJlcikgKGkzMi5jb25zdCAzKSlcXG4gICAgKHRoZW5cXG4gICAgKGNhbGwgJGxvZ1xcbiAgICAgICAgICAgICAobG9jYWwuZ2V0ICRvZmZzZXQpXFxuICAgICAgICAgICAgIChsb2NhbC5nZXQgJGxlbmd0aClcXG4gICAgICAgICAgICAgKGxvY2FsLmdldCAkbnVtYmVyKVxcbiAgICAgICAgICAgICAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDY0KSkpXFxuICAgICAgICAgICAgIChjYWxsICRic3dhcF9tMjU2IChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOTYpKSlcXG4gICAgICAgICAgICAgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDEyOCkpKVxcbiAgICAgICAgICAgICAoaTMyLmNvbnN0ICAwKSlcXG4gICAgKVxcbiAgKVxcbiAgKGlmIChpMzIuZXEgKGxvY2FsLmdldCAkbnVtYmVyKSAoaTMyLmNvbnN0IDQpKVxcbiAgICAodGhlblxcbiAgICAoY2FsbCAkbG9nXFxuICAgICAgICAgICAgIChsb2NhbC5nZXQgJG9mZnNldClcXG4gICAgICAgICAgICAgKGxvY2FsLmdldCAkbGVuZ3RoKVxcbiAgICAgICAgICAgICAobG9jYWwuZ2V0ICRudW1iZXIpXFxuICAgICAgICAgICAgIChjYWxsICRic3dhcF9tMjU2IChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgNjQpKSlcXG4gICAgICAgICAgICAgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA5NikpKVxcbiAgICAgICAgICAgICAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTI4KSkpXFxuICAgICAgICAgICAgIChjYWxsICRic3dhcF9tMjU2IChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNjApKSkpXFxuICAgIClcXG4gIClcXG4pXFxuXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fbG9nXFxcIiAoZnVuYyAkbG9nIChwYXJhbSBpMzIgaTMyIGkzMiBpMzIgaTMyIGkzMiBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiTE9HXFxcIiAoZnVuYyAkTE9HKSlcIlxuICB9LFxuICBcIkNBTExEQVRBTE9BRFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgc3RhY2s6XFxuOzsgIDA6IGRhdGFPZmZzZXRcXG4oZnVuYyAkQ0FMTERBVEFMT0FEXFxuICAobG9jYWwgJHdyaXRlT2Zmc2V0IGkzMilcXG4gIChsb2NhbCAkd3JpdGVPZmZzZXQwIGk2NClcXG4gIChsb2NhbCAkd3JpdGVPZmZzZXQxIGk2NClcXG4gIChsb2NhbCAkd3JpdGVPZmZzZXQyIGk2NClcXG4gIChsb2NhbCAkd3JpdGVPZmZzZXQzIGk2NClcXG5cXG4gIChsb2NhbC5zZXQgJHdyaXRlT2Zmc2V0MCAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICAwKSkpKVxcbiAgKGxvY2FsLnNldCAkd3JpdGVPZmZzZXQxIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkpXFxuICAobG9jYWwuc2V0ICR3cml0ZU9mZnNldDIgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJHdyaXRlT2Zmc2V0MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDApKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAoaTY0LmNvbnN0IDApKVxcblxcbiAgKGxvY2FsLnNldCAkd3JpdGVPZmZzZXRcXG4gICAgICAgICAgICAgKGNhbGwgJGNoZWNrX292ZXJmbG93IChsb2NhbC5nZXQgJHdyaXRlT2Zmc2V0MClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJHdyaXRlT2Zmc2V0MSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJHdyaXRlT2Zmc2V0MilcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJHdyaXRlT2Zmc2V0MykpKVxcblxcbiAgKGNhbGwgJGNhbGxEYXRhQ29weSAoZ2xvYmFsLmdldCAkc3ApIChsb2NhbC5nZXQgJHdyaXRlT2Zmc2V0KSAoaTMyLmNvbnN0IDMyKSlcXG4gIDs7IHN3YXAgdG9wIHN0YWNrIGl0ZW1cXG4gIChkcm9wIChjYWxsICRic3dhcF9tMjU2IChnbG9iYWwuZ2V0ICRzcCkpKVxcbilcXG5cIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9jYWxsRGF0YUNvcHlcXFwiIChmdW5jICRjYWxsRGF0YUNvcHkgKHBhcmFtIGkzMiBpMzIgaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkNBTExEQVRBTE9BRFxcXCIgKGZ1bmMgJENBTExEQVRBTE9BRCkpXCJcbiAgfSxcbiAgXCJHQVNcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkR0FTICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSAoY2FsbCAkZ2V0R2FzTGVmdCkpXFxuICAgIDs7IHplcm8gb3V0IG1lbVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA1NikpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDQ4KSkgKGk2NC5jb25zdCAwKSlcXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNDApKSAoaTY0LmNvbnN0IDApKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRHYXNMZWZ0XFxcIiAoZnVuYyAkZ2V0R2FzTGVmdCAgKHJlc3VsdCBpNjQpKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJHQVNcXFwiIChmdW5jICRHQVMpKVwiXG4gIH0sXG4gIFwiQUREUkVTU1wiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRBRERSRVNTICAgKGNhbGwgJGdldEFkZHJlc3MoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkoZHJvcCAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2dldEFkZHJlc3NcXFwiIChmdW5jICRnZXRBZGRyZXNzIChwYXJhbSBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQUREUkVTU1xcXCIgKGZ1bmMgJEFERFJFU1MpKVwiXG4gIH0sXG4gIFwiQkFMQU5DRVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRCQUxBTkNFIChwYXJhbSAkY2FsbGJhY2sgaTMyKSAgKGNhbGwgJGdldEV4dGVybmFsQmFsYW5jZShjYWxsICRic3dhcF9tMjU2IChnbG9iYWwuZ2V0ICRzcCkpKGdsb2JhbC5nZXQgJHNwKShsb2NhbC5nZXQgJGNhbGxiYWNrKSkoZHJvcCAoY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0RXh0ZXJuYWxCYWxhbmNlXFxcIiAoZnVuYyAkZ2V0RXh0ZXJuYWxCYWxhbmNlIChwYXJhbSBpMzIgaTMyIGkzMikgKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJCQUxBTkNFXFxcIiAoZnVuYyAkQkFMQU5DRSkpXCJcbiAgfSxcbiAgXCJTRUxGQkFMQU5DRVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRTRUxGQkFMQU5DRSAocGFyYW0gJGNhbGxiYWNrIGkzMikgIChjYWxsICRnZXRCYWxhbmNlKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkobG9jYWwuZ2V0ICRjYWxsYmFjaykpKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRCYWxhbmNlXFxcIiAoZnVuYyAkZ2V0QmFsYW5jZSAocGFyYW0gaTMyIGkzMikgKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJTRUxGQkFMQU5DRVxcXCIgKGZ1bmMgJFNFTEZCQUxBTkNFKSlcIlxuICB9LFxuICBcIkNIQUlOSURcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkQ0hBSU5JRCAocGFyYW0gJGNhbGxiYWNrIGkzMikgIChjYWxsICRnZXRDaGFpbklkKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkobG9jYWwuZ2V0ICRjYWxsYmFjaykpKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRDaGFpbklkXFxcIiAoZnVuYyAkZ2V0Q2hhaW5JZCAocGFyYW0gaTMyIGkzMikgKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJDSEFJTklEXFxcIiAoZnVuYyAkQ0hBSU5JRCkpXCJcbiAgfSxcbiAgXCJCQVNFRkVFXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJEJBU0VGRUUgKHBhcmFtICRjYWxsYmFjayBpMzIpICAoY2FsbCAkZ2V0QmFzZUZlZShpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKGxvY2FsLmdldCAkY2FsbGJhY2spKShkcm9wIChjYWxsICRic3dhcF9tMjU2IChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0QmFzZUZlZVxcXCIgKGZ1bmMgJGdldEJhc2VGZWUgKHBhcmFtIGkzMiBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQkFTRUZFRVxcXCIgKGZ1bmMgJEJBU0VGRUUpKVwiXG4gIH0sXG4gIFwiT1JJR0lOXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJE9SSUdJTiAgIChjYWxsICRnZXRUeE9yaWdpbihpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKShkcm9wIChjYWxsICRic3dhcF9tMjU2IChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0VHhPcmlnaW5cXFwiIChmdW5jICRnZXRUeE9yaWdpbiAocGFyYW0gaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIk9SSUdJTlxcXCIgKGZ1bmMgJE9SSUdJTikpXCJcbiAgfSxcbiAgXCJDQUxMRVJcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkQ0FMTEVSICAgKGNhbGwgJGdldENhbGxlcihpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKShkcm9wIChjYWxsICRic3dhcF9tMjU2IChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0Q2FsbGVyXFxcIiAoZnVuYyAkZ2V0Q2FsbGVyIChwYXJhbSBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQ0FMTEVSXFxcIiAoZnVuYyAkQ0FMTEVSKSlcIlxuICB9LFxuICBcIkNBTExWQUxVRVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRDQUxMVkFMVUUgICAoY2FsbCAkZ2V0Q2FsbFZhbHVlKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRDYWxsVmFsdWVcXFwiIChmdW5jICRnZXRDYWxsVmFsdWUgKHBhcmFtIGkzMikgKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJDQUxMVkFMVUVcXFwiIChmdW5jICRDQUxMVkFMVUUpKVwiXG4gIH0sXG4gIFwiQ0FMTERBVEFTSVpFXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJENBTExEQVRBU0laRSAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkgKGk2NC5leHRlbmRfaTMyX3UgKGNhbGwgJGdldENhbGxEYXRhU2l6ZSkpKVxcbiAgICA7OyB6ZXJvIG91dCBtZW1cXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNTYpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA0OCkpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDQwKSkgKGk2NC5jb25zdCAwKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0Q2FsbERhdGFTaXplXFxcIiAoZnVuYyAkZ2V0Q2FsbERhdGFTaXplICAocmVzdWx0IGkzMikpKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkNBTExEQVRBU0laRVxcXCIgKGZ1bmMgJENBTExEQVRBU0laRSkpXCJcbiAgfSxcbiAgXCJDQUxMREFUQUNPUFlcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkQ0FMTERBVEFDT1BZIChsb2NhbCAkb2Zmc2V0MCBpMzIpKGxvY2FsICRsZW5ndGgwIGkzMikgKGxvY2FsLnNldCAkb2Zmc2V0MCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChnbG9iYWwuZ2V0ICRzcCkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpKShsb2NhbC5zZXQgJGxlbmd0aDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTY0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTU2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQ4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQwKSkpKSlcXG4gICAgKGNhbGwgJG1lbXVzZWdhcyAobG9jYWwuZ2V0ICRvZmZzZXQwKSAobG9jYWwuZ2V0ICRsZW5ndGgwKSlcXG4gICAgKGxvY2FsLnNldCAkb2Zmc2V0MCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpIChsb2NhbC5nZXQgJG9mZnNldDApKSkgKGNhbGwgJGNhbGxEYXRhQ29weShsb2NhbC5nZXQgJG9mZnNldDApKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTMyKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTI0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTgpKSkpKGxvY2FsLmdldCAkbGVuZ3RoMCkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2NhbGxEYXRhQ29weVxcXCIgKGZ1bmMgJGNhbGxEYXRhQ29weSAocGFyYW0gaTMyIGkzMiBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQ0FMTERBVEFDT1BZXFxcIiAoZnVuYyAkQ0FMTERBVEFDT1BZKSlcIlxuICB9LFxuICBcIkNPREVTSVpFXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJENPREVTSVpFIChwYXJhbSAkY2FsbGJhY2sgaTMyKSAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSAoaTY0LmV4dGVuZF9pMzJfdSAoY2FsbCAkZ2V0Q29kZVNpemUobG9jYWwuZ2V0ICRjYWxsYmFjaykpKSlcXG4gICAgOzsgemVybyBvdXQgbWVtXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDU2KSkgKGk2NC5jb25zdCAwKSlcXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA0MCkpIChpNjQuY29uc3QgMCkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2dldENvZGVTaXplXFxcIiAoZnVuYyAkZ2V0Q29kZVNpemUgKHBhcmFtIGkzMikgKHJlc3VsdCBpMzIpKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJDT0RFU0laRVxcXCIgKGZ1bmMgJENPREVTSVpFKSlcIlxuICB9LFxuICBcIkNPREVDT1BZXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJENPREVDT1BZIChwYXJhbSAkY2FsbGJhY2sgaTMyKShsb2NhbCAkb2Zmc2V0MCBpMzIpKGxvY2FsICRsZW5ndGgwIGkzMikgKGxvY2FsLnNldCAkb2Zmc2V0MCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChnbG9iYWwuZ2V0ICRzcCkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpKShsb2NhbC5zZXQgJGxlbmd0aDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTY0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTU2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQ4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQwKSkpKSlcXG4gICAgKGNhbGwgJG1lbXVzZWdhcyAobG9jYWwuZ2V0ICRvZmZzZXQwKSAobG9jYWwuZ2V0ICRsZW5ndGgwKSlcXG4gICAgKGxvY2FsLnNldCAkb2Zmc2V0MCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpIChsb2NhbC5nZXQgJG9mZnNldDApKSkgKGNhbGwgJGNvZGVDb3B5KGxvY2FsLmdldCAkb2Zmc2V0MCkoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMzIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMjQpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtOCkpKSkobG9jYWwuZ2V0ICRsZW5ndGgwKShsb2NhbC5nZXQgJGNhbGxiYWNrKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fY29kZUNvcHlcXFwiIChmdW5jICRjb2RlQ29weSAocGFyYW0gaTMyIGkzMiBpMzIgaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkNPREVDT1BZXFxcIiAoZnVuYyAkQ09ERUNPUFkpKVwiXG4gIH0sXG4gIFwiRVhUQ09ERVNJWkVcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkRVhUQ09ERVNJWkUgKHBhcmFtICRjYWxsYmFjayBpMzIpICAoaTY0LnN0b3JlIChnbG9iYWwuZ2V0ICRzcCkgKGk2NC5leHRlbmRfaTMyX3UgKGNhbGwgJGdldEV4dGVybmFsQ29kZVNpemUoY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKShsb2NhbC5nZXQgJGNhbGxiYWNrKSkpKVxcbiAgICA7OyB6ZXJvIG91dCBtZW1cXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSAoaTY0LmNvbnN0IDApKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRFeHRlcm5hbENvZGVTaXplXFxcIiAoZnVuYyAkZ2V0RXh0ZXJuYWxDb2RlU2l6ZSAocGFyYW0gaTMyIGkzMikgKHJlc3VsdCBpMzIpKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJFWFRDT0RFU0laRVxcXCIgKGZ1bmMgJEVYVENPREVTSVpFKSlcIlxuICB9LFxuICBcIkVYVENPREVIQVNIXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJEVYVENPREVIQVNIIChwYXJhbSAkY2FsbGJhY2sgaTMyKSAgKGNhbGwgJGdldEV4dGVybmFsQ29kZUhhc2goY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKShnbG9iYWwuZ2V0ICRzcCkobG9jYWwuZ2V0ICRjYWxsYmFjaykpKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGdsb2JhbC5nZXQgJHNwKSkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2dldEV4dGVybmFsQ29kZUhhc2hcXFwiIChmdW5jICRnZXRFeHRlcm5hbENvZGVIYXNoIChwYXJhbSBpMzIgaTMyIGkzMikgKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJFWFRDT0RFSEFTSFxcXCIgKGZ1bmMgJEVYVENPREVIQVNIKSlcIlxuICB9LFxuICBcIkVYVENPREVDT1BZXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJEVYVENPREVDT1BZIChwYXJhbSAkY2FsbGJhY2sgaTMyKShsb2NhbCAkb2Zmc2V0MCBpMzIpKGxvY2FsICRsZW5ndGgwIGkzMikgKGxvY2FsLnNldCAkb2Zmc2V0MCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMzIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMjQpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtOCkpKSkpKGxvY2FsLnNldCAkbGVuZ3RoMCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtOTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtODgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtODApKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNzIpKSkpKVxcbiAgICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJG9mZnNldDApIChsb2NhbC5nZXQgJGxlbmd0aDApKVxcbiAgICAobG9jYWwuc2V0ICRvZmZzZXQwIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkgKGxvY2FsLmdldCAkb2Zmc2V0MCkpKSAoY2FsbCAkZXh0ZXJuYWxDb2RlQ29weShjYWxsICRic3dhcF9tMjU2IChnbG9iYWwuZ2V0ICRzcCkpKGxvY2FsLmdldCAkb2Zmc2V0MCkoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNjQpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNDgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNDApKSkpKGxvY2FsLmdldCAkbGVuZ3RoMCkobG9jYWwuZ2V0ICRjYWxsYmFjaykpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2V4dGVybmFsQ29kZUNvcHlcXFwiIChmdW5jICRleHRlcm5hbENvZGVDb3B5IChwYXJhbSBpMzIgaTMyIGkzMiBpMzIgaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkVYVENPREVDT1BZXFxcIiAoZnVuYyAkRVhUQ09ERUNPUFkpKVwiXG4gIH0sXG4gIFwiR0FTUFJJQ0VcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkR0FTUFJJQ0UgICAoY2FsbCAkZ2V0VHhHYXNQcmljZShpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKShkcm9wIChjYWxsICRic3dhcF9tMjU2IChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0VHhHYXNQcmljZVxcXCIgKGZ1bmMgJGdldFR4R2FzUHJpY2UgKHBhcmFtIGkzMikgKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJHQVNQUklDRVxcXCIgKGZ1bmMgJEdBU1BSSUNFKSlcIlxuICB9LFxuICBcIkJMT0NLSEFTSFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRCTE9DS0hBU0ggKHBhcmFtICRjYWxsYmFjayBpMzIpICAoY2FsbCAkZ2V0QmxvY2tIYXNoKGNhbGwgJGNoZWNrX292ZXJmbG93X2k2NFxcbiAgICAgICAgICAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkoZ2xvYmFsLmdldCAkc3ApKGxvY2FsLmdldCAkY2FsbGJhY2spKShkcm9wIChjYWxsICRic3dhcF9tMjU2IChnbG9iYWwuZ2V0ICRzcCkpKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRCbG9ja0hhc2hcXFwiIChmdW5jICRnZXRCbG9ja0hhc2ggKHBhcmFtIGk2NCBpMzIgaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkJMT0NLSEFTSFxcXCIgKGZ1bmMgJEJMT0NLSEFTSCkpXCJcbiAgfSxcbiAgXCJDT0lOQkFTRVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRDT0lOQkFTRSAgIChjYWxsICRnZXRCbG9ja0NvaW5iYXNlKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRCbG9ja0NvaW5iYXNlXFxcIiAoZnVuYyAkZ2V0QmxvY2tDb2luYmFzZSAocGFyYW0gaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkNPSU5CQVNFXFxcIiAoZnVuYyAkQ09JTkJBU0UpKVwiXG4gIH0sXG4gIFwiVElNRVNUQU1QXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJFRJTUVTVEFNUCAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkgKGNhbGwgJGdldEJsb2NrVGltZXN0YW1wKSlcXG4gICAgOzsgemVybyBvdXQgbWVtXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDU2KSkgKGk2NC5jb25zdCAwKSlcXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA0MCkpIChpNjQuY29uc3QgMCkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2dldEJsb2NrVGltZXN0YW1wXFxcIiAoZnVuYyAkZ2V0QmxvY2tUaW1lc3RhbXAgIChyZXN1bHQgaTY0KSkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiVElNRVNUQU1QXFxcIiAoZnVuYyAkVElNRVNUQU1QKSlcIlxuICB9LFxuICBcIk5VTUJFUlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICROVU1CRVIgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpIChjYWxsICRnZXRCbG9ja051bWJlcikpXFxuICAgIDs7IHplcm8gb3V0IG1lbVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA1NikpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDQ4KSkgKGk2NC5jb25zdCAwKSlcXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNDApKSAoaTY0LmNvbnN0IDApKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRCbG9ja051bWJlclxcXCIgKGZ1bmMgJGdldEJsb2NrTnVtYmVyICAocmVzdWx0IGk2NCkpKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIk5VTUJFUlxcXCIgKGZ1bmMgJE5VTUJFUikpXCJcbiAgfSxcbiAgXCJESUZGSUNVTFRZXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJERJRkZJQ1VMVFkgICAoY2FsbCAkZ2V0QmxvY2tEaWZmaWN1bHR5KGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2dldEJsb2NrRGlmZmljdWx0eVxcXCIgKGZ1bmMgJGdldEJsb2NrRGlmZmljdWx0eSAocGFyYW0gaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkRJRkZJQ1VMVFlcXFwiIChmdW5jICRESUZGSUNVTFRZKSlcIlxuICB9LFxuICBcIkdBU0xJTUlUXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJEdBU0xJTUlUICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSAoY2FsbCAkZ2V0QmxvY2tHYXNMaW1pdCkpXFxuICAgIDs7IHplcm8gb3V0IG1lbVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA1NikpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDQ4KSkgKGk2NC5jb25zdCAwKSlcXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNDApKSAoaTY0LmNvbnN0IDApKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRCbG9ja0dhc0xpbWl0XFxcIiAoZnVuYyAkZ2V0QmxvY2tHYXNMaW1pdCAgKHJlc3VsdCBpNjQpKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJHQVNMSU1JVFxcXCIgKGZ1bmMgJEdBU0xJTUlUKSlcIlxuICB9LFxuICBcIkNSRUFURVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRDUkVBVEUgKHBhcmFtICRjYWxsYmFjayBpMzIpKGxvY2FsICRvZmZzZXQwIGkzMikobG9jYWwgJGxlbmd0aDAgaTMyKSAobG9jYWwuc2V0ICRvZmZzZXQwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0zMikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0yNCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC04KSkpKSkobG9jYWwuc2V0ICRsZW5ndGgwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC02NCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC01NikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC00OCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC00MCkpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MCkgKGxvY2FsLmdldCAkbGVuZ3RoMCkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQwKSkpIChjYWxsICRjcmVhdGUoY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKShsb2NhbC5nZXQgJG9mZnNldDApKGxvY2FsLmdldCAkbGVuZ3RoMCkoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTY0KSkobG9jYWwuZ2V0ICRjYWxsYmFjaykpKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC02NCkpKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fY3JlYXRlXFxcIiAoZnVuYyAkY3JlYXRlIChwYXJhbSBpMzIgaTMyIGkzMiBpMzIgaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkNSRUFURVxcXCIgKGZ1bmMgJENSRUFURSkpXCJcbiAgfSxcbiAgXCJDUkVBVEUyXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJENSRUFURTIgKHBhcmFtICRjYWxsYmFjayBpMzIpKGxvY2FsICRvZmZzZXQwIGkzMikobG9jYWwgJGxlbmd0aDAgaTMyKSAobG9jYWwuc2V0ICRvZmZzZXQwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0zMikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0yNCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC04KSkpKSkobG9jYWwuc2V0ICRsZW5ndGgwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC02NCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC01NikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC00OCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC00MCkpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MCkgKGxvY2FsLmdldCAkbGVuZ3RoMCkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQwKSkpIChjYWxsICRjcmVhdGUyKGNhbGwgJGJzd2FwX20yNTYgKGdsb2JhbC5nZXQgJHNwKSkobG9jYWwuZ2V0ICRvZmZzZXQwKShsb2NhbC5nZXQgJGxlbmd0aDApKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC05NikpKShpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtOTYpKShsb2NhbC5nZXQgJGNhbGxiYWNrKSkoZHJvcCAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTk2KSkpKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9jcmVhdGUyXFxcIiAoZnVuYyAkY3JlYXRlMiAocGFyYW0gaTMyIGkzMiBpMzIgaTMyIGkzMiBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQ1JFQVRFMlxcXCIgKGZ1bmMgJENSRUFURTIpKVwiXG4gIH0sXG4gIFwiQ0FMTFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRDQUxMIChwYXJhbSAkY2FsbGJhY2sgaTMyKShsb2NhbCAkb2Zmc2V0MCBpMzIpKGxvY2FsICRsZW5ndGgwIGkzMikobG9jYWwgJG9mZnNldDEgaTMyKShsb2NhbCAkbGVuZ3RoMSBpMzIpIChsb2NhbC5zZXQgJG9mZnNldDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTk2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTg4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTgwKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTcyKSkpKSkobG9jYWwuc2V0ICRsZW5ndGgwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMjgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTIwKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTExMikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMDQpKSkpKVxcbiAgICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJG9mZnNldDApIChsb2NhbC5nZXQgJGxlbmd0aDApKVxcbiAgICAobG9jYWwuc2V0ICRvZmZzZXQwIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkgKGxvY2FsLmdldCAkb2Zmc2V0MCkpKShsb2NhbC5zZXQgJG9mZnNldDEgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE2MCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNTIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTQ0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTEzNikpKSkpKGxvY2FsLnNldCAkbGVuZ3RoMSAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTkyKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE4NCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNzYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTY4KSkpKSlcXG4gICAgKGNhbGwgJG1lbXVzZWdhcyAobG9jYWwuZ2V0ICRvZmZzZXQxKSAobG9jYWwuZ2V0ICRsZW5ndGgxKSlcXG4gICAgKGxvY2FsLnNldCAkb2Zmc2V0MSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpIChsb2NhbC5nZXQgJG9mZnNldDEpKSkgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE5MikpIChpNjQuZXh0ZW5kX2kzMl91IChpMzIuZXF6IChjYWxsICRjYWxsKGNhbGwgJGNoZWNrX292ZXJmbG93X2k2NFxcbiAgICAgICAgICAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTMyKSkpKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC02NCkpKShsb2NhbC5nZXQgJG9mZnNldDApKGxvY2FsLmdldCAkbGVuZ3RoMCkobG9jYWwuZ2V0ICRvZmZzZXQxKShsb2NhbC5nZXQgJGxlbmd0aDEpKGxvY2FsLmdldCAkY2FsbGJhY2spKSkpKVxcbiAgICA7OyB6ZXJvIG91dCBtZW1cXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE2OCkpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNzYpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTg0KSkgKGk2NC5jb25zdCAwKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fY2FsbFxcXCIgKGZ1bmMgJGNhbGwgKHBhcmFtIGk2NCBpMzIgaTMyIGkzMiBpMzIgaTMyIGkzMiBpMzIpIChyZXN1bHQgaTMyKSkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQ0FMTFxcXCIgKGZ1bmMgJENBTEwpKVwiXG4gIH0sXG4gIFwiQ0FMTENPREVcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkQ0FMTENPREUgKHBhcmFtICRjYWxsYmFjayBpMzIpKGxvY2FsICRvZmZzZXQwIGkzMikobG9jYWwgJGxlbmd0aDAgaTMyKShsb2NhbCAkb2Zmc2V0MSBpMzIpKGxvY2FsICRsZW5ndGgxIGkzMikgKGxvY2FsLnNldCAkb2Zmc2V0MCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtOTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtODgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtODApKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNzIpKSkpKShsb2NhbC5zZXQgJGxlbmd0aDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTEyOCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMjApKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTEyKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTEwNCkpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MCkgKGxvY2FsLmdldCAkbGVuZ3RoMCkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQwKSkpKGxvY2FsLnNldCAkb2Zmc2V0MSAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTYwKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE1MikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNDQpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTM2KSkpKSkobG9jYWwuc2V0ICRsZW5ndGgxIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xOTIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTg0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE3NikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNjgpKSkpKVxcbiAgICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJG9mZnNldDEpIChsb2NhbC5nZXQgJGxlbmd0aDEpKVxcbiAgICAobG9jYWwuc2V0ICRvZmZzZXQxIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkgKGxvY2FsLmdldCAkb2Zmc2V0MSkpKSAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTkyKSkgKGk2NC5leHRlbmRfaTMyX3UgKGkzMi5lcXogKGNhbGwgJGNhbGxDb2RlKGNhbGwgJGNoZWNrX292ZXJmbG93X2k2NFxcbiAgICAgICAgICAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTMyKSkpKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC02NCkpKShsb2NhbC5nZXQgJG9mZnNldDApKGxvY2FsLmdldCAkbGVuZ3RoMCkobG9jYWwuZ2V0ICRvZmZzZXQxKShsb2NhbC5nZXQgJGxlbmd0aDEpKGxvY2FsLmdldCAkY2FsbGJhY2spKSkpKVxcbiAgICA7OyB6ZXJvIG91dCBtZW1cXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE2OCkpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNzYpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTg0KSkgKGk2NC5jb25zdCAwKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fY2FsbENvZGVcXFwiIChmdW5jICRjYWxsQ29kZSAocGFyYW0gaTY0IGkzMiBpMzIgaTMyIGkzMiBpMzIgaTMyIGkzMikgKHJlc3VsdCBpMzIpKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJDQUxMQ09ERVxcXCIgKGZ1bmMgJENBTExDT0RFKSlcIlxuICB9LFxuICBcIkRFTEVHQVRFQ0FMTFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRERUxFR0FURUNBTEwgKHBhcmFtICRjYWxsYmFjayBpMzIpKGxvY2FsICRvZmZzZXQwIGkzMikobG9jYWwgJGxlbmd0aDAgaTMyKShsb2NhbCAkb2Zmc2V0MSBpMzIpKGxvY2FsICRsZW5ndGgxIGkzMikgKGxvY2FsLnNldCAkb2Zmc2V0MCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNjQpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNDgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNDApKSkpKShsb2NhbC5zZXQgJGxlbmd0aDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTk2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTg4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTgwKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTcyKSkpKSlcXG4gICAgKGNhbGwgJG1lbXVzZWdhcyAobG9jYWwuZ2V0ICRvZmZzZXQwKSAobG9jYWwuZ2V0ICRsZW5ndGgwKSlcXG4gICAgKGxvY2FsLnNldCAkb2Zmc2V0MCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpIChsb2NhbC5nZXQgJG9mZnNldDApKSkobG9jYWwuc2V0ICRvZmZzZXQxIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMjgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTIwKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTExMikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMDQpKSkpKShsb2NhbC5zZXQgJGxlbmd0aDEgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE2MCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNTIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTQ0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTEzNikpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MSkgKGxvY2FsLmdldCAkbGVuZ3RoMSkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDEgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQxKSkpIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNjApKSAoaTY0LmV4dGVuZF9pMzJfdSAoaTMyLmVxeiAoY2FsbCAkY2FsbERlbGVnYXRlKGNhbGwgJGNoZWNrX292ZXJmbG93X2k2NFxcbiAgICAgICAgICAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTMyKSkpKGxvY2FsLmdldCAkb2Zmc2V0MCkobG9jYWwuZ2V0ICRsZW5ndGgwKShsb2NhbC5nZXQgJG9mZnNldDEpKGxvY2FsLmdldCAkbGVuZ3RoMSkobG9jYWwuZ2V0ICRjYWxsYmFjaykpKSkpXFxuICAgIDs7IHplcm8gb3V0IG1lbVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTM2KSkgKGk2NC5jb25zdCAwKSlcXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE0NCkpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNTIpKSAoaTY0LmNvbnN0IDApKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9jYWxsRGVsZWdhdGVcXFwiIChmdW5jICRjYWxsRGVsZWdhdGUgKHBhcmFtIGk2NCBpMzIgaTMyIGkzMiBpMzIgaTMyIGkzMikgKHJlc3VsdCBpMzIpKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJERUxFR0FURUNBTExcXFwiIChmdW5jICRERUxFR0FURUNBTEwpKVwiXG4gIH0sXG4gIFwiU1RBVElDQ0FMTFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRTVEFUSUNDQUxMIChwYXJhbSAkY2FsbGJhY2sgaTMyKShsb2NhbCAkb2Zmc2V0MCBpMzIpKGxvY2FsICRsZW5ndGgwIGkzMikobG9jYWwgJG9mZnNldDEgaTMyKShsb2NhbCAkbGVuZ3RoMSBpMzIpIChsb2NhbC5zZXQgJG9mZnNldDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTY0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTU2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQ4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQwKSkpKSkobG9jYWwuc2V0ICRsZW5ndGgwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC05NikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC04OCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC04MCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC03MikpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MCkgKGxvY2FsLmdldCAkbGVuZ3RoMCkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQwKSkpKGxvY2FsLnNldCAkb2Zmc2V0MSAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTI4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTEyMCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMTIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTA0KSkpKSkobG9jYWwuc2V0ICRsZW5ndGgxIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNjApKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTUyKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE0NCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMzYpKSkpKVxcbiAgICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJG9mZnNldDEpIChsb2NhbC5nZXQgJGxlbmd0aDEpKVxcbiAgICAobG9jYWwuc2V0ICRvZmZzZXQxIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkgKGxvY2FsLmdldCAkb2Zmc2V0MSkpKSAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTYwKSkgKGk2NC5leHRlbmRfaTMyX3UgKGkzMi5lcXogKGNhbGwgJGNhbGxTdGF0aWMoY2FsbCAkY2hlY2tfb3ZlcmZsb3dfaTY0XFxuICAgICAgICAgIChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKShjYWxsICRic3dhcF9tMjU2IChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMzIpKSkobG9jYWwuZ2V0ICRvZmZzZXQwKShsb2NhbC5nZXQgJGxlbmd0aDApKGxvY2FsLmdldCAkb2Zmc2V0MSkobG9jYWwuZ2V0ICRsZW5ndGgxKShsb2NhbC5nZXQgJGNhbGxiYWNrKSkpKSlcXG4gICAgOzsgemVybyBvdXQgbWVtXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMzYpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTQ0KSkgKGk2NC5jb25zdCAwKSlcXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE1MikpIChpNjQuY29uc3QgMCkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2NhbGxTdGF0aWNcXFwiIChmdW5jICRjYWxsU3RhdGljIChwYXJhbSBpNjQgaTMyIGkzMiBpMzIgaTMyIGkzMiBpMzIpIChyZXN1bHQgaTMyKSkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiU1RBVElDQ0FMTFxcXCIgKGZ1bmMgJFNUQVRJQ0NBTEwpKVwiXG4gIH0sXG4gIFwiUkVUVVJOREFUQUNPUFlcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkUkVUVVJOREFUQUNPUFkgKGxvY2FsICRvZmZzZXQwIGkzMikobG9jYWwgJGxlbmd0aDAgaTMyKSAobG9jYWwuc2V0ICRvZmZzZXQwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkpKGxvY2FsLnNldCAkbGVuZ3RoMCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNjQpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNDgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNDApKSkpKVxcbiAgICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJG9mZnNldDApIChsb2NhbC5nZXQgJGxlbmd0aDApKVxcbiAgICAobG9jYWwuc2V0ICRvZmZzZXQwIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkgKGxvY2FsLmdldCAkb2Zmc2V0MCkpKSAoY2FsbCAkcmV0dXJuRGF0YUNvcHkobG9jYWwuZ2V0ICRvZmZzZXQwKShjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0zMikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0yNCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC04KSkpKShsb2NhbC5nZXQgJGxlbmd0aDApKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9yZXR1cm5EYXRhQ29weVxcXCIgKGZ1bmMgJHJldHVybkRhdGFDb3B5IChwYXJhbSBpMzIgaTMyIGkzMikgKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJSRVRVUk5EQVRBQ09QWVxcXCIgKGZ1bmMgJFJFVFVSTkRBVEFDT1BZKSlcIlxuICB9LFxuICBcIlJFVFVSTkRBVEFTSVpFXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJFJFVFVSTkRBVEFTSVpFICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSAoaTY0LmV4dGVuZF9pMzJfdSAoY2FsbCAkZ2V0UmV0dXJuRGF0YVNpemUpKSlcXG4gICAgOzsgemVybyBvdXQgbWVtXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDU2KSkgKGk2NC5jb25zdCAwKSlcXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA0MCkpIChpNjQuY29uc3QgMCkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2dldFJldHVybkRhdGFTaXplXFxcIiAoZnVuYyAkZ2V0UmV0dXJuRGF0YVNpemUgIChyZXN1bHQgaTMyKSkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiUkVUVVJOREFUQVNJWkVcXFwiIChmdW5jICRSRVRVUk5EQVRBU0laRSkpXCJcbiAgfSxcbiAgXCJTU1RPUkVcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkU1NUT1JFIChwYXJhbSAkY2FsbGJhY2sgaTMyKSAgKGNhbGwgJHN0b3JhZ2VTdG9yZShjYWxsICRic3dhcF9tMjU2IChnbG9iYWwuZ2V0ICRzcCkpKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0zMikpKShsb2NhbC5nZXQgJGNhbGxiYWNrKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fc3RvcmFnZVN0b3JlXFxcIiAoZnVuYyAkc3RvcmFnZVN0b3JlIChwYXJhbSBpMzIgaTMyIGkzMikgKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJTU1RPUkVcXFwiIChmdW5jICRTU1RPUkUpKVwiXG4gIH0sXG4gIFwiU0xPQURcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkU0xPQUQgKHBhcmFtICRjYWxsYmFjayBpMzIpICAoY2FsbCAkc3RvcmFnZUxvYWQoY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKShnbG9iYWwuZ2V0ICRzcCkobG9jYWwuZ2V0ICRjYWxsYmFjaykpKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGdsb2JhbC5nZXQgJHNwKSkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX3N0b3JhZ2VMb2FkXFxcIiAoZnVuYyAkc3RvcmFnZUxvYWQgKHBhcmFtIGkzMiBpMzIgaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIlNMT0FEXFxcIiAoZnVuYyAkU0xPQUQpKVwiXG4gIH0sXG4gIFwiU0VMRkRFU1RSVUNUXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJFNFTEZERVNUUlVDVCAgIChjYWxsICRzZWxmRGVzdHJ1Y3QoY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fc2VsZkRlc3RydWN0XFxcIiAoZnVuYyAkc2VsZkRlc3RydWN0IChwYXJhbSBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiU0VMRkRFU1RSVUNUXFxcIiAoZnVuYyAkU0VMRkRFU1RSVUNUKSlcIlxuICB9LFxuICBcIlJFVFVSTlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRSRVRVUk4gKGxvY2FsICRvZmZzZXQwIGkzMikobG9jYWwgJGxlbmd0aDAgaTMyKSAobG9jYWwuc2V0ICRvZmZzZXQwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkpKGxvY2FsLnNldCAkbGVuZ3RoMCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMzIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMjQpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtOCkpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MCkgKGxvY2FsLmdldCAkbGVuZ3RoMCkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQwKSkpIChjYWxsICRmaW5pc2gobG9jYWwuZ2V0ICRvZmZzZXQwKShsb2NhbC5nZXQgJGxlbmd0aDApKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9maW5pc2hcXFwiIChmdW5jICRmaW5pc2ggKHBhcmFtIGkzMiBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiUkVUVVJOXFxcIiAoZnVuYyAkUkVUVVJOKSlcIlxuICB9LFxuICBcIlJFVkVSVFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRSRVZFUlQgKGxvY2FsICRvZmZzZXQwIGkzMikobG9jYWwgJGxlbmd0aDAgaTMyKSAobG9jYWwuc2V0ICRvZmZzZXQwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkpKGxvY2FsLnNldCAkbGVuZ3RoMCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMzIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMjQpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtOCkpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MCkgKGxvY2FsLmdldCAkbGVuZ3RoMCkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQwKSkpIChjYWxsICRyZXZlcnQobG9jYWwuZ2V0ICRvZmZzZXQwKShsb2NhbC5nZXQgJGxlbmd0aDApKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9yZXZlcnRcXFwiIChmdW5jICRyZXZlcnQgKHBhcmFtIGkzMiBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiUkVWRVJUXFxcIiAoZnVuYyAkUkVWRVJUKSlcIlxuICB9LFxuICBcIlBVU0hcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIlBVU0hcXFwiIChmdW5jICRQVVNIIChwYXJhbSBpNjQgaTY0IGk2NCBpNjQpICkpXCIsXG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJFBVU0hcXG4gIChwYXJhbSAkYTAgaTY0KVxcbiAgKHBhcmFtICRhMSBpNjQpXFxuICAocGFyYW0gJGEyIGk2NClcXG4gIChwYXJhbSAkYTMgaTY0KVxcbiAgKGxvY2FsICRzcCBpMzIpXFxuXFxuICA7OyBpbmNyZWFtZW50IHN0YWNrIHBvaW50ZXJcXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgKGk2NC5zdG9yZSAobG9jYWwuZ2V0ICRzcCkgKGxvY2FsLmdldCAkYTMpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkgKGxvY2FsLmdldCAkYTIpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChsb2NhbC5nZXQgJGExKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICRhMCkpXFxuKVxcblwiXG4gIH0sXG4gIFwiTVNUT1JFXCI6IHtcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJNU1RPUkVcXFwiIChmdW5jICRNU1RPUkUgKSlcIixcbiAgICBcIndhc3RcIjogXCI7OyBzdGFjazpcXG47OyAgMDogd29yZFxcbjs7IC0xOiBvZmZzZXRcXG4oZnVuYyAkTVNUT1JFXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIChsb2NhbCAkb2Zmc2V0ICAgaTMyKVxcbiAgXFxuICAobG9jYWwgJG9mZnNldDAgaTY0KVxcbiAgKGxvY2FsICRvZmZzZXQxIGk2NClcXG4gIChsb2NhbCAkb2Zmc2V0MiBpNjQpXFxuICAobG9jYWwgJG9mZnNldDMgaTY0KVxcblxcbiAgOzsgbG9hZCBhcmdzIGZyb20gdGhlIHN0YWNrXFxuICAobG9jYWwuc2V0ICRvZmZzZXQwIChpNjQubG9hZCAgICAgICAgICAoZ2xvYmFsLmdldCAkc3ApKSlcXG4gIChsb2NhbC5zZXQgJG9mZnNldDEgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcblxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0IFxcbiAgICAgICAgICAgICAoY2FsbCAkY2hlY2tfb3ZlcmZsb3cgKGxvY2FsLmdldCAkb2Zmc2V0MClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJG9mZnNldDEpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRvZmZzZXQyKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0MykpKVxcbiAgOzsgc3VidHJhY2UgZ2FzIHVzZWFnZVxcbiAgKGNhbGwgJG1lbXVzZWdhcyAobG9jYWwuZ2V0ICRvZmZzZXQpIChpMzIuY29uc3QgMzIpKVxcblxcbiAgOzsgcG9wIGl0ZW0gZnJvbSB0aGUgc3RhY2tcXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgOzsgc3dhcCB0b3Agc3RhY2sgaXRlbVxcbiAgKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJG9mZnNldCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRvZmZzZXQpIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkpKVxcbiAgOzsgc3RvcmUgd29yZCB0byBtZW1vcnlcXG4gIChpNjQuc3RvcmUgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0KSAgICAgICAgICAgICAgICAgKGk2NC5sb2FkICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJG9mZnNldCkgKGkzMi5jb25zdCA4KSkgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkb2Zmc2V0KSAoaTMyLmNvbnN0IDE2KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRvZmZzZXQpIChpMzIuY29uc3QgMjQpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiTUxPQURcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIk1MT0FEXFxcIiAoZnVuYyAkTUxPQUQgKSlcIixcbiAgICBcIndhc3RcIjogXCI7OyBzdGFjazpcXG47OyAgMDogb2Zmc2V0XFxuKGZ1bmMgJE1MT0FEXFxuICAobG9jYWwgJG9mZnNldCBpMzIpXFxuICAobG9jYWwgJG9mZnNldDAgaTY0KVxcbiAgKGxvY2FsICRvZmZzZXQxIGk2NClcXG4gIChsb2NhbCAkb2Zmc2V0MiBpNjQpXFxuICAobG9jYWwgJG9mZnNldDMgaTY0KVxcblxcbiAgOzsgbG9hZCBhcmdzIGZyb20gdGhlIHN0YWNrXFxuICAobG9jYWwuc2V0ICRvZmZzZXQwIChpNjQubG9hZCAgICAgICAgICAoZ2xvYmFsLmdldCAkc3ApKSlcXG4gIChsb2NhbC5zZXQgJG9mZnNldDEgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcblxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0IFxcbiAgICAgICAgICAgICAoY2FsbCAkY2hlY2tfb3ZlcmZsb3cgKGxvY2FsLmdldCAkb2Zmc2V0MClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJG9mZnNldDEpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRvZmZzZXQyKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0MykpKVxcbiAgOzsgc3VidHRyYWN0IGdhcyB1c2VhZ2VcXG4gIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0KSAoaTMyLmNvbnN0ICAzMikpXFxuXFxuICA7OyBGSVhNRTogaG93IHRvIGRlYWwgd2l0aCBvdmVyZmxvdz9cXG4gIChsb2NhbC5zZXQgJG9mZnNldCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRvZmZzZXQpIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkpKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkb2Zmc2V0KSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkb2Zmc2V0KSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGk2NC5zdG9yZSAgICAgICAgICAoZ2xvYmFsLmdldCAkc3ApICAgICAgICAgICAgICAgICAoaTY0LmxvYWQgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0KSkpXFxuXFxuICA7OyBzd2FwXFxuICAoZHJvcCAoY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJEVVBcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkRVUFxcXCIgKGZ1bmMgJERVUCAocGFyYW0gaTMyKSApKVwiLFxuICAgIFwid2FzdFwiOiBcIihmdW5jICREVVBcXG4gIChwYXJhbSAkYTAgaTMyKVxcbiAgKGxvY2FsICRzcCBpMzIpXFxuXFxuICAobG9jYWwgJHNwX3JlZiBpMzIpXFxuICBcXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcbiAgKGxvY2FsLnNldCAkc3BfcmVmIChpMzIuc3ViIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSAoaTMyLm11bCAobG9jYWwuZ2V0ICRhMCkgKGkzMi5jb25zdCAzMikpKSlcXG4gIFxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcF9yZWYpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAoaTY0LmxvYWQgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3BfcmVmKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGk2NC5sb2FkIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwX3JlZikgKGkzMi5jb25zdCAxNikpKSlcXG4gIChpNjQuc3RvcmUgICAgICAgICAgKGxvY2FsLmdldCAkc3ApICAgICAgICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3BfcmVmKSAoaTMyLmNvbnN0IDI0KSkpKVxcbilcXG5cIlxuICB9LFxuICBcIklTWkVST1wiOiB7XG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiSVNaRVJPXFxcIiAoZnVuYyAkSVNaRVJPICkpXCIsXG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJElTWkVST1xcbiAgKGxvY2FsICRhMCBpNjQpXFxuICAobG9jYWwgJGExIGk2NClcXG4gIChsb2NhbCAkYTIgaTY0KVxcbiAgKGxvY2FsICRhMyBpNjQpXFxuXFxuICA7OyBsb2FkIGFyZ3MgZnJvbSB0aGUgc3RhY2tcXG4gIChsb2NhbC5zZXQgJGEwIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRhMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYTIgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkYTMgKGk2NC5sb2FkIChnbG9iYWwuZ2V0ICRzcCkpKVxcblxcbiAgKGk2NC5zdG9yZSAoZ2xvYmFsLmdldCAkc3ApXFxuICAgIChpNjQuZXh0ZW5kX2kzMl91XFxuICAgICAgKGNhbGwgJGlzemVyb18yNTYgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYTMpKVxcbiAgICApXFxuICApXFxuXFxuICA7OyB6ZXJvIG91dCB0aGUgcmVzdCBvZiBtZW1vcnlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAoaTY0LmNvbnN0IDApKVxcbilcXG5cIlxuICB9LFxuICBcIkxUXCI6IHtcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJMVFxcXCIgKGZ1bmMgJExUICkpXCIsXG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJExUXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIChsb2NhbCAkYTAgaTY0KVxcbiAgKGxvY2FsICRhMSBpNjQpXFxuICAobG9jYWwgJGEyIGk2NClcXG4gIChsb2NhbCAkYTMgaTY0KVxcbiAgKGxvY2FsICRiMCBpNjQpXFxuICAobG9jYWwgJGIxIGk2NClcXG4gIChsb2NhbCAkYjIgaTY0KVxcbiAgKGxvY2FsICRiMyBpNjQpXFxuXFxuICAobG9jYWwuc2V0ICRzcCAoZ2xvYmFsLmdldCAkc3ApKVxcblxcbiAgOzsgbG9hZCBhcmdzIGZyb20gdGhlIHN0YWNrXFxuICAobG9jYWwuc2V0ICRhMCAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRhMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRhMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGEzIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGIwIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGIxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGIyIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkYjMgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKSAoaTY0LmV4dGVuZF9pMzJfdVxcbiAgICAoaTMyLm9yICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPCBiMFxcbiAgICAoaTMyLmFuZCAoaTY0LmVxICAgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPT0gYjBcXG4gICAgKGkzMi5vciAgKGk2NC5sdF91IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExIDwgYjFcXG4gICAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID09IGIxXFxuICAgIChpMzIub3IgIChpNjQubHRfdSAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA8IGIyXFxuICAgIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA9PSBiMlxcbiAgICAgICAgICAgICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYTMpIChsb2NhbC5nZXQgJGIzKSkpKSkpKSkpKSA7OyBhMyA8IGIzXFxuXFxuICA7OyB6ZXJvICBvdXQgdGhlIHJlc3Qgb2YgdGhlIHN0YWNrIGl0ZW1cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5jb25zdCAwKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJHVFwiOiB7XG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiR1RcXFwiIChmdW5jICRHVCApKVwiLFxuICAgIFwid2FzdFwiOiBcIihmdW5jICRHVFxcbiAgKGxvY2FsICRzcCBpMzIpXFxuXFxuICAobG9jYWwgJGEwIGk2NClcXG4gIChsb2NhbCAkYTEgaTY0KVxcbiAgKGxvY2FsICRhMiBpNjQpXFxuICAobG9jYWwgJGEzIGk2NClcXG4gIChsb2NhbCAkYjAgaTY0KVxcbiAgKGxvY2FsICRiMSBpNjQpXFxuICAobG9jYWwgJGIyIGk2NClcXG4gIChsb2NhbCAkYjMgaTY0KVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGdsb2JhbC5nZXQgJHNwKSlcXG5cXG4gIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYTAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYTEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYTIgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRhMyAoaTY0LmxvYWQgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAobG9jYWwuc2V0ICRiMCAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRiMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRiMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGIzIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgKGk2NC5zdG9yZSAobG9jYWwuZ2V0ICRzcCkgKGk2NC5leHRlbmRfaTMyX3VcXG4gICAgKGkzMi5vciAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPiBiMFxcbiAgICAoaTMyLmFuZCAoaTY0LmVxICAgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPT0gYTFcXG4gICAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID4gYjFcXG4gICAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID09IGIxXFxuICAgIChpMzIub3IgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA+IGIyXFxuICAgIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA9PSBiMlxcbiAgICAgICAgICAgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYTMpIChsb2NhbC5nZXQgJGIzKSkpKSkpKSkpKSA7OyBhMyA+IGIzXFxuXFxuICA7OyB6ZXJvICBvdXQgdGhlIHJlc3Qgb2YgdGhlIHN0YWNrIGl0ZW1cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5jb25zdCAwKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJTTFRcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIlNMVFxcXCIgKGZ1bmMgJFNMVCApKVwiLFxuICAgIFwid2FzdFwiOiBcIihmdW5jICRTTFRcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgKGxvY2FsICRhMCBpNjQpXFxuICAobG9jYWwgJGExIGk2NClcXG4gIChsb2NhbCAkYTIgaTY0KVxcbiAgKGxvY2FsICRhMyBpNjQpXFxuICAobG9jYWwgJGIwIGk2NClcXG4gIChsb2NhbCAkYjEgaTY0KVxcbiAgKGxvY2FsICRiMiBpNjQpXFxuICAobG9jYWwgJGIzIGk2NClcXG5cXG4gIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYTAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGExIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRhMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRhMyAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSkpXFxuXFxuICAobG9jYWwuc2V0ICRzcCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGIwIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGIxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGIyIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkYjMgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKSAoaTY0LmV4dGVuZF9pMzJfdVxcbiAgICAoaTMyLm9yICAoaTY0Lmx0X3MgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPCBiMFxcbiAgICAoaTMyLmFuZCAoaTY0LmVxICAgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPT0gYjBcXG4gICAgKGkzMi5vciAgKGk2NC5sdF91IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExIDwgYjFcXG4gICAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID09IGIxXFxuICAgIChpMzIub3IgIChpNjQubHRfdSAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA8IGIyXFxuICAgIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA9PSBiMlxcbiAgICAgICAgICAgICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYTMpIChsb2NhbC5nZXQgJGIzKSkpKSkpKSkpKSA7OyBhMyA8IGIzXFxuXFxuICA7OyB6ZXJvICBvdXQgdGhlIHJlc3Qgb2YgdGhlIHN0YWNrIGl0ZW1cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5jb25zdCAwKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJTSFJcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIlNIUlxcXCIgKGZ1bmMgJFNIUiApKVwiLFxuICAgIFwid2FzdFwiOiBcIihmdW5jICRTSFJcXG4gICAgKGxvY2FsICRzcCBpMzIpXFxuICAgIChsb2NhbCAkeDEgaTY0KVxcbiAgICAobG9jYWwgJHgyIGk2NClcXG4gICAgKGxvY2FsICR4MyBpNjQpXFxuICAgIChsb2NhbCAkeDQgaTY0KVxcbiAgICAobG9jYWwgJHkxIGk2NClcXG4gICAgKGxvY2FsICR5MiBpNjQpXFxuICAgIChsb2NhbCAkeTMgaTY0KVxcbiAgICAobG9jYWwgJHk0IGk2NClcXG5cXG4gICAgKGxvY2FsICR6MSBpNjQpXFxuICAgIChsb2NhbCAkejIgaTY0KVxcbiAgICAobG9jYWwgJHozIGk2NClcXG4gICAgKGxvY2FsICR6NCBpNjQpXFxuICAgIChsb2NhbCAkdCBpNjQpXFxuXFxuICAgIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgICAobG9jYWwuc2V0ICR4MSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4MiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAgIChsb2NhbC5zZXQgJHg0IChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKSlcXG5cXG4gICAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAgIChsb2NhbC5zZXQgJHkxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeTIgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAobG9jYWwuc2V0ICR5MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeTQgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAgIChibG9ja1xcbiAgICAgICAgKGlmIChpMzIuYW5kIChpNjQuZXF6IChsb2NhbC5nZXQgJHgxKSkgKGk2NC5lcXogKGxvY2FsLmdldCAkeDIpKSkgKHRoZW5cXG4gICAgICAgICAgICAoaWYgKGk2NC5lcXogKGxvY2FsLmdldCAkeDMpKSAodGhlblxcbiAgICAgICAgICAgICAgICAoaWYgKGk2NC5lcXogKGxvY2FsLmdldCAkeDQpKVxcbiAgICAgICAgICAgICAgICAgICAgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MSAobG9jYWwuZ2V0ICR5MSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGxvY2FsLmdldCAkeTIpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHozIChsb2NhbC5nZXQgJHkzKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6NCAobG9jYWwuZ2V0ICR5NCkpXFxuICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgICAgICAoZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpZiAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgMjU2KSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpNjQuZ2VfdSAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCAxMjgpKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTQgKGxvY2FsLmdldCAkeTIpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTMgKGxvY2FsLmdldCAkeTEpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTIgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkxIChpNjQuY29uc3QgMCkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR4NCAoaTY0LnN1YiAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCAxMjgpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpNjQuZ2VfdSAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCA2NCkpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5NCAobG9jYWwuZ2V0ICR5MykpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MyAobG9jYWwuZ2V0ICR5MikpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MiAobG9jYWwuZ2V0ICR5MSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MSAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeDQgKGk2NC5zdWIgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgNjQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vcClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6NCAoY2FsbCAkc2hyX3NpbmdsZSAobG9jYWwuZ2V0ICR5NCkgKGxvY2FsLmdldCAkeDQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHQgKGdsb2JhbC5nZXQgJGdsb2JhbF8pKVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejMgKGNhbGwgJHNocl9zaW5nbGUgKGxvY2FsLmdldCAkeTMpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR0IChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6NCAoaTY0Lm9yIChsb2NhbC5nZXQgJHo0KSAobG9jYWwuZ2V0ICR0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGNhbGwgJHNocl9zaW5nbGUgKGxvY2FsLmdldCAkeTIpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR0IChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MyAoaTY0Lm9yIChsb2NhbC5nZXQgJHozKSAobG9jYWwuZ2V0ICR0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejEgKGNhbGwgJHNocl9zaW5nbGUgKGxvY2FsLmdldCAkeTEpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR0IChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MiAoaTY0Lm9yIChsb2NhbC5nZXQgJHoyKSAobG9jYWwuZ2V0ICR0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICkpXFxuICAgICAgICApKVxcblxcbiAgICApXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICR6MSkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAobG9jYWwuZ2V0ICR6MikpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAobG9jYWwuZ2V0ICR6MykpXFxuICAgIChpNjQuc3RvcmUgICAgICAgICAgKGxvY2FsLmdldCAkc3ApICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICR6NCkpXFxuKVxcblxcbihmdW5jICRzaHJfc2luZ2xlXFxuICAgIChwYXJhbSAkYSBpNjQpXFxuICAgIChwYXJhbSAkYW1vdW50IGk2NClcXG4gICAgKHJlc3VsdCBpNjQpXFxuICAgIChsb2NhbCAkeCBpNjQpXFxuICAgIChsb2NhbCAkeSBpNjQpXFxuICAgIChibG9ja1xcbiAgICAgICAgKGxvY2FsLnNldCAkeSAoaTY0LnNobCAobG9jYWwuZ2V0ICRhKSAoaTY0LnN1YiAoaTY0LmNvbnN0IDY0KSAobG9jYWwuZ2V0ICRhbW91bnQpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICR4IChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYW1vdW50KSkpXFxuXFxuICAgIClcXG4gICAgKGdsb2JhbC5zZXQgJGdsb2JhbF8gKGxvY2FsLmdldCAkeSkpXFxuICAgIChsb2NhbC5nZXQgJHgpXFxuKVxcblwiXG4gIH0sXG4gIFwiRVFcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkVRXFxcIiAoZnVuYyAkRVEgKSlcIixcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkRVFcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKVxcbiAgICAoaTY0LmV4dGVuZF9pMzJfdVxcbiAgICAgIChpMzIuYW5kIChpNjQuZXEgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgNTYpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgICAgIChpMzIuYW5kIChpNjQuZXEgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgNDgpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAgIChpMzIuYW5kIChpNjQuZXEgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgNDApKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgICAgICAgICAgICAgIChpNjQuZXEgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkgKGk2NC5sb2FkICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSkpKSkpKSlcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGk2NC5jb25zdCAwKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJBRERcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkFERFxcXCIgKGZ1bmMgJEFERCApKVwiLFxuICAgIFwid2FzdFwiOiBcIihmdW5jICRBRERcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgKGxvY2FsICRhIGk2NClcXG4gIChsb2NhbCAkYyBpNjQpXFxuICAobG9jYWwgJGQgaTY0KVxcbiAgKGxvY2FsICRjYXJyeSBpNjQpXFxuXFxuICAobG9jYWwuc2V0ICRzcCAoZ2xvYmFsLmdldCAkc3ApKVxcblxcbiAgOzsgZCBjIGIgYVxcbiAgOzsgcG9wIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRjIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkZCAoaTY0LmxvYWQgKGxvY2FsLmdldCAkc3ApKSlcXG4gIDs7IGRlY2VtZW50IHRoZSBzdGFjayBwb2ludGVyXFxuICAobG9jYWwuc2V0ICRzcCAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXFxuXFxuICA7OyBkXFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRkKSAoaTY0LmxvYWQgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpKVxcbiAgOzsgc2F2ZSBkICB0byBtZW1cXG4gIChpNjQuc3RvcmUgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICRjYXJyeSkpXFxuICA7OyBjaGVjayAgZm9yIG92ZXJmbG93XFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkY2FycnkpIChsb2NhbC5nZXQgJGQpKSkpXFxuXFxuICA7OyBjIHVzZSAkZCBhcyByZWdcXG4gIChsb2NhbC5zZXQgJGQgICAgIChpNjQuYWRkIChpNjQubG9hZCAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5leHRlbmRfaTMyX3UgKGk2NC5sdF91IChsb2NhbC5nZXQgJGQpIChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgKGxvY2FsLnNldCAkZCAgICAgKGk2NC5hZGQgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkZCkpKVxcbiAgOzsgc3RvcmUgdGhlIHJlc3VsdFxcbiAgKGk2NC5zdG9yZSAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChsb2NhbC5nZXQgJGQpKVxcbiAgOzsgY2hlY2sgb3ZlcmZsb3dcXG4gIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQub3IgKGk2NC5leHRlbmRfaTMyX3UgIChpNjQubHRfdSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRjKSkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuXFxuICA7OyBiXFxuICA7OyBhZGQgY2FycnlcXG4gIChsb2NhbC5zZXQgJGQgICAgIChpNjQuYWRkIChpNjQubG9hZCAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuXFxuICA7OyB1c2UgcmVnIGNcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkZCAoaTY0LmFkZCAobG9jYWwuZ2V0ICRjKSAobG9jYWwuZ2V0ICRkKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSAobG9jYWwuZ2V0ICRkKSlcXG4gIDs7IGFcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkc3ApXFxuICAgICAgICAgICAgIChpNjQuYWRkICAgICAgICA7OyBhZGQgYVxcbiAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGEpXFxuICAgICAgICAgICAgICAgKGk2NC5hZGRcXG4gICAgICAgICAgICAgICAgIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpICA7OyBsb2FkIHRoZSBvcGVyYW5kXFxuICAgICAgICAgICAgICAgICAoaTY0Lm9yICA7OyBjYXJyeVxcbiAgICAgICAgICAgICAgICAgICAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkYykpKVxcbiAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRjYXJyeSkpKSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiU1VCXCI6IHtcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJTVUJcXFwiIChmdW5jICRTVUIgKSlcIixcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkU1VCXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIChsb2NhbCAkYSBpNjQpXFxuICAobG9jYWwgJGIgaTY0KVxcbiAgKGxvY2FsICRjIGk2NClcXG4gIChsb2NhbCAkZCBpNjQpXFxuXFxuICAobG9jYWwgJGExIGk2NClcXG4gIChsb2NhbCAkYjEgaTY0KVxcbiAgKGxvY2FsICRjMSBpNjQpXFxuICAobG9jYWwgJGQxIGk2NClcXG5cXG4gIChsb2NhbCAkY2FycnkgaTY0KVxcbiAgKGxvY2FsICR0ZW1wIGk2NClcXG5cXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGIgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGQgKGk2NC5sb2FkICAgICAgICAgIChnbG9iYWwuZ2V0ICRzcCkpKVxcbiAgOzsgZGVjZW1lbnQgdGhlIHN0YWNrIHBvaW50ZXJcXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgKGxvY2FsLnNldCAkYTEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYjEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYzEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkZDEgKGk2NC5sb2FkICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICA7OyBhICogNjReMyArIGIqNjReMiArIGMqNjQgKyBkXFxuICA7OyBkXFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkZDEpKSkpXFxuICAobG9jYWwuc2V0ICRkIChpNjQuc3ViIChsb2NhbC5nZXQgJGQpIChsb2NhbC5nZXQgJGQxKSkpXFxuXFxuICA7OyBjXFxuICAobG9jYWwuc2V0ICR0ZW1wIChpNjQuc3ViIChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYykpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5zdWIgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYzEpKSlcXG4gIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQub3IgKGk2NC5leHRlbmRfaTMyX3UgKGk2NC5ndF91IChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJHRlbXApKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG5cXG4gIDs7IGJcXG4gIChsb2NhbC5zZXQgJHRlbXAgKGk2NC5zdWIgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZXh0ZW5kX2kzMl91IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiKSkpKVxcbiAgKGxvY2FsLnNldCAkYiAoaTY0LnN1YiAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiMSkpKVxcblxcbiAgOzsgYVxcbiAgKGxvY2FsLnNldCAkYSAoaTY0LnN1YiAoaTY0LnN1YiAobG9jYWwuZ2V0ICRhKSAoaTY0Lm9yIChpNjQuZXh0ZW5kX2kzMl91IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICR0ZW1wKSkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpIChsb2NhbC5nZXQgJGExKSkpXFxuXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGxvY2FsLmdldCAkYSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkYikpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGxvY2FsLmdldCAkYykpXFxuICAoaTY0LnN0b3JlICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkZCkpXFxuKVxcblwiXG4gIH0sXG4gIFwiU1dBUFwiOiB7XG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiU1dBUFxcXCIgKGZ1bmMgJFNXQVAgKHBhcmFtIGkzMikgKSlcIixcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkU1dBUFxcbiAgKHBhcmFtICRhMCBpMzIpXFxuICAobG9jYWwgJHNwX3JlZiBpMzIpXFxuXFxuICAobG9jYWwgJHRvcGEgaTY0KVxcbiAgKGxvY2FsICR0b3BiIGk2NClcXG4gIChsb2NhbCAkdG9wYyBpNjQpXFxuICAobG9jYWwgJHRvcGQgaTY0KVxcbiAgXFxuICAobG9jYWwuc2V0ICRzcF9yZWYgKGkzMi5zdWIgKGkzMi5hZGQgIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpMzIubXVsIChpMzIuYWRkIChsb2NhbC5nZXQgJGEwKSAoaTMyLmNvbnN0IDEpKSAoaTMyLmNvbnN0IDMyKSkpKVxcblxcbiAgKGxvY2FsLnNldCAkdG9wYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkdG9wYiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkdG9wYyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkdG9wZCAoaTY0LmxvYWQgICAgICAgICAgKGdsb2JhbC5nZXQgJHNwKSkpXFxuICBcXG4gIDs7IHJlcGxhY2UgdGhlIHRvcCBlbGVtZW50XFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcF9yZWYpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGk2NC5sb2FkIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwX3JlZikgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAoaTY0LmxvYWQgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3BfcmVmKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGk2NC5zdG9yZSAgICAgICAgICAoZ2xvYmFsLmdldCAkc3ApICAgICAgICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3BfcmVmKSAoaTMyLmNvbnN0IDI0KSkpKVxcblxcbiAgOzsgc3RvcmUgdGhlIG9sZCB0b3AgZWxlbWVudFxcbiAgKGk2NC5zdG9yZSAobG9jYWwuZ2V0ICRzcF9yZWYpICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICR0b3BhKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3BfcmVmKSAoaTMyLmNvbnN0IDgpKSAgKGxvY2FsLmdldCAkdG9wYikpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwX3JlZikgKGkzMi5jb25zdCAxNikpIChsb2NhbC5nZXQgJHRvcGMpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcF9yZWYpIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICR0b3BkKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJjaGVja19vdmVyZmxvd1wiOiB7XG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiY2hlY2tfb3ZlcmZsb3dcXFwiIChmdW5jICRjaGVja19vdmVyZmxvdyAocGFyYW0gaTY0IGk2NCBpNjQgaTY0KSAgKHJlc3VsdCBpMzIpICkpXCIsXG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGNoZWNrX292ZXJmbG93XFxuICAocGFyYW0gJGEgaTY0KVxcbiAgKHBhcmFtICRiIGk2NClcXG4gIChwYXJhbSAkYyBpNjQpXFxuICAocGFyYW0gJGQgaTY0KVxcbiAgKHJlc3VsdCBpMzIpXFxuXFxuICAobG9jYWwgJE1BWF9JTlQgaTMyKVxcbiAgKGxvY2FsLnNldCAkTUFYX0lOVCAoaTMyLmNvbnN0IC0xKSlcXG5cXG4gIChpZlxcbiAgICAoaTMyLmFuZFxcbiAgICAgIChpMzIuYW5kXFxuICAgICAgICAoaTY0LmVxeiAgKGxvY2FsLmdldCAkZCkpXFxuICAgICAgICAoaTY0LmVxeiAgKGxvY2FsLmdldCAkYykpKVxcbiAgICAgIChpMzIuYW5kXFxuICAgICAgICAoaTY0LmVxeiAgKGxvY2FsLmdldCAkYikpXFxuICAgICAgICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkTUFYX0lOVCkpKSkpXFxuICAgICAocmV0dXJuIChpMzIud3JhcF9pNjQgKGxvY2FsLmdldCAkYSkpKSlcXG5cXG4gICAgIChyZXR1cm4gKGxvY2FsLmdldCAkTUFYX0lOVCkpXFxuKVxcblwiXG4gIH0sXG4gIFwiQURETU9EXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBzdGFjazpcXG47OyAgMDogQVxcbjs7IC0xOiBCXFxuOzsgLTI6IE1PRFxcbihmdW5jICRBRERNT0RcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgKGxvY2FsICRhIGk2NClcXG4gIChsb2NhbCAkYiBpNjQpXFxuICAobG9jYWwgJGMgaTY0KVxcbiAgKGxvY2FsICRkIGk2NClcXG5cXG4gIChsb2NhbCAkYTEgaTY0KVxcbiAgKGxvY2FsICRiMSBpNjQpXFxuICAobG9jYWwgJGMxIGk2NClcXG4gIChsb2NhbCAkZDEgaTY0KVxcblxcbiAgKGxvY2FsICRtb2RhIGk2NClcXG4gIChsb2NhbCAkbW9kYiBpNjQpXFxuICAobG9jYWwgJG1vZGMgaTY0KVxcbiAgKGxvY2FsICRtb2RkIGk2NClcXG5cXG4gIChsb2NhbCAkY2FycnkgaTY0KVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGdsb2JhbC5nZXQgJHNwKSlcXG5cXG4gIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRiIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRkIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGExIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGIxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGMxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkZDEgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAobG9jYWwuc2V0ICRzcCAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgKGxvY2FsLnNldCAkbW9kYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRtb2RiIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJG1vZGMgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRtb2RkIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgOzsgYSAqIDY0XjMgKyBiKjY0XjIgKyBjKjY0ICsgZFxcbiAgOzsgZFxcbiAgKGxvY2FsLnNldCAkZCAgICAgKGk2NC5hZGQgKGxvY2FsLmdldCAkZDEpIChsb2NhbC5nZXQgJGQpKSlcXG4gIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZXh0ZW5kX2kzMl91IChpNjQubHRfdSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRkMSkpKSlcXG4gIDs7IGNcXG4gIChsb2NhbC5zZXQgJGMgICAgIChpNjQuYWRkIChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAobG9jYWwuc2V0ICRjICAgICAoaTY0LmFkZCAobG9jYWwuZ2V0ICRjMSkgKGxvY2FsLmdldCAkYykpKVxcbiAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5vciAoaTY0LmV4dGVuZF9pMzJfdSAgKGk2NC5sdF91IChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJGMxKSkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICA7OyBiXFxuICAobG9jYWwuc2V0ICRiICAgICAoaTY0LmFkZCAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5leHRlbmRfaTMyX3UgKGk2NC5sdF91IChsb2NhbC5nZXQgJGIpIChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgKGxvY2FsLnNldCAkYiAgICAgKGk2NC5hZGQgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGIpKSlcXG4gIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQub3IgKGk2NC5leHRlbmRfaTMyX3UgIChpNjQubHRfdSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICRiMSkpKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgOzsgYVxcbiAgKGxvY2FsLnNldCAkYSAgICAgKGk2NC5hZGQgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZXh0ZW5kX2kzMl91IChpNjQubHRfdSAobG9jYWwuZ2V0ICRhKSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gIChsb2NhbC5zZXQgJGEgICAgIChpNjQuYWRkIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRhKSkpXFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lm9yIChpNjQuZXh0ZW5kX2kzMl91ICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYTEpKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG5cXG4gIChjYWxsICRtb2RfMzIwXFxuICAgICAgICAobG9jYWwuZ2V0ICRjYXJyeSkgKGxvY2FsLmdldCAkYSkgICAgKGxvY2FsLmdldCAkYikgICAgKGxvY2FsLmdldCAkYykgICAgKGxvY2FsLmdldCAkZClcXG4gICAgICAgIChpNjQuY29uc3QgMCkgICAgICAobG9jYWwuZ2V0ICRtb2RhKSAobG9jYWwuZ2V0ICRtb2RiKSAobG9jYWwuZ2V0ICRtb2RjKSAobG9jYWwuZ2V0ICRtb2RkKSAobG9jYWwuZ2V0ICRzcCkpXFxuKVxcblwiXG4gIH0sXG4gIFwiQU5EXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkQU5EXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkgIChpNjQuYW5kIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuYW5kIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQuYW5kIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkgKGk2NC5hbmQgKGk2NC5sb2FkIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKSAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSkpKVxcbilcXG5cIlxuICB9LFxuICBcIkJZVEVcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IHN0YWNrOlxcbjs7ICAwOiBvZmZzZXRcXG47OyAtMTogdmFsdWVcXG4oZnVuYyAkQllURVxcbiAgICAobG9jYWwgJHNwIGkzMilcXG5cXG4gICAgKGxvY2FsICR4MSBpNjQpXFxuICAgIChsb2NhbCAkeDIgaTY0KVxcbiAgICAobG9jYWwgJHgzIGk2NClcXG4gICAgKGxvY2FsICR4NCBpNjQpXFxuICAgIChsb2NhbCAkeTEgaTY0KVxcbiAgICAobG9jYWwgJHkyIGk2NClcXG4gICAgKGxvY2FsICR5MyBpNjQpXFxuICAgIChsb2NhbCAkeTQgaTY0KVxcblxcbiAgICAobG9jYWwgJHIxIGk2NClcXG4gICAgKGxvY2FsICRyMiBpNjQpXFxuICAgIChsb2NhbCAkcjMgaTY0KVxcbiAgICAobG9jYWwgJHI0IGk2NClcXG4gICAgKGxvY2FsICRjb21wb25lbnQgaTY0KVxcbiAgICAobG9jYWwgJGNvbmRpdGlvbiBpNjQpXFxuXFxuICAgIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgICAobG9jYWwuc2V0ICR4MSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4MiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAgIChsb2NhbC5zZXQgJHg0IChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKSlcXG5cXG4gICAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAgIChsb2NhbC5zZXQgJHkxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeTIgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAobG9jYWwuc2V0ICR5MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeTQgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAgIChibG9ja1xcbiAgICAgICAgKGlmIChpNjQuZXF6IChpNjQub3IgKGk2NC5vciAobG9jYWwuZ2V0ICR4MSkgKGxvY2FsLmdldCAkeDIpKSAobG9jYWwuZ2V0ICR4MykpKSAodGhlblxcbiAgICAgICAgICAgIChub3ApXFxuICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJGNvbmRpdGlvbiAoaTY0LmRpdl91IChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDgpKSlcXG4gICAgICAgICAgICAgICAgKGlmIChpNjQuZXEgKGxvY2FsLmdldCAkY29uZGl0aW9uKSAoaTY0LmNvbnN0IDApKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkY29tcG9uZW50IChsb2NhbC5nZXQgJHkxKSlcXG4gICAgICAgICAgICAgICAgKShlbHNlXFxuICAgICAgICAgICAgICAgICAgICAoaWYgKGk2NC5lcSAobG9jYWwuZ2V0ICRjb25kaXRpb24pIChpNjQuY29uc3QgMSkpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkY29tcG9uZW50IChsb2NhbC5nZXQgJHkyKSlcXG4gICAgICAgICAgICAgICAgICAgICkoZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpZiAoaTY0LmVxIChsb2NhbC5nZXQgJGNvbmRpdGlvbikgKGk2NC5jb25zdCAyKSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkY29tcG9uZW50IChsb2NhbC5nZXQgJHkzKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICApKGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpNjQuZXEgKGxvY2FsLmdldCAkY29uZGl0aW9uKSAoaTY0LmNvbnN0IDMpKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkY29tcG9uZW50IChsb2NhbC5nZXQgJHk0KSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICApKVxcbiAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgKSlcXG5cXG4gICAgICAgICAgICApXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkeDQgKGk2NC5tdWwgKGk2NC5yZW1fdSAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCA4KSkgKGk2NC5jb25zdCA4KSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkcjQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjb21wb25lbnQpIChpNjQuc3ViIChpNjQuY29uc3QgNTYpIChsb2NhbC5nZXQgJHg0KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHI0IChpNjQuYW5kIChpNjQuY29uc3QgMjU1KSAobG9jYWwuZ2V0ICRyNCkpKVxcbiAgICAgICAgKSlcXG5cXG4gICAgKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGxvY2FsLmdldCAkcjEpKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkcjIpKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGxvY2FsLmdldCAkcjMpKVxcbiAgICAoaTY0LnN0b3JlICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkcjQpKVxcbilcXG5cIlxuICB9LFxuICBcIkRJVlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJERJVlxcbiAgKGxvY2FsICRzcCBpMzIpXFxuICA7OyBkaXZpZGVuZFxcbiAgKGxvY2FsICRhIGk2NClcXG4gIChsb2NhbCAkYiBpNjQpXFxuICAobG9jYWwgJGMgaTY0KVxcbiAgKGxvY2FsICRkIGk2NClcXG5cXG4gIDs7IGRpdmlzb3JcXG4gIChsb2NhbCAkYTEgaTY0KVxcbiAgKGxvY2FsICRiMSBpNjQpXFxuICAobG9jYWwgJGMxIGk2NClcXG4gIChsb2NhbCAkZDEgaTY0KVxcblxcbiAgOzsgcXVvdGllbnRcXG4gIChsb2NhbCAkYXEgaTY0KVxcbiAgKGxvY2FsICRicSBpNjQpXFxuICAobG9jYWwgJGNxIGk2NClcXG4gIChsb2NhbCAkZHEgaTY0KVxcblxcbiAgOzsgbWFza1xcbiAgKGxvY2FsICRtYXNrYSBpNjQpXFxuICAobG9jYWwgJG1hc2tiIGk2NClcXG4gIChsb2NhbCAkbWFza2MgaTY0KVxcbiAgKGxvY2FsICRtYXNrZCBpNjQpXFxuICAobG9jYWwgJGNhcnJ5IGkzMilcXG4gIChsb2NhbCAkdGVtcCAgaTY0KVxcbiAgKGxvY2FsICR0ZW1wMiAgaTY0KVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGdsb2JhbC5nZXQgJHNwKSlcXG4gIChsb2NhbC5zZXQgJG1hc2tkIChpNjQuY29uc3QgMSkpXFxuXFxuICA7OyBsb2FkIGFyZ3MgZnJvbSB0aGUgc3RhY2tcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRjIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkZCAoaTY0LmxvYWQgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAobG9jYWwuc2V0ICRhMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRiMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRjMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGQxIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgKGJsb2NrICRtYWluXFxuICAgIDs7IGNoZWNrIGRpdiBieSAwXFxuICAgIChpZiAoY2FsbCAkaXN6ZXJvXzI1NiAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkpXFxuICAgICAgKGJyICRtYWluKVxcbiAgICApXFxuXFxuICAgIDs7IGFsaWduIGJpdHNcXG4gICAgKGJsb2NrICRkb25lXFxuICAgICAgKGxvb3AgJGxvb3BcXG4gICAgICAgIDs7IGFsaWduIGJpdHM7XFxuICAgICAgICAoaWZcXG4gICAgICAgICAgOzsgY2hlY2sgdG8gbWFrZSBzdXJlIHdlIGFyZSBub3Qgb3ZlcmZsb3dpbmdcXG4gICAgICAgICAgKGkzMi5vciAoaTY0LmVxeiAoaTY0LmNseiAobG9jYWwuZ2V0ICRhMSkpKVxcbiAgICAgICAgICA7OyAgZGl2aXNvciA8IGRpdmlkZW5kXFxuICAgICAgICAgIChjYWxsICRndGVfMjU2IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSAobG9jYWwuZ2V0ICRhKSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICRjKSAobG9jYWwuZ2V0ICRkKSkpXFxuICAgICAgICAgIChiciAkZG9uZSlcXG4gICAgICAgIClcXG5cXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yIDw8IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGExIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGExKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYjEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGQxIChpNjQuc2hsIChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IDEpKSlcXG5cXG4gICAgICAgIDs7IG1hc2sgPSBtYXNrIDw8IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2thIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2thKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2IgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYyAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYykgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tkKSAoaTY0LmNvbnN0IDEpKSlcXG5cXG4gICAgICAgIChiciAkbG9vcClcXG4gICAgICApXFxuICAgIClcXG5cXG5cXG4gICAgKGJsb2NrICRkb25lXFxuICAgICAgKGxvb3AgJGxvb3BcXG4gICAgICAgIDs7IGxvb3Agd2hpbGUgbWFzayAhPSAwXFxuICAgICAgICAoaWYgKGNhbGwgJGlzemVyb18yNTYgKGxvY2FsLmdldCAkbWFza2EpIChsb2NhbC5nZXQgJG1hc2tiKSAobG9jYWwuZ2V0ICRtYXNrYykgKGxvY2FsLmdldCAkbWFza2QpKVxcbiAgICAgICAgICAoYnIgJGRvbmUpXFxuICAgICAgICApXFxuICAgICAgICA7OyBpZiBkaXZpZGVuZCA+PSBkaXZpc29yXFxuICAgICAgICAoaWYgKGNhbGwgJGd0ZV8yNTYgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkYTEpIChsb2NhbC5nZXQgJGIxKSAobG9jYWwuZ2V0ICRjMSkgKGxvY2FsLmdldCAkZDEpKVxcbiAgICAgICAgICAodGhlblxcbiAgICAgICAgICAgIDs7IGRpdmlkZW5kID0gZGl2aWRlbmQgLSBkaXZpc29yXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5sdF91IChsb2NhbC5nZXQgJGQpIChsb2NhbC5nZXQgJGQxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkZCAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGQpIChsb2NhbC5nZXQgJGQxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGMpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRjKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkYyAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGMxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5vciAgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRjKSAobG9jYWwuZ2V0ICR0ZW1wKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkYikgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5ndF91IChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGIpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRiICAgICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYjEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLm9yICAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGIpIChsb2NhbC5nZXQgJHRlbXApKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGEgICAgIChpNjQuc3ViICAoaTY0LnN1YiAobG9jYWwuZ2V0ICRhKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSAobG9jYWwuZ2V0ICRhMSkpKVxcblxcbiAgICAgICAgICAgIDs7IHJlc3VsdCA9IHJlc3VsdCArIG1hc2tcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRkcSAgIChpNjQuYWRkIChsb2NhbC5nZXQgJG1hc2tkKSAobG9jYWwuZ2V0ICRkcSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgKGk2NC5leHRlbmRfaTMyX3UgKGk2NC5sdF91IChsb2NhbC5nZXQgJGRxKSAobG9jYWwuZ2V0ICRtYXNrZCkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjcSAgIChpNjQuYWRkIChsb2NhbC5nZXQgJGNxKSAobG9jYWwuZ2V0ICR0ZW1wKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkY3EpIChsb2NhbC5nZXQgJHRlbXApKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY3EgICAoaTY0LmFkZCAobG9jYWwuZ2V0ICRtYXNrYykgKGxvY2FsLmdldCAkY3EpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wIChpNjQub3IgKGk2NC5leHRlbmRfaTMyX3UgIChpNjQubHRfdSAobG9jYWwuZ2V0ICRjcSkgKGxvY2FsLmdldCAkbWFza2MpKSkgKGxvY2FsLmdldCAkdGVtcCkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGJxICAgKGk2NC5hZGQgKGxvY2FsLmdldCAkYnEpIChsb2NhbC5nZXQgJHRlbXApKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wIChpNjQuZXh0ZW5kX2kzMl91IChpNjQubHRfdSAobG9jYWwuZ2V0ICRicSkgKGxvY2FsLmdldCAkdGVtcCkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRicSAgIChpNjQuYWRkIChsb2NhbC5nZXQgJG1hc2tiKSAobG9jYWwuZ2V0ICRicSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGFxICAgKGk2NC5hZGQgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuYWRkIChsb2NhbC5nZXQgJGFxKSAoaTY0Lm9yIChpNjQuZXh0ZW5kX2kzMl91IChpNjQubHRfdSAobG9jYWwuZ2V0ICRicSkgKGxvY2FsLmdldCAkbWFza2IpKSkgKGxvY2FsLmdldCAkdGVtcCkpKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yID4+IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGQxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYzEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGExIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYTEpIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgICAgOzsgbWFzayA9IG1hc2sgPj4gMVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2QgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYyAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tiIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2thKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2EgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCAxKSkpXFxuICAgICAgICAoYnIgJGxvb3ApXFxuICAgICAgKVxcbiAgICApXFxuICApOzsgZW5kIG9mIG1haW5cXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICRhcSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkYnEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkgIChsb2NhbC5nZXQgJGNxKSlcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkc3ApIChsb2NhbC5nZXQgJGRxKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJFWFBcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRFWFBcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgOzsgYmFzZVxcbiAgKGxvY2FsICRiYXNlMCBpNjQpXFxuICAobG9jYWwgJGJhc2UxIGk2NClcXG4gIChsb2NhbCAkYmFzZTIgaTY0KVxcbiAgKGxvY2FsICRiYXNlMyBpNjQpXFxuXFxuICA7OyBleHBcXG4gIChsb2NhbCAkZXhwMCBpNjQpXFxuICAobG9jYWwgJGV4cDEgaTY0KVxcbiAgKGxvY2FsICRleHAyIGk2NClcXG4gIChsb2NhbCAkZXhwMyBpNjQpXFxuXFxuICAobG9jYWwgJHIwIGk2NClcXG4gIChsb2NhbCAkcjEgaTY0KVxcbiAgKGxvY2FsICRyMiBpNjQpXFxuICAobG9jYWwgJHIzIGk2NClcXG5cXG4gIChsb2NhbCAkZ2FzQ291bnRlciBpMzIpXFxuICAobG9jYWwuc2V0ICRzcCAoZ2xvYmFsLmdldCAkc3ApKVxcblxcbiAgOzsgbG9hZCBhcmdzIGZyb20gdGhlIHN0YWNrXFxuICAobG9jYWwuc2V0ICRiYXNlMCAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRiYXNlMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRiYXNlMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkpXFxuICAobG9jYWwuc2V0ICRiYXNlMyAoaTY0LmxvYWQgICAgICAgICAgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAobG9jYWwuc2V0ICRleHAwIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGV4cDEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkZXhwMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkpXFxuICAobG9jYWwuc2V0ICRleHAzIChpNjQubG9hZCAgICAgICAgICAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgOzsgbGV0IHJlc3VsdCA9IG5ldyBCTlsxXVxcbiAgKGxvY2FsLnNldCAkcjMgKGk2NC5jb25zdCAxKSlcXG5cXG4gIChibG9jayAkZG9uZVxcbiAgICAobG9vcCAkbG9vcFxcbiAgICAgICA7OyB3aGlsZSBbZXhwID4gMF0ge1xcbiAgICAgIChpZiAoY2FsbCAkaXN6ZXJvXzI1NiAobG9jYWwuZ2V0ICRleHAwKSAobG9jYWwuZ2V0ICRleHAxKSAobG9jYWwuZ2V0ICRleHAyKSAobG9jYWwuZ2V0ICRleHAzKSlcXG4gICAgICAgIChiciAkZG9uZSlcXG4gICAgICApXFxuXFxuICAgICAgOzsgaWZbZXhwLm1vZG5bMl0gPT09IDFdXFxuICAgICAgOzsgaXMgb2RkP1xcbiAgICAgIChpZiAoaTY0LmVxeiAoaTY0LmN0eiAobG9jYWwuZ2V0ICRleHAzKSkpXFxuXFxuICAgICAgICA7OyByZXN1bHQgPSByZXN1bHQubXVsW2Jhc2VdLm1vZFtUV09fUE9XMjU2XVxcbiAgICAgICAgOzsgciA9IHIgKiBhXFxuICAgICAgICAodGhlblxcbiAgICAgICAgICAoY2FsbCAkbXVsXzI1NiAobG9jYWwuZ2V0ICRyMCkgKGxvY2FsLmdldCAkcjEpIChsb2NhbC5nZXQgJHIyKSAobG9jYWwuZ2V0ICRyMykgKGxvY2FsLmdldCAkYmFzZTApIChsb2NhbC5nZXQgJGJhc2UxKSAobG9jYWwuZ2V0ICRiYXNlMikgKGxvY2FsLmdldCAkYmFzZTMpIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpXFxuICAgICAgICAgIChsb2NhbC5zZXQgJHIwIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gICAgICAgICAgKGxvY2FsLnNldCAkcjEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAgICAgICAobG9jYWwuc2V0ICRyMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkpXFxuICAgICAgICAgIChsb2NhbC5zZXQgJHIzIChpNjQubG9hZCAgICAgICAgICAobG9jYWwuZ2V0ICRzcCkpKVxcbiAgICAgICAgKVxcbiAgICAgIClcXG4gICAgICA7OyBleHAgPSBleHAuc2hybiAxXFxuICAgICAgKGxvY2FsLnNldCAkZXhwMyAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGV4cDMpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGV4cDIpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkZXhwMiAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGV4cDIpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGV4cDEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkZXhwMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGV4cDEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGV4cDApIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkZXhwMCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGV4cDApIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgIDs7IGJhc2UgPSBiYXNlLm11bHJbYmFzZXJdLm1vZHJbVFdPX1BPVzI1Nl1cXG4gICAgICAoY2FsbCAkbXVsXzI1NiAobG9jYWwuZ2V0ICRiYXNlMCkgKGxvY2FsLmdldCAkYmFzZTEpIChsb2NhbC5nZXQgJGJhc2UyKSAobG9jYWwuZ2V0ICRiYXNlMykgKGxvY2FsLmdldCAkYmFzZTApIChsb2NhbC5nZXQgJGJhc2UxKSAobG9jYWwuZ2V0ICRiYXNlMikgKGxvY2FsLmdldCAkYmFzZTMpIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpXFxuICAgICAgKGxvY2FsLnNldCAkYmFzZTAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGJhc2UxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gICAgICAobG9jYWwuc2V0ICRiYXNlMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYmFzZTMgKGk2NC5sb2FkICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAgICAgKGxvY2FsLnNldCAkZ2FzQ291bnRlciAoaTMyLmFkZCAobG9jYWwuZ2V0ICRnYXNDb3VudGVyKSAoaTMyLmNvbnN0IDEpKSlcXG4gICAgICAoYnIgJGxvb3ApXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IHVzZSBnYXNcXG4gIDs7IExvZzI1NltFeHBvbmVudF0gKiAxMFxcbiAgKGNhbGwgJHVzZUdhc1xcbiAgICAoaTY0LmV4dGVuZF9pMzJfdVxcbiAgICAgIChpMzIubXVsXFxuICAgICAgICAoaTMyLmNvbnN0IDEwKVxcbiAgICAgICAgKGkzMi5kaXZfdVxcbiAgICAgICAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRnYXNDb3VudGVyKSAoaTMyLmNvbnN0IDcpKVxcbiAgICAgICAgICAoaTMyLmNvbnN0IDgpKSkpKVxcblxcbiAgOzsgZGVjZW1lbnQgdGhlIHN0YWNrIHBvaW50ZXJcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICRyMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkcjEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpIChsb2NhbC5nZXQgJHIyKSlcXG4gIChpNjQuc3RvcmUgICAgICAgICAgKGxvY2FsLmdldCAkc3ApICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRyMykpXFxuKVxcblwiXG4gIH0sXG4gIFwiTU9EXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkTU9EXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIDs7IGRpdmlkZW5kXFxuICAobG9jYWwgJGEgaTY0KVxcbiAgKGxvY2FsICRiIGk2NClcXG4gIChsb2NhbCAkYyBpNjQpXFxuICAobG9jYWwgJGQgaTY0KVxcblxcbiAgOzsgZGl2aXNvclxcbiAgKGxvY2FsICRhMSBpNjQpXFxuICAobG9jYWwgJGIxIGk2NClcXG4gIChsb2NhbCAkYzEgaTY0KVxcbiAgKGxvY2FsICRkMSBpNjQpXFxuXFxuICA7OyBxdW90aWVudFxcbiAgKGxvY2FsICRhcSBpNjQpXFxuICAobG9jYWwgJGJxIGk2NClcXG4gIChsb2NhbCAkY3EgaTY0KVxcbiAgKGxvY2FsICRkcSBpNjQpXFxuXFxuICA7OyBtYXNrXFxuICAobG9jYWwgJG1hc2thIGk2NClcXG4gIChsb2NhbCAkbWFza2IgaTY0KVxcbiAgKGxvY2FsICRtYXNrYyBpNjQpXFxuICAobG9jYWwgJG1hc2tkIGk2NClcXG4gIChsb2NhbCAkY2FycnkgaTMyKVxcbiAgKGxvY2FsICR0ZW1wIGk2NClcXG5cXG4gIChsb2NhbC5zZXQgJG1hc2tkIChpNjQuY29uc3QgMSkpXFxuXFxuICA7OyBsb2FkIGFyZ3MgZnJvbSB0aGUgc3RhY2tcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGIgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGQgKGk2NC5sb2FkICAgICAgICAgIChnbG9iYWwuZ2V0ICRzcCkpKVxcbiAgOzsgZGVjZW1lbnQgdGhlIHN0YWNrIHBvaW50ZXJcXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgKGxvY2FsLnNldCAkYTEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYjEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYzEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkZDEgKGk2NC5sb2FkICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuXFxuICAoYmxvY2sgJG1haW5cXG4gICAgOzsgY2hlY2sgZGl2IGJ5IDBcXG4gICAgKGlmIChjYWxsICRpc3plcm9fMjU2IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSlcXG4gICAgICAodGhlblxcbiAgICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYiAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYyAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGJyICRtYWluKVxcbiAgICAgIClcXG4gICAgKVxcblxcbiAgICA7OyBhbGlnbiBiaXRzXFxuICAgIChibG9jayAkZG9uZVxcbiAgICAgICAgKGxvb3AgJGxvb3BcXG4gICAgICAgIDs7IGFsaWduIGJpdHM7XFxuICAgICAgICAoaWYgKGkzMi5vciAoaTY0LmVxeiAoaTY0LmNseiAobG9jYWwuZ2V0ICRhMSkpKSAoY2FsbCAkZ3RlXzI1NiAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkZCkpKVxcbiAgICAgICAgICAoYnIgJGRvbmUpXFxuICAgICAgICApXFxuXFxuICAgICAgICA7OyBkaXZpc29yID0gZGl2aXNvciA8PCAxXFxuICAgICAgICAobG9jYWwuc2V0ICRhMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGIxIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYzEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRkMSAoaTY0LnNobCAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICA7OyBtYXNrID0gbWFzayA8PCAxXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tiIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2MgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICAoYnIgJGxvb3ApXFxuICAgICAgKVxcbiAgICApXFxuXFxuICAgIChibG9jayAkZG9uZVxcbiAgICAgIChsb29wICRsb29wXFxuICAgICAgICA7OyBsb29wIHdoaWxlIG1hc2sgIT0gMFxcbiAgICAgICAgKGlmIChjYWxsICRpc3plcm9fMjU2IChsb2NhbC5nZXQgJG1hc2thKSAobG9jYWwuZ2V0ICRtYXNrYikgKGxvY2FsLmdldCAkbWFza2MpIChsb2NhbC5nZXQgJG1hc2tkKSlcXG4gICAgICAgICAgKGJyICRkb25lKVxcbiAgICAgICAgKVxcbiAgICAgICAgOzsgaWYgZGl2aWRlbmQgPj0gZGl2aXNvclxcbiAgICAgICAgKGlmIChjYWxsICRndGVfMjU2IChsb2NhbC5nZXQgJGEpIChsb2NhbC5nZXQgJGIpIChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJGQpIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSlcXG4gICAgICAgICAgKHRoZW5cXG4gICAgICAgICAgICA7OyBkaXZpZGVuZCA9IGRpdmlkZW5kIC0gZGl2aXNvclxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQubHRfdSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRkMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGQgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRkMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRjKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYykpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGMgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRjMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkdGVtcCkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGIpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkYiAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGIxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5vciAgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICR0ZW1wKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRhICAgICAoaTY0LnN1YiAgKGk2NC5zdWIgKGxvY2FsLmdldCAkYSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkgKGxvY2FsLmdldCAkYTEpKSlcXG4gICAgICAgICAgKVxcbiAgICAgICAgKVxcbiAgICAgICAgOzsgZGl2aXNvciA9IGRpdmlzb3IgPj4gMVxcbiAgICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGIxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGExKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICA7OyBtYXNrID0gbWFzayA+PiAxXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZCAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tkKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYykgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tjIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2IgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2thKSAoaTY0LmNvbnN0IDEpKSlcXG4gICAgICAgIChiciAkbG9vcClcXG4gICAgICApXFxuICAgIClcXG4gICk7OyBlbmQgb2YgbWFpblxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChsb2NhbC5nZXQgJGEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChsb2NhbC5nZXQgJGIpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpIChsb2NhbC5nZXQgJGMpKVxcbiAgKGk2NC5zdG9yZSAgICAgICAgICAobG9jYWwuZ2V0ICRzcCkgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGQpKVxcbilcXG5cIlxuICB9LFxuICBcIk1TSVpFXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkTVNJWkVcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgOzsgdGhlcmUncyBubyBpbnB1dCBpdGVtIGZvciB1cyB0byBvdmVyd3JpdGVcXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAwKSkgXFxuICAgICAgICAgICAgIChpNjQubXVsIChnbG9iYWwuZ2V0ICR3b3JkQ291bnQpIChpNjQuY29uc3QgMzIpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGk2NC5jb25zdCAwKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAoaTY0LmNvbnN0IDApKVxcbilcXG5cIlxuICB9LFxuICBcIk1TVE9SRThcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IHN0YWNrOlxcbjs7ICAwOiBvZmZzZXRcXG47OyAtMTogd29yZFxcbihmdW5jICRNU1RPUkU4XFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIChsb2NhbCAkb2Zmc2V0IGkzMilcXG5cXG4gIChsb2NhbCAkb2Zmc2V0MCBpNjQpXFxuICAobG9jYWwgJG9mZnNldDEgaTY0KVxcbiAgKGxvY2FsICRvZmZzZXQyIGk2NClcXG4gIChsb2NhbCAkb2Zmc2V0MyBpNjQpXFxuXFxuICA7OyBsb2FkIGFyZ3MgZnJvbSB0aGUgc3RhY2tcXG4gIChsb2NhbC5zZXQgJG9mZnNldDAgKGk2NC5sb2FkICAgICAgICAgIChnbG9iYWwuZ2V0ICRzcCkpKVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRvZmZzZXQyIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRvZmZzZXQzIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuXFxuICAobG9jYWwuc2V0ICRvZmZzZXQgXFxuICAgICAgICAgICAgIChjYWxsICRjaGVja19vdmVyZmxvdyAobG9jYWwuZ2V0ICRvZmZzZXQwKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0MSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJG9mZnNldDIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRvZmZzZXQzKSkpXFxuXFxuICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJG9mZnNldCkgKGkzMi5jb25zdCAxKSlcXG5cXG4gIDs7IHBvcCBzdGFja1xcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuICAobG9jYWwuc2V0ICRvZmZzZXQgKGkzMi5hZGQgKGxvY2FsLmdldCAkb2Zmc2V0KSAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpKSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJG9mZnNldCkgKGkzMi5jb25zdCAwKSkgKGkzMi5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiTVVMXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkTVVMXFxuICAoY2FsbCAkbXVsXzI1NlxcbiAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKVxcbiAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKVxcbiAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKVxcbiAgICAgICAgKGk2NC5sb2FkICAgICAgICAgIChnbG9iYWwuZ2V0ICRzcCkpXFxuICAgICAgICAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpXFxuICAgICAgICAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpXFxuICAgICAgICAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpXFxuICAgICAgICAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuICAgICAgICAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpXFxuICApXFxuKVxcblwiXG4gIH0sXG4gIFwiTVVMTU9EXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkTVVMTU9EXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIChsb2NhbCAkYSBpNjQpXFxuICAobG9jYWwgJGMgaTY0KVxcbiAgKGxvY2FsICRlIGk2NClcXG4gIChsb2NhbCAkZyBpNjQpXFxuICAobG9jYWwgJGkgaTY0KVxcbiAgKGxvY2FsICRrIGk2NClcXG4gIChsb2NhbCAkbSBpNjQpXFxuICAobG9jYWwgJG8gaTY0KVxcbiAgKGxvY2FsICRiIGk2NClcXG4gIChsb2NhbCAkZCBpNjQpXFxuICAobG9jYWwgJGYgaTY0KVxcbiAgKGxvY2FsICRoIGk2NClcXG4gIChsb2NhbCAkaiBpNjQpXFxuICAobG9jYWwgJGwgaTY0KVxcbiAgKGxvY2FsICRuIGk2NClcXG4gIChsb2NhbCAkcCBpNjQpXFxuICAobG9jYWwgJHRlbXA3IGk2NClcXG4gIChsb2NhbCAkdGVtcDYgaTY0KVxcbiAgKGxvY2FsICR0ZW1wNSBpNjQpXFxuICAobG9jYWwgJHRlbXA0IGk2NClcXG4gIChsb2NhbCAkdGVtcDMgaTY0KVxcbiAgKGxvY2FsICR0ZW1wMiBpNjQpXFxuICAobG9jYWwgJHRlbXAxIGk2NClcXG4gIChsb2NhbCAkdGVtcDAgaTY0KVxcbiAgKGxvY2FsICRyb3dDYXJyeSBpNjQpXFxuXFxuICAobG9jYWwgJG1vZGEgaTY0KVxcbiAgKGxvY2FsICRtb2RiIGk2NClcXG4gIChsb2NhbCAkbW9kYyBpNjQpXFxuICAobG9jYWwgJG1vZGQgaTY0KVxcblxcbiAgOzsgcG9wIHR3byBpdGVtcyBvZiB0aGUgc3RhY2tcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGUgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGcgKGk2NC5sb2FkICAgICAgICAgIChnbG9iYWwuZ2V0ICRzcCkpKVxcbiAgKGxvY2FsLnNldCAkaSAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkayAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkbSAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkbyAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDY0KSkpXFxuXFxuICA7OyBNVUxcXG4gIDs7ICBhIGIgYyBkIGUgZiBnIGhcXG4gIDs7KiBpIGogayBsIG0gbiBvIHBcXG4gIDs7LS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgOzsgc3BsaXQgdGhlIG9wc1xcbiAgKGxvY2FsLnNldCAkYiAoaTY0LmFuZCAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IDMyKSkpIFxcblxcbiAgKGxvY2FsLnNldCAkZCAoaTY0LmFuZCAobG9jYWwuZ2V0ICRjKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjKSAoaTY0LmNvbnN0IDMyKSkpIFxcblxcbiAgKGxvY2FsLnNldCAkZiAoaTY0LmFuZCAobG9jYWwuZ2V0ICRlKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJGUgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRlKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICAobG9jYWwuc2V0ICRoIChpNjQuYW5kIChsb2NhbC5nZXQgJGcpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKVxcbiAgKGxvY2FsLnNldCAkZyAoaTY0LnNocl91IChsb2NhbC5nZXQgJGcpIChpNjQuY29uc3QgMzIpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGogKGk2NC5hbmQgKGxvY2FsLmdldCAkaSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpXFxuICAobG9jYWwuc2V0ICRpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaSkgKGk2NC5jb25zdCAzMikpKSBcXG5cXG4gIChsb2NhbC5zZXQgJGwgKGk2NC5hbmQgKGxvY2FsLmdldCAkaykgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpXFxuICAobG9jYWwuc2V0ICRrIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaykgKGk2NC5jb25zdCAzMikpKSBcXG5cXG4gIChsb2NhbC5zZXQgJG4gKGk2NC5hbmQgKGxvY2FsLmdldCAkbSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpXFxuICAobG9jYWwuc2V0ICRtIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbSkgKGk2NC5jb25zdCAzMikpKVxcblxcbiAgKGxvY2FsLnNldCAkcCAoaTY0LmFuZCAobG9jYWwuZ2V0ICRvKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJG8gKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRvKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICAgOzsgZmlyc3Qgcm93IG11bHRpcGxpY2F0aW9uIFxcbiAgOzsgcCAqIGhcXG4gIChsb2NhbC5zZXQgJHRlbXAwIChpNjQubXVsIChsb2NhbC5nZXQgJHApIChsb2NhbC5nZXQgJGgpKSlcXG4gIDs7IHAgKiBnICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXAxIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJHApIChsb2NhbC5nZXQgJGcpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAwKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgcCAqIGYgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDIgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkZikpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDEpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBwICogZSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wMyAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRwKSAobG9jYWwuZ2V0ICRlKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wMikgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IHAgKiBkICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA0IChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJHApIChsb2NhbC5nZXQgJGQpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAzKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgcCAqIGMgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDUgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkYykpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBwICogYiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRwKSAobG9jYWwuZ2V0ICRiKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNSkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IHAgKiBhICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA3IChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJHApIChsb2NhbC5nZXQgJGEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA2KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgKGxvY2FsLnNldCAkcm93Q2FycnkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNykgKGk2NC5jb25zdCAzMikpKVxcblxcbiAgOzsgc2Vjb25kIHJvd1xcbiAgOzsgbyAqIGggKyAkdGVtcDEgXFxuICAobG9jYWwuc2V0ICR0ZW1wMSAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRoKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDEpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIDs7IG8gKiBnICsgJHRlbXAyICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXAyIChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG8pIChsb2NhbC5nZXQgJGcpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDEpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBvICogZiArICR0ZW1wMyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wMyAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRmKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAyKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbyAqIGUgKyAkdGVtcDQgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDQgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbykgKGxvY2FsLmdldCAkZSkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA0KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wMykgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG8gKiBkICsgJHRlbXA1ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA1IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG8pIChsb2NhbC5nZXQgJGQpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBvICogYyArICR0ZW1wNiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRjKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbyAqIGIgKyAkdGVtcDcgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDcgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbykgKGxvY2FsLmdldCAkYikpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG8gKiBhICsgY2FycnkgKyByb3dDYXJyeVxcbiAgKGxvY2FsLnNldCAkcCAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRhKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNykgKGk2NC5jb25zdCAzMikpKSAobG9jYWwuZ2V0ICRyb3dDYXJyeSkpKVxcbiAgKGxvY2FsLnNldCAkcm93Q2FycnkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRwKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICA7OyB0aGlyZCByb3cgLSBuXFxuICA7OyBuICogaCArICR0ZW1wMiBcXG4gIChsb2NhbC5zZXQgJHRlbXAyIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgOzsgbiAqIGcgKyAkdGVtcDMgIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wMyAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRuKSAobG9jYWwuZ2V0ICRnKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAyKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbiAqIGYgKyAkdGVtcDQpICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA0IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGYpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBuICogZSArICR0ZW1wNSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNSAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRuKSAobG9jYWwuZ2V0ICRlKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA0KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbiAqIGQgKyAkdGVtcDYgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDYgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbikgKGxvY2FsLmdldCAkZCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA2KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNSkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG4gKiBjICsgJHRlbXA3ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA3IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGMpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNykgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBuICogYiArICRwICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHAgICAgIChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGIpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICRwKSAgICAgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDcpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBuICogYSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRvIChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHApIChpNjQuY29uc3QgMzIpKSkgKGxvY2FsLmdldCAkcm93Q2FycnkpKSlcXG4gIChsb2NhbC5zZXQgJHJvd0NhcnJ5IChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbykgKGk2NC5jb25zdCAzMikpKVxcblxcbiAgOzsgZm9ydGggcm93IFxcbiAgOzsgbSAqIGggKyAkdGVtcDNcXG4gIChsb2NhbC5zZXQgJHRlbXAzIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG0pIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMykgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgOzsgbSAqIGcgKyAkdGVtcDQgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDQgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkZykpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA0KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wMykgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG0gKiBmICsgJHRlbXA1ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA1IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG0pIChsb2NhbC5nZXQgJGYpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBtICogZSArICR0ZW1wNiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRtKSAobG9jYWwuZ2V0ICRlKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbSAqIGQgKyAkdGVtcDcgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDcgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkZCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG0gKiBjICsgJHAgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkcCAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkYykpIChpNjQuYW5kIChsb2NhbC5nZXQgJHApICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNykgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG0gKiBiICsgJG8gKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkbyAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkYikpIChpNjQuYW5kIChsb2NhbC5nZXQgJG8pICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRwKSAgICAgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG0gKiBhICsgY2FycnkgKyByb3dDYXJyeVxcbiAgKGxvY2FsLnNldCAkbiAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkYSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbykgKGk2NC5jb25zdCAzMikpKSAobG9jYWwuZ2V0ICRyb3dDYXJyeSkpKVxcbiAgKGxvY2FsLnNldCAkcm93Q2FycnkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRuKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICA7OyBmaXRoIHJvd1xcbiAgOzsgbCAqIGggKyAkdGVtcDRcXG4gIChsb2NhbC5zZXQgJHRlbXA0IChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGwpIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgOzsgbCAqIGcgKyAkdGVtcDUgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDUgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbCkgKGxvY2FsLmdldCAkZykpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGwgKiBmICsgJHRlbXA2ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA2IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGwpIChsb2NhbC5nZXQgJGYpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBsICogZSArICR0ZW1wNyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNyAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRlKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDcpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA2KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbCAqIGQgKyAkcCArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRwICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRkKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkcCkgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbCAqIGMgKyAkbyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRvICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRjKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbykgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHApICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbCAqIGIgKyAkbiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRuICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRiKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbikgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG8pICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbCAqIGEgKyBjYXJyeSArIHJvd0NhcnJ5XFxuICAobG9jYWwuc2V0ICRtICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRhKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRuKSAoaTY0LmNvbnN0IDMyKSkpIChsb2NhbC5nZXQgJHJvd0NhcnJ5KSkpXFxuICAobG9jYWwuc2V0ICRyb3dDYXJyeSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG0pIChpNjQuY29uc3QgMzIpKSlcXG5cXG4gIDs7IHNpeHRoIHJvdyBcXG4gIDs7IGsgKiBoICsgJHRlbXA1XFxuICAobG9jYWwuc2V0ICR0ZW1wNSAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRoKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIDs7IGsgKiBnICsgJHRlbXA2ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA2IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGspIChsb2NhbC5nZXQgJGcpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBrICogZiArICR0ZW1wNyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNyAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRmKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDcpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA2KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgayAqIGUgKyAkcCArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRwICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRlKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkcCkgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgayAqIGQgKyAkbyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRvICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRkKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbykgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHApICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgayAqIGMgKyAkbiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRuICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRjKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbikgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG8pICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgayAqIGIgKyAkbSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRtICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRiKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbSkgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG4pICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgayAqIGEgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkbCAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaykgKGxvY2FsLmdldCAkYSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbSkgKGk2NC5jb25zdCAzMikpKSAobG9jYWwuZ2V0ICRyb3dDYXJyeSkpKVxcbiAgKGxvY2FsLnNldCAkcm93Q2FycnkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRsKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICA7OyBzZXZlbnRoIHJvd1xcbiAgOzsgaiAqIGggKyAkdGVtcDZcXG4gIChsb2NhbC5zZXQgJHRlbXA2IChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGopIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgOzsgaiAqIGcgKyAkdGVtcDcgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDcgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaikgKGxvY2FsLmdldCAkZykpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGogKiBmICsgJHAgK2NhcnJ5XFxuICAobG9jYWwuc2V0ICRwICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRmKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkcCkgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgaiAqIGUgKyAkbyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRvICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRlKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbykgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHApICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgaiAqIGQgKyAkbiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRuICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRkKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbikgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG8pICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgaiAqIGMgKyAkbSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRtICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRjKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbSkgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG4pICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgaiAqIGIgKyAkbCArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRsICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRiKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbCkgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG0pICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgaiAqIGEgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkayAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaikgKGxvY2FsLmdldCAkYSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbCkgKGk2NC5jb25zdCAzMikpKSAobG9jYWwuZ2V0ICRyb3dDYXJyeSkpKVxcbiAgKGxvY2FsLnNldCAkcm93Q2FycnkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRrKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICA7OyBlaWd0aCByb3dcXG4gIDs7IGkgKiBoICsgJHRlbXA3IFxcbiAgKGxvY2FsLnNldCAkdGVtcDcgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkaCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkpXFxuICA7OyBpICogZyArICRwIFxcbiAgKGxvY2FsLnNldCAkcCAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkZykpIChpNjQuYW5kIChsb2NhbC5nZXQgJHApICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNykgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGkgKiBmICsgJG8gKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkbyAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkZikpIChpNjQuYW5kIChsb2NhbC5nZXQgJG8pICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRwKSAgICAgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGkgKiBlICsgJG4gKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkbiAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkZSkpIChpNjQuYW5kIChsb2NhbC5nZXQgJG4pICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRvKSAgICAgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGkgKiBkICsgJG0gKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkbSAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkZCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJG0pICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRuKSAgICAgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGkgKiBjICsgJGwgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkbCAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkYykpIChpNjQuYW5kIChsb2NhbC5nZXQgJGwpICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtKSAgICAgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGkgKiBiICsgJGsgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkayAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkYikpIChpNjQuYW5kIChsb2NhbC5nZXQgJGspICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRsKSAgICAgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGkgKiBhICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJGogICAgIChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGkpIChsb2NhbC5nZXQgJGEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGspIChpNjQuY29uc3QgMzIpKSkgKGxvY2FsLmdldCAkcm93Q2FycnkpKSlcXG5cXG4gIDs7IGNvbWJpbmUgdGVybXNcXG4gIChsb2NhbC5zZXQgJGEgKGxvY2FsLmdldCAkaikpXFxuICAobG9jYWwuc2V0ICRiIChpNjQub3IgKGk2NC5zaGwgKGxvY2FsLmdldCAkaykgICAgIChpNjQuY29uc3QgMzIpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICRsKSAgICAgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgKGxvY2FsLnNldCAkYyAoaTY0Lm9yIChpNjQuc2hsIChsb2NhbC5nZXQgJG0pICAgICAoaTY0LmNvbnN0IDMyKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbikgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIChsb2NhbC5zZXQgJGQgKGk2NC5vciAoaTY0LnNobCAobG9jYWwuZ2V0ICRvKSAgICAgKGk2NC5jb25zdCAzMikpIChpNjQuYW5kIChsb2NhbC5nZXQgJHApICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkpXFxuICAobG9jYWwuc2V0ICRlIChpNjQub3IgKGk2NC5zaGwgKGxvY2FsLmdldCAkdGVtcDcpIChpNjQuY29uc3QgMzIpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgKGxvY2FsLnNldCAkZiAoaTY0Lm9yIChpNjQuc2hsIChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIChsb2NhbC5zZXQgJGcgKGk2NC5vciAoaTY0LnNobCAobG9jYWwuZ2V0ICR0ZW1wMykgKGk2NC5jb25zdCAzMikpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXAyKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkpXFxuICAobG9jYWwuc2V0ICRoIChpNjQub3IgKGk2NC5zaGwgKGxvY2FsLmdldCAkdGVtcDEpIChpNjQuY29uc3QgMzIpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMCkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcblxcbiAgOzsgcG9wIHRoZSBNT0QgYXJnbXVuZXQgb2ZmIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkbW9kYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRtb2RiIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJG1vZGMgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkbW9kZCAoaTY0LmxvYWQgICAgICAgICAgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIChjYWxsICRtb2RfNTEyXFxuICAgICAgICAgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkZSkgKGxvY2FsLmdldCAkZikgKGxvY2FsLmdldCAkZykgKGxvY2FsLmdldCAkaCkgXFxuICAgICAgICAgKGk2NC5jb25zdCAwKSAgKGk2NC5jb25zdCAwKSAoaTY0LmNvbnN0IDApICAoaTY0LmNvbnN0IDApICAobG9jYWwuZ2V0ICRtb2RhKSAobG9jYWwuZ2V0ICRtb2RiKSAobG9jYWwuZ2V0ICRtb2RjKSAobG9jYWwuZ2V0ICRtb2RkKSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpXFxuICApXFxuKVxcblwiXG4gIH0sXG4gIFwiTk9UXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkTk9UXFxuICA7OyBGSVhNRTogY29uc2lkZXIgdXNpbmcgMHhmZmZmZmZmZmZmZmZmZmZmIGluc3RlYWQgb2YgLTE/XFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQueG9yIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkgKGk2NC5jb25zdCAtMSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAoaTY0LnhvciAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpIChpNjQuY29uc3QgLTEpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGk2NC54b3IgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgMCkpIChpNjQueG9yIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDApKSkgKGk2NC5jb25zdCAtMSkpKVxcbilcXG5cIlxuICB9LFxuICBcIk9SXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkT1JcXG4gIChpNjQuc3RvcmUgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGk2NC5vciAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAoaTY0Lm9yIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQub3IgKGk2NC5sb2FkIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkgKGk2NC5vciAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpIChpNjQubG9hZCAgICAgICAgICAoZ2xvYmFsLmdldCAkc3ApKSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiUENcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRQQ1xcbiAgKHBhcmFtICRwYyBpMzIpXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIDs7IGFkZCBvbmUgdG8gdGhlIHN0YWNrXFxuICAobG9jYWwuc2V0ICRzcCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSlcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkc3ApIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJHBjKSkpXFxuXFxuICA7OyB6ZXJvIG91dCByZXN0IG9mIHN0YWNrXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5jb25zdCAwKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJTQVJcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRTQVJcXG4gICAgKGxvY2FsICRzcCBpMzIpXFxuICAgIChsb2NhbCAkeDEgaTY0KVxcbiAgICAobG9jYWwgJHgyIGk2NClcXG4gICAgKGxvY2FsICR4MyBpNjQpXFxuICAgIChsb2NhbCAkeDQgaTY0KVxcbiAgICAobG9jYWwgJHkxIGk2NClcXG4gICAgKGxvY2FsICR5MiBpNjQpXFxuICAgIChsb2NhbCAkeTMgaTY0KVxcbiAgICAobG9jYWwgJHk0IGk2NClcXG5cXG4gICAgKGxvY2FsICR6MSBpNjQpXFxuICAgIChsb2NhbCAkejIgaTY0KVxcbiAgICAobG9jYWwgJHozIGk2NClcXG4gICAgKGxvY2FsICR6NCBpNjQpXFxuXFxuICAgIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgICAobG9jYWwuc2V0ICR4MSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4MiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAgIChsb2NhbC5zZXQgJHg0IChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKSlcXG5cXG4gICAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAgIChsb2NhbC5zZXQgJHkxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeTIgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAobG9jYWwuc2V0ICR5MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeTQgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAgIChibG9jayAkbGFiZWxfc2FyX2ludGVybmFsXFxuICAgICAgICAoaWYgKGk2NC5ndF91IChpNjQuY2x6IChsb2NhbC5nZXQgJHkxKSkgKGk2NC5jb25zdCAwKSkgKHRoZW5cXG4gICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejEgKGNhbGwgJHNocl8gKGxvY2FsLmdldCAkeDEpIChsb2NhbC5nZXQgJHgyKSAobG9jYWwuZ2V0ICR4MykgKGxvY2FsLmdldCAkeDQpIChsb2NhbC5nZXQgJHkxKSAobG9jYWwuZ2V0ICR5MikgKGxvY2FsLmdldCAkeTMpIChsb2NhbC5nZXQgJHk0KSkpXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHoyIChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG4gICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejMgKGdsb2JhbC5nZXQgJGdsb2JhbF9fMSkpXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHo0IChnbG9iYWwuZ2V0ICRnbG9iYWxfXzIpKVxcblxcbiAgICAgICAgICAgIClcXG4gICAgICAgICAgICAoYnIgJGxhYmVsX3Nhcl9pbnRlcm5hbClcXG4gICAgICAgICkpXFxuICAgICAgICAoaWYgKGNhbGwgJGd0ZV8yNTZ4MjU2XzY0IChsb2NhbC5nZXQgJHgxKSAobG9jYWwuZ2V0ICR4MikgKGxvY2FsLmdldCAkeDMpIChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDApIChpNjQuY29uc3QgMCkgKGk2NC5jb25zdCAwKSAoaTY0LmNvbnN0IDI1NikpICh0aGVuXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkejEgKGk2NC5jb25zdCAxODQ0Njc0NDA3MzcwOTU1MTYxNSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGk2NC5jb25zdCAxODQ0Njc0NDA3MzcwOTU1MTYxNSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkejMgKGk2NC5jb25zdCAxODQ0Njc0NDA3MzcwOTU1MTYxNSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkejQgKGk2NC5jb25zdCAxODQ0Njc0NDA3MzcwOTU1MTYxNSkpXFxuICAgICAgICApKVxcbiAgICAgICAgKGlmIChjYWxsICRsdF8yNTZ4MjU2XzY0IChsb2NhbC5nZXQgJHgxKSAobG9jYWwuZ2V0ICR4MikgKGxvY2FsLmdldCAkeDMpIChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDApIChpNjQuY29uc3QgMCkgKGk2NC5jb25zdCAwKSAoaTY0LmNvbnN0IDI1NikpICh0aGVuXFxuICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkxIChjYWxsICRzaHJfIChpNjQuY29uc3QgMCkgKGk2NC5jb25zdCAwKSAoaTY0LmNvbnN0IDApIChsb2NhbC5nZXQgJHg0KSAobG9jYWwuZ2V0ICR5MSkgKGxvY2FsLmdldCAkeTIpIChsb2NhbC5nZXQgJHkzKSAobG9jYWwuZ2V0ICR5NCkpKVxcbiAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MiAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkzIChnbG9iYWwuZ2V0ICRnbG9iYWxfXzEpKVxcbiAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5NCAoZ2xvYmFsLmdldCAkZ2xvYmFsX18yKSlcXG5cXG4gICAgICAgICAgICApXFxuICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHoxIChjYWxsICRzaGxfIChpNjQuY29uc3QgMCkgKGk2NC5jb25zdCAwKSAoaTY0LmNvbnN0IDApIChpNjQuc3ViIChpNjQuY29uc3QgMjU2KSAobG9jYWwuZ2V0ICR4NCkpIChpNjQuY29uc3QgMTg0NDY3NDQwNzM3MDk1NTE2MTUpIChpNjQuY29uc3QgMTg0NDY3NDQwNzM3MDk1NTE2MTUpIChpNjQuY29uc3QgMTg0NDY3NDQwNzM3MDk1NTE2MTUpIChpNjQuY29uc3QgMTg0NDY3NDQwNzM3MDk1NTE2MTUpKSlcXG4gICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGdsb2JhbC5nZXQgJGdsb2JhbF8pKVxcbiAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MyAoZ2xvYmFsLmdldCAkZ2xvYmFsX18xKSlcXG4gICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejQgKGdsb2JhbC5nZXQgJGdsb2JhbF9fMikpXFxuXFxuICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MSAoY2FsbCAkb3JfIChsb2NhbC5nZXQgJHkxKSAobG9jYWwuZ2V0ICR5MikgKGxvY2FsLmdldCAkeTMpIChsb2NhbC5nZXQgJHk0KSAobG9jYWwuZ2V0ICR6MSkgKGxvY2FsLmdldCAkejIpIChsb2NhbC5nZXQgJHozKSAobG9jYWwuZ2V0ICR6NCkpKVxcbiAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MiAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHozIChnbG9iYWwuZ2V0ICRnbG9iYWxfXzEpKVxcbiAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6NCAoZ2xvYmFsLmdldCAkZ2xvYmFsX18yKSlcXG5cXG4gICAgICAgICAgICApXFxuICAgICAgICApKVxcblxcbiAgICApXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICR6MSkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAobG9jYWwuZ2V0ICR6MikpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAobG9jYWwuZ2V0ICR6MykpXFxuICAgIChpNjQuc3RvcmUgICAgICAgICAgKGxvY2FsLmdldCAkc3ApICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICR6NCkpXFxuKVxcblxcbihmdW5jICRsdF8yNTZ4MjU2XzY0XFxuICAgIChwYXJhbSAkeDEgaTY0KVxcbiAgICAocGFyYW0gJHgyIGk2NClcXG4gICAgKHBhcmFtICR4MyBpNjQpXFxuICAgIChwYXJhbSAkeDQgaTY0KVxcbiAgICAocGFyYW0gJHkxIGk2NClcXG4gICAgKHBhcmFtICR5MiBpNjQpXFxuICAgIChwYXJhbSAkeTMgaTY0KVxcbiAgICAocGFyYW0gJHk0IGk2NClcXG4gICAgKHJlc3VsdCBpMzIpXFxuICAgIChsb2NhbCAkeiBpMzIpXFxuICAgIChsb2NhbCAkY29uZGl0aW9uXzEwNiBpMzIpXFxuICAgIChsb2NhbCAkY29uZGl0aW9uXzEwNyBpMzIpXFxuICAgIChsb2NhbCAkY29uZGl0aW9uXzEwOCBpMzIpXFxuICAgIChibG9ja1xcbiAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY29uZGl0aW9uXzEwNiAoY2FsbCAkY21wIChsb2NhbC5nZXQgJHgxKSAobG9jYWwuZ2V0ICR5MSkpKVxcbiAgICAgICAgICAgIChpZiAoaTMyLmVxIChsb2NhbC5nZXQgJGNvbmRpdGlvbl8xMDYpIChpMzIuY29uc3QgMCkpICh0aGVuXFxuICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkY29uZGl0aW9uXzEwNyAoY2FsbCAkY21wIChsb2NhbC5nZXQgJHgyKSAobG9jYWwuZ2V0ICR5MikpKVxcbiAgICAgICAgICAgICAgICAgICAgKGlmIChpMzIuZXEgKGxvY2FsLmdldCAkY29uZGl0aW9uXzEwNykgKGkzMi5jb25zdCAwKSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkY29uZGl0aW9uXzEwOCAoY2FsbCAkY21wIChsb2NhbC5nZXQgJHgzKSAobG9jYWwuZ2V0ICR5MykpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaWYgKGkzMi5lcSAobG9jYWwuZ2V0ICRjb25kaXRpb25fMTA4KSAoaTMyLmNvbnN0IDApKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeiAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkeDQpIChsb2NhbC5nZXQgJHk0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkoZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpMzIuZXEgKGxvY2FsLmdldCAkY29uZGl0aW9uXzEwOCkgKGkzMi5jb25zdCAxKSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6IChpMzIuY29uc3QgMCkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6IChpMzIuY29uc3QgMSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgICkoZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpZiAoaTMyLmVxIChsb2NhbC5nZXQgJGNvbmRpdGlvbl8xMDcpIChpMzIuY29uc3QgMSkpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHogKGkzMi5jb25zdCAwKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICApKGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeiAoaTMyLmNvbnN0IDEpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXFxuICAgICAgICAgICAgICAgICAgICApKVxcblxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgKShlbHNlXFxuICAgICAgICAgICAgICAgIChpZiAoaTMyLmVxIChsb2NhbC5nZXQgJGNvbmRpdGlvbl8xMDYpIChpMzIuY29uc3QgMSkpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6IChpMzIuY29uc3QgMCkpXFxuICAgICAgICAgICAgICAgICkoZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeiAoaTMyLmNvbnN0IDEpKVxcbiAgICAgICAgICAgICAgICApKVxcbiAgICAgICAgICAgICkpXFxuXFxuICAgICAgICApXFxuXFxuICAgIClcXG4gICAgKGxvY2FsLmdldCAkeilcXG4pXFxuXFxuKGZ1bmMgJGd0ZV8yNTZ4MjU2XzY0XFxuICAgIChwYXJhbSAkeDEgaTY0KVxcbiAgICAocGFyYW0gJHgyIGk2NClcXG4gICAgKHBhcmFtICR4MyBpNjQpXFxuICAgIChwYXJhbSAkeDQgaTY0KVxcbiAgICAocGFyYW0gJHkxIGk2NClcXG4gICAgKHBhcmFtICR5MiBpNjQpXFxuICAgIChwYXJhbSAkeTMgaTY0KVxcbiAgICAocGFyYW0gJHk0IGk2NClcXG4gICAgKHJlc3VsdCBpMzIpXFxuICAgIChsb2NhbCAkeiBpMzIpXFxuICAgIChibG9ja1xcbiAgICAgICAgKGxvY2FsLnNldCAkeiAoaTMyLmVxeiAoY2FsbCAkbHRfMjU2eDI1Nl82NCAobG9jYWwuZ2V0ICR4MSkgKGxvY2FsLmdldCAkeDIpIChsb2NhbC5nZXQgJHgzKSAobG9jYWwuZ2V0ICR4NCkgKGxvY2FsLmdldCAkeTEpIChsb2NhbC5nZXQgJHkyKSAobG9jYWwuZ2V0ICR5MykgKGxvY2FsLmdldCAkeTQpKSkpXFxuXFxuICAgIClcXG4gICAgKGxvY2FsLmdldCAkeilcXG4pXFxuXFxuXFxuKGZ1bmMgJG9yX1xcbiAgICAocGFyYW0gJHgxIGk2NClcXG4gICAgKHBhcmFtICR4MiBpNjQpXFxuICAgIChwYXJhbSAkeDMgaTY0KVxcbiAgICAocGFyYW0gJHg0IGk2NClcXG4gICAgKHBhcmFtICR5MSBpNjQpXFxuICAgIChwYXJhbSAkeTIgaTY0KVxcbiAgICAocGFyYW0gJHkzIGk2NClcXG4gICAgKHBhcmFtICR5NCBpNjQpXFxuICAgIChyZXN1bHQgaTY0KVxcbiAgICAobG9jYWwgJHIxIGk2NClcXG4gICAgKGxvY2FsICRyMiBpNjQpXFxuICAgIChsb2NhbCAkcjMgaTY0KVxcbiAgICAobG9jYWwgJHI0IGk2NClcXG4gICAgKGJsb2NrXFxuICAgICAgICAobG9jYWwuc2V0ICRyMSAoaTY0Lm9yIChsb2NhbC5nZXQgJHgxKSAobG9jYWwuZ2V0ICR5MSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkcjIgKGk2NC5vciAobG9jYWwuZ2V0ICR4MikgKGxvY2FsLmdldCAkeTIpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJHIzIChpNjQub3IgKGxvY2FsLmdldCAkeDMpIChsb2NhbC5nZXQgJHkzKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRyNCAoaTY0Lm9yIChsb2NhbC5nZXQgJHg0KSAobG9jYWwuZ2V0ICR5NCkpKVxcblxcbiAgICApXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfIChsb2NhbC5nZXQgJHIyKSlcXG4gICAgKGdsb2JhbC5zZXQgJGdsb2JhbF9fMSAobG9jYWwuZ2V0ICRyMykpXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfXzIgKGxvY2FsLmdldCAkcjQpKVxcbiAgICAobG9jYWwuZ2V0ICRyMSlcXG4pXFxuXFxuXFxuKGZ1bmMgJGNtcFxcbiAgICAocGFyYW0gJGEgaTY0KVxcbiAgICAocGFyYW0gJGIgaTY0KVxcbiAgICAocmVzdWx0IGkzMilcXG4gICAgKGxvY2FsICRyIGkzMilcXG4gICAgKGJsb2NrXFxuICAgICAgICAobG9jYWwuc2V0ICRyIChzZWxlY3QgKGkzMi5jb25zdCA0Mjk0OTY3Mjk1KSAoaTY0Lm5lIChsb2NhbC5nZXQgJGEpIChsb2NhbC5nZXQgJGIpKSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYikpKSlcXG5cXG4gICAgKVxcbiAgICAobG9jYWwuZ2V0ICRyKVxcbilcXG5cXG5cXG4oZnVuYyAkc2hyX3NpbmdsZV9cXG4gICAgKHBhcmFtICRhIGk2NClcXG4gICAgKHBhcmFtICRhbW91bnQgaTY0KVxcbiAgICAocmVzdWx0IGk2NClcXG4gICAgKGxvY2FsICR4IGk2NClcXG4gICAgKGxvY2FsICR5IGk2NClcXG4gICAgKGJsb2NrXFxuICAgICAgICAobG9jYWwuc2V0ICR5IChpNjQuc2hsIChsb2NhbC5nZXQgJGEpIChpNjQuc3ViIChpNjQuY29uc3QgNjQpIChsb2NhbC5nZXQgJGFtb3VudCkpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJHggKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhKSAobG9jYWwuZ2V0ICRhbW91bnQpKSlcXG5cXG4gICAgKVxcbiAgICAoZ2xvYmFsLnNldCAkZ2xvYmFsXyAobG9jYWwuZ2V0ICR5KSlcXG4gICAgKGxvY2FsLmdldCAkeClcXG4pXFxuXFxuKGZ1bmMgJHNocl9cXG4gICAgKHBhcmFtICR4MSBpNjQpXFxuICAgIChwYXJhbSAkeDIgaTY0KVxcbiAgICAocGFyYW0gJHgzIGk2NClcXG4gICAgKHBhcmFtICR4NCBpNjQpXFxuICAgIChwYXJhbSAkeTEgaTY0KVxcbiAgICAocGFyYW0gJHkyIGk2NClcXG4gICAgKHBhcmFtICR5MyBpNjQpXFxuICAgIChwYXJhbSAkeTQgaTY0KVxcbiAgICAocmVzdWx0IGk2NClcXG4gICAgKGxvY2FsICR6MSBpNjQpXFxuICAgIChsb2NhbCAkejIgaTY0KVxcbiAgICAobG9jYWwgJHozIGk2NClcXG4gICAgKGxvY2FsICR6NCBpNjQpXFxuICAgIChsb2NhbCAkdCBpNjQpXFxuICAgIChibG9ja1xcbiAgICAgICAgKGlmIChpMzIuYW5kIChpNjQuZXF6IChsb2NhbC5nZXQgJHgxKSkgKGk2NC5lcXogKGxvY2FsLmdldCAkeDIpKSkgKHRoZW5cXG4gICAgICAgICAgICAoaWYgKGk2NC5lcXogKGxvY2FsLmdldCAkeDMpKSAodGhlblxcbiAgICAgICAgICAgICAgICAoaWYgKGk2NC5lcXogKGxvY2FsLmdldCAkeDQpKVxcbiAgICAgICAgICAgICAgICAgICAgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MSAobG9jYWwuZ2V0ICR5MSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGxvY2FsLmdldCAkeTIpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHozIChsb2NhbC5nZXQgJHkzKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6NCAobG9jYWwuZ2V0ICR5NCkpXFxuICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgICAgICAoZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpZiAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgMjU2KSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpNjQuZ2VfdSAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCAxMjgpKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTQgKGxvY2FsLmdldCAkeTIpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTMgKGxvY2FsLmdldCAkeTEpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTIgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkxIChpNjQuY29uc3QgMCkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR4NCAoaTY0LnN1YiAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCAxMjgpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpNjQuZ2VfdSAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCA2NCkpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5NCAobG9jYWwuZ2V0ICR5MykpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MyAobG9jYWwuZ2V0ICR5MikpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MiAobG9jYWwuZ2V0ICR5MSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MSAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeDQgKGk2NC5zdWIgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgNjQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vcClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6NCAoY2FsbCAkc2hyX3NpbmdsZV8gKGxvY2FsLmdldCAkeTQpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR0IChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHozIChjYWxsICRzaHJfc2luZ2xlXyAobG9jYWwuZ2V0ICR5MykgKGxvY2FsLmdldCAkeDQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHQgKGdsb2JhbC5nZXQgJGdsb2JhbF8pKVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHo0IChpNjQub3IgKGxvY2FsLmdldCAkejQpIChsb2NhbC5nZXQgJHQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MiAoY2FsbCAkc2hyX3NpbmdsZV8gKGxvY2FsLmdldCAkeTIpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR0IChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MyAoaTY0Lm9yIChsb2NhbC5nZXQgJHozKSAobG9jYWwuZ2V0ICR0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejEgKGNhbGwgJHNocl9zaW5nbGVfIChsb2NhbC5nZXQgJHkxKSAobG9jYWwuZ2V0ICR4NCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkdCAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGk2NC5vciAobG9jYWwuZ2V0ICR6MikgKGxvY2FsLmdldCAkdCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXFxuICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICApKVxcbiAgICAgICAgKSlcXG5cXG4gICAgKVxcbiAgICAoZ2xvYmFsLnNldCAkZ2xvYmFsXyAobG9jYWwuZ2V0ICR6MikpXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfXzEgKGxvY2FsLmdldCAkejMpKVxcbiAgICAoZ2xvYmFsLnNldCAkZ2xvYmFsX18yIChsb2NhbC5nZXQgJHo0KSlcXG4gICAgKGxvY2FsLmdldCAkejEpXFxuKVxcblxcblxcbihmdW5jICRzaGxfc2luZ2xlX1xcbiAgICAocGFyYW0gJGEgaTY0KVxcbiAgICAocGFyYW0gJGFtb3VudCBpNjQpXFxuICAgIChyZXN1bHQgaTY0KVxcbiAgICAobG9jYWwgJHggaTY0KVxcbiAgICAobG9jYWwgJHkgaTY0KVxcbiAgICAoYmxvY2tcXG4gICAgICAgIChsb2NhbC5zZXQgJHggKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhKSAoaTY0LnN1YiAoaTY0LmNvbnN0IDY0KSAobG9jYWwuZ2V0ICRhbW91bnQpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICR5IChpNjQuc2hsIChsb2NhbC5nZXQgJGEpIChsb2NhbC5nZXQgJGFtb3VudCkpKVxcblxcbiAgICApXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfIChsb2NhbC5nZXQgJHkpKVxcbiAgICAobG9jYWwuZ2V0ICR4KVxcbilcXG5cXG4oZnVuYyAkc2hsX1xcbiAgICAocGFyYW0gJHgxIGk2NClcXG4gICAgKHBhcmFtICR4MiBpNjQpXFxuICAgIChwYXJhbSAkeDMgaTY0KVxcbiAgICAocGFyYW0gJHg0IGk2NClcXG4gICAgKHBhcmFtICR5MSBpNjQpXFxuICAgIChwYXJhbSAkeTIgaTY0KVxcbiAgICAocGFyYW0gJHkzIGk2NClcXG4gICAgKHBhcmFtICR5NCBpNjQpXFxuICAgIChyZXN1bHQgaTY0KVxcbiAgICAobG9jYWwgJHoxIGk2NClcXG4gICAgKGxvY2FsICR6MiBpNjQpXFxuICAgIChsb2NhbCAkejMgaTY0KVxcbiAgICAobG9jYWwgJHo0IGk2NClcXG4gICAgKGxvY2FsICR0IGk2NClcXG4gICAgKGxvY2FsICRyIGk2NClcXG4gICAgKGJsb2NrXFxuICAgICAgICAoaWYgKGkzMi5hbmQgKGk2NC5lcXogKGxvY2FsLmdldCAkeDEpKSAoaTY0LmVxeiAobG9jYWwuZ2V0ICR4MikpKSAodGhlblxcbiAgICAgICAgICAgIChpZiAoaTY0LmVxeiAobG9jYWwuZ2V0ICR4MykpICh0aGVuXFxuICAgICAgICAgICAgICAgIChpZiAoaTY0LmVxeiAobG9jYWwuZ2V0ICR4NCkpXFxuICAgICAgICAgICAgICAgICAgICAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHoxIChsb2NhbC5nZXQgJHkxKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MiAobG9jYWwuZ2V0ICR5MikpXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejMgKGxvY2FsLmdldCAkeTMpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHo0IChsb2NhbC5nZXQgJHk0KSlcXG4gICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgIChlbHNlXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpNjQubHRfdSAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCAyNTYpKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaWYgKGk2NC5nZV91IChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDEyOCkpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MSAobG9jYWwuZ2V0ICR5MykpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MiAobG9jYWwuZ2V0ICR5NCkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MyAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTQgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHg0IChpNjQuc3ViIChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDEyOCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaWYgKGk2NC5nZV91IChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDY0KSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkxIChsb2NhbC5nZXQgJHkyKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkyIChsb2NhbC5nZXQgJHkzKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkzIChsb2NhbC5nZXQgJHk0KSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHk0IChpNjQuY29uc3QgMCkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR4NCAoaTY0LnN1YiAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCA2NCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9wKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHQgKGNhbGwgJHNobF9zaW5nbGVfIChsb2NhbC5nZXQgJHk0KSAobG9jYWwuZ2V0ICR4NCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejQgKGdsb2JhbC5nZXQgJGdsb2JhbF8pKVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkciAoY2FsbCAkc2hsX3NpbmdsZV8gKGxvY2FsLmdldCAkeTMpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MyAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejMgKGk2NC5vciAobG9jYWwuZ2V0ICR6MykgKGxvY2FsLmdldCAkdCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHQgKGNhbGwgJHNobF9zaW5nbGVfIChsb2NhbC5nZXQgJHkyKSAobG9jYWwuZ2V0ICR4NCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGdsb2JhbC5nZXQgJGdsb2JhbF8pKVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHoyIChpNjQub3IgKGxvY2FsLmdldCAkejIpIChsb2NhbC5nZXQgJHIpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICRyIChjYWxsICRzaGxfc2luZ2xlXyAobG9jYWwuZ2V0ICR5MSkgKGxvY2FsLmdldCAkeDQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHoxIChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MSAoaTY0Lm9yIChsb2NhbC5nZXQgJHoxKSAobG9jYWwuZ2V0ICR0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICkpXFxuICAgICAgICApKVxcblxcbiAgICApXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfIChsb2NhbC5nZXQgJHoyKSlcXG4gICAgKGdsb2JhbC5zZXQgJGdsb2JhbF9fMSAobG9jYWwuZ2V0ICR6MykpXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfXzIgKGxvY2FsLmdldCAkejQpKVxcbiAgICAobG9jYWwuZ2V0ICR6MSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJTRElWXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkU0RJVlxcbiAgKGxvY2FsICRzcCBpMzIpXFxuXFxuICA7OyBkaXZpZGVuZFxcbiAgKGxvY2FsICRhIGk2NClcXG4gIChsb2NhbCAkYiBpNjQpXFxuICAobG9jYWwgJGMgaTY0KVxcbiAgKGxvY2FsICRkIGk2NClcXG5cXG4gIDs7IGRpdmlzb3JcXG4gIChsb2NhbCAkYTEgaTY0KVxcbiAgKGxvY2FsICRiMSBpNjQpXFxuICAobG9jYWwgJGMxIGk2NClcXG4gIChsb2NhbCAkZDEgaTY0KVxcblxcbiAgOzsgcXVvdGllbnRcXG4gIChsb2NhbCAkYXEgaTY0KVxcbiAgKGxvY2FsICRicSBpNjQpXFxuICAobG9jYWwgJGNxIGk2NClcXG4gIChsb2NhbCAkZHEgaTY0KVxcblxcbiAgOzsgbWFza1xcbiAgKGxvY2FsICRtYXNrYSBpNjQpXFxuICAobG9jYWwgJG1hc2tiIGk2NClcXG4gIChsb2NhbCAkbWFza2MgaTY0KVxcbiAgKGxvY2FsICRtYXNrZCBpNjQpXFxuICAobG9jYWwgJGNhcnJ5IGkzMilcXG4gIChsb2NhbCAkdGVtcCAgaTY0KVxcbiAgKGxvY2FsICR0ZW1wMiBpNjQpXFxuICAobG9jYWwgJHNpZ24gaTMyKVxcblxcbiAgKGxvY2FsLnNldCAkbWFza2QgKGk2NC5jb25zdCAxKSlcXG5cXG4gIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRkIChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgKGxvY2FsLnNldCAkYTEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYjEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYzEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRkMSAoaTY0LmxvYWQgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIDs7IGdldCB0aGUgcmVzdWx0aW5nIHNpZ25cXG4gIChsb2NhbC5zZXQgJHNpZ24gKGkzMi53cmFwX2k2NCAoaTY0LnNocl91IChpNjQueG9yIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRhKSkgKGk2NC5jb25zdCA2MykpKSlcXG5cXG4gIDs7IGNvbnZlcnQgdG8gdW5zaWduZWQgdmFsdWVcXG4gIChpZiAoaTY0LmVxeiAoaTY0LmNseiAobG9jYWwuZ2V0ICRhKSkpXFxuICAgICh0aGVuXFxuICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LnhvciAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYiAoaTY0LnhvciAobG9jYWwuZ2V0ICRiKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYyAoaTY0LnhvciAobG9jYWwuZ2V0ICRjKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LnhvciAobG9jYWwuZ2V0ICRkKSAoaTY0LmNvbnN0IC0xKSkpXFxuXFxuICAgICAgOzsgYSA9IGEgKyAxXFxuICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LmFkZCAobG9jYWwuZ2V0ICRkKSAoaTY0LmNvbnN0IDEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmVxeiAobG9jYWwuZ2V0ICRkKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYyAoaTY0LmFkZCAobG9jYWwuZ2V0ICRjKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLmFuZCAoaTY0LmVxeiAobG9jYWwuZ2V0ICRjKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAobG9jYWwuc2V0ICRiIChpNjQuYWRkIChsb2NhbC5nZXQgJGIpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIuYW5kIChpNjQuZXF6IChsb2NhbC5nZXQgJGIpKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGEgKGk2NC5hZGQgKGxvY2FsLmdldCAkYSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgIClcXG4gIClcXG4gIChpZiAoaTY0LmVxeiAoaTY0LmNseiAobG9jYWwuZ2V0ICRhMSkpKVxcbiAgICAodGhlblxcbiAgICAgIChsb2NhbC5zZXQgJGExIChpNjQueG9yIChsb2NhbC5nZXQgJGExKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYjEgKGk2NC54b3IgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgLTEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LnhvciAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCAtMSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGQxIChpNjQueG9yIChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IC0xKSkpXFxuXFxuICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC5hZGQgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgMSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZXF6IChsb2NhbC5nZXQgJGQxKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYzEgKGk2NC5hZGQgKGxvY2FsLmdldCAkYzEpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIuYW5kIChpNjQuZXF6IChsb2NhbC5nZXQgJGMxKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRiMSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5hbmQgKGk2NC5lcXogKGxvY2FsLmdldCAkYjEpKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGExIChpNjQuYWRkIChsb2NhbC5nZXQgJGExKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGJsb2NrICRtYWluXFxuICAgIDs7IGNoZWNrIGRpdiBieSAwXFxuICAgIChpZiAoY2FsbCAkaXN6ZXJvXzI1NiAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkpXFxuICAgICAgKGJyICRtYWluKVxcbiAgICApXFxuXFxuICAgIDs7IGFsaWduIGJpdHNcXG4gICAgKGJsb2NrICRkb25lXFxuICAgICAgKGxvb3AgJGxvb3BcXG4gICAgICAgIDs7IGFsaWduIGJpdHM7XFxuICAgICAgICAoaWYgKGkzMi5vciAoaTY0LmVxeiAoaTY0LmNseiAobG9jYWwuZ2V0ICRhMSkpKSAoY2FsbCAkZ3RlXzI1NiAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkZCkpKVxcbiAgICAgICAgICAoYnIgJGRvbmUpXFxuICAgICAgICApXFxuXFxuICAgICAgICA7OyBkaXZpc29yID0gZGl2aXNvciA8PCAxXFxuICAgICAgICAobG9jYWwuc2V0ICRhMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGIxIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYzEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRkMSAoaTY0LnNobCAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICA7OyBtYXNrID0gbWFzayA8PCAxXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tiIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2MgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICAoYnIgJGxvb3ApXFxuICAgICAgKVxcbiAgICApXFxuXFxuICAgIChibG9jayAkZG9uZVxcbiAgICAgIChsb29wICRsb29wXFxuICAgICAgICA7OyBsb29wIHdoaWxlIG1hc2sgIT0gMFxcbiAgICAgICAgKGlmIChjYWxsICRpc3plcm9fMjU2IChsb2NhbC5nZXQgJG1hc2thKSAobG9jYWwuZ2V0ICRtYXNrYikgKGxvY2FsLmdldCAkbWFza2MpIChsb2NhbC5nZXQgJG1hc2tkKSlcXG4gICAgICAgICAgKGJyICRkb25lKVxcbiAgICAgICAgKVxcbiAgICAgICAgOzsgaWYgZGl2aWRlbmQgPj0gZGl2aXNvclxcbiAgICAgICAgKGlmIChjYWxsICRndGVfMjU2IChsb2NhbC5nZXQgJGEpIChsb2NhbC5nZXQgJGIpIChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJGQpIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSlcXG4gICAgICAgICAgKHRoZW5cXG4gICAgICAgICAgICA7OyBkaXZpZGVuZCA9IGRpdmlkZW5kIC0gZGl2aXNvclxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQubHRfdSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRkMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGQgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRkMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRjKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYykpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGMgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRjMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkdGVtcCkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGIpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkYiAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGIxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5vciAgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICR0ZW1wKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRhICAgICAoaTY0LnN1YiAgKGk2NC5zdWIgKGxvY2FsLmdldCAkYSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkgKGxvY2FsLmdldCAkYTEpKSlcXG5cXG4gICAgICAgICAgICA7OyByZXN1bHQgPSByZXN1bHQgKyBtYXNrXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkZHEgICAgKGk2NC5hZGQgIChsb2NhbC5nZXQgJG1hc2tkKSAobG9jYWwuZ2V0ICRkcSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQubHRfdSAobG9jYWwuZ2V0ICRkcSkgKGxvY2FsLmdldCAkbWFza2QpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LmFkZCAgKGxvY2FsLmdldCAkY3EpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQubHRfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRjcSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNxICAgIChpNjQuYWRkICAobG9jYWwuZ2V0ICRtYXNrYykgKGxvY2FsLmdldCAkdGVtcCkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkY3EpIChsb2NhbC5nZXQgJG1hc2tjKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LmFkZCAgKGxvY2FsLmdldCAkYnEpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQubHRfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRicSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGJxICAgIChpNjQuYWRkICAobG9jYWwuZ2V0ICRtYXNrYikgKGxvY2FsLmdldCAkdGVtcCkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYnEpIChsb2NhbC5nZXQgJG1hc2tiKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRhcSAgICAoaTY0LmFkZCAgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuYWRkIChsb2NhbC5nZXQgJGFxKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yID4+IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGQxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYzEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGExIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYTEpIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgICAgOzsgbWFzayA9IG1hc2sgPj4gMVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2QgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYyAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tiIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2thKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2EgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCAxKSkpXFxuICAgICAgICAoYnIgJGxvb3ApXFxuICAgICAgKVxcbiAgICApXFxuICApOzsgZW5kIG9mIG1haW5cXG5cXG4gIDs7IGNvbnZlcnQgdG8gc2lnbmVkXFxuICAoaWYgKGxvY2FsLmdldCAkc2lnbilcXG4gICAgKHRoZW5cXG4gICAgICAobG9jYWwuc2V0ICRhcSAoaTY0LnhvciAobG9jYWwuZ2V0ICRhcSkgKGk2NC5jb25zdCAtMSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGJxIChpNjQueG9yIChsb2NhbC5nZXQgJGJxKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkY3EgKGk2NC54b3IgKGxvY2FsLmdldCAkY3EpIChpNjQuY29uc3QgLTEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRkcSAoaTY0LnhvciAobG9jYWwuZ2V0ICRkcSkgKGk2NC5jb25zdCAtMSkpKVxcblxcbiAgICAgIChsb2NhbC5zZXQgJGRxIChpNjQuYWRkIChsb2NhbC5nZXQgJGRxKSAoaTY0LmNvbnN0IDEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjcSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRjcSkgKGk2NC5leHRlbmRfaTMyX3UgKGk2NC5lcXogKGxvY2FsLmdldCAkZHEpKSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGJxIChpNjQuYWRkIChsb2NhbC5nZXQgJGJxKSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0LmVxeiAobG9jYWwuZ2V0ICRjcSkpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYXEgKGk2NC5hZGQgKGxvY2FsLmdldCAkYXEpIChpNjQuZXh0ZW5kX2kzMl91IChpNjQuZXF6IChsb2NhbC5nZXQgJGJxKSkpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChsb2NhbC5nZXQgJGFxKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAobG9jYWwuZ2V0ICRicSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGxvY2FsLmdldCAkY3EpKVxcbiAgKGk2NC5zdG9yZSAgICAgICAgICAobG9jYWwuZ2V0ICRzcCkgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGRxKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJTR1RcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRTR1RcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgKGxvY2FsICRhMCBpNjQpXFxuICAobG9jYWwgJGExIGk2NClcXG4gIChsb2NhbCAkYTIgaTY0KVxcbiAgKGxvY2FsICRhMyBpNjQpXFxuICAobG9jYWwgJGIwIGk2NClcXG4gIChsb2NhbCAkYjEgaTY0KVxcbiAgKGxvY2FsICRiMiBpNjQpXFxuICAobG9jYWwgJGIzIGk2NClcXG5cXG4gIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYTAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGExIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRhMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRhMyAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSkpXFxuXFxuICAobG9jYWwuc2V0ICRzcCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGIwIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGIxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGIyIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkYjMgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKSAoaTY0LmV4dGVuZF9pMzJfdVxcbiAgICAoaTMyLm9yICAoaTY0Lmd0X3MgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPiBiMFxcbiAgICAoaTMyLmFuZCAoaTY0LmVxICAgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPT0gYTFcXG4gICAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID4gYjFcXG4gICAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID09IGIxXFxuICAgIChpMzIub3IgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA+IGIyXFxuICAgIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA9PSBiMlxcbiAgICAgICAgICAgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYTMpIChsb2NhbC5nZXQgJGIzKSkpKSkpKSkpKSA7OyBhMyA+IGIzXFxuXFxuICA7OyB6ZXJvICBvdXQgdGhlIHJlc3Qgb2YgdGhlIHN0YWNrIGl0ZW1cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5jb25zdCAwKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJTSEEzXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkU0hBM1xcbiAgKGxvY2FsICRkYXRhT2Zmc2V0IGkzMilcXG4gIChsb2NhbCAkZGF0YU9mZnNldDAgaTY0KVxcbiAgKGxvY2FsICRkYXRhT2Zmc2V0MSBpNjQpXFxuICAobG9jYWwgJGRhdGFPZmZzZXQyIGk2NClcXG4gIChsb2NhbCAkZGF0YU9mZnNldDMgaTY0KVxcblxcbiAgKGxvY2FsICRsZW5ndGggaTMyKVxcbiAgKGxvY2FsICRsZW5ndGgwIGk2NClcXG4gIChsb2NhbCAkbGVuZ3RoMSBpNjQpXFxuICAobG9jYWwgJGxlbmd0aDIgaTY0KVxcbiAgKGxvY2FsICRsZW5ndGgzIGk2NClcXG5cXG4gIChsb2NhbCAkY29udGV4dE9mZnNldCBpMzIpXFxuICAobG9jYWwgJG91dHB1dE9mZnNldCBpMzIpXFxuXFxuICAobG9jYWwuc2V0ICRsZW5ndGgwIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkpXFxuICAobG9jYWwuc2V0ICRsZW5ndGgxIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRsZW5ndGgyIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRsZW5ndGgzIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGRhdGFPZmZzZXQwIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMCkpKSlcXG4gIChsb2NhbC5zZXQgJGRhdGFPZmZzZXQxIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGRhdGFPZmZzZXQyIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRkYXRhT2Zmc2V0MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcblxcbiAgKGxvY2FsLnNldCAkbGVuZ3RoXFxuICAgICAgICAgICAgIChjYWxsICRjaGVja19vdmVyZmxvdyAobG9jYWwuZ2V0ICRsZW5ndGgwKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkbGVuZ3RoMSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGxlbmd0aDIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRsZW5ndGgzKSkpXFxuICAobG9jYWwuc2V0ICRkYXRhT2Zmc2V0XFxuICAgICAgICAgICAgIChjYWxsICRjaGVja19vdmVyZmxvdyAobG9jYWwuZ2V0ICRkYXRhT2Zmc2V0MClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGRhdGFPZmZzZXQxKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkZGF0YU9mZnNldDIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRkYXRhT2Zmc2V0MykpKVxcblxcbiAgOzsgY2hhcmdlIGNvcHkgZmVlIGNlaWwod29yZHMvMzIpICogNlxcbiAgKGNhbGwgJHVzZUdhcyAoaTY0LmV4dGVuZF9pMzJfdSAoaTMyLm11bCAoaTMyLmRpdl91IChpMzIuYWRkIChsb2NhbC5nZXQgJGxlbmd0aCkgKGkzMi5jb25zdCAzMSkpIChpMzIuY29uc3QgMzIpKSAoaTMyLmNvbnN0IDYpKSkpXFxuICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJGRhdGFPZmZzZXQpIChsb2NhbC5nZXQgJGxlbmd0aCkpXFxuXFxuICAobG9jYWwuc2V0ICRkYXRhT2Zmc2V0IChpMzIuYWRkIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkgKGxvY2FsLmdldCAkZGF0YU9mZnNldCkpKVxcblxcbiAgKGxvY2FsLnNldCAkY29udGV4dE9mZnNldCAoaTMyLmNvbnN0IDMyODA4KSlcXG4gIChsb2NhbC5zZXQgJG91dHB1dE9mZnNldCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSlcXG5cXG4gIChjYWxsICRrZWNjYWsgKGxvY2FsLmdldCAkY29udGV4dE9mZnNldCkgKGxvY2FsLmdldCAkZGF0YU9mZnNldCkgKGxvY2FsLmdldCAkbGVuZ3RoKSAobG9jYWwuZ2V0ICRvdXRwdXRPZmZzZXQpKVxcblxcbiAgKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGxvY2FsLmdldCAkb3V0cHV0T2Zmc2V0KSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiU0hMXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkU0hMXFxuICAgIChsb2NhbCAkc3AgaTMyKVxcbiAgICAobG9jYWwgJHgxIGk2NClcXG4gICAgKGxvY2FsICR4MiBpNjQpXFxuICAgIChsb2NhbCAkeDMgaTY0KVxcbiAgICAobG9jYWwgJHg0IGk2NClcXG4gICAgKGxvY2FsICR5MSBpNjQpXFxuICAgIChsb2NhbCAkeTIgaTY0KVxcbiAgICAobG9jYWwgJHkzIGk2NClcXG4gICAgKGxvY2FsICR5NCBpNjQpXFxuXFxuICAgIChsb2NhbCAkejEgaTY0KVxcbiAgICAobG9jYWwgJHoyIGk2NClcXG4gICAgKGxvY2FsICR6MyBpNjQpXFxuICAgIChsb2NhbCAkejQgaTY0KVxcbiAgICAobG9jYWwgJHQgaTY0KVxcbiAgICAobG9jYWwgJHIgaTY0KVxcblxcbiAgICA7OyBsb2FkIGFyZ3MgZnJvbSB0aGUgc3RhY2tcXG4gICAgKGxvY2FsLnNldCAkeDEgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeDIgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gICAgKGxvY2FsLnNldCAkeDMgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4NCAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSkpXFxuXFxuICAgIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgICAobG9jYWwuc2V0ICR5MSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAgIChsb2NhbC5zZXQgJHkyIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gICAgKGxvY2FsLnNldCAkeTMgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAgIChsb2NhbC5zZXQgJHk0IChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgICAoYmxvY2tcXG4gICAgICAgIChpZiAoaTMyLmFuZCAoaTY0LmVxeiAobG9jYWwuZ2V0ICR4MSkpIChpNjQuZXF6IChsb2NhbC5nZXQgJHgyKSkpICh0aGVuXFxuICAgICAgICAgICAgKGlmIChpNjQuZXF6IChsb2NhbC5nZXQgJHgzKSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgKGlmIChpNjQuZXF6IChsb2NhbC5nZXQgJHg0KSlcXG4gICAgICAgICAgICAgICAgICAgICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejEgKGxvY2FsLmdldCAkeTEpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHoyIChsb2NhbC5nZXQgJHkyKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MyAobG9jYWwuZ2V0ICR5MykpXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejQgKGxvY2FsLmdldCAkeTQpKVxcbiAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgKGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAoaWYgKGk2NC5sdF91IChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDI1NikpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpZiAoaTY0LmdlX3UgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgMTI4KSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkxIChsb2NhbC5nZXQgJHkzKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkyIChsb2NhbC5nZXQgJHk0KSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkzIChpNjQuY29uc3QgMCkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5NCAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeDQgKGk2NC5zdWIgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgMTI4KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpZiAoaTY0LmdlX3UgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgNjQpKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTEgKGxvY2FsLmdldCAkeTIpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTIgKGxvY2FsLmdldCAkeTMpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTMgKGxvY2FsLmdldCAkeTQpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTQgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHg0IChpNjQuc3ViIChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDY0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub3ApXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkdCAoY2FsbCAkc2hsX3NpbmdsZSAobG9jYWwuZ2V0ICR5NCkgKGxvY2FsLmdldCAkeDQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHo0IChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHIgKGNhbGwgJHNobF9zaW5nbGUgKGxvY2FsLmdldCAkeTMpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MyAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejMgKGk2NC5vciAobG9jYWwuZ2V0ICR6MykgKGxvY2FsLmdldCAkdCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHQgKGNhbGwgJHNobF9zaW5nbGUgKGxvY2FsLmdldCAkeTIpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MiAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGk2NC5vciAobG9jYWwuZ2V0ICR6MikgKGxvY2FsLmdldCAkcikpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHIgKGNhbGwgJHNobF9zaW5nbGUgKGxvY2FsLmdldCAkeTEpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MSAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejEgKGk2NC5vciAobG9jYWwuZ2V0ICR6MSkgKGxvY2FsLmdldCAkdCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXFxuICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICApKVxcbiAgICAgICAgKSlcXG5cXG4gICAgKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGxvY2FsLmdldCAkejEpKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkejIpKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGxvY2FsLmdldCAkejMpKVxcbiAgICAoaTY0LnN0b3JlICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkejQpKVxcbilcXG5cXG4oZnVuYyAkc2hsX3NpbmdsZVxcbiAgICAocGFyYW0gJGEgaTY0KVxcbiAgICAocGFyYW0gJGFtb3VudCBpNjQpXFxuICAgIChyZXN1bHQgaTY0KVxcbiAgICAobG9jYWwgJHggaTY0KVxcbiAgICAobG9jYWwgJHkgaTY0KVxcbiAgICAoYmxvY2tcXG4gICAgICAgIChsb2NhbC5zZXQgJHggKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhKSAoaTY0LnN1YiAoaTY0LmNvbnN0IDY0KSAobG9jYWwuZ2V0ICRhbW91bnQpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICR5IChpNjQuc2hsIChsb2NhbC5nZXQgJGEpIChsb2NhbC5nZXQgJGFtb3VudCkpKVxcblxcbiAgICApXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfIChsb2NhbC5nZXQgJHkpKVxcbiAgICAobG9jYWwuZ2V0ICR4KVxcbilcXG5cIlxuICB9LFxuICBcIlNJR05FWFRFTkRcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRTSUdORVhURU5EXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIChsb2NhbCAkYTAgaTY0KVxcbiAgKGxvY2FsICRhMSBpNjQpXFxuICAobG9jYWwgJGEyIGk2NClcXG4gIChsb2NhbCAkYTMgaTY0KVxcblxcbiAgKGxvY2FsICRiMCBpNjQpXFxuICAobG9jYWwgJGIxIGk2NClcXG4gIChsb2NhbCAkYjIgaTY0KVxcbiAgKGxvY2FsICRiMyBpNjQpXFxuICAobG9jYWwgJHNpZ24gaTY0KVxcbiAgKGxvY2FsICR0IGkzMilcXG4gIChsb2NhbCAkZW5kIGkzMilcXG5cXG4gIChsb2NhbC5zZXQgJGEwIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRhMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYTIgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGEzIChpNjQubG9hZCAgICAgICAgICAoZ2xvYmFsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJGVuZCAoZ2xvYmFsLmdldCAkc3ApKVxcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAoaWYgKGkzMi5hbmRcXG4gICAgICAgIChpMzIuYW5kXFxuICAgICAgICAgIChpMzIuYW5kXFxuICAgICAgICAgICAgKGk2NC5sdF91IChsb2NhbC5nZXQgJGEzKSAoaTY0LmNvbnN0IDMyKSlcXG4gICAgICAgICAgICAoaTY0LmVxeiAobG9jYWwuZ2V0ICRhMikpKVxcbiAgICAgICAgICAoaTY0LmVxeiAobG9jYWwuZ2V0ICRhMSkpKVxcbiAgICAgICAgKGk2NC5lcXogKGxvY2FsLmdldCAkYTApKSlcXG4gICAgKHRoZW5cXG4gICAgICAobG9jYWwuc2V0ICR0IChpMzIuYWRkIChpMzIud3JhcF9pNjQgKGxvY2FsLmdldCAkYTMpKSAobG9jYWwuZ2V0ICRzcCkpKVxcbiAgICAgIChsb2NhbC5zZXQgJHNpZ24gKGk2NC5zaHJfcyAoaTY0LmxvYWQ4X3MgKGxvY2FsLmdldCAkdCkpIChpNjQuY29uc3QgOCkpKVxcbiAgICAgIChsb2NhbC5zZXQgJHQgKGkzMi5hZGQgKGxvY2FsLmdldCAkdCkgKGkzMi5jb25zdCAxKSkpXFxuICAgICAgKGJsb2NrICRkb25lXFxuICAgICAgICAobG9vcCAkbG9vcFxcbiAgICAgICAgICAoaWYgKGkzMi5sdF91IChsb2NhbC5nZXQgJGVuZCkgKGxvY2FsLmdldCAkdCkpXFxuICAgICAgICAgICAgKGJyICRkb25lKVxcbiAgICAgICAgICApXFxuICAgICAgICAgIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkdCkgKGxvY2FsLmdldCAkc2lnbikpXFxuICAgICAgICAgIChsb2NhbC5zZXQgJHQgKGkzMi5hZGQgKGxvY2FsLmdldCAkdCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgICAgIChiciAkbG9vcClcXG4gICAgICAgIClcXG4gICAgICApXFxuICAgIClcXG4gIClcXG4pXFxuXFxuXCJcbiAgfSxcbiAgXCJTTU9EXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkU01PRFxcbiAgKGxvY2FsICRzcCBpMzIpXFxuICA7OyBkaXZpZGVuZFxcbiAgKGxvY2FsICRhIGk2NClcXG4gIChsb2NhbCAkYiBpNjQpXFxuICAobG9jYWwgJGMgaTY0KVxcbiAgKGxvY2FsICRkIGk2NClcXG5cXG4gIDs7IGRpdmlzb3JcXG4gIChsb2NhbCAkYTEgaTY0KVxcbiAgKGxvY2FsICRiMSBpNjQpXFxuICAobG9jYWwgJGMxIGk2NClcXG4gIChsb2NhbCAkZDEgaTY0KVxcblxcbiAgOzsgcXVvdGllbnRcXG4gIChsb2NhbCAkYXEgaTY0KVxcbiAgKGxvY2FsICRicSBpNjQpXFxuICAobG9jYWwgJGNxIGk2NClcXG4gIChsb2NhbCAkZHEgaTY0KVxcblxcbiAgOzsgbWFza1xcbiAgKGxvY2FsICRtYXNrYSBpNjQpXFxuICAobG9jYWwgJG1hc2tiIGk2NClcXG4gIChsb2NhbCAkbWFza2MgaTY0KVxcbiAgKGxvY2FsICRtYXNrZCBpNjQpXFxuICAobG9jYWwgJGNhcnJ5IGkzMilcXG4gIChsb2NhbCAkc2lnbiBpMzIpXFxuICAobG9jYWwgJHRlbXAgIGk2NClcXG4gIChsb2NhbCAkdGVtcDIgIGk2NClcXG5cXG4gIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkZCAoaTY0LmxvYWQgICAgICAgICAgKGdsb2JhbC5nZXQgJHNwKSkpXFxuICA7OyBkZWNlbWVudCB0aGUgc3RhY2sgcG9pbnRlclxcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAobG9jYWwuc2V0ICRhMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRiMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRjMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkpXFxuICAobG9jYWwuc2V0ICRkMSAoaTY0LmxvYWQgICAgICAgICAgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJG1hc2tkIChpNjQuY29uc3QgMSkpXFxuICAobG9jYWwuc2V0ICRzaWduIChpMzIud3JhcF9pNjQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRkKSAoaTY0LmNvbnN0IDYzKSkpKVxcblxcbiAgOzsgY29udmVydCB0byB1bnNpZ25lZCB2YWx1ZVxcbiAgKGlmIChpNjQuZXF6IChpNjQuY2x6IChsb2NhbC5nZXQgJGEpKSlcXG4gICAgKHRoZW5cXG4gICAgICAobG9jYWwuc2V0ICRhIChpNjQueG9yIChsb2NhbC5nZXQgJGEpIChpNjQuY29uc3QgLTEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRiIChpNjQueG9yIChsb2NhbC5nZXQgJGIpIChpNjQuY29uc3QgLTEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjIChpNjQueG9yIChsb2NhbC5nZXQgJGMpIChpNjQuY29uc3QgLTEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRkIChpNjQueG9yIChsb2NhbC5nZXQgJGQpIChpNjQuY29uc3QgLTEpKSlcXG5cXG4gICAgICA7OyBhID0gYSArIDFcXG4gICAgICAobG9jYWwuc2V0ICRkIChpNjQuYWRkIChsb2NhbC5nZXQgJGQpIChpNjQuY29uc3QgMSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZXF6IChsb2NhbC5nZXQgJGQpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjIChpNjQuYWRkIChsb2NhbC5nZXQgJGMpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIuYW5kIChpNjQuZXF6IChsb2NhbC5nZXQgJGMpKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGIgKGk2NC5hZGQgKGxvY2FsLmdldCAkYikgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5hbmQgKGk2NC5lcXogKGxvY2FsLmdldCAkYikpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRhKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGlmIChpNjQuZXF6IChpNjQuY2x6IChsb2NhbC5nZXQgJGExKSkpXFxuICAgICh0aGVuXFxuICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC54b3IgKGxvY2FsLmdldCAkYTEpIChpNjQuY29uc3QgLTEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LnhvciAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCAtMSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGMxIChpNjQueG9yIChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC54b3IgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgLTEpKSlcXG5cXG4gICAgICAobG9jYWwuc2V0ICRkMSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCAxKSkpXFxuICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5lcXogKGxvY2FsLmdldCAkZDEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRjMSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5hbmQgKGk2NC5lcXogKGxvY2FsLmdldCAkYzEpKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGIxIChpNjQuYWRkIChsb2NhbC5nZXQgJGIxKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLmFuZCAoaTY0LmVxeiAobG9jYWwuZ2V0ICRiMSkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC5hZGQgKGxvY2FsLmdldCAkYTEpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICApXFxuICApXFxuXFxuICAoYmxvY2sgJG1haW5cXG4gICAgOzsgY2hlY2sgZGl2IGJ5IDBcXG4gICAgKGlmIChjYWxsICRpc3plcm9fMjU2IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSlcXG4gICAgICAodGhlblxcbiAgICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYiAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYyAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGJyICRtYWluKVxcbiAgICAgIClcXG4gICAgKVxcblxcbiAgICA7OyBhbGlnbiBiaXRzXFxuICAgIChibG9jayAkZG9uZVxcbiAgICAgIChsb29wICRsb29wXFxuICAgICAgICA7OyBhbGlnbiBiaXRzO1xcbiAgICAgICAgKGlmIChpMzIub3IgKGk2NC5lcXogKGk2NC5jbHogKGxvY2FsLmdldCAkYTEpKSkgKGNhbGwgJGd0ZV8yNTYgKGxvY2FsLmdldCAkYTEpIChsb2NhbC5nZXQgJGIxKSAobG9jYWwuZ2V0ICRjMSkgKGxvY2FsLmdldCAkZDEpIChsb2NhbC5nZXQgJGEpIChsb2NhbC5nZXQgJGIpIChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJGQpKSlcXG4gICAgICAgICAgKGJyICRkb25lKVxcbiAgICAgICAgKVxcblxcbiAgICAgICAgOzsgZGl2aXNvciA9IGRpdmlzb3IgPDwgMVxcbiAgICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkYTEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGMxIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC5zaGwgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgICAgOzsgbWFzayA9IG1hc2sgPDwgMVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2EgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYiAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYykgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tjIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tkKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2QgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgICAgKGJyICRsb29wKVxcbiAgICAgIClcXG4gICAgKVxcblxcbiAgICAoYmxvY2sgJGRvbmVcXG4gICAgICAobG9vcCAkbG9vcFxcbiAgICAgICAgOzsgbG9vcCB3aGlsZSBtYXNrICE9IDBcXG4gICAgICAgIChpZiAoY2FsbCAkaXN6ZXJvXzI1NiAobG9jYWwuZ2V0ICRtYXNrYSkgKGxvY2FsLmdldCAkbWFza2IpIChsb2NhbC5nZXQgJG1hc2tjKSAobG9jYWwuZ2V0ICRtYXNrZCkpXFxuICAgICAgICAgIChiciAkZG9uZSlcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGlmIGRpdmlkZW5kID49IGRpdmlzb3JcXG4gICAgICAgIChpZiAoY2FsbCAkZ3RlXzI1NiAobG9jYWwuZ2V0ICRhKSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICRjKSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkpXFxuICAgICAgICAgICh0aGVuXFxuICAgICAgICAgICAgOzsgZGl2aWRlbmQgPSBkaXZpZGVuZCAtIGRpdmlzb3JcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkZDEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRkICAgICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkZDEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkYykgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5ndF91IChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGMpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjICAgICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYzEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLm9yICAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJHRlbXApKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRiKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYikpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGIgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkdGVtcCkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkYSAgICAgKGk2NC5zdWIgIChpNjQuc3ViIChsb2NhbC5nZXQgJGEpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpIChsb2NhbC5nZXQgJGExKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yID4+IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGQxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYzEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGExIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYTEpIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgICAgOzsgbWFzayA9IG1hc2sgPj4gMVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2QgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYyAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tiIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2thKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2EgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCAxKSkpXFxuICAgICAgICAoYnIgJGxvb3ApXFxuICAgICAgKVxcbiAgICApXFxuICApXFxuXFxuICA7OyBjb252ZXJ0IHRvIHNpZ25lZFxcbiAgKGlmIChsb2NhbC5nZXQgJHNpZ24pXFxuICAgICh0aGVuXFxuICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LnhvciAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYiAoaTY0LnhvciAobG9jYWwuZ2V0ICRiKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYyAoaTY0LnhvciAobG9jYWwuZ2V0ICRjKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LnhvciAobG9jYWwuZ2V0ICRkKSAoaTY0LmNvbnN0IC0xKSkpXFxuXFxuICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LmFkZCAobG9jYWwuZ2V0ICRkKSAoaTY0LmNvbnN0IDEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjIChpNjQuYWRkIChsb2NhbC5nZXQgJGMpIChpNjQuZXh0ZW5kX2kzMl91IChpNjQuZXF6IChsb2NhbC5nZXQgJGQpKSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGIgKGk2NC5hZGQgKGxvY2FsLmdldCAkYikgKGk2NC5leHRlbmRfaTMyX3UgKGk2NC5lcXogKGxvY2FsLmdldCAkYykpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRhKSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0LmVxeiAobG9jYWwuZ2V0ICRiKSkpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgOzsgc2F2ZSB0aGUgc3RhY2tcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICRhKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAobG9jYWwuZ2V0ICRiKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAobG9jYWwuZ2V0ICRjKSlcXG4gIChpNjQuc3RvcmUgICAgICAgICAgKGxvY2FsLmdldCAkc3ApICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRkKSlcXG4pIDs7IGVuZCBmb3IgU01PRFxcblwiXG4gIH0sXG4gIFwiWE9SXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkWE9SXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpIChpNjQueG9yIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQueG9yIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQueG9yIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpIChpNjQueG9yIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgMCkpKSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiYnN3YXBfaTMyXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkYnN3YXBfaTMyXFxuICAocGFyYW0gJGludCBpMzIpXFxuICAocmVzdWx0IGkzMilcXG5cXG4gIChpMzIub3JcXG4gICAgKGkzMi5vclxcbiAgICAgIChpMzIuYW5kIChpMzIuc2hyX3UgKGxvY2FsLmdldCAkaW50KSAoaTMyLmNvbnN0IDI0KSkgKGkzMi5jb25zdCAweGZmKSkgOzsgNyAtPiAwXFxuICAgICAgKGkzMi5hbmQgKGkzMi5zaHJfdSAobG9jYWwuZ2V0ICRpbnQpIChpMzIuY29uc3QgOCkpIChpMzIuY29uc3QgMHhmZjAwKSkpIDs7IDYgLT4gMVxcbiAgICAoaTMyLm9yXFxuICAgICAgKGkzMi5hbmQgKGkzMi5zaGwgKGxvY2FsLmdldCAkaW50KSAoaTMyLmNvbnN0IDgpKSAoaTMyLmNvbnN0IDB4ZmYwMDAwKSkgOzsgNSAtPiAyXFxuICAgICAgKGkzMi5hbmQgKGkzMi5zaGwgKGxvY2FsLmdldCAkaW50KSAoaTMyLmNvbnN0IDI0KSkgKGkzMi5jb25zdCAweGZmMDAwMDAwKSkpKSA7OyA0IC0+IDNcXG4pXFxuXCJcbiAgfSxcbiAgXCJic3dhcF9pNjRcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRic3dhcF9pNjRcXG4gIChwYXJhbSAkaW50IGk2NClcXG4gIChyZXN1bHQgaTY0KVxcblxcbiAgKGk2NC5vclxcbiAgICAoaTY0Lm9yXFxuICAgICAgKGk2NC5vclxcbiAgICAgICAgKGk2NC5hbmQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRpbnQpIChpNjQuY29uc3QgNTYpKSAoaTY0LmNvbnN0IDB4ZmYpKSA7OyA3IC0+IDBcXG4gICAgICAgIChpNjQuYW5kIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaW50KSAoaTY0LmNvbnN0IDQwKSkgKGk2NC5jb25zdCAweGZmMDApKSkgOzsgNiAtPiAxXFxuICAgICAgKGk2NC5vclxcbiAgICAgICAgKGk2NC5hbmQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRpbnQpIChpNjQuY29uc3QgMjQpKSAoaTY0LmNvbnN0IDB4ZmYwMDAwKSkgOzsgNSAtPiAyXFxuICAgICAgICAoaTY0LmFuZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGludCkgKGk2NC5jb25zdCAgOCkpIChpNjQuY29uc3QgMHhmZjAwMDAwMCkpKSkgOzsgNCAtPiAzXFxuICAgIChpNjQub3JcXG4gICAgICAoaTY0Lm9yXFxuICAgICAgICAoaTY0LmFuZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRpbnQpIChpNjQuY29uc3QgOCkpICAgKGk2NC5jb25zdCAweGZmMDAwMDAwMDApKSA7OyAzIC0+IDRcXG4gICAgICAgIChpNjQuYW5kIChpNjQuc2hsIChsb2NhbC5nZXQgJGludCkgKGk2NC5jb25zdCAyNCkpICAgKGk2NC5jb25zdCAweGZmMDAwMDAwMDAwMCkpKSA7OyAyIC0+IDVcXG4gICAgICAoaTY0Lm9yXFxuICAgICAgICAoaTY0LmFuZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRpbnQpIChpNjQuY29uc3QgNDApKSAgIChpNjQuY29uc3QgMHhmZjAwMDAwMDAwMDAwMCkpIDs7IDEgLT4gNlxcbiAgICAgICAgKGk2NC5hbmQgKGk2NC5zaGwgKGxvY2FsLmdldCAkaW50KSAoaTY0LmNvbnN0IDU2KSkgICAoaTY0LmNvbnN0IDB4ZmYwMDAwMDAwMDAwMDAwMCkpKSkpIDs7IDAgLT4gN1xcbilcXG5cIlxuICB9LFxuICBcImJzd2FwX20xMjhcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRic3dhcF9tMTI4XFxuICAocGFyYW0gJHNwIGkzMilcXG4gIChyZXN1bHQgaTMyKVxcbiAgKGxvY2FsICR0ZW1wIGk2NClcXG5cXG4gIChsb2NhbC5zZXQgJHRlbXAgKGNhbGwgJGJzd2FwX2k2NCAoaTY0LmxvYWQgKGxvY2FsLmdldCAkc3ApKSkpXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKSAoY2FsbCAkYnN3YXBfaTY0IChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpIChsb2NhbC5nZXQgJHRlbXApKVxcbiAgKGxvY2FsLmdldCAkc3ApXFxuKVxcblwiXG4gIH0sXG4gIFwiYnN3YXBfbTE2MFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGJzd2FwX20xNjBcXG4gIChwYXJhbSAkc3AgaTMyKVxcbiAgKHJlc3VsdCBpMzIpXFxuICAobG9jYWwgJHRlbXAgaTY0KVxcblxcbiAgKGxvY2FsLnNldCAkdGVtcCAoY2FsbCAkYnN3YXBfaTY0IChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKSlcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkc3ApIChjYWxsICRic3dhcF9pNjQgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDEyKSkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTIpKSAobG9jYWwuZ2V0ICR0ZW1wKSlcXG5cXG4gIChpMzIuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpIChjYWxsICRic3dhcF9pMzIgKGkzMi5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpKVxcbiAgKGxvY2FsLmdldCAkc3ApXFxuKVxcblwiXG4gIH0sXG4gIFwiYnN3YXBfbTI1NlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGJzd2FwX20yNTZcXG4gIChwYXJhbSAkc3AgaTMyKVxcbiAgKHJlc3VsdCBpMzIpXFxuICAobG9jYWwgJHRlbXAgaTY0KVxcblxcbiAgKGxvY2FsLnNldCAkdGVtcCAoY2FsbCAkYnN3YXBfaTY0IChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKSlcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkc3ApIChjYWxsICRic3dhcF9pNjQgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICR0ZW1wKSlcXG5cXG4gIChsb2NhbC5zZXQgJHRlbXAgKGNhbGwgJGJzd2FwX2k2NCAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGNhbGwgJGJzd2FwX2k2NCAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChsb2NhbC5nZXQgJHRlbXApKVxcbiAgKGxvY2FsLmdldCAkc3ApXFxuKVxcblwiXG4gIH0sXG4gIFwiY2FsbGJhY2tcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRjYWxsYmFja1xcbiAgKGNhbGwgJG1haW4pXFxuKVxcblwiXG4gIH0sXG4gIFwiY2FsbGJhY2tfMTI4XCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkY2FsbGJhY2tfMTI4XFxuICAocGFyYW0gJHJlc3VsdCBpMzIpXFxuXFxuICAoZHJvcCAoY2FsbCAkYnN3YXBfbTEyOCAoZ2xvYmFsLmdldCAkc3ApKSlcXG4gIChjYWxsICRtYWluKVxcbilcXG5cIlxuICB9LFxuICBcImNhbGxiYWNrXzE2MFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGNhbGxiYWNrXzE2MFxcbiAgKHBhcmFtICRyZXN1bHQgaTMyKVxcblxcbiAgKGRyb3AgKGNhbGwgJGJzd2FwX20xNjAgKGdsb2JhbC5nZXQgJHNwKSkpXFxuICAoY2FsbCAkbWFpbilcXG4pXFxuXCJcbiAgfSxcbiAgXCJjYWxsYmFja18yNTZcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRjYWxsYmFja18yNTZcXG4gIChwYXJhbSAkcmVzdWx0IGkzMilcXG5cXG4gIChkcm9wIChjYWxsICRic3dhcF9tMjU2IChnbG9iYWwuZ2V0ICRzcCkpKVxcbiAgKGNhbGwgJG1haW4pXFxuKVxcblwiXG4gIH0sXG4gIFwiY2FsbGJhY2tfMzJcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRjYWxsYmFja18zMlxcbiAgKHBhcmFtICRyZXN1bHQgaTMyKVxcblxcbiAgKGk2NC5zdG9yZSAoZ2xvYmFsLmdldCAkc3ApIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJHJlc3VsdCkpKVxcbiAgOzsgemVybyBvdXQgbWVtXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkgKGk2NC5jb25zdCAwKSlcXG5cXG4gIChjYWxsICRtYWluKVxcbilcXG5cIlxuICB9LFxuICBcImNoZWNrX292ZXJmbG93X2k2NFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGNoZWNrX292ZXJmbG93X2k2NFxcbiAgKHBhcmFtICRhIGk2NClcXG4gIChwYXJhbSAkYiBpNjQpXFxuICAocGFyYW0gJGMgaTY0KVxcbiAgKHBhcmFtICRkIGk2NClcXG4gIChyZXN1bHQgaTY0KVxcblxcbiAgKGlmXFxuICAgIChpMzIuYW5kIFxcbiAgICAgIChpMzIuYW5kIFxcbiAgICAgICAgKGk2NC5lcXogIChsb2NhbC5nZXQgJGQpKVxcbiAgICAgICAgKGk2NC5lcXogIChsb2NhbC5nZXQgJGMpKSlcXG4gICAgICAoaTY0LmVxeiAgKGxvY2FsLmdldCAkYikpKVxcbiAgICAocmV0dXJuIChsb2NhbC5nZXQgJGEpKSlcXG5cXG4gICAgKHJldHVybiAoaTY0LmNvbnN0IDB4ZmZmZmZmZmZmZmZmZmZmZikpXFxuKVxcblwiXG4gIH0sXG4gIFwiZ3RlXzI1NlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgaXMgYSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYiAvLyBhID49IGJcXG4oZnVuYyAkZ3RlXzI1NlxcbiAgKHBhcmFtICRhMCBpNjQpXFxuICAocGFyYW0gJGExIGk2NClcXG4gIChwYXJhbSAkYTIgaTY0KVxcbiAgKHBhcmFtICRhMyBpNjQpXFxuXFxuICAocGFyYW0gJGIwIGk2NClcXG4gIChwYXJhbSAkYjEgaTY0KVxcbiAgKHBhcmFtICRiMiBpNjQpXFxuICAocGFyYW0gJGIzIGk2NClcXG5cXG4gIChyZXN1bHQgaTMyKVxcblxcbiAgOzsgYTAgPiBiMCB8fCBbYTAgPT0gYjAgJiYgW2ExID4gYjEgfHwgW2ExID09IGIxICYmIFthMiA+IGIyIHx8IFthMiA9PSBiMiAmJiBhMyA+PSBiMyBdXV1dXFxuICAoaTMyLm9yICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPiBiMFxcbiAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGEwKSAobG9jYWwuZ2V0ICRiMCkpXFxuICAoaTMyLm9yICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYTEpIChsb2NhbC5nZXQgJGIxKSkgOzsgYTEgPiBiMVxcbiAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID09IGIxXFxuICAoaTMyLm9yICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYTIpIChsb2NhbC5nZXQgJGIyKSkgOzsgYTIgPiBiMlxcbiAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGEyKSAobG9jYWwuZ2V0ICRiMikpXFxuICAgICAgICAgICAoaTY0LmdlX3UgKGxvY2FsLmdldCAkYTMpIChsb2NhbC5nZXQgJGIzKSkpKSkpKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJndGVfMzIwXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkZ3RlXzMyMFxcbiAgKHBhcmFtICRhMCBpNjQpXFxuICAocGFyYW0gJGExIGk2NClcXG4gIChwYXJhbSAkYTIgaTY0KVxcbiAgKHBhcmFtICRhMyBpNjQpXFxuICAocGFyYW0gJGE0IGk2NClcXG5cXG4gIChwYXJhbSAkYjAgaTY0KVxcbiAgKHBhcmFtICRiMSBpNjQpXFxuICAocGFyYW0gJGIyIGk2NClcXG4gIChwYXJhbSAkYjMgaTY0KVxcbiAgKHBhcmFtICRiNCBpNjQpXFxuXFxuICAocmVzdWx0IGkzMilcXG5cXG4gIDs7IGEwID4gYjAgfHwgW2EwID09IGIwICYmIFthMSA+IGIxIHx8IFthMSA9PSBiMSAmJiBbYTIgPiBiMiB8fCBbYTIgPT0gYjIgJiYgYTMgPj0gYjMgXV1dXVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGEwKSAobG9jYWwuZ2V0ICRiMCkpIDs7IGEwID4gYjBcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMCkgKGxvY2FsLmdldCAkYjApKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID4gYjFcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpKSA7OyBhMSA9PSBiMVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGEyKSAobG9jYWwuZ2V0ICRiMikpIDs7IGEyID4gYjJcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGEzKSAobG9jYWwuZ2V0ICRiMykpIDs7IGEyID4gYjJcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMykgKGxvY2FsLmdldCAkYjMpKVxcbiAgICAgICAgICAgKGk2NC5nZV91IChsb2NhbC5nZXQgJGE0KSAobG9jYWwuZ2V0ICRiNCkpKSkpKSkpKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJndGVfNTEyXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkZ3RlXzUxMlxcbiAgKHBhcmFtICRhMCBpNjQpXFxuICAocGFyYW0gJGExIGk2NClcXG4gIChwYXJhbSAkYTIgaTY0KVxcbiAgKHBhcmFtICRhMyBpNjQpXFxuICAocGFyYW0gJGE0IGk2NClcXG4gIChwYXJhbSAkYTUgaTY0KVxcbiAgKHBhcmFtICRhNiBpNjQpXFxuICAocGFyYW0gJGE3IGk2NClcXG5cXG4gIChwYXJhbSAkYjAgaTY0KVxcbiAgKHBhcmFtICRiMSBpNjQpXFxuICAocGFyYW0gJGIyIGk2NClcXG4gIChwYXJhbSAkYjMgaTY0KVxcbiAgKHBhcmFtICRiNCBpNjQpXFxuICAocGFyYW0gJGI1IGk2NClcXG4gIChwYXJhbSAkYjYgaTY0KVxcbiAgKHBhcmFtICRiNyBpNjQpXFxuXFxuICAocmVzdWx0IGkzMilcXG5cXG4gIDs7IGEwID4gYjAgfHwgW2EwID09IGIwICYmIFthMSA+IGIxIHx8IFthMSA9PSBiMSAmJiBbYTIgPiBiMiB8fCBbYTIgPT0gYjIgJiYgYTMgPj0gYjMgXV1dXVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGEwKSAobG9jYWwuZ2V0ICRiMCkpIDs7IGEwID4gYjBcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMCkgKGxvY2FsLmdldCAkYjApKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID4gYjFcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpKSA7OyBhMSA9PSBiMVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGEyKSAobG9jYWwuZ2V0ICRiMikpIDs7IGEyID4gYjJcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGEzKSAobG9jYWwuZ2V0ICRiMykpIDs7IGEzID4gYjNcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMykgKGxvY2FsLmdldCAkYjMpKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGE0KSAobG9jYWwuZ2V0ICRiNCkpIDs7IGE0ID4gYjRcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhNCkgKGxvY2FsLmdldCAkYjQpKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGE1KSAobG9jYWwuZ2V0ICRiNSkpIDs7IGE1ID4gYjVcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhNSkgKGxvY2FsLmdldCAkYjUpKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGE2KSAobG9jYWwuZ2V0ICRiNikpIDs7IGE2ID4gYjZcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhNikgKGxvY2FsLmdldCAkYjYpKVxcbiAgICAgICAgICAgKGk2NC5nZV91IChsb2NhbC5nZXQgJGE3KSAobG9jYWwuZ2V0ICRiNykpKSkpKSkpKSkpKSkpKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJpc3plcm9fMjU2XCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkaXN6ZXJvXzI1NlxcbiAgKHBhcmFtIGk2NClcXG4gIChwYXJhbSBpNjQpXFxuICAocGFyYW0gaTY0KVxcbiAgKHBhcmFtIGk2NClcXG4gIChyZXN1bHQgaTMyKVxcblxcbiAgKGk2NC5lcXogKGk2NC5vciAoaTY0Lm9yIChpNjQub3IgKGxvY2FsLmdldCAwKSAobG9jYWwuZ2V0IDEpKSAobG9jYWwuZ2V0IDIpKSAobG9jYWwuZ2V0IDMpKSkgXFxuKVxcblwiXG4gIH0sXG4gIFwiaXN6ZXJvXzMyMFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGlzemVyb18zMjBcXG4gIChwYXJhbSBpNjQpXFxuICAocGFyYW0gaTY0KVxcbiAgKHBhcmFtIGk2NClcXG4gIChwYXJhbSBpNjQpXFxuICAocGFyYW0gaTY0KVxcbiAgKHJlc3VsdCBpMzIpXFxuXFxuICAoaTY0LmVxeiAoaTY0Lm9yIChpNjQub3IgKGk2NC5vciAoaTY0Lm9yIChsb2NhbC5nZXQgMCkgKGxvY2FsLmdldCAxKSkgKGxvY2FsLmdldCAyKSkgKGxvY2FsLmdldCAzKSkgKGxvY2FsLmdldCA0KSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiaXN6ZXJvXzUxMlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGlzemVyb181MTJcXG4gIChwYXJhbSBpNjQpXFxuICAocGFyYW0gaTY0KVxcbiAgKHBhcmFtIGk2NClcXG4gIChwYXJhbSBpNjQpXFxuICAocGFyYW0gaTY0KVxcbiAgKHBhcmFtIGk2NClcXG4gIChwYXJhbSBpNjQpXFxuICAocGFyYW0gaTY0KVxcbiAgKHJlc3VsdCBpMzIpXFxuICAoaTY0LmVxeiAoaTY0Lm9yIChpNjQub3IgKGk2NC5vciAoaTY0Lm9yIChpNjQub3IgKGk2NC5vciAoaTY0Lm9yIChsb2NhbC5nZXQgMCkgKGxvY2FsLmdldCAxKSkgKGxvY2FsLmdldCAyKSkgKGxvY2FsLmdldCAzKSkgKGxvY2FsLmdldCA0KSkgKGxvY2FsLmdldCA1KSkgKGxvY2FsLmdldCA2KSkgKGxvY2FsLmdldCA3KSkpXFxuKVxcblwiXG4gIH0sXG4gIFwia2VjY2FrXCI6IHtcbiAgICBcIndhc3RcIjogXCI7O1xcbjs7IENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9heGljL2tlY2Nhay13YXNtIChoYXMgbW9yZSBjb21tZW50cylcXG47O1xcblxcbihmdW5jICRrZWNjYWtfdGhldGFcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcblxcbiAgKGxvY2FsICRDMCBpNjQpXFxuICAobG9jYWwgJEMxIGk2NClcXG4gIChsb2NhbCAkQzIgaTY0KVxcbiAgKGxvY2FsICRDMyBpNjQpXFxuICAobG9jYWwgJEM0IGk2NClcXG4gIChsb2NhbCAkRDAgaTY0KVxcbiAgKGxvY2FsICREMSBpNjQpXFxuICAobG9jYWwgJEQyIGk2NClcXG4gIChsb2NhbCAkRDMgaTY0KVxcbiAgKGxvY2FsICRENCBpNjQpXFxuXFxuICA7OyBDW3hdID0gQVt4XSBeIEFbeCArIDVdIF4gQVt4ICsgMTBdIF4gQVt4ICsgMTVdIF4gQVt4ICsgMjBdO1xcbiAgKGxvY2FsLnNldCAkQzBcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMCkpKVxcbiAgICAgIChpNjQueG9yXFxuICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDApKSlcXG4gICAgICAgIChpNjQueG9yXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4MCkpKVxcbiAgICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjApKSlcXG4gICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTYwKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICApXFxuICAgIClcXG4gIClcXG5cXG4gIChsb2NhbC5zZXQgJEMxXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDgpKSlcXG4gICAgICAoaTY0LnhvclxcbiAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDQ4KSkpXFxuICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgODgpKSlcXG4gICAgICAgICAgKGk2NC54b3JcXG4gICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTI4KSkpXFxuICAgICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE2OCkpKVxcbiAgICAgICAgICApXFxuICAgICAgICApXFxuICAgICAgKVxcbiAgICApXFxuICApXFxuXFxuICAobG9jYWwuc2V0ICRDMlxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNikpKVxcbiAgICAgIChpNjQueG9yXFxuICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNTYpKSlcXG4gICAgICAgIChpNjQueG9yXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA5NikpKVxcbiAgICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMzYpKSlcXG4gICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTc2KSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICApXFxuICAgIClcXG4gIClcXG5cXG4gIChsb2NhbC5zZXQgJEMzXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSkpXFxuICAgICAgKGk2NC54b3JcXG4gICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA2NCkpKVxcbiAgICAgICAgKGk2NC54b3JcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEwNCkpKVxcbiAgICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNDQpKSlcXG4gICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTg0KSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICApXFxuICAgIClcXG4gIClcXG5cXG4gIChsb2NhbC5zZXQgJEM0XFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDMyKSkpXFxuICAgICAgKGk2NC54b3JcXG4gICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA3MikpKVxcbiAgICAgICAgKGk2NC54b3JcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDExMikpKVxcbiAgICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNTIpKSlcXG4gICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTkyKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICApXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IERbMF0gPSBST1RMNjQoQ1sxXSwgMSkgXiBDWzRdO1xcbiAgKGxvY2FsLnNldCAkRDBcXG4gICAgKGk2NC54b3JcXG4gICAgICAobG9jYWwuZ2V0ICRDNClcXG4gICAgICAoaTY0LnJvdGxcXG4gICAgICAgIChsb2NhbC5nZXQgJEMxKVxcbiAgICAgICAgKGk2NC5jb25zdCAxKVxcbiAgICAgIClcXG4gICAgKVxcbiAgKVxcblxcbiAgOzsgRFsxXSA9IFJPVEw2NChDWzJdLCAxKSBeIENbMF07XFxuICAobG9jYWwuc2V0ICREMVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChsb2NhbC5nZXQgJEMwKVxcbiAgICAgIChpNjQucm90bFxcbiAgICAgICAgKGxvY2FsLmdldCAkQzIpXFxuICAgICAgICAoaTY0LmNvbnN0IDEpXFxuICAgICAgKVxcbiAgICApXFxuICApXFxuXFxuICA7OyBEWzJdID0gUk9UTDY0KENbM10sIDEpIF4gQ1sxXTtcXG4gIChsb2NhbC5zZXQgJEQyXFxuICAgIChpNjQueG9yXFxuICAgICAgKGxvY2FsLmdldCAkQzEpXFxuICAgICAgKGk2NC5yb3RsXFxuICAgICAgICAobG9jYWwuZ2V0ICRDMylcXG4gICAgICAgIChpNjQuY29uc3QgMSlcXG4gICAgICApXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IERbM10gPSBST1RMNjQoQ1s0XSwgMSkgXiBDWzJdO1xcbiAgKGxvY2FsLnNldCAkRDNcXG4gICAgKGk2NC54b3JcXG4gICAgICAobG9jYWwuZ2V0ICRDMilcXG4gICAgICAoaTY0LnJvdGxcXG4gICAgICAgIChsb2NhbC5nZXQgJEM0KVxcbiAgICAgICAgKGk2NC5jb25zdCAxKVxcbiAgICAgIClcXG4gICAgKVxcbiAgKVxcblxcbiAgOzsgRFs0XSA9IFJPVEw2NChDWzBdLCAxKSBeIENbM107XFxuICAobG9jYWwuc2V0ICRENFxcbiAgICAoaTY0LnhvclxcbiAgICAgIChsb2NhbC5nZXQgJEMzKVxcbiAgICAgIChpNjQucm90bFxcbiAgICAgICAgKGxvY2FsLmdldCAkQzApXFxuICAgICAgICAoaTY0LmNvbnN0IDEpXFxuICAgICAgKVxcbiAgICApXFxuICApXFxuXFxuICA7OyBBW3hdICAgICAgXj0gRFt4XTtcXG4gIDs7IEFbeCArIDVdICBePSBEW3hdO1xcbiAgOzsgQVt4ICsgMTBdIF49IERbeF07XFxuICA7OyBBW3ggKyAxNV0gXj0gRFt4XTtcXG4gIDs7IEFbeCArIDIwXSBePSBEW3hdO1xcbiAgXFxuICA7OyB4ID0gMFxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAwKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMCkpKVxcbiAgICAgIChsb2NhbC5nZXQgJEQwKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDQwKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDApKSlcXG4gICAgICAobG9jYWwuZ2V0ICREMClcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4MCkpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDgwKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDApXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTIwKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTIwKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDApXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTYwKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTYwKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDApXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IHggPSAxXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDgpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDEpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDgpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA0OCkpKVxcbiAgICAgIChsb2NhbC5nZXQgJEQxKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDg4KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgODgpKSlcXG4gICAgICAobG9jYWwuZ2V0ICREMSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjgpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjgpKSlcXG4gICAgICAobG9jYWwuZ2V0ICREMSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNjgpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNjgpKSlcXG4gICAgICAobG9jYWwuZ2V0ICREMSlcXG4gICAgKVxcbiAgKVxcblxcbiAgOzsgeCA9IDJcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTYpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNikpKVxcbiAgICAgIChsb2NhbC5nZXQgJEQyKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDU2KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNTYpKSlcXG4gICAgICAobG9jYWwuZ2V0ICREMilcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA5NikpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDk2KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDIpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTM2KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTM2KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDIpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTc2KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTc2KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDIpXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IHggPSAzXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMjQpKSlcXG4gICAgICAobG9jYWwuZ2V0ICREMylcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA2NCkpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDY0KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDMpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTA0KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTA0KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDMpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTQ0KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTQ0KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDMpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTg0KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTg0KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDMpXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IHggPSA0XFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDMyKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMzIpKSlcXG4gICAgICAobG9jYWwuZ2V0ICRENClcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA3MikpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDcyKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDQpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTEyKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTEyKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDQpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTUyKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTUyKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDQpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTkyKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTkyKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDQpXFxuICAgIClcXG4gIClcXG4pXFxuXFxuKGZ1bmMgJGtlY2Nha19yaG9cXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcbiAgKHBhcmFtICRyb3RhdGlvbl9jb25zdHMgaTMyKVxcblxcbiAgOzsobG9jYWwgJHRtcCBpMzIpXFxuXFxuICA7OyBzdGF0ZVsgMV0gPSBST1RMNjQoc3RhdGVbIDFdLCAgMSk7XFxuICA7Oyhsb2NhbC5zZXQgJHRtcCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxKSkpXFxuICA7OyhpNjQuc3RvcmUgKGxvY2FsLmdldCAkdG1wKSAoaTY0LnJvdGwgKGk2NC5sb2FkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICA7Oyhsb2NhbC5zZXQgJHRtcCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAyKSkpXFxuICA7OyhpNjQuc3RvcmUgKGxvY2FsLmdldCAkdG1wKSAoaTY0LnJvdGwgKGk2NC5sb2FkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSkgKGk2NC5jb25zdCA2MikpKVxcblxcbiAgKGxvY2FsICR0bXAgaTMyKVxcbiAgKGxvY2FsICRpIGkzMilcXG5cXG4gIDs7IGZvciAoaSA9IDA7IGkgPD0gMjQ7IGkrKylcXG4gIChsb2NhbC5zZXQgJGkgKGkzMi5jb25zdCAwKSlcXG4gIChibG9jayAkZG9uZVxcbiAgICAobG9vcCAkbG9vcFxcbiAgICAgIChpZiAoaTMyLmdlX3UgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCAyNCkpXFxuICAgICAgICAoYnIgJGRvbmUpXFxuICAgICAgKVxcblxcbiAgICAgIChsb2NhbC5zZXQgJHRtcCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAoaTMyLmNvbnN0IDEpIChsb2NhbC5nZXQgJGkpKSkpKVxcblxcbiAgICAgIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkdG1wKSAoaTY0LnJvdGwgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHRtcCkpIChpNjQubG9hZDhfdSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChsb2NhbC5nZXQgJGkpKSkpKVxcblxcbiAgICAgIChsb2NhbC5zZXQgJGkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCAxKSkpXFxuICAgICAgKGJyICRsb29wKVxcbiAgICApXFxuICApXFxuKVxcblxcbihmdW5jICRrZWNjYWtfcGlcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcblxcbiAgKGxvY2FsICRBMSBpNjQpXFxuICAobG9jYWwuc2V0ICRBMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgOCkpKSlcXG5cXG4gIDs7IFN3YXAgbm9uLW92ZXJsYXBwaW5nIGZpZWxkcywgaS5lLiAkQTEgPSAkQTYsIGV0Yy5cXG4gIDs7IE5PVEU6ICRBMCBpcyB1bnRvdWNoZWRcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgOCkpIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA0OCkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDgpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNzIpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDcyKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE3NikpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTc2KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDExMikpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTEyKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE2MCkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTYwKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNikpIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA5NikpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgOTYpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTA0KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMDQpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTUyKSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNTIpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTg0KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxODQpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTIwKSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjApKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMzIpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDMyKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE5MikpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTkyKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE2OCkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTY4KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDY0KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA2NCkpIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjgpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEyOCkpIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA0MCkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDApKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMjQpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE0NCkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTQ0KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEzNikpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTM2KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDg4KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4OCkpIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA1NikpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNTYpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgODApKSkpXFxuXFxuICA7OyBQbGFjZSB0aGUgcHJldmlvdXNseSBzYXZlZCBvdmVybGFwcGluZyBmaWVsZFxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4MCkpIChsb2NhbC5nZXQgJEExKSlcXG4pXFxuXFxuKGZ1bmMgJGtlY2Nha19jaGlcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcblxcbiAgKGxvY2FsICRBMCBpNjQpXFxuICAobG9jYWwgJEExIGk2NClcXG4gIChsb2NhbCAkaSBpMzIpXFxuXFxuICA7OyBmb3IgKHJvdW5kID0gMDsgcm91bmQgPCAyNTsgaSArPSA1KVxcbiAgKGxvY2FsLnNldCAkaSAoaTMyLmNvbnN0IDApKVxcbiAgKGJsb2NrICRkb25lXFxuICAgIChsb29wICRsb29wXFxuICAgICAgKGlmIChpMzIuZ2VfdSAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDI1KSlcXG4gICAgICAgIChiciAkZG9uZSlcXG4gICAgICApXFxuXFxuICAgICAgKGxvY2FsLnNldCAkQTAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChsb2NhbC5nZXQgJGkpKSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJEExIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDEpKSkpKSlcXG5cXG4gICAgICA7OyBBWzAgKyBpXSBePSB+QTEgJiBBWzIgKyBpXTtcXG4gICAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChsb2NhbC5nZXQgJGkpKSlcXG4gICAgICAgIChpNjQueG9yXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAobG9jYWwuZ2V0ICRpKSkpKVxcbiAgICAgICAgICAoaTY0LmFuZFxcbiAgICAgICAgICAgIChpNjQueG9yIChsb2NhbC5nZXQgJEExKSAoaTY0LmNvbnN0IDB4RkZGRkZGRkZGRkZGRkZGRikpIDs7IGJpdHdpc2Ugbm90XFxuICAgICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChpMzIuYWRkIChsb2NhbC5nZXQgJGkpIChpMzIuY29uc3QgMikpKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICApXFxuXFxuICAgICAgOzsgQVsxICsgaV0gXj0gfkFbMiArIGldICYgQVszICsgaV07XFxuICAgICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDEpKSkpXFxuICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIubXVsIChpMzIuY29uc3QgOCkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCAxKSkpKSlcXG4gICAgICAgICAgKGk2NC5hbmRcXG4gICAgICAgICAgICAoaTY0LnhvciAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIubXVsIChpMzIuY29uc3QgOCkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCAyKSkpKSkgKGk2NC5jb25zdCAweEZGRkZGRkZGRkZGRkZGRkYpKSA7OyBiaXR3aXNlIG5vdFxcbiAgICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDMpKSkpKVxcbiAgICAgICAgICApXFxuICAgICAgICApXFxuICAgICAgKVxcblxcbiAgICAgIDs7IEFbMiArIGldIF49IH5BWzMgKyBpXSAmIEFbNCArIGldO1xcbiAgICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIubXVsIChpMzIuY29uc3QgOCkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCAyKSkpKVxcbiAgICAgICAgKGk2NC54b3JcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChpMzIuYWRkIChsb2NhbC5nZXQgJGkpIChpMzIuY29uc3QgMikpKSkpXFxuICAgICAgICAgIChpNjQuYW5kXFxuICAgICAgICAgICAgKGk2NC54b3IgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChpMzIuYWRkIChsb2NhbC5nZXQgJGkpIChpMzIuY29uc3QgMykpKSkpIChpNjQuY29uc3QgMHhGRkZGRkZGRkZGRkZGRkZGKSkgOzsgYml0d2lzZSBub3RcXG4gICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIubXVsIChpMzIuY29uc3QgOCkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCA0KSkpKSlcXG4gICAgICAgICAgKVxcbiAgICAgICAgKVxcbiAgICAgIClcXG5cXG4gICAgICA7OyBBWzMgKyBpXSBePSB+QVs0ICsgaV0gJiBBMDtcXG4gICAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChpMzIuYWRkIChsb2NhbC5nZXQgJGkpIChpMzIuY29uc3QgMykpKSlcXG4gICAgICAgIChpNjQueG9yXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDMpKSkpKVxcbiAgICAgICAgICAoaTY0LmFuZFxcbiAgICAgICAgICAgIChpNjQueG9yIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDQpKSkpKSAoaTY0LmNvbnN0IDB4RkZGRkZGRkZGRkZGRkZGRikpIDs7IGJpdHdpc2Ugbm90XFxuICAgICAgICAgICAgKGxvY2FsLmdldCAkQTApXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICApXFxuXFxuICAgICAgOzsgQVs0ICsgaV0gXj0gfkEwICYgQTE7XFxuICAgICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDQpKSkpXFxuICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIubXVsIChpMzIuY29uc3QgOCkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCA0KSkpKSlcXG4gICAgICAgICAgKGk2NC5hbmRcXG4gICAgICAgICAgICAoaTY0LnhvciAobG9jYWwuZ2V0ICRBMCkgKGk2NC5jb25zdCAweEZGRkZGRkZGRkZGRkZGRkYpKSA7OyBiaXR3aXNlIG5vdFxcbiAgICAgICAgICAgIChsb2NhbC5nZXQgJEExKVxcbiAgICAgICAgICApXFxuICAgICAgICApXFxuICAgICAgKVxcblxcbiAgICAgIChsb2NhbC5zZXQgJGkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCA1KSkpXFxuICAgICAgKGJyICRsb29wKVxcbiAgICApXFxuICApXFxuKVxcblxcbihmdW5jICRrZWNjYWtfcGVybXV0ZVxcbiAgKHBhcmFtICRjb250ZXh0X29mZnNldCBpMzIpXFxuXFxuICAobG9jYWwgJHJvdGF0aW9uX2NvbnN0cyBpMzIpXFxuICAobG9jYWwgJHJvdW5kX2NvbnN0cyBpMzIpXFxuICAobG9jYWwgJHJvdW5kIGkzMilcXG5cXG4gIChsb2NhbC5zZXQgJHJvdW5kX2NvbnN0cyAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA0MDApKSlcXG4gIChsb2NhbC5zZXQgJHJvdGF0aW9uX2NvbnN0cyAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA1OTIpKSlcXG5cXG4gIDs7IGZvciAocm91bmQgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKVxcbiAgKGxvY2FsLnNldCAkcm91bmQgKGkzMi5jb25zdCAwKSlcXG4gIChibG9jayAkZG9uZVxcbiAgICAobG9vcCAkbG9vcFxcbiAgICAgIChpZiAoaTMyLmdlX3UgKGxvY2FsLmdldCAkcm91bmQpIChpMzIuY29uc3QgMjQpKVxcbiAgICAgICAgKGJyICRkb25lKVxcbiAgICAgIClcXG5cXG4gICAgICA7OyB0aGV0YSB0cmFuc2Zvcm1cXG4gICAgICAoY2FsbCAka2VjY2FrX3RoZXRhIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSlcXG5cXG4gICAgICA7OyByaG8gdHJhbnNmb3JtXFxuICAgICAgKGNhbGwgJGtlY2Nha19yaG8gKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykpXFxuXFxuICAgICAgOzsgcGkgdHJhbnNmb3JtXFxuICAgICAgKGNhbGwgJGtlY2Nha19waSAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkpXFxuXFxuICAgICAgOzsgY2hpIHRyYW5zZm9ybVxcbiAgICAgIChjYWxsICRrZWNjYWtfY2hpIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSlcXG5cXG4gICAgICA7OyBpb3RhIHRyYW5zZm9ybVxcbiAgICAgIDs7IGNvbnRleHRfb2Zmc2V0WzBdIF49IEtFQ0NBS19ST1VORF9DT05TVEFOVFNbcm91bmRdO1xcbiAgICAgIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpXFxuICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAoaTY0LmxvYWQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkcm91bmRfY29uc3RzKSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChsb2NhbC5nZXQgJHJvdW5kKSkpKVxcbiAgICAgICAgKVxcbiAgICAgIClcXG5cXG4gICAgICAobG9jYWwuc2V0ICRyb3VuZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3VuZCkgKGkzMi5jb25zdCAxKSkpXFxuICAgICAgKGJyICRsb29wKVxcbiAgICApICBcXG4gICkgXFxuKVxcblxcbihmdW5jICRrZWNjYWtfYmxvY2tcXG4gIChwYXJhbSAkaW5wdXRfb2Zmc2V0IGkzMilcXG4gIChwYXJhbSAkaW5wdXRfbGVuZ3RoIGkzMikgOzsgaWdub3JlZCwgd2UgZXhwZWN0IGtlY2NhazI1NlxcbiAgKHBhcmFtICRjb250ZXh0X29mZnNldCBpMzIpXFxuXFxuICA7OyByZWFkIGJsb2NrcyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBYT1IgYWdhaW5zdCBjb250ZXh0X29mZnNldFxcblxcbiAgKGk2NC5zdG9yZVxcbiAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAwKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMCkpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgMCkpKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlXFxuICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDgpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCA4KSkpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmVcXG4gICAgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTYpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNikpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgMTYpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZVxcbiAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAyNCkpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSkpXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCAyNCkpKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlXFxuICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDMyKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMzIpKSlcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkaW5wdXRfb2Zmc2V0KSAoaTMyLmNvbnN0IDMyKSkpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmVcXG4gICAgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDApKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA0MCkpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgNDApKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZVxcbiAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA0OCkpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDQ4KSkpXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCA0OCkpKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlXFxuICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDU2KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNTYpKSlcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkaW5wdXRfb2Zmc2V0KSAoaTMyLmNvbnN0IDU2KSkpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmVcXG4gICAgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNjQpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA2NCkpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgNjQpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZVxcbiAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA3MikpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDcyKSkpXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCA3MikpKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlXFxuICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDgwKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgODApKSlcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkaW5wdXRfb2Zmc2V0KSAoaTMyLmNvbnN0IDgwKSkpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmVcXG4gICAgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgODgpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4OCkpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgODgpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZVxcbiAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA5NikpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDk2KSkpXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCA5NikpKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlXFxuICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEwNCkpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEwNCkpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgMTA0KSkpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmVcXG4gICAgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTEyKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTEyKSkpXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCAxMTIpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZVxcbiAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjApKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjApKSlcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkaW5wdXRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEyMCkpKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlXFxuICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEyOCkpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEyOCkpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgMTI4KSkpXFxuICAgIClcXG4gIClcXG4gIFxcbiAgKGNhbGwgJGtlY2Nha19wZXJtdXRlIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSlcXG4pXFxuXFxuOztcXG47OyBJbml0aWFsaXNlIHRoZSBjb250ZXh0XFxuOztcXG4oZnVuYyAka2VjY2FrX2luaXRcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcbiAgKGxvY2FsICRyb3VuZF9jb25zdHMgaTMyKVxcbiAgKGxvY2FsICRyb3RhdGlvbl9jb25zdHMgaTMyKVxcblxcbiAgKGNhbGwgJGtlY2Nha19yZXNldCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkpXFxuXFxuICA7OyBpbnNlcnQgdGhlIHJvdW5kIGNvbnN0YW50cyAodXNlZCBieSAkS0VDQ0FLX0lPVEEpXFxuICAobG9jYWwuc2V0ICRyb3VuZF9jb25zdHMgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDAwKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAwKSkgKGk2NC5jb25zdCAweDAwMDAwMDAwMDAwMDAwMDEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3VuZF9jb25zdHMpIChpMzIuY29uc3QgOCkpIChpNjQuY29uc3QgMHgwMDAwMDAwMDAwMDA4MDgyKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkcm91bmRfY29uc3RzKSAoaTMyLmNvbnN0IDE2KSkgKGk2NC5jb25zdCAweDgwMDAwMDAwMDAwMDgwOEEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3VuZF9jb25zdHMpIChpMzIuY29uc3QgMjQpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDA4MDAwODAwMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAzMikpIChpNjQuY29uc3QgMHgwMDAwMDAwMDAwMDA4MDhCKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkcm91bmRfY29uc3RzKSAoaTMyLmNvbnN0IDQwKSkgKGk2NC5jb25zdCAweDAwMDAwMDAwODAwMDAwMDEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3VuZF9jb25zdHMpIChpMzIuY29uc3QgNDgpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDA4MDAwODA4MSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCA1NikpIChpNjQuY29uc3QgMHg4MDAwMDAwMDAwMDA4MDA5KSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkcm91bmRfY29uc3RzKSAoaTMyLmNvbnN0IDY0KSkgKGk2NC5jb25zdCAweDAwMDAwMDAwMDAwMDAwOEEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3VuZF9jb25zdHMpIChpMzIuY29uc3QgNzIpKSAoaTY0LmNvbnN0IDB4MDAwMDAwMDAwMDAwMDA4OCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCA4MCkpIChpNjQuY29uc3QgMHgwMDAwMDAwMDgwMDA4MDA5KSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkcm91bmRfY29uc3RzKSAoaTMyLmNvbnN0IDg4KSkgKGk2NC5jb25zdCAweDAwMDAwMDAwODAwMDAwMEEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3VuZF9jb25zdHMpIChpMzIuY29uc3QgOTYpKSAoaTY0LmNvbnN0IDB4MDAwMDAwMDA4MDAwODA4QikpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxMDQpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDAwMDAwMDA4QikpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxMTIpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDAwMDAwODA4OSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxMjApKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDAwMDAwODAwMykpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxMjgpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDAwMDAwODAwMikpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxMzYpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDAwMDAwMDA4MCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxNDQpKSAoaTY0LmNvbnN0IDB4MDAwMDAwMDAwMDAwODAwQSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxNTIpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDA4MDAwMDAwQSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxNjApKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDA4MDAwODA4MSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxNjgpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDAwMDAwODA4MCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxNzYpKSAoaTY0LmNvbnN0IDB4MDAwMDAwMDA4MDAwMDAwMSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxODQpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDA4MDAwODAwOCkpXFxuXFxuICA7OyBpbnNlcnQgdGhlIHJvdGF0aW9uIGNvbnN0YW50cyAodXNlZCBieSAka2VjY2FrX3JobylcXG4gIChsb2NhbC5zZXQgJHJvdGF0aW9uX2NvbnN0cyAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA1OTIpKSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAwKSkgKGkzMi5jb25zdCAxKSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAxKSkgKGkzMi5jb25zdCA2MikpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgMikpIChpMzIuY29uc3QgMjgpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDMpKSAoaTMyLmNvbnN0IDI3KSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCA0KSkgKGkzMi5jb25zdCAzNikpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgNSkpIChpMzIuY29uc3QgNDQpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDYpKSAoaTMyLmNvbnN0IDYpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDcpKSAoaTMyLmNvbnN0IDU1KSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCA4KSkgKGkzMi5jb25zdCAyMCkpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgOSkpIChpMzIuY29uc3QgMykpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgMTApKSAoaTMyLmNvbnN0IDEwKSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAxMSkpIChpMzIuY29uc3QgNDMpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDEyKSkgKGkzMi5jb25zdCAyNSkpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgMTMpKSAoaTMyLmNvbnN0IDM5KSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAxNCkpIChpMzIuY29uc3QgNDEpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDE1KSkgKGkzMi5jb25zdCA0NSkpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgMTYpKSAoaTMyLmNvbnN0IDE1KSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAxNykpIChpMzIuY29uc3QgMjEpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDE4KSkgKGkzMi5jb25zdCA4KSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAxOSkpIChpMzIuY29uc3QgMTgpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDIwKSkgKGkzMi5jb25zdCAyKSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAyMSkpIChpMzIuY29uc3QgNjEpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDIyKSkgKGkzMi5jb25zdCA1NikpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgMjMpKSAoaTMyLmNvbnN0IDE0KSlcXG4pXFxuXFxuOztcXG47OyBSZXNldCB0aGUgY29udGV4dFxcbjs7XFxuKGZ1bmMgJGtlY2Nha19yZXNldFxcbiAgKHBhcmFtICRjb250ZXh0X29mZnNldCBpMzIpXFxuXFxuICA7OyBjbGVhciBvdXQgdGhlIGNvbnRleHQgbWVtb3J5XFxuICAoZHJvcCAoY2FsbCAkbWVtc2V0IChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDApIChpMzIuY29uc3QgNDAwKSkpXFxuKVxcblxcbjs7XFxuOzsgUHVzaCBpbnB1dCB0byB0aGUgY29udGV4dFxcbjs7XFxuKGZ1bmMgJGtlY2Nha191cGRhdGVcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcbiAgKHBhcmFtICRpbnB1dF9vZmZzZXQgaTMyKVxcbiAgKHBhcmFtICRpbnB1dF9sZW5ndGggaTMyKVxcblxcbiAgKGxvY2FsICRyZXNpZHVlX29mZnNldCBpMzIpXFxuICAobG9jYWwgJHJlc2lkdWVfYnVmZmVyIGkzMilcXG4gIChsb2NhbCAkcmVzaWR1ZV9pbmRleCBpMzIpXFxuICAobG9jYWwgJHRtcCBpMzIpXFxuXFxuICA7OyB0aGlzIGlzIHdoZXJlIHdlIHN0b3JlIHRoZSBwb2ludGVyXFxuICAobG9jYWwuc2V0ICRyZXNpZHVlX29mZnNldCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAyMDApKSlcXG4gIDs7IHRoaXMgaXMgd2hlcmUgdGhlIGJ1ZmZlciBpc1xcbiAgKGxvY2FsLnNldCAkcmVzaWR1ZV9idWZmZXIgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMjA4KSkpXFxuXFxuICAobG9jYWwuc2V0ICRyZXNpZHVlX2luZGV4IChpMzIubG9hZCAobG9jYWwuZ2V0ICRyZXNpZHVlX29mZnNldCkpKVxcblxcbiAgOzsgcHJvY2VzcyByZXNpZHVlIGZyb20gbGFzdCBibG9ja1xcbiAgKGlmIChpMzIubmUgKGxvY2FsLmdldCAkcmVzaWR1ZV9pbmRleCkgKGkzMi5jb25zdCAwKSlcXG4gICAgKHRoZW5cXG4gICAgICA7OyB0aGUgc3BhY2UgbGVmdCBpbiB0aGUgcmVzaWR1ZSBidWZmZXJcXG4gICAgICAobG9jYWwuc2V0ICR0bXAgKGkzMi5zdWIgKGkzMi5jb25zdCAxMzYpIChsb2NhbC5nZXQgJHJlc2lkdWVfaW5kZXgpKSlcXG5cXG4gICAgICA7OyBsaW1pdCB0byB3aGF0IHdlIGhhdmUgYXMgYW4gaW5wdXRcXG4gICAgICAoaWYgKGkzMi5sdF91IChsb2NhbC5nZXQgJGlucHV0X2xlbmd0aCkgKGxvY2FsLmdldCAkdG1wKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJHRtcCAobG9jYWwuZ2V0ICRpbnB1dF9sZW5ndGgpKVxcbiAgICAgIClcXG5cXG4gICAgICA7OyBmaWxsIHVwIHRoZSByZXNpZHVlIGJ1ZmZlclxcbiAgICAgIChkcm9wIChjYWxsICRtZW1jcHlcXG4gICAgICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJHJlc2lkdWVfYnVmZmVyKSAobG9jYWwuZ2V0ICRyZXNpZHVlX2luZGV4KSlcXG4gICAgICAgIChsb2NhbC5nZXQgJGlucHV0X29mZnNldClcXG4gICAgICAgIChsb2NhbC5nZXQgJHRtcClcXG4gICAgICApKVxcblxcbiAgICAgIChsb2NhbC5zZXQgJHJlc2lkdWVfaW5kZXggKGkzMi5hZGQgKGxvY2FsLmdldCAkcmVzaWR1ZV9pbmRleCkgKGxvY2FsLmdldCAkdG1wKSkpXFxuXFxuICAgICAgOzsgYmxvY2sgY29tcGxldGVcXG4gICAgICAoaWYgKGkzMi5lcSAobG9jYWwuZ2V0ICRyZXNpZHVlX2luZGV4KSAoaTMyLmNvbnN0IDEzNikpXFxuICAgICAgICAoY2FsbCAka2VjY2FrX2Jsb2NrIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCAxMzYpIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSlcXG5cXG4gICAgICAgIChsb2NhbC5zZXQgJHJlc2lkdWVfaW5kZXggKGkzMi5jb25zdCAwKSlcXG4gICAgICApXFxuXFxuICAgICAgKGkzMi5zdG9yZSAobG9jYWwuZ2V0ICRyZXNpZHVlX29mZnNldCkgKGxvY2FsLmdldCAkcmVzaWR1ZV9pbmRleCkpXFxuXFxuICAgICAgKGxvY2FsLnNldCAkaW5wdXRfbGVuZ3RoIChpMzIuc3ViIChsb2NhbC5nZXQgJGlucHV0X2xlbmd0aCkgKGxvY2FsLmdldCAkdG1wKSkpXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IHdoaWxlIChpbnB1dF9sZW5ndGggPiBibG9ja19zaXplKVxcbiAgKGJsb2NrICRkb25lXFxuICAgIChsb29wICRsb29wXFxuICAgICAgKGlmIChpMzIubHRfdSAobG9jYWwuZ2V0ICRpbnB1dF9sZW5ndGgpIChpMzIuY29uc3QgMTM2KSlcXG4gICAgICAgIChiciAkZG9uZSlcXG4gICAgICApXFxuXFxuICAgICAgKGNhbGwgJGtlY2Nha19ibG9jayAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgMTM2KSAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkpXFxuXFxuICAgICAgKGxvY2FsLnNldCAkaW5wdXRfb2Zmc2V0IChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCAxMzYpKSlcXG4gICAgICAobG9jYWwuc2V0ICRpbnB1dF9sZW5ndGggKGkzMi5zdWIgKGxvY2FsLmdldCAkaW5wdXRfbGVuZ3RoKSAoaTMyLmNvbnN0IDEzNikpKVxcbiAgICAgIChiciAkbG9vcClcXG4gICAgKVxcbiAgKVxcblxcbiAgOzsgY29weSB0byB0aGUgcmVzaWR1ZSBidWZmZXJcXG4gIChpZiAoaTMyLmd0X3UgKGxvY2FsLmdldCAkaW5wdXRfbGVuZ3RoKSAoaTMyLmNvbnN0IDApKVxcbiAgICAodGhlblxcbiAgICAgIChkcm9wIChjYWxsICRtZW1jcHlcXG4gICAgICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJHJlc2lkdWVfYnVmZmVyKSAobG9jYWwuZ2V0ICRyZXNpZHVlX2luZGV4KSlcXG4gICAgICAgIChsb2NhbC5nZXQgJGlucHV0X29mZnNldClcXG4gICAgICAgIChsb2NhbC5nZXQgJGlucHV0X2xlbmd0aClcXG4gICAgICApKVxcblxcbiAgICAgIChsb2NhbC5zZXQgJHJlc2lkdWVfaW5kZXggKGkzMi5hZGQgKGxvY2FsLmdldCAkcmVzaWR1ZV9pbmRleCkgKGxvY2FsLmdldCAkaW5wdXRfbGVuZ3RoKSkpXFxuICAgICAgKGkzMi5zdG9yZSAobG9jYWwuZ2V0ICRyZXNpZHVlX29mZnNldCkgKGxvY2FsLmdldCAkcmVzaWR1ZV9pbmRleCkpXFxuICAgIClcXG4gIClcXG4pXFxuXFxuOztcXG47OyBGaW5hbGlzZSBhbmQgcmV0dXJuIHRoZSBoYXNoXFxuOztcXG47OyBUaGUgMjU2IGJpdCBoYXNoIGlzIHJldHVybmVkIGF0IHRoZSBvdXRwdXQgb2Zmc2V0Llxcbjs7XFxuKGZ1bmMgJGtlY2Nha19maW5pc2hcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcbiAgKHBhcmFtICRvdXRwdXRfb2Zmc2V0IGkzMilcXG5cXG4gIChsb2NhbCAkcmVzaWR1ZV9vZmZzZXQgaTMyKVxcbiAgKGxvY2FsICRyZXNpZHVlX2J1ZmZlciBpMzIpXFxuICAobG9jYWwgJHJlc2lkdWVfaW5kZXggaTMyKVxcbiAgKGxvY2FsICR0bXAgaTMyKVxcblxcbiAgOzsgdGhpcyBpcyB3aGVyZSB3ZSBzdG9yZSB0aGUgcG9pbnRlclxcbiAgKGxvY2FsLnNldCAkcmVzaWR1ZV9vZmZzZXQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMjAwKSkpXFxuICA7OyB0aGlzIGlzIHdoZXJlIHRoZSBidWZmZXIgaXNcXG4gIChsb2NhbC5zZXQgJHJlc2lkdWVfYnVmZmVyIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDIwOCkpKVxcblxcbiAgKGxvY2FsLnNldCAkcmVzaWR1ZV9pbmRleCAoaTMyLmxvYWQgKGxvY2FsLmdldCAkcmVzaWR1ZV9vZmZzZXQpKSlcXG4gIChsb2NhbC5zZXQgJHRtcCAobG9jYWwuZ2V0ICRyZXNpZHVlX2luZGV4KSlcXG5cXG4gIDs7IGNsZWFyIHRoZSByZXN0IG9mIHRoZSByZXNpZHVlIGJ1ZmZlclxcbiAgKGRyb3AgKGNhbGwgJG1lbXNldCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyZXNpZHVlX2J1ZmZlcikgKGxvY2FsLmdldCAkdG1wKSkgKGkzMi5jb25zdCAwKSAoaTMyLnN1YiAoaTMyLmNvbnN0IDEzNikgKGxvY2FsLmdldCAkdG1wKSkpKVxcblxcbiAgOzsgKChjaGFyKiljdHgtPm1lc3NhZ2UpW2N0eC0+cmVzdF0gfD0gMHgwMTtcXG4gIChsb2NhbC5zZXQgJHRtcCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyZXNpZHVlX2J1ZmZlcikgKGxvY2FsLmdldCAkcmVzaWR1ZV9pbmRleCkpKVxcbiAgKGkzMi5zdG9yZTggKGxvY2FsLmdldCAkdG1wKSAoaTMyLm9yIChpMzIubG9hZDhfdSAobG9jYWwuZ2V0ICR0bXApKSAoaTMyLmNvbnN0IDB4MDEpKSlcXG5cXG4gIDs7ICgoY2hhciopY3R4LT5tZXNzYWdlKVtibG9ja19zaXplIC0gMV0gfD0gMHg4MDtcXG4gIChsb2NhbC5zZXQgJHRtcCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyZXNpZHVlX2J1ZmZlcikgKGkzMi5jb25zdCAxMzUpKSlcXG4gIChpMzIuc3RvcmU4IChsb2NhbC5nZXQgJHRtcCkgKGkzMi5vciAoaTMyLmxvYWQ4X3UgKGxvY2FsLmdldCAkdG1wKSkgKGkzMi5jb25zdCAweDgwKSkpXFxuXFxuICAoY2FsbCAka2VjY2FrX2Jsb2NrIChsb2NhbC5nZXQgJHJlc2lkdWVfYnVmZmVyKSAoaTMyLmNvbnN0IDEzNikgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpKVxcblxcbiAgOzsgdGhlIGZpcnN0IDMyIGJ5dGVzIHBvaW50ZWQgYXQgYnkgJG91dHB1dF9vZmZzZXQgaXMgdGhlIGZpbmFsIGhhc2hcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkb3V0cHV0X29mZnNldCkgKGk2NC5sb2FkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJG91dHB1dF9vZmZzZXQpIChpMzIuY29uc3QgOCkpIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRvdXRwdXRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE2KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRvdXRwdXRfb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSkpKVxcbilcXG5cXG47O1xcbjs7IENhbGN1bGF0ZSB0aGUgaGFzaC4gSGVscGVyIG1ldGhvZCBpbmNvcnBvcmF0aW5nIHRoZSBhYm92ZSB0aHJlZS5cXG47O1xcbihmdW5jICRrZWNjYWtcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcbiAgKHBhcmFtICRpbnB1dF9vZmZzZXQgaTMyKVxcbiAgKHBhcmFtICRpbnB1dF9sZW5ndGggaTMyKVxcbiAgKHBhcmFtICRvdXRwdXRfb2Zmc2V0IGkzMilcXG5cXG4gIChjYWxsICRrZWNjYWtfaW5pdCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkpXFxuICAoY2FsbCAka2VjY2FrX3VwZGF0ZSAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGxvY2FsLmdldCAkaW5wdXRfb2Zmc2V0KSAobG9jYWwuZ2V0ICRpbnB1dF9sZW5ndGgpKVxcbiAgKGNhbGwgJGtlY2Nha19maW5pc2ggKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChsb2NhbC5nZXQgJG91dHB1dF9vZmZzZXQpKVxcbilcXG5cIlxuICB9LFxuICBcIm1lbWNweVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOztcXG47OyBtZW1jcHkgZnJvbSBld2FzbS1saWJjL2V3YXNtLWNsZWFudXBcXG47O1xcbihmdW5jICRtZW1jcHlcXG4gIChwYXJhbSAkZHN0IGkzMilcXG4gIChwYXJhbSAkc3JjIGkzMilcXG4gIChwYXJhbSAkbGVuZ3RoIGkzMilcXG4gIChyZXN1bHQgaTMyKVxcblxcbiAgKGxvY2FsICRpIGkzMilcXG5cXG4gIChsb2NhbC5zZXQgJGkgKGkzMi5jb25zdCAwKSlcXG5cXG4gIChibG9jayAkZG9uZVxcbiAgICAobG9vcCAkbG9vcFxcbiAgICAgIChpZiAoaTMyLmdlX3UgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkbGVuZ3RoKSlcXG4gICAgICAgIChiciAkZG9uZSlcXG4gICAgICApXFxuXFxuICAgICAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkZHN0KSAobG9jYWwuZ2V0ICRpKSkgKGkzMi5sb2FkOF91IChpMzIuYWRkIChsb2NhbC5nZXQgJHNyYykgKGxvY2FsLmdldCAkaSkpKSlcXG5cXG4gICAgICAobG9jYWwuc2V0ICRpIChpMzIuYWRkIChsb2NhbC5nZXQgJGkpIChpMzIuY29uc3QgMSkpKVxcbiAgICAgIChiciAkbG9vcClcXG4gICAgKVxcbiAgKVxcblxcbiAgKHJldHVybiAobG9jYWwuZ2V0ICRkc3QpKVxcbilcXG5cIlxuICB9LFxuICBcIm1lbXNldFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOztcXG47OyBtZW1jcHkgZnJvbSBld2FzbS1saWJjL2V3YXNtLWNsZWFudXBcXG47O1xcbihmdW5jICRtZW1zZXRcXG4gIChwYXJhbSAkcHRyIGkzMilcXG4gIChwYXJhbSAkdmFsdWUgaTMyKVxcbiAgKHBhcmFtICRsZW5ndGggaTMyKVxcbiAgKHJlc3VsdCBpMzIpXFxuICAobG9jYWwgJGkgaTMyKVxcblxcbiAgKGxvY2FsLnNldCAkaSAoaTMyLmNvbnN0IDApKVxcblxcbiAgKGJsb2NrICRkb25lXFxuICAgIChsb29wICRsb29wXFxuICAgICAgKGlmIChpMzIuZ2VfdSAobG9jYWwuZ2V0ICRpKSAobG9jYWwuZ2V0ICRsZW5ndGgpKVxcbiAgICAgICAgKGJyICRkb25lKVxcbiAgICAgIClcXG5cXG4gICAgICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRwdHIpIChsb2NhbC5nZXQgJGkpKSAobG9jYWwuZ2V0ICR2YWx1ZSkpXFxuXFxuICAgICAgKGxvY2FsLnNldCAkaSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDEpKSlcXG4gICAgICAoYnIgJGxvb3ApXFxuICAgIClcXG4gIClcXG4gIChsb2NhbC5nZXQgJHB0cilcXG4pXFxuXCJcbiAgfSxcbiAgXCJtZW11c2VnYXNcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRtZW11c2VnYXNcXG4gIChwYXJhbSAkb2Zmc2V0IGkzMilcXG4gIChwYXJhbSAkbGVuZ3RoIGkzMilcXG5cXG4gIChsb2NhbCAkY29zdCBpNjQpXFxuICA7OyB0aGUgbnVtYmVyIG9mIG5ldyB3b3JkcyBiZWluZyBhbGxvY2F0ZWRcXG4gIChsb2NhbCAkbmV3V29yZENvdW50IGk2NClcXG5cXG4gIChpZiAoaTMyLmVxeiAobG9jYWwuZ2V0ICRsZW5ndGgpKVxcbiAgICAodGhlbiAocmV0dXJuKSlcXG4gIClcXG5cXG4gIDs7IGNvbnN0IG5ld01lbW9yeVdvcmRDb3VudCA9IE1hdGguY2VpbFtbb2Zmc2V0ICsgbGVuZ3RoXSAvIDMyXVxcbiAgKGxvY2FsLnNldCAkbmV3V29yZENvdW50XFxuICAgIChpNjQuZGl2X3UgKGk2NC5hZGQgKGk2NC5jb25zdCAzMSkgKGk2NC5hZGQgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkb2Zmc2V0KSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkbGVuZ3RoKSkpKVxcbiAgICAgICAgICAgICAgIChpNjQuY29uc3QgMzIpKSlcXG5cXG4gIDs7aWYgW3J1blN0YXRlLmhpZ2hlc3RNZW0gPj0gaGlnaGVzdE1lbV0gIHJldHVyblxcbiAgKGlmIChpNjQubGVfdSAobG9jYWwuZ2V0ICRuZXdXb3JkQ291bnQpIChnbG9iYWwuZ2V0ICR3b3JkQ291bnQpKVxcbiAgICAodGhlbiAocmV0dXJuKSlcXG4gIClcXG5cXG4gIDs7IHdvcmRzICogMyArIHdvcmRzIF4yIC8gNTEyXFxuICAobG9jYWwuc2V0ICRjb3N0XFxuICAgICAoaTY0LmFkZFxcbiAgICAgICAoaTY0Lm11bCAobG9jYWwuZ2V0ICRuZXdXb3JkQ291bnQpIChpNjQuY29uc3QgMykpXFxuICAgICAgIChpNjQuZGl2X3VcXG4gICAgICAgICAoaTY0Lm11bCAobG9jYWwuZ2V0ICRuZXdXb3JkQ291bnQpXFxuICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkbmV3V29yZENvdW50KSlcXG4gICAgICAgICAoaTY0LmNvbnN0IDUxMikpKSlcXG5cXG4gIChjYWxsICR1c2VHYXMgIChpNjQuc3ViIChsb2NhbC5nZXQgJGNvc3QpIChnbG9iYWwuZ2V0ICRwcmV2TWVtQ29zdCkpKVxcbiAgKGdsb2JhbC5zZXQgJHByZXZNZW1Db3N0IChsb2NhbC5nZXQgJGNvc3QpKVxcbiAgKGdsb2JhbC5zZXQgJHdvcmRDb3VudCAobG9jYWwuZ2V0ICRuZXdXb3JkQ291bnQpKVxcblxcbiAgOzsgZ3JvdyBhY3R1YWwgbWVtb3J5XFxuICA7OyB0aGUgZmlyc3QgMzE3MDQgYnl0ZXMgYXJlIGd1YXJhbnRlZWQgdG8gYmUgYXZhaWxhYmxlXFxuICA7OyBhZGp1c3QgZm9yIDMyIGJ5dGVzICAtIHRoZSBtYXhpbWFsIHNpemUgb2YgTVNUT1JFIHdyaXRlXFxuICA7OyBUT0RPIGl0IHNob3VsZCBiZSBtZW1vcnkuc2l6ZSAqIHBhZ2Vfc2l6ZVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0IChpMzIuYWRkIChsb2NhbC5nZXQgJGxlbmd0aCkgKGkzMi5hZGQgKGxvY2FsLmdldCAkb2Zmc2V0KSAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpKSkpXFxuICAoaWYgKGkzMi5ndF91IChsb2NhbC5nZXQgJG9mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA2NTUzNikgKG1lbW9yeS5zaXplKSkpXFxuICAgICh0aGVuXFxuICAgICAgKGRyb3AgKG1lbW9yeS5ncm93XFxuICAgICAgICAoaTMyLmRpdl91IChpMzIuYWRkIChpMzIuY29uc3QgNjU1MzUpIChpMzIuc3ViIChsb2NhbC5nZXQgJG9mZnNldCkgKG1lbW9yeS5zaXplKSkpIChpMzIuY29uc3QgNjU1MzYpKSkpXFxuICAgIClcXG4gIClcXG4pXFxuXCJcbiAgfSxcbiAgXCJtb2RfMzIwXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkbW9kXzMyMFxcbiAgOzsgZGl2aWRlbmRcXG4gIChwYXJhbSAkYSBpNjQpXFxuICAocGFyYW0gJGIgaTY0KVxcbiAgKHBhcmFtICRjIGk2NClcXG4gIChwYXJhbSAkZCBpNjQpXFxuICAocGFyYW0gJGUgaTY0KVxcblxcbiAgOzsgZGl2aXNvclxcbiAgKHBhcmFtICRhMSBpNjQpXFxuICAocGFyYW0gJGIxIGk2NClcXG4gIChwYXJhbSAkYzEgaTY0KVxcbiAgKHBhcmFtICRkMSBpNjQpXFxuICAocGFyYW0gJGUxIGk2NClcXG5cXG4gIDs7IHN0YWNrIHBvaW50ZXJcXG4gIChwYXJhbSAkc3AgaTMyKVxcblxcbiAgOzsgcXVvdGllbnRcXG4gIChsb2NhbCAkYXEgaTY0KVxcbiAgKGxvY2FsICRicSBpNjQpXFxuICAobG9jYWwgJGNxIGk2NClcXG4gIChsb2NhbCAkZHEgaTY0KVxcbiAgKGxvY2FsICRlcSBpNjQpXFxuXFxuICA7OyBtYXNrXFxuICAobG9jYWwgJG1hc2thIGk2NClcXG4gIChsb2NhbCAkbWFza2IgaTY0KVxcbiAgKGxvY2FsICRtYXNrYyBpNjQpXFxuICAobG9jYWwgJG1hc2tkIGk2NClcXG4gIChsb2NhbCAkbWFza2UgaTY0KVxcblxcbiAgKGxvY2FsICRjYXJyeSBpMzIpXFxuICAobG9jYWwgJHRlbXAgaTY0KVxcblxcbiAgKGxvY2FsLnNldCAkbWFza2UgKGk2NC5jb25zdCAxKSlcXG4gIChibG9jayAkbWFpblxcbiAgICA7OyBjaGVjayBkaXYgYnkgMFxcbiAgICAoaWYgKGNhbGwgJGlzemVyb18zMjAgKGxvY2FsLmdldCAkYTEpIChsb2NhbC5nZXQgJGIxKSAobG9jYWwuZ2V0ICRjMSkgKGxvY2FsLmdldCAkZDEpIChsb2NhbC5nZXQgJGUxKSlcXG4gICAgICAodGhlblxcbiAgICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYiAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYyAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZSAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGJyICRtYWluKVxcbiAgICAgIClcXG4gICAgKVxcblxcbiAgICAoYmxvY2sgJGRvbmVcXG4gICAgICA7OyBhbGlnbiBiaXRzXFxuICAgICAgKGxvb3AgJGxvb3BcXG4gICAgICAgIDs7IGFsaWduIGJpdHM7XFxuICAgICAgICAoaWYgKGkzMi5vciAoaTY0LmVxeiAoaTY0LmNseiAobG9jYWwuZ2V0ICRhMSkpKSAoY2FsbCAkZ3RlXzMyMFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSAobG9jYWwuZ2V0ICRlMSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRhKSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICRjKSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRlKSkpXFxuICAgICAgICAgIChiciAkZG9uZSlcXG4gICAgICAgIClcXG5cXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yIDw8IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGExIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGExKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYjEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGQxIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGUxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZTEgKGk2NC5zaGwgKGxvY2FsLmdldCAkZTEpIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgICAgOzsgbWFzayA9IG1hc2sgPDwgMVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2EgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYiAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYykgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tjIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tkKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2QgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2UpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZSkgKGk2NC5jb25zdCAxKSkpXFxuICAgICAgICAoYnIgJGxvb3ApXFxuICAgICAgKVxcbiAgICApXFxuXFxuICAgIChibG9jayAkZG9uZVxcbiAgICAgIChsb29wICRsb29wXFxuICAgICAgICA7OyBsb29wIHdoaWxlIG1hc2sgIT0gMFxcbiAgICAgICAgKGlmIChjYWxsICRpc3plcm9fMzIwIChsb2NhbC5nZXQgJG1hc2thKSAobG9jYWwuZ2V0ICRtYXNrYikgKGxvY2FsLmdldCAkbWFza2MpIChsb2NhbC5nZXQgJG1hc2tkKSAobG9jYWwuZ2V0ICRtYXNrZSkpXFxuICAgICAgICAgIChiciAkZG9uZSlcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGlmIGRpdmlkZW5kID49IGRpdmlzb3JcXG4gICAgICAgIChpZiAoY2FsbCAkZ3RlXzMyMCAobG9jYWwuZ2V0ICRhKSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICRjKSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRlKSAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkgKGxvY2FsLmdldCAkZTEpKVxcbiAgICAgICAgICAodGhlblxcbiAgICAgICAgICAgIDs7IGRpdmlkZW5kID0gZGl2aWRlbmQgLSBkaXZpc29yXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5sdF91IChsb2NhbC5nZXQgJGUpIChsb2NhbC5nZXQgJGUxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkZSAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGUpIChsb2NhbC5nZXQgJGUxKSkpXFxuXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGQpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRkKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkZCAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGQxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5vciAgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICR0ZW1wKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG5cXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkYykgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5ndF91IChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGMpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjICAgICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYzEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLm9yICAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJHRlbXApKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcblxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRiKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYikpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGIgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkdGVtcCkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkYSAgICAgKGk2NC5zdWIgIChpNjQuc3ViIChsb2NhbC5nZXQgJGEpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpIChsb2NhbC5nZXQgJGExKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yID4+IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGUxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZTEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGIxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGExKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICA7OyBtYXNrID0gbWFzayA+PiAxXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tlKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tkIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2MgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYykgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYiAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2thIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuY29uc3QgMSkpKVxcbiAgICAgICAgKGJyICRsb29wKVxcbiAgICAgIClcXG4gICAgKVxcbiAgKTs7IGVuZCBvZiBtYWluXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGxvY2FsLmdldCAkYikpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkYykpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSAgKGxvY2FsLmdldCAkZCkpXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKSAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkZSkpXFxuKVxcblwiXG4gIH0sXG4gIFwibW9kXzUxMlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgTW9kdWxvIDB4MDZcXG4oZnVuYyAkbW9kXzUxMlxcbiAgOzsgZGl2aWRlbmRcXG4gIChwYXJhbSAkYSBpNjQpXFxuICAocGFyYW0gJGIgaTY0KVxcbiAgKHBhcmFtICRjIGk2NClcXG4gIChwYXJhbSAkZCBpNjQpXFxuICAocGFyYW0gJGUgaTY0KVxcbiAgKHBhcmFtICRmIGk2NClcXG4gIChwYXJhbSAkZyBpNjQpXFxuICAocGFyYW0gJGggaTY0KVxcblxcbiAgOzsgZGl2aXNvclxcbiAgKHBhcmFtICRhMSBpNjQpXFxuICAocGFyYW0gJGIxIGk2NClcXG4gIChwYXJhbSAkYzEgaTY0KVxcbiAgKHBhcmFtICRkMSBpNjQpXFxuICAocGFyYW0gJGUxIGk2NClcXG4gIChwYXJhbSAkZjEgaTY0KVxcbiAgKHBhcmFtICRnMSBpNjQpXFxuICAocGFyYW0gJGgxIGk2NClcXG5cXG4gIChwYXJhbSAkc3AgaTMyKVxcblxcbiAgOzsgcXVvdGllbnRcXG4gIChsb2NhbCAkYXEgaTY0KVxcbiAgKGxvY2FsICRicSBpNjQpXFxuICAobG9jYWwgJGNxIGk2NClcXG4gIChsb2NhbCAkZHEgaTY0KVxcblxcbiAgOzsgbWFza1xcbiAgKGxvY2FsICRtYXNrYSBpNjQpXFxuICAobG9jYWwgJG1hc2tiIGk2NClcXG4gIChsb2NhbCAkbWFza2MgaTY0KVxcbiAgKGxvY2FsICRtYXNrZCBpNjQpXFxuICAobG9jYWwgJG1hc2tlIGk2NClcXG4gIChsb2NhbCAkbWFza2YgaTY0KVxcbiAgKGxvY2FsICRtYXNrZyBpNjQpXFxuICAobG9jYWwgJG1hc2toIGk2NClcXG5cXG4gIChsb2NhbCAkY2FycnkgaTMyKVxcbiAgKGxvY2FsICR0ZW1wIGk2NClcXG5cXG4gIChsb2NhbC5zZXQgJG1hc2toIChpNjQuY29uc3QgMSkpXFxuXFxuICAoYmxvY2sgJG1haW5cXG4gICAgOzsgY2hlY2sgZGl2IGJ5IDBcXG4gICAgKGlmIChjYWxsICRpc3plcm9fNTEyIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSAobG9jYWwuZ2V0ICRlMSkgKGxvY2FsLmdldCAkZjEpIChsb2NhbC5nZXQgJGcxKSAobG9jYWwuZ2V0ICRoMSkpXFxuICAgICAgKHRoZW5cXG4gICAgICAgIChsb2NhbC5zZXQgJGUgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGYgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGcgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGggKGk2NC5jb25zdCAwKSlcXG4gICAgICAgIChiciAkbWFpbilcXG4gICAgICApXFxuICAgIClcXG5cXG4gICAgOzsgYWxpZ24gYml0c1xcbiAgICAoYmxvY2sgJGRvbmVcXG4gICAgICAobG9vcCAkbG9vcFxcbiAgICAgICAgOzsgYWxpZ24gYml0cztcXG4gICAgICAgIChpZiAoaTMyLm9yIChpNjQuZXF6IChpNjQuY2x6IChsb2NhbC5nZXQgJGExKSkpXFxuICAgICAgICAgIChjYWxsICRndGVfNTEyIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSAobG9jYWwuZ2V0ICRlMSkgKGxvY2FsLmdldCAkZjEpIChsb2NhbC5nZXQgJGcxKSAobG9jYWwuZ2V0ICRoMSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkYSkgIChsb2NhbC5nZXQgJGIpICAobG9jYWwuZ2V0ICRjKSAgKGxvY2FsLmdldCAkZCkgIChsb2NhbC5nZXQgJGUpICAobG9jYWwuZ2V0ICRmKSAgKGxvY2FsLmdldCAkZykgIChsb2NhbC5nZXQgJGgpKSlcXG4gICAgICAgICAgKGJyICRkb25lKVxcbiAgICAgICAgKVxcblxcbiAgICAgICAgOzsgZGl2aXNvciA9IGRpdmlzb3IgPDwgMVxcbiAgICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkYTEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGMxIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZTEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRlMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRlMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRmMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGYxIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGYxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGcxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZzEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkZzEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaDEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRoMSAoaTY0LnNobCAobG9jYWwuZ2V0ICRoMSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICA7OyBtYXNrID0gbWFzayA8PCAxXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tiIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2MgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZCAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrZSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tlIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tlKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tmKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2YgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2YpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2cpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZyAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZykgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNraCkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2toIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2toKSAoaTY0LmNvbnN0IDEpKSlcXG4gICAgICAgIChiciAkbG9vcClcXG4gICAgICApXFxuICAgIClcXG5cXG4gICAgKGJsb2NrICRkb25lXFxuICAgICAgKGxvb3AgJGxvb3BcXG4gICAgICAgIDs7IGxvb3Agd2hpbGUgbWFzayAhPSAwXFxuICAgICAgICAoaWYgKGNhbGwgJGlzemVyb181MTIgKGxvY2FsLmdldCAkbWFza2EpIChsb2NhbC5nZXQgJG1hc2tiKSAobG9jYWwuZ2V0ICRtYXNrYykgKGxvY2FsLmdldCAkbWFza2QpIChsb2NhbC5nZXQgJG1hc2tlKSAobG9jYWwuZ2V0ICRtYXNrZikgKGxvY2FsLmdldCAkbWFza2cpIChsb2NhbC5nZXQgJG1hc2toKSlcXG4gICAgICAgICAgKGJyICRkb25lKVxcbiAgICAgICAgKVxcbiAgICAgICAgOzsgaWYgZGl2aWRlbmQgPj0gZGl2aXNvclxcbiAgICAgICAgKGlmIChjYWxsICRndGVfNTEyXFxuICAgICAgICAgIChsb2NhbC5nZXQgJGEpICAobG9jYWwuZ2V0ICRiKSAgKGxvY2FsLmdldCAkYykgIChsb2NhbC5nZXQgJGQpICAobG9jYWwuZ2V0ICRlKSAgKGxvY2FsLmdldCAkZikgIChsb2NhbC5nZXQgJGcpICAobG9jYWwuZ2V0ICRoKVxcbiAgICAgICAgICAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkgKGxvY2FsLmdldCAkZTEpIChsb2NhbC5nZXQgJGYxKSAobG9jYWwuZ2V0ICRnMSkgKGxvY2FsLmdldCAkaDEpKVxcbiAgICAgICAgICAodGhlblxcbiAgICAgICAgICAgIDs7IGRpdmlkZW5kID0gZGl2aWRlbmQgLSBkaXZpc29yXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5sdF91IChsb2NhbC5nZXQgJGgpIChsb2NhbC5nZXQgJGgxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkaCAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGgpIChsb2NhbC5nZXQgJGgxKSkpXFxuXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGcpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRnKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkZyAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGcxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5vciAgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRnKSAobG9jYWwuZ2V0ICR0ZW1wKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG5cXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkZikgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5ndF91IChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGYpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRmICAgICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkZjEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLm9yICAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGYpIChsb2NhbC5nZXQgJHRlbXApKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcblxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRlKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkZSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGUgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRlMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkZSkgKGxvY2FsLmdldCAkdGVtcCkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGQpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRkKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkZCAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGQxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5vciAgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICR0ZW1wKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG5cXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkYykgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5ndF91IChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGMpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjICAgICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYzEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLm9yICAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJHRlbXApKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcblxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRiKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYikpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGIgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkdGVtcCkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkYSAgICAgKGk2NC5zdWIgIChpNjQuc3ViIChsb2NhbC5nZXQgJGEpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpIChsb2NhbC5nZXQgJGExKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yID4+IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGgxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaDEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGcxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZzEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRnMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkZjEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRmMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGYxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRlMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGUxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZTEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGIxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGExKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICA7OyBtYXNrID0gbWFzayA+PiAxXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNraCAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2toKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZykgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tnIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2cpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tmKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2YgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrZikgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2UpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tlKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tkIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2MgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYykgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYiAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2thIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuY29uc3QgMSkpKVxcbiAgICAgICAgKGJyICRsb29wKVxcbiAgICAgIClcXG4gICAgKVxcbiAgKTs7IGVuZCBvZiBtYWluXFxuXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKSAobG9jYWwuZ2V0ICRlKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpIChsb2NhbC5nZXQgJGYpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChsb2NhbC5nZXQgJGcpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChsb2NhbC5nZXQgJGgpKVxcbilcXG5cIlxuICB9LFxuICBcIm11bF8yNTZcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRtdWxfMjU2XFxuICA7OyAgYSBiIGMgZCBlIGYgZyBoXFxuICA7OyogaSBqIGsgbCBtIG4gbyBwXFxuICA7Oy0tLS0tLS0tLS0tLS0tLS1cXG4gIChwYXJhbSAkYSBpNjQpXFxuICAocGFyYW0gJGMgaTY0KVxcbiAgKHBhcmFtICRlIGk2NClcXG4gIChwYXJhbSAkZyBpNjQpXFxuXFxuICAocGFyYW0gJGkgaTY0KVxcbiAgKHBhcmFtICRrIGk2NClcXG4gIChwYXJhbSAkbSBpNjQpXFxuICAocGFyYW0gJG8gaTY0KVxcblxcbiAgKHBhcmFtICRzcCBpMzIpXFxuXFxuICAobG9jYWwgJGIgaTY0KVxcbiAgKGxvY2FsICRkIGk2NClcXG4gIChsb2NhbCAkZiBpNjQpXFxuICAobG9jYWwgJGggaTY0KVxcbiAgKGxvY2FsICRqIGk2NClcXG4gIChsb2NhbCAkbCBpNjQpXFxuICAobG9jYWwgJG4gaTY0KVxcbiAgKGxvY2FsICRwIGk2NClcXG4gIChsb2NhbCAkdGVtcDYgaTY0KVxcbiAgKGxvY2FsICR0ZW1wNSBpNjQpXFxuICAobG9jYWwgJHRlbXA0IGk2NClcXG4gIChsb2NhbCAkdGVtcDMgaTY0KVxcbiAgKGxvY2FsICR0ZW1wMiBpNjQpXFxuICAobG9jYWwgJHRlbXAxIGk2NClcXG4gIChsb2NhbCAkdGVtcDAgaTY0KVxcblxcbiAgOzsgc3BsaXQgdGhlIG9wc1xcbiAgKGxvY2FsLnNldCAkYiAoaTY0LmFuZCAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IDMyKSkpIFxcblxcbiAgKGxvY2FsLnNldCAkZCAoaTY0LmFuZCAobG9jYWwuZ2V0ICRjKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjKSAoaTY0LmNvbnN0IDMyKSkpIFxcblxcbiAgKGxvY2FsLnNldCAkZiAoaTY0LmFuZCAobG9jYWwuZ2V0ICRlKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJGUgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRlKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICAobG9jYWwuc2V0ICRoIChpNjQuYW5kIChsb2NhbC5nZXQgJGcpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKVxcbiAgKGxvY2FsLnNldCAkZyAoaTY0LnNocl91IChsb2NhbC5nZXQgJGcpIChpNjQuY29uc3QgMzIpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGogKGk2NC5hbmQgKGxvY2FsLmdldCAkaSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpXFxuICAobG9jYWwuc2V0ICRpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaSkgKGk2NC5jb25zdCAzMikpKSBcXG5cXG4gIChsb2NhbC5zZXQgJGwgKGk2NC5hbmQgKGxvY2FsLmdldCAkaykgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpXFxuICAobG9jYWwuc2V0ICRrIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaykgKGk2NC5jb25zdCAzMikpKSBcXG5cXG4gIChsb2NhbC5zZXQgJG4gKGk2NC5hbmQgKGxvY2FsLmdldCAkbSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpXFxuICAobG9jYWwuc2V0ICRtIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbSkgKGk2NC5jb25zdCAzMikpKVxcblxcbiAgKGxvY2FsLnNldCAkcCAoaTY0LmFuZCAobG9jYWwuZ2V0ICRvKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJG8gKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRvKSAoaTY0LmNvbnN0IDMyKSkpXFxuICA7OyBmaXJzdCByb3cgbXVsdGlwbGljYXRpb24gXFxuICA7OyBwICogaFxcbiAgKGxvY2FsLnNldCAkdGVtcDAgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkaCkpKVxcbiAgOzsgcCAqIGcgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDEgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkZykpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDApIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBwICogZiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wMiAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRwKSAobG9jYWwuZ2V0ICRmKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wMSkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IHAgKiBlICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXAzIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJHApIChsb2NhbC5nZXQgJGUpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAyKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgcCAqIGQgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkZCkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBwICogYyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNSAgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkYykpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBwICogYiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkYikpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBwICogYSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRhICAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRwKSAobG9jYWwuZ2V0ICRhKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IHNlY29uZCByb3dcXG4gIDs7IG8gKiBoICsgJHRlbXAxIFxcXCJwZ1xcXCJcXG4gIChsb2NhbC5zZXQgJHRlbXAxIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG8pIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgOzsgbyAqIGcgKyAkdGVtcDIgXFxcInBmXFxcIiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wMiAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRnKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDIpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAxKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbyAqIGYgKyAkdGVtcDMgXFxcInBlXFxcIiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wMyAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRmKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAyKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbyAqIGUgKyAkdGVtcDQgICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA0IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG8pIChsb2NhbC5nZXQgJGUpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBvICogZCArICR0ZW1wNSAgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDUgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbykgKGxvY2FsLmdldCAkZCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG8gKiBjICsgJHRlbXA2ICArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRjKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbyAqIGIgKyAkYSAgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkYSAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRiKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkYSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyB0aGlyZCByb3cgLSBuXFxuICA7OyBuICogaCArICR0ZW1wMiBcXG4gIChsb2NhbC5zZXQgJHRlbXAyIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgOzsgbiAqIGcgKyAkdGVtcDMgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDMgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbikgKGxvY2FsLmdldCAkZykpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXAzKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wMikgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG4gKiBmICsgJHRlbXA0ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA0IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGYpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBuICogZSArICR0ZW1wNSAgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDUgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbikgKGxvY2FsLmdldCAkZSkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG4gKiBkICsgJHRlbXA2ICArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRuKSAobG9jYWwuZ2V0ICRkKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbiAqIGMgKyAkYSAgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkYSAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRuKSAobG9jYWwuZ2V0ICRjKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkYSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgMzIpKSkpXFxuXFxuICA7OyBmb3J0aCByb3cgXFxuICA7OyBtICogaCArICR0ZW1wM1xcbiAgKGxvY2FsLnNldCAkdGVtcDMgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkaCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXAzKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkpXFxuICA7OyBtICogZyArICR0ZW1wNCArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNCAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRtKSAobG9jYWwuZ2V0ICRnKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAzKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbSAqIGYgKyAkdGVtcDUgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDUgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkZikpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG0gKiBlICsgJHRlbXA2ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA2IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG0pIChsb2NhbC5nZXQgJGUpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBtICogZCArICRhICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkZCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJGEpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA2KSAoaTY0LmNvbnN0IDMyKSkpKVxcblxcbiAgOzsgZml0aCByb3dcXG4gIDs7IGwgKiBoICsgJHRlbXA0XFxuICAobG9jYWwuc2V0ICR0ZW1wNCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRoKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIDs7IGwgKiBnICsgJHRlbXA1ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA1IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGwpIChsb2NhbC5nZXQgJGcpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBsICogZiArICR0ZW1wNiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRmKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbCAqIGUgKyAkYSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRhIChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGwpIChsb2NhbC5nZXQgJGUpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCAzMikpKSlcXG5cXG4gIDs7IHNpeHRoIHJvdyBcXG4gIDs7IGsgKiBoICsgJHRlbXA1XFxuICAobG9jYWwuc2V0ICR0ZW1wNSAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRoKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIDs7IGsgKiBnICsgJHRlbXA2ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA2IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGspIChsb2NhbC5nZXQgJGcpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBrICogZiArICRhICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaykgKGxvY2FsLmdldCAkZikpIChpNjQuYW5kIChsb2NhbC5nZXQgJGEpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA2KSAoaTY0LmNvbnN0IDMyKSkpKVxcblxcbiAgOzsgc2V2ZW50aCByb3dcXG4gIDs7IGogKiBoICsgJHRlbXA2XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRoKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIDs7IGogKiBnICsgJGEgKyBjYXJyeVxcblxcbiAgOzsgZWlndGggcm93XFxuICA7OyBpICogaCArICRhXFxuICAobG9jYWwuc2V0ICRhIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGkpIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRnKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkYSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgMzIpKSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcblxcbiAgOzsgY29tYmluZSB0ZXJtc1xcbiAgKGxvY2FsLnNldCAkYSAoaTY0Lm9yIChpNjQuc2hsIChsb2NhbC5nZXQgJGEpIChpNjQuY29uc3QgMzIpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgKGxvY2FsLnNldCAkYyAoaTY0Lm9yIChpNjQuc2hsIChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIChsb2NhbC5zZXQgJGUgKGk2NC5vciAoaTY0LnNobCAobG9jYWwuZ2V0ICR0ZW1wMykgKGk2NC5jb25zdCAzMikpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXAyKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkpXFxuICAobG9jYWwuc2V0ICRnIChpNjQub3IgKGk2NC5zaGwgKGxvY2FsLmdldCAkdGVtcDEpIChpNjQuY29uc3QgMzIpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMCkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcblxcbiAgOzsgc2F2ZSBzdGFjayBcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkc3ApIChsb2NhbC5nZXQgJGEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkgKGxvY2FsLmdldCAkYykpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkZSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGxvY2FsLmdldCAkZykpXFxuKVxcblwiXG4gIH1cbn0iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiTE9HXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkTE9HXFxuICAocGFyYW0gJG51bWJlciBpMzIpXFxuXFxuICAobG9jYWwgJG9mZnNldCBpMzIpXFxuICAobG9jYWwgJG9mZnNldDAgaTY0KVxcbiAgKGxvY2FsICRvZmZzZXQxIGk2NClcXG4gIChsb2NhbCAkb2Zmc2V0MiBpNjQpXFxuICAobG9jYWwgJG9mZnNldDMgaTY0KVxcblxcbiAgKGxvY2FsICRsZW5ndGggaTMyKVxcbiAgKGxvY2FsICRsZW5ndGgwIGk2NClcXG4gIChsb2NhbCAkbGVuZ3RoMSBpNjQpXFxuICAobG9jYWwgJGxlbmd0aDIgaTY0KVxcbiAgKGxvY2FsICRsZW5ndGgzIGk2NClcXG5cXG4gIChsb2NhbC5zZXQgJG9mZnNldDAgKGk2NC5sb2FkICAgICAgICAgIChnbG9iYWwuZ2V0ICRzcCkpKVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcblxcbiAgKGxvY2FsLnNldCAkbGVuZ3RoMCAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKVxcbiAgKGxvY2FsLnNldCAkbGVuZ3RoMSAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkbGVuZ3RoMiAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkbGVuZ3RoMyAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcblxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0XFxuICAgICAgICAgICAgIChjYWxsICRjaGVja19vdmVyZmxvdyAobG9jYWwuZ2V0ICRvZmZzZXQwKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0MSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJG9mZnNldDIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRvZmZzZXQzKSkpXFxuXFxuICAobG9jYWwuc2V0ICRsZW5ndGhcXG4gICAgICAgICAgICAgKGNhbGwgJGNoZWNrX292ZXJmbG93IChsb2NhbC5nZXQgJGxlbmd0aDApXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRsZW5ndGgxKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkbGVuZ3RoMilcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGxlbmd0aDMpKSlcXG5cXG4gIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0KSAobG9jYWwuZ2V0ICRsZW5ndGgpKVxcblxcbiAgKGlmIChpMzIuZXEgKGxvY2FsLmdldCAkbnVtYmVyKSAoaTMyLmNvbnN0IDApKVxcbiAgICAodGhlblxcbiAgICAgIChjYWxsICRsb2dcXG4gICAgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0KVxcbiAgICAgICAgICAgICAobG9jYWwuZ2V0ICRsZW5ndGgpXFxuICAgICAgICAgICAgIChsb2NhbC5nZXQgJG51bWJlcilcXG4gICAgICAgICAgICAgKGkzMi5jb25zdCAgMClcXG4gICAgICAgICAgICAgKGkzMi5jb25zdCAgMClcXG4gICAgICAgICAgICAgKGkzMi5jb25zdCAgMClcXG4gICAgICAgICAgICAgKGkzMi5jb25zdCAgMCkpXFxuICAgIClcXG4gIClcXG4gIChpZiAoaTMyLmVxIChsb2NhbC5nZXQgJG51bWJlcikgKGkzMi5jb25zdCAxKSlcXG4gICAgKHRoZW5cXG4gICAgKGNhbGwgJGxvZ1xcbiAgICAgICAgICAgICAobG9jYWwuZ2V0ICRvZmZzZXQpXFxuICAgICAgICAgICAgIChsb2NhbC5nZXQgJGxlbmd0aClcXG4gICAgICAgICAgICAgKGxvY2FsLmdldCAkbnVtYmVyKVxcbiAgICAgICAgICAgICAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDY0KSkpXFxuICAgICAgICAgICAgIChpMzIuY29uc3QgIDApXFxuICAgICAgICAgICAgIChpMzIuY29uc3QgIDApXFxuICAgICAgICAgICAgIChpMzIuY29uc3QgIDApKVxcbiAgICApXFxuICApXFxuICAoaWYgKGkzMi5lcSAobG9jYWwuZ2V0ICRudW1iZXIpIChpMzIuY29uc3QgMikpXFxuICAgICh0aGVuXFxuICAgIChjYWxsICRsb2dcXG4gICAgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0KVxcbiAgICAgICAgICAgICAobG9jYWwuZ2V0ICRsZW5ndGgpXFxuICAgICAgICAgICAgIChsb2NhbC5nZXQgJG51bWJlcilcXG4gICAgICAgICAgICAgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA2NCkpKVxcbiAgICAgICAgICAgICAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDk2KSkpXFxuICAgICAgICAgICAgIChpMzIuY29uc3QgIDApXFxuICAgICAgICAgICAgIChpMzIuY29uc3QgIDApKVxcbiAgICApXFxuICApXFxuICAoaWYgKGkzMi5lcSAobG9jYWwuZ2V0ICRudW1iZXIpIChpMzIuY29uc3QgMykpXFxuICAgICh0aGVuXFxuICAgIChjYWxsICRsb2dcXG4gICAgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0KVxcbiAgICAgICAgICAgICAobG9jYWwuZ2V0ICRsZW5ndGgpXFxuICAgICAgICAgICAgIChsb2NhbC5nZXQgJG51bWJlcilcXG4gICAgICAgICAgICAgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA2NCkpKVxcbiAgICAgICAgICAgICAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDk2KSkpXFxuICAgICAgICAgICAgIChjYWxsICRic3dhcF9tMjU2IChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxMjgpKSlcXG4gICAgICAgICAgICAgKGkzMi5jb25zdCAgMCkpXFxuICAgIClcXG4gIClcXG4gIChpZiAoaTMyLmVxIChsb2NhbC5nZXQgJG51bWJlcikgKGkzMi5jb25zdCA0KSlcXG4gICAgKHRoZW5cXG4gICAgKGNhbGwgJGxvZ1xcbiAgICAgICAgICAgICAobG9jYWwuZ2V0ICRvZmZzZXQpXFxuICAgICAgICAgICAgIChsb2NhbC5nZXQgJGxlbmd0aClcXG4gICAgICAgICAgICAgKGxvY2FsLmdldCAkbnVtYmVyKVxcbiAgICAgICAgICAgICAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDY0KSkpXFxuICAgICAgICAgICAgIChjYWxsICRic3dhcF9tMjU2IChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOTYpKSlcXG4gICAgICAgICAgICAgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDEyOCkpKVxcbiAgICAgICAgICAgICAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYwKSkpKVxcbiAgICApXFxuICApXFxuKVxcblwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2xvZ1xcXCIgKGZ1bmMgJGxvZyAocGFyYW0gaTMyIGkzMiBpMzIgaTMyIGkzMiBpMzIgaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkxPR1xcXCIgKGZ1bmMgJExPRykpXCJcbiAgfSxcbiAgXCJDQUxMREFUQUxPQURcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IHN0YWNrOlxcbjs7ICAwOiBkYXRhT2Zmc2V0XFxuKGZ1bmMgJENBTExEQVRBTE9BRFxcbiAgKGxvY2FsICR3cml0ZU9mZnNldCBpMzIpXFxuICAobG9jYWwgJHdyaXRlT2Zmc2V0MCBpNjQpXFxuICAobG9jYWwgJHdyaXRlT2Zmc2V0MSBpNjQpXFxuICAobG9jYWwgJHdyaXRlT2Zmc2V0MiBpNjQpXFxuICAobG9jYWwgJHdyaXRlT2Zmc2V0MyBpNjQpXFxuXFxuICAobG9jYWwuc2V0ICR3cml0ZU9mZnNldDAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgMCkpKSlcXG4gIChsb2NhbC5zZXQgJHdyaXRlT2Zmc2V0MSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkd3JpdGVPZmZzZXQyIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICR3cml0ZU9mZnNldDMgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICAwKSkgKGk2NC5jb25zdCAwKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGk2NC5jb25zdCAwKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGk2NC5jb25zdCAwKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5jb25zdCAwKSlcXG5cXG4gIChsb2NhbC5zZXQgJHdyaXRlT2Zmc2V0XFxuICAgICAgICAgICAgIChjYWxsICRjaGVja19vdmVyZmxvdyAobG9jYWwuZ2V0ICR3cml0ZU9mZnNldDApXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICR3cml0ZU9mZnNldDEpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICR3cml0ZU9mZnNldDIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICR3cml0ZU9mZnNldDMpKSlcXG5cXG4gIChjYWxsICRjYWxsRGF0YUNvcHkgKGdsb2JhbC5nZXQgJHNwKSAobG9jYWwuZ2V0ICR3cml0ZU9mZnNldCkgKGkzMi5jb25zdCAzMikpXFxuICA7OyBzd2FwIHRvcCBzdGFjayBpdGVtXFxuICAoZHJvcCAoY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKSlcXG4pXFxuXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fY2FsbERhdGFDb3B5XFxcIiAoZnVuYyAkY2FsbERhdGFDb3B5IChwYXJhbSBpMzIgaTMyIGkzMikgKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJDQUxMREFUQUxPQURcXFwiIChmdW5jICRDQUxMREFUQUxPQUQpKVwiXG4gIH0sXG4gIFwiR0FTXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJEdBUyAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkgKGNhbGwgJGdldEdhc0xlZnQpKVxcbiAgICA7OyB6ZXJvIG91dCBtZW1cXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNTYpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA0OCkpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDQwKSkgKGk2NC5jb25zdCAwKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0R2FzTGVmdFxcXCIgKGZ1bmMgJGdldEdhc0xlZnQgIChyZXN1bHQgaTY0KSkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiR0FTXFxcIiAoZnVuYyAkR0FTKSlcIlxuICB9LFxuICBcIkFERFJFU1NcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkQUREUkVTUyAgIChjYWxsICRnZXRBZGRyZXNzKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRBZGRyZXNzXFxcIiAoZnVuYyAkZ2V0QWRkcmVzcyAocGFyYW0gaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkFERFJFU1NcXFwiIChmdW5jICRBRERSRVNTKSlcIlxuICB9LFxuICBcIkJBTEFOQ0VcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkQkFMQU5DRSAgIChjYWxsICRnZXRFeHRlcm5hbEJhbGFuY2UoY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKShnbG9iYWwuZ2V0ICRzcCkpKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGdsb2JhbC5nZXQgJHNwKSkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2dldEV4dGVybmFsQmFsYW5jZVxcXCIgKGZ1bmMgJGdldEV4dGVybmFsQmFsYW5jZSAocGFyYW0gaTMyIGkzMikgKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJCQUxBTkNFXFxcIiAoZnVuYyAkQkFMQU5DRSkpXCJcbiAgfSxcbiAgXCJTRUxGQkFMQU5DRVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRTRUxGQkFMQU5DRSAgIChjYWxsICRnZXRCYWxhbmNlKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRCYWxhbmNlXFxcIiAoZnVuYyAkZ2V0QmFsYW5jZSAocGFyYW0gaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIlNFTEZCQUxBTkNFXFxcIiAoZnVuYyAkU0VMRkJBTEFOQ0UpKVwiXG4gIH0sXG4gIFwiQ0hBSU5JRFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRDSEFJTklEICAgKGNhbGwgJGdldENoYWluSWQoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkoZHJvcCAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2dldENoYWluSWRcXFwiIChmdW5jICRnZXRDaGFpbklkIChwYXJhbSBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQ0hBSU5JRFxcXCIgKGZ1bmMgJENIQUlOSUQpKVwiXG4gIH0sXG4gIFwiQkFTRUZFRVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRCQVNFRkVFICAgKGNhbGwgJGdldEJhc2VGZWUoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkoZHJvcCAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2dldEJhc2VGZWVcXFwiIChmdW5jICRnZXRCYXNlRmVlIChwYXJhbSBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQkFTRUZFRVxcXCIgKGZ1bmMgJEJBU0VGRUUpKVwiXG4gIH0sXG4gIFwiT1JJR0lOXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJE9SSUdJTiAgIChjYWxsICRnZXRUeE9yaWdpbihpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKShkcm9wIChjYWxsICRic3dhcF9tMjU2IChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0VHhPcmlnaW5cXFwiIChmdW5jICRnZXRUeE9yaWdpbiAocGFyYW0gaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIk9SSUdJTlxcXCIgKGZ1bmMgJE9SSUdJTikpXCJcbiAgfSxcbiAgXCJDQUxMRVJcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkQ0FMTEVSICAgKGNhbGwgJGdldENhbGxlcihpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKShkcm9wIChjYWxsICRic3dhcF9tMjU2IChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0Q2FsbGVyXFxcIiAoZnVuYyAkZ2V0Q2FsbGVyIChwYXJhbSBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQ0FMTEVSXFxcIiAoZnVuYyAkQ0FMTEVSKSlcIlxuICB9LFxuICBcIkNBTExWQUxVRVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRDQUxMVkFMVUUgICAoY2FsbCAkZ2V0Q2FsbFZhbHVlKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRDYWxsVmFsdWVcXFwiIChmdW5jICRnZXRDYWxsVmFsdWUgKHBhcmFtIGkzMikgKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJDQUxMVkFMVUVcXFwiIChmdW5jICRDQUxMVkFMVUUpKVwiXG4gIH0sXG4gIFwiQ0FMTERBVEFTSVpFXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJENBTExEQVRBU0laRSAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkgKGk2NC5leHRlbmRfaTMyX3UgKGNhbGwgJGdldENhbGxEYXRhU2l6ZSkpKVxcbiAgICA7OyB6ZXJvIG91dCBtZW1cXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNTYpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA0OCkpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDQwKSkgKGk2NC5jb25zdCAwKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0Q2FsbERhdGFTaXplXFxcIiAoZnVuYyAkZ2V0Q2FsbERhdGFTaXplICAocmVzdWx0IGkzMikpKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkNBTExEQVRBU0laRVxcXCIgKGZ1bmMgJENBTExEQVRBU0laRSkpXCJcbiAgfSxcbiAgXCJDQUxMREFUQUNPUFlcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkQ0FMTERBVEFDT1BZIChsb2NhbCAkb2Zmc2V0MCBpMzIpKGxvY2FsICRsZW5ndGgwIGkzMikgKGxvY2FsLnNldCAkb2Zmc2V0MCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChnbG9iYWwuZ2V0ICRzcCkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpKShsb2NhbC5zZXQgJGxlbmd0aDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTY0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTU2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQ4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQwKSkpKSlcXG4gICAgKGNhbGwgJG1lbXVzZWdhcyAobG9jYWwuZ2V0ICRvZmZzZXQwKSAobG9jYWwuZ2V0ICRsZW5ndGgwKSlcXG4gICAgKGxvY2FsLnNldCAkb2Zmc2V0MCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpIChsb2NhbC5nZXQgJG9mZnNldDApKSkgKGNhbGwgJGNhbGxEYXRhQ29weShsb2NhbC5nZXQgJG9mZnNldDApKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTMyKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTI0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTgpKSkpKGxvY2FsLmdldCAkbGVuZ3RoMCkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2NhbGxEYXRhQ29weVxcXCIgKGZ1bmMgJGNhbGxEYXRhQ29weSAocGFyYW0gaTMyIGkzMiBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQ0FMTERBVEFDT1BZXFxcIiAoZnVuYyAkQ0FMTERBVEFDT1BZKSlcIlxuICB9LFxuICBcIkNPREVTSVpFXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJENPREVTSVpFICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSAoaTY0LmV4dGVuZF9pMzJfdSAoY2FsbCAkZ2V0Q29kZVNpemUpKSlcXG4gICAgOzsgemVybyBvdXQgbWVtXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDU2KSkgKGk2NC5jb25zdCAwKSlcXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA0MCkpIChpNjQuY29uc3QgMCkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2dldENvZGVTaXplXFxcIiAoZnVuYyAkZ2V0Q29kZVNpemUgIChyZXN1bHQgaTMyKSkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQ09ERVNJWkVcXFwiIChmdW5jICRDT0RFU0laRSkpXCJcbiAgfSxcbiAgXCJDT0RFQ09QWVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRDT0RFQ09QWSAobG9jYWwgJG9mZnNldDAgaTMyKShsb2NhbCAkbGVuZ3RoMCBpMzIpIChsb2NhbC5zZXQgJG9mZnNldDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKSkobG9jYWwuc2V0ICRsZW5ndGgwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC02NCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC01NikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC00OCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC00MCkpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MCkgKGxvY2FsLmdldCAkbGVuZ3RoMCkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQwKSkpIChjYWxsICRjb2RlQ29weShsb2NhbC5nZXQgJG9mZnNldDApKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTMyKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTI0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTgpKSkpKGxvY2FsLmdldCAkbGVuZ3RoMCkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2NvZGVDb3B5XFxcIiAoZnVuYyAkY29kZUNvcHkgKHBhcmFtIGkzMiBpMzIgaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkNPREVDT1BZXFxcIiAoZnVuYyAkQ09ERUNPUFkpKVwiXG4gIH0sXG4gIFwiRVhUQ09ERVNJWkVcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkRVhUQ09ERVNJWkUgICAoaTY0LnN0b3JlIChnbG9iYWwuZ2V0ICRzcCkgKGk2NC5leHRlbmRfaTMyX3UgKGNhbGwgJGdldEV4dGVybmFsQ29kZVNpemUoY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKSkpKVxcbiAgICA7OyB6ZXJvIG91dCBtZW1cXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSAoaTY0LmNvbnN0IDApKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRFeHRlcm5hbENvZGVTaXplXFxcIiAoZnVuYyAkZ2V0RXh0ZXJuYWxDb2RlU2l6ZSAocGFyYW0gaTMyKSAocmVzdWx0IGkzMikpKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkVYVENPREVTSVpFXFxcIiAoZnVuYyAkRVhUQ09ERVNJWkUpKVwiXG4gIH0sXG4gIFwiRVhUQ09ERUhBU0hcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkRVhUQ09ERUhBU0ggICAoY2FsbCAkZ2V0RXh0ZXJuYWxDb2RlSGFzaChjYWxsICRic3dhcF9tMjU2IChnbG9iYWwuZ2V0ICRzcCkpKGdsb2JhbC5nZXQgJHNwKSkoZHJvcCAoY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0RXh0ZXJuYWxDb2RlSGFzaFxcXCIgKGZ1bmMgJGdldEV4dGVybmFsQ29kZUhhc2ggKHBhcmFtIGkzMiBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiRVhUQ09ERUhBU0hcXFwiIChmdW5jICRFWFRDT0RFSEFTSCkpXCJcbiAgfSxcbiAgXCJFWFRDT0RFQ09QWVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRFWFRDT0RFQ09QWSAobG9jYWwgJG9mZnNldDAgaTMyKShsb2NhbCAkbGVuZ3RoMCBpMzIpIChsb2NhbC5zZXQgJG9mZnNldDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTMyKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTI0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTgpKSkpKShsb2NhbC5zZXQgJGxlbmd0aDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTk2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTg4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTgwKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTcyKSkpKSlcXG4gICAgKGNhbGwgJG1lbXVzZWdhcyAobG9jYWwuZ2V0ICRvZmZzZXQwKSAobG9jYWwuZ2V0ICRsZW5ndGgwKSlcXG4gICAgKGxvY2FsLnNldCAkb2Zmc2V0MCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpIChsb2NhbC5nZXQgJG9mZnNldDApKSkgKGNhbGwgJGV4dGVybmFsQ29kZUNvcHkoY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKShsb2NhbC5nZXQgJG9mZnNldDApKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTY0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTU2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQ4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQwKSkpKShsb2NhbC5nZXQgJGxlbmd0aDApKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9leHRlcm5hbENvZGVDb3B5XFxcIiAoZnVuYyAkZXh0ZXJuYWxDb2RlQ29weSAocGFyYW0gaTMyIGkzMiBpMzIgaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkVYVENPREVDT1BZXFxcIiAoZnVuYyAkRVhUQ09ERUNPUFkpKVwiXG4gIH0sXG4gIFwiR0FTUFJJQ0VcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkR0FTUFJJQ0UgICAoY2FsbCAkZ2V0VHhHYXNQcmljZShpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKShkcm9wIChjYWxsICRic3dhcF9tMjU2IChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0VHhHYXNQcmljZVxcXCIgKGZ1bmMgJGdldFR4R2FzUHJpY2UgKHBhcmFtIGkzMikgKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJHQVNQUklDRVxcXCIgKGZ1bmMgJEdBU1BSSUNFKSlcIlxuICB9LFxuICBcIkJMT0NLSEFTSFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRCTE9DS0hBU0ggICAoY2FsbCAkZ2V0QmxvY2tIYXNoKGNhbGwgJGNoZWNrX292ZXJmbG93X2k2NFxcbiAgICAgICAgICAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkoZ2xvYmFsLmdldCAkc3ApKShkcm9wIChjYWxsICRic3dhcF9tMjU2IChnbG9iYWwuZ2V0ICRzcCkpKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9nZXRCbG9ja0hhc2hcXFwiIChmdW5jICRnZXRCbG9ja0hhc2ggKHBhcmFtIGk2NCBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQkxPQ0tIQVNIXFxcIiAoZnVuYyAkQkxPQ0tIQVNIKSlcIlxuICB9LFxuICBcIkNPSU5CQVNFXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJENPSU5CQVNFICAgKGNhbGwgJGdldEJsb2NrQ29pbmJhc2UoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkoZHJvcCAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2dldEJsb2NrQ29pbmJhc2VcXFwiIChmdW5jICRnZXRCbG9ja0NvaW5iYXNlIChwYXJhbSBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQ09JTkJBU0VcXFwiIChmdW5jICRDT0lOQkFTRSkpXCJcbiAgfSxcbiAgXCJUSU1FU1RBTVBcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkVElNRVNUQU1QICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSAoY2FsbCAkZ2V0QmxvY2tUaW1lc3RhbXApKVxcbiAgICA7OyB6ZXJvIG91dCBtZW1cXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNTYpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA0OCkpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDQwKSkgKGk2NC5jb25zdCAwKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0QmxvY2tUaW1lc3RhbXBcXFwiIChmdW5jICRnZXRCbG9ja1RpbWVzdGFtcCAgKHJlc3VsdCBpNjQpKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJUSU1FU1RBTVBcXFwiIChmdW5jICRUSU1FU1RBTVApKVwiXG4gIH0sXG4gIFwiTlVNQkVSXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJE5VTUJFUiAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkgKGNhbGwgJGdldEJsb2NrTnVtYmVyKSlcXG4gICAgOzsgemVybyBvdXQgbWVtXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDU2KSkgKGk2NC5jb25zdCAwKSlcXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA0MCkpIChpNjQuY29uc3QgMCkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2dldEJsb2NrTnVtYmVyXFxcIiAoZnVuYyAkZ2V0QmxvY2tOdW1iZXIgIChyZXN1bHQgaTY0KSkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiTlVNQkVSXFxcIiAoZnVuYyAkTlVNQkVSKSlcIlxuICB9LFxuICBcIkRJRkZJQ1VMVFlcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkRElGRklDVUxUWSAgIChjYWxsICRnZXRCbG9ja0RpZmZpY3VsdHkoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0QmxvY2tEaWZmaWN1bHR5XFxcIiAoZnVuYyAkZ2V0QmxvY2tEaWZmaWN1bHR5IChwYXJhbSBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiRElGRklDVUxUWVxcXCIgKGZ1bmMgJERJRkZJQ1VMVFkpKVwiXG4gIH0sXG4gIFwiR0FTTElNSVRcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkR0FTTElNSVQgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpIChjYWxsICRnZXRCbG9ja0dhc0xpbWl0KSlcXG4gICAgOzsgemVybyBvdXQgbWVtXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDU2KSkgKGk2NC5jb25zdCAwKSlcXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA0MCkpIChpNjQuY29uc3QgMCkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2dldEJsb2NrR2FzTGltaXRcXFwiIChmdW5jICRnZXRCbG9ja0dhc0xpbWl0ICAocmVzdWx0IGk2NCkpKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkdBU0xJTUlUXFxcIiAoZnVuYyAkR0FTTElNSVQpKVwiXG4gIH0sXG4gIFwiQ1JFQVRFXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJENSRUFURSAobG9jYWwgJG9mZnNldDAgaTMyKShsb2NhbCAkbGVuZ3RoMCBpMzIpIChsb2NhbC5zZXQgJG9mZnNldDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTMyKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTI0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTgpKSkpKShsb2NhbC5zZXQgJGxlbmd0aDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTY0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTU2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQ4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQwKSkpKSlcXG4gICAgKGNhbGwgJG1lbXVzZWdhcyAobG9jYWwuZ2V0ICRvZmZzZXQwKSAobG9jYWwuZ2V0ICRsZW5ndGgwKSlcXG4gICAgKGxvY2FsLnNldCAkb2Zmc2V0MCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpIChsb2NhbC5nZXQgJG9mZnNldDApKSkgKGNhbGwgJGNyZWF0ZShjYWxsICRic3dhcF9tMjU2IChnbG9iYWwuZ2V0ICRzcCkpKGxvY2FsLmdldCAkb2Zmc2V0MCkobG9jYWwuZ2V0ICRsZW5ndGgwKShpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNjQpKSkoZHJvcCAoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTY0KSkpKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9jcmVhdGVcXFwiIChmdW5jICRjcmVhdGUgKHBhcmFtIGkzMiBpMzIgaTMyIGkzMikgKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJDUkVBVEVcXFwiIChmdW5jICRDUkVBVEUpKVwiXG4gIH0sXG4gIFwiQ1JFQVRFMlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRDUkVBVEUyIChsb2NhbCAkb2Zmc2V0MCBpMzIpKGxvY2FsICRsZW5ndGgwIGkzMikgKGxvY2FsLnNldCAkb2Zmc2V0MCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMzIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMjQpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtOCkpKSkpKGxvY2FsLnNldCAkbGVuZ3RoMCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNjQpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNDgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtNDApKSkpKVxcbiAgICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJG9mZnNldDApIChsb2NhbC5nZXQgJGxlbmd0aDApKVxcbiAgICAobG9jYWwuc2V0ICRvZmZzZXQwIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkgKGxvY2FsLmdldCAkb2Zmc2V0MCkpKSAoY2FsbCAkY3JlYXRlMihjYWxsICRic3dhcF9tMjU2IChnbG9iYWwuZ2V0ICRzcCkpKGxvY2FsLmdldCAkb2Zmc2V0MCkobG9jYWwuZ2V0ICRsZW5ndGgwKShjYWxsICRic3dhcF9tMjU2IChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtOTYpKSkoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTk2KSkpKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC05NikpKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fY3JlYXRlMlxcXCIgKGZ1bmMgJGNyZWF0ZTIgKHBhcmFtIGkzMiBpMzIgaTMyIGkzMiBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQ1JFQVRFMlxcXCIgKGZ1bmMgJENSRUFURTIpKVwiXG4gIH0sXG4gIFwiQ0FMTFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRDQUxMIChsb2NhbCAkb2Zmc2V0MCBpMzIpKGxvY2FsICRsZW5ndGgwIGkzMikobG9jYWwgJG9mZnNldDEgaTMyKShsb2NhbCAkbGVuZ3RoMSBpMzIpIChsb2NhbC5zZXQgJG9mZnNldDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTk2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTg4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTgwKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTcyKSkpKSkobG9jYWwuc2V0ICRsZW5ndGgwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMjgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTIwKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTExMikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMDQpKSkpKVxcbiAgICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJG9mZnNldDApIChsb2NhbC5nZXQgJGxlbmd0aDApKVxcbiAgICAobG9jYWwuc2V0ICRvZmZzZXQwIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkgKGxvY2FsLmdldCAkb2Zmc2V0MCkpKShsb2NhbC5zZXQgJG9mZnNldDEgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE2MCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNTIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTQ0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTEzNikpKSkpKGxvY2FsLnNldCAkbGVuZ3RoMSAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTkyKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE4NCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNzYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTY4KSkpKSlcXG4gICAgKGNhbGwgJG1lbXVzZWdhcyAobG9jYWwuZ2V0ICRvZmZzZXQxKSAobG9jYWwuZ2V0ICRsZW5ndGgxKSlcXG4gICAgKGxvY2FsLnNldCAkb2Zmc2V0MSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpIChsb2NhbC5nZXQgJG9mZnNldDEpKSkgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE5MikpIChpNjQuZXh0ZW5kX2kzMl91IChpMzIuZXF6IChjYWxsICRjYWxsKGNhbGwgJGNoZWNrX292ZXJmbG93X2k2NFxcbiAgICAgICAgICAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTMyKSkpKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC02NCkpKShsb2NhbC5nZXQgJG9mZnNldDApKGxvY2FsLmdldCAkbGVuZ3RoMCkobG9jYWwuZ2V0ICRvZmZzZXQxKShsb2NhbC5nZXQgJGxlbmd0aDEpKSkpKVxcbiAgICA7OyB6ZXJvIG91dCBtZW1cXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE2OCkpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNzYpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTg0KSkgKGk2NC5jb25zdCAwKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fY2FsbFxcXCIgKGZ1bmMgJGNhbGwgKHBhcmFtIGk2NCBpMzIgaTMyIGkzMiBpMzIgaTMyIGkzMikgKHJlc3VsdCBpMzIpKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJDQUxMXFxcIiAoZnVuYyAkQ0FMTCkpXCJcbiAgfSxcbiAgXCJDQUxMQ09ERVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRDQUxMQ09ERSAobG9jYWwgJG9mZnNldDAgaTMyKShsb2NhbCAkbGVuZ3RoMCBpMzIpKGxvY2FsICRvZmZzZXQxIGkzMikobG9jYWwgJGxlbmd0aDEgaTMyKSAobG9jYWwuc2V0ICRvZmZzZXQwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC05NikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC04OCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC04MCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC03MikpKSkpKGxvY2FsLnNldCAkbGVuZ3RoMCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTI4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTEyMCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMTIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTA0KSkpKSlcXG4gICAgKGNhbGwgJG1lbXVzZWdhcyAobG9jYWwuZ2V0ICRvZmZzZXQwKSAobG9jYWwuZ2V0ICRsZW5ndGgwKSlcXG4gICAgKGxvY2FsLnNldCAkb2Zmc2V0MCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpIChsb2NhbC5nZXQgJG9mZnNldDApKSkobG9jYWwuc2V0ICRvZmZzZXQxIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNjApKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTUyKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE0NCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMzYpKSkpKShsb2NhbC5zZXQgJGxlbmd0aDEgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE5MikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xODQpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTc2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE2OCkpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MSkgKGxvY2FsLmdldCAkbGVuZ3RoMSkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDEgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQxKSkpIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xOTIpKSAoaTY0LmV4dGVuZF9pMzJfdSAoaTMyLmVxeiAoY2FsbCAkY2FsbENvZGUoY2FsbCAkY2hlY2tfb3ZlcmZsb3dfaTY0XFxuICAgICAgICAgIChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKShjYWxsICRic3dhcF9tMjU2IChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMzIpKSkoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTY0KSkpKGxvY2FsLmdldCAkb2Zmc2V0MCkobG9jYWwuZ2V0ICRsZW5ndGgwKShsb2NhbC5nZXQgJG9mZnNldDEpKGxvY2FsLmdldCAkbGVuZ3RoMSkpKSkpXFxuICAgIDs7IHplcm8gb3V0IG1lbVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTY4KSkgKGk2NC5jb25zdCAwKSlcXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE3NikpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xODQpKSAoaTY0LmNvbnN0IDApKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9jYWxsQ29kZVxcXCIgKGZ1bmMgJGNhbGxDb2RlIChwYXJhbSBpNjQgaTMyIGkzMiBpMzIgaTMyIGkzMiBpMzIpIChyZXN1bHQgaTMyKSkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiQ0FMTENPREVcXFwiIChmdW5jICRDQUxMQ09ERSkpXCJcbiAgfSxcbiAgXCJERUxFR0FURUNBTExcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkREVMRUdBVEVDQUxMIChsb2NhbCAkb2Zmc2V0MCBpMzIpKGxvY2FsICRsZW5ndGgwIGkzMikobG9jYWwgJG9mZnNldDEgaTMyKShsb2NhbCAkbGVuZ3RoMSBpMzIpIChsb2NhbC5zZXQgJG9mZnNldDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTY0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTU2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQ4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQwKSkpKSkobG9jYWwuc2V0ICRsZW5ndGgwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC05NikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC04OCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC04MCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC03MikpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MCkgKGxvY2FsLmdldCAkbGVuZ3RoMCkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQwKSkpKGxvY2FsLnNldCAkb2Zmc2V0MSAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTI4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTEyMCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMTIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTA0KSkpKSkobG9jYWwuc2V0ICRsZW5ndGgxIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNjApKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTUyKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE0NCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMzYpKSkpKVxcbiAgICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJG9mZnNldDEpIChsb2NhbC5nZXQgJGxlbmd0aDEpKVxcbiAgICAobG9jYWwuc2V0ICRvZmZzZXQxIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkgKGxvY2FsLmdldCAkb2Zmc2V0MSkpKSAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTYwKSkgKGk2NC5leHRlbmRfaTMyX3UgKGkzMi5lcXogKGNhbGwgJGNhbGxEZWxlZ2F0ZShjYWxsICRjaGVja19vdmVyZmxvd19pNjRcXG4gICAgICAgICAgKGk2NC5sb2FkIChnbG9iYWwuZ2V0ICRzcCkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpKGNhbGwgJGJzd2FwX20yNTYgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0zMikpKShsb2NhbC5nZXQgJG9mZnNldDApKGxvY2FsLmdldCAkbGVuZ3RoMCkobG9jYWwuZ2V0ICRvZmZzZXQxKShsb2NhbC5nZXQgJGxlbmd0aDEpKSkpKVxcbiAgICA7OyB6ZXJvIG91dCBtZW1cXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTEzNikpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNDQpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTUyKSkgKGk2NC5jb25zdCAwKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fY2FsbERlbGVnYXRlXFxcIiAoZnVuYyAkY2FsbERlbGVnYXRlIChwYXJhbSBpNjQgaTMyIGkzMiBpMzIgaTMyIGkzMikgKHJlc3VsdCBpMzIpKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJERUxFR0FURUNBTExcXFwiIChmdW5jICRERUxFR0FURUNBTEwpKVwiXG4gIH0sXG4gIFwiU1RBVElDQ0FMTFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRTVEFUSUNDQUxMIChsb2NhbCAkb2Zmc2V0MCBpMzIpKGxvY2FsICRsZW5ndGgwIGkzMikobG9jYWwgJG9mZnNldDEgaTMyKShsb2NhbCAkbGVuZ3RoMSBpMzIpIChsb2NhbC5zZXQgJG9mZnNldDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTY0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTU2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQ4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTQwKSkpKSkobG9jYWwuc2V0ICRsZW5ndGgwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC05NikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC04OCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC04MCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC03MikpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MCkgKGxvY2FsLmdldCAkbGVuZ3RoMCkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQwKSkpKGxvY2FsLnNldCAkb2Zmc2V0MSAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTI4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTEyMCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMTIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTA0KSkpKSkobG9jYWwuc2V0ICRsZW5ndGgxIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xNjApKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTUyKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE0NCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMzYpKSkpKVxcbiAgICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJG9mZnNldDEpIChsb2NhbC5nZXQgJGxlbmd0aDEpKVxcbiAgICAobG9jYWwuc2V0ICRvZmZzZXQxIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkgKGxvY2FsLmdldCAkb2Zmc2V0MSkpKSAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTYwKSkgKGk2NC5leHRlbmRfaTMyX3UgKGkzMi5lcXogKGNhbGwgJGNhbGxTdGF0aWMoY2FsbCAkY2hlY2tfb3ZlcmZsb3dfaTY0XFxuICAgICAgICAgIChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKShjYWxsICRic3dhcF9tMjU2IChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMzIpKSkobG9jYWwuZ2V0ICRvZmZzZXQwKShsb2NhbC5nZXQgJGxlbmd0aDApKGxvY2FsLmdldCAkb2Zmc2V0MSkobG9jYWwuZ2V0ICRsZW5ndGgxKSkpKSlcXG4gICAgOzsgemVybyBvdXQgbWVtXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC0xMzYpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTQ0KSkgKGk2NC5jb25zdCAwKSlcXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE1MikpIChpNjQuY29uc3QgMCkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX2NhbGxTdGF0aWNcXFwiIChmdW5jICRjYWxsU3RhdGljIChwYXJhbSBpNjQgaTMyIGkzMiBpMzIgaTMyIGkzMikgKHJlc3VsdCBpMzIpKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJTVEFUSUNDQUxMXFxcIiAoZnVuYyAkU1RBVElDQ0FMTCkpXCJcbiAgfSxcbiAgXCJSRVRVUk5EQVRBQ09QWVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRSRVRVUk5EQVRBQ09QWSAobG9jYWwgJG9mZnNldDAgaTMyKShsb2NhbCAkbGVuZ3RoMCBpMzIpIChsb2NhbC5zZXQgJG9mZnNldDAgKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKSkobG9jYWwuc2V0ICRsZW5ndGgwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC02NCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC01NikpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC00OCkpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IC00MCkpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MCkgKGxvY2FsLmdldCAkbGVuZ3RoMCkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQwKSkpIChjYWxsICRyZXR1cm5EYXRhQ29weShsb2NhbC5nZXQgJG9mZnNldDApKGNhbGwgJGNoZWNrX292ZXJmbG93XFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTMyKSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTI0KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTE2KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTgpKSkpKGxvY2FsLmdldCAkbGVuZ3RoMCkpKVwiLFxuICAgIFwiaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImVudlxcXCIgXFxcImV0aGVyZXVtX3JldHVybkRhdGFDb3B5XFxcIiAoZnVuYyAkcmV0dXJuRGF0YUNvcHkgKHBhcmFtIGkzMiBpMzIgaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIlJFVFVSTkRBVEFDT1BZXFxcIiAoZnVuYyAkUkVUVVJOREFUQUNPUFkpKVwiXG4gIH0sXG4gIFwiUkVUVVJOREFUQVNJWkVcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IGdlbmVyYXRlZCBieSAuL3dhc20vZ2VuZXJhdGVJbnRlcmZhY2UuanNcXG4oZnVuYyAkUkVUVVJOREFUQVNJWkUgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpIChpNjQuZXh0ZW5kX2kzMl91IChjYWxsICRnZXRSZXR1cm5EYXRhU2l6ZSkpKVxcbiAgICA7OyB6ZXJvIG91dCBtZW1cXG4gICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgNTYpKSAoaTY0LmNvbnN0IDApKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA0OCkpIChpNjQuY29uc3QgMCkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDQwKSkgKGk2NC5jb25zdCAwKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fZ2V0UmV0dXJuRGF0YVNpemVcXFwiIChmdW5jICRnZXRSZXR1cm5EYXRhU2l6ZSAgKHJlc3VsdCBpMzIpKSlcIixcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJSRVRVUk5EQVRBU0laRVxcXCIgKGZ1bmMgJFJFVFVSTkRBVEFTSVpFKSlcIlxuICB9LFxuICBcIlNTVE9SRVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRTU1RPUkUgICAoY2FsbCAkc3RvcmFnZVN0b3JlKGNhbGwgJGJzd2FwX20yNTYgKGdsb2JhbC5nZXQgJHNwKSkoY2FsbCAkYnN3YXBfbTI1NiAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgLTMyKSkpKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9zdG9yYWdlU3RvcmVcXFwiIChmdW5jICRzdG9yYWdlU3RvcmUgKHBhcmFtIGkzMiBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiU1NUT1JFXFxcIiAoZnVuYyAkU1NUT1JFKSlcIlxuICB9LFxuICBcIlNMT0FEXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJFNMT0FEICAgKGNhbGwgJHN0b3JhZ2VMb2FkKGNhbGwgJGJzd2FwX20yNTYgKGdsb2JhbC5nZXQgJHNwKSkoZ2xvYmFsLmdldCAkc3ApKShkcm9wIChjYWxsICRic3dhcF9tMjU2IChnbG9iYWwuZ2V0ICRzcCkpKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9zdG9yYWdlTG9hZFxcXCIgKGZ1bmMgJHN0b3JhZ2VMb2FkIChwYXJhbSBpMzIgaTMyKSApKVwiLFxuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIlNMT0FEXFxcIiAoZnVuYyAkU0xPQUQpKVwiXG4gIH0sXG4gIFwiU0VMRkRFU1RSVUNUXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBnZW5lcmF0ZWQgYnkgLi93YXNtL2dlbmVyYXRlSW50ZXJmYWNlLmpzXFxuKGZ1bmMgJFNFTEZERVNUUlVDVCAgIChjYWxsICRzZWxmRGVzdHJ1Y3QoY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKSkpXCIsXG4gICAgXCJpbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZW52XFxcIiBcXFwiZXRoZXJldW1fc2VsZkRlc3RydWN0XFxcIiAoZnVuYyAkc2VsZkRlc3RydWN0IChwYXJhbSBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiU0VMRkRFU1RSVUNUXFxcIiAoZnVuYyAkU0VMRkRFU1RSVUNUKSlcIlxuICB9LFxuICBcIlJFVFVSTlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRSRVRVUk4gKGxvY2FsICRvZmZzZXQwIGkzMikobG9jYWwgJGxlbmd0aDAgaTMyKSAobG9jYWwuc2V0ICRvZmZzZXQwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkpKGxvY2FsLnNldCAkbGVuZ3RoMCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMzIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMjQpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtOCkpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MCkgKGxvY2FsLmdldCAkbGVuZ3RoMCkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQwKSkpIChjYWxsICRmaW5pc2gobG9jYWwuZ2V0ICRvZmZzZXQwKShsb2NhbC5nZXQgJGxlbmd0aDApKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9maW5pc2hcXFwiIChmdW5jICRmaW5pc2ggKHBhcmFtIGkzMiBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiUkVUVVJOXFxcIiAoZnVuYyAkUkVUVVJOKSlcIlxuICB9LFxuICBcIlJFVkVSVFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgZ2VuZXJhdGVkIGJ5IC4vd2FzbS9nZW5lcmF0ZUludGVyZmFjZS5qc1xcbihmdW5jICRSRVZFUlQgKGxvY2FsICRvZmZzZXQwIGkzMikobG9jYWwgJGxlbmd0aDAgaTMyKSAobG9jYWwuc2V0ICRvZmZzZXQwIChjYWxsICRjaGVja19vdmVyZmxvd1xcbiAgICAgICAgICAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkpKGxvY2FsLnNldCAkbGVuZ3RoMCAoY2FsbCAkY2hlY2tfb3ZlcmZsb3dcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMzIpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMjQpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtMTYpKSlcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAtOCkpKSkpXFxuICAgIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0MCkgKGxvY2FsLmdldCAkbGVuZ3RoMCkpXFxuICAgIChsb2NhbC5zZXQgJG9mZnNldDAgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJG1lbXN0YXJ0KSAobG9jYWwuZ2V0ICRvZmZzZXQwKSkpIChjYWxsICRyZXZlcnQobG9jYWwuZ2V0ICRvZmZzZXQwKShsb2NhbC5nZXQgJGxlbmd0aDApKSlcIixcbiAgICBcImltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJlbnZcXFwiIFxcXCJldGhlcmV1bV9yZXZlcnRcXFwiIChmdW5jICRyZXZlcnQgKHBhcmFtIGkzMiBpMzIpICkpXCIsXG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiUkVWRVJUXFxcIiAoZnVuYyAkUkVWRVJUKSlcIlxuICB9LFxuICBcIlBVU0hcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIlBVU0hcXFwiIChmdW5jICRQVVNIIChwYXJhbSBpNjQgaTY0IGk2NCBpNjQpICkpXCIsXG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJFBVU0hcXG4gIChwYXJhbSAkYTAgaTY0KVxcbiAgKHBhcmFtICRhMSBpNjQpXFxuICAocGFyYW0gJGEyIGk2NClcXG4gIChwYXJhbSAkYTMgaTY0KVxcbiAgKGxvY2FsICRzcCBpMzIpXFxuXFxuICA7OyBpbmNyZWFtZW50IHN0YWNrIHBvaW50ZXJcXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgKGk2NC5zdG9yZSAobG9jYWwuZ2V0ICRzcCkgKGxvY2FsLmdldCAkYTMpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkgKGxvY2FsLmdldCAkYTIpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChsb2NhbC5nZXQgJGExKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICRhMCkpXFxuKVxcblwiXG4gIH0sXG4gIFwiTVNUT1JFXCI6IHtcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJNU1RPUkVcXFwiIChmdW5jICRNU1RPUkUgKSlcIixcbiAgICBcIndhc3RcIjogXCI7OyBzdGFjazpcXG47OyAgMDogd29yZFxcbjs7IC0xOiBvZmZzZXRcXG4oZnVuYyAkTVNUT1JFXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIChsb2NhbCAkb2Zmc2V0ICAgaTMyKVxcbiAgXFxuICAobG9jYWwgJG9mZnNldDAgaTY0KVxcbiAgKGxvY2FsICRvZmZzZXQxIGk2NClcXG4gIChsb2NhbCAkb2Zmc2V0MiBpNjQpXFxuICAobG9jYWwgJG9mZnNldDMgaTY0KVxcblxcbiAgOzsgbG9hZCBhcmdzIGZyb20gdGhlIHN0YWNrXFxuICAobG9jYWwuc2V0ICRvZmZzZXQwIChpNjQubG9hZCAgICAgICAgICAoZ2xvYmFsLmdldCAkc3ApKSlcXG4gIChsb2NhbC5zZXQgJG9mZnNldDEgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcblxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0IFxcbiAgICAgICAgICAgICAoY2FsbCAkY2hlY2tfb3ZlcmZsb3cgKGxvY2FsLmdldCAkb2Zmc2V0MClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJG9mZnNldDEpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRvZmZzZXQyKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0MykpKVxcbiAgOzsgc3VidHJhY2UgZ2FzIHVzZWFnZVxcbiAgKGNhbGwgJG1lbXVzZWdhcyAobG9jYWwuZ2V0ICRvZmZzZXQpIChpMzIuY29uc3QgMzIpKVxcblxcbiAgOzsgcG9wIGl0ZW0gZnJvbSB0aGUgc3RhY2tcXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgOzsgc3dhcCB0b3Agc3RhY2sgaXRlbVxcbiAgKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJG9mZnNldCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRvZmZzZXQpIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkpKVxcbiAgOzsgc3RvcmUgd29yZCB0byBtZW1vcnlcXG4gIChpNjQuc3RvcmUgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0KSAgICAgICAgICAgICAgICAgKGk2NC5sb2FkICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJG9mZnNldCkgKGkzMi5jb25zdCA4KSkgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkb2Zmc2V0KSAoaTMyLmNvbnN0IDE2KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRvZmZzZXQpIChpMzIuY29uc3QgMjQpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiTUxPQURcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIk1MT0FEXFxcIiAoZnVuYyAkTUxPQUQgKSlcIixcbiAgICBcIndhc3RcIjogXCI7OyBzdGFjazpcXG47OyAgMDogb2Zmc2V0XFxuKGZ1bmMgJE1MT0FEXFxuICAobG9jYWwgJG9mZnNldCBpMzIpXFxuICAobG9jYWwgJG9mZnNldDAgaTY0KVxcbiAgKGxvY2FsICRvZmZzZXQxIGk2NClcXG4gIChsb2NhbCAkb2Zmc2V0MiBpNjQpXFxuICAobG9jYWwgJG9mZnNldDMgaTY0KVxcblxcbiAgOzsgbG9hZCBhcmdzIGZyb20gdGhlIHN0YWNrXFxuICAobG9jYWwuc2V0ICRvZmZzZXQwIChpNjQubG9hZCAgICAgICAgICAoZ2xvYmFsLmdldCAkc3ApKSlcXG4gIChsb2NhbC5zZXQgJG9mZnNldDEgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcblxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0IFxcbiAgICAgICAgICAgICAoY2FsbCAkY2hlY2tfb3ZlcmZsb3cgKGxvY2FsLmdldCAkb2Zmc2V0MClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJG9mZnNldDEpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRvZmZzZXQyKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0MykpKVxcbiAgOzsgc3VidHRyYWN0IGdhcyB1c2VhZ2VcXG4gIChjYWxsICRtZW11c2VnYXMgKGxvY2FsLmdldCAkb2Zmc2V0KSAoaTMyLmNvbnN0ICAzMikpXFxuXFxuICA7OyBGSVhNRTogaG93IHRvIGRlYWwgd2l0aCBvdmVyZmxvdz9cXG4gIChsb2NhbC5zZXQgJG9mZnNldCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRvZmZzZXQpIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkpKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkb2Zmc2V0KSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkb2Zmc2V0KSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGk2NC5zdG9yZSAgICAgICAgICAoZ2xvYmFsLmdldCAkc3ApICAgICAgICAgICAgICAgICAoaTY0LmxvYWQgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0KSkpXFxuXFxuICA7OyBzd2FwXFxuICAoZHJvcCAoY2FsbCAkYnN3YXBfbTI1NiAoZ2xvYmFsLmdldCAkc3ApKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJEVVBcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkRVUFxcXCIgKGZ1bmMgJERVUCAocGFyYW0gaTMyKSApKVwiLFxuICAgIFwid2FzdFwiOiBcIihmdW5jICREVVBcXG4gIChwYXJhbSAkYTAgaTMyKVxcbiAgKGxvY2FsICRzcCBpMzIpXFxuXFxuICAobG9jYWwgJHNwX3JlZiBpMzIpXFxuICBcXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcbiAgKGxvY2FsLnNldCAkc3BfcmVmIChpMzIuc3ViIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSAoaTMyLm11bCAobG9jYWwuZ2V0ICRhMCkgKGkzMi5jb25zdCAzMikpKSlcXG4gIFxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcF9yZWYpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAoaTY0LmxvYWQgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3BfcmVmKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGk2NC5sb2FkIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwX3JlZikgKGkzMi5jb25zdCAxNikpKSlcXG4gIChpNjQuc3RvcmUgICAgICAgICAgKGxvY2FsLmdldCAkc3ApICAgICAgICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3BfcmVmKSAoaTMyLmNvbnN0IDI0KSkpKVxcbilcXG5cIlxuICB9LFxuICBcIklTWkVST1wiOiB7XG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiSVNaRVJPXFxcIiAoZnVuYyAkSVNaRVJPICkpXCIsXG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJElTWkVST1xcbiAgKGxvY2FsICRhMCBpNjQpXFxuICAobG9jYWwgJGExIGk2NClcXG4gIChsb2NhbCAkYTIgaTY0KVxcbiAgKGxvY2FsICRhMyBpNjQpXFxuXFxuICA7OyBsb2FkIGFyZ3MgZnJvbSB0aGUgc3RhY2tcXG4gIChsb2NhbC5zZXQgJGEwIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRhMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYTIgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkYTMgKGk2NC5sb2FkIChnbG9iYWwuZ2V0ICRzcCkpKVxcblxcbiAgKGk2NC5zdG9yZSAoZ2xvYmFsLmdldCAkc3ApXFxuICAgIChpNjQuZXh0ZW5kX2kzMl91XFxuICAgICAgKGNhbGwgJGlzemVyb18yNTYgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYTMpKVxcbiAgICApXFxuICApXFxuXFxuICA7OyB6ZXJvIG91dCB0aGUgcmVzdCBvZiBtZW1vcnlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAoaTY0LmNvbnN0IDApKVxcbilcXG5cIlxuICB9LFxuICBcIkxUXCI6IHtcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJMVFxcXCIgKGZ1bmMgJExUICkpXCIsXG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJExUXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIChsb2NhbCAkYTAgaTY0KVxcbiAgKGxvY2FsICRhMSBpNjQpXFxuICAobG9jYWwgJGEyIGk2NClcXG4gIChsb2NhbCAkYTMgaTY0KVxcbiAgKGxvY2FsICRiMCBpNjQpXFxuICAobG9jYWwgJGIxIGk2NClcXG4gIChsb2NhbCAkYjIgaTY0KVxcbiAgKGxvY2FsICRiMyBpNjQpXFxuXFxuICAobG9jYWwuc2V0ICRzcCAoZ2xvYmFsLmdldCAkc3ApKVxcblxcbiAgOzsgbG9hZCBhcmdzIGZyb20gdGhlIHN0YWNrXFxuICAobG9jYWwuc2V0ICRhMCAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRhMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRhMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGEzIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGIwIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGIxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGIyIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkYjMgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKSAoaTY0LmV4dGVuZF9pMzJfdVxcbiAgICAoaTMyLm9yICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPCBiMFxcbiAgICAoaTMyLmFuZCAoaTY0LmVxICAgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPT0gYjBcXG4gICAgKGkzMi5vciAgKGk2NC5sdF91IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExIDwgYjFcXG4gICAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID09IGIxXFxuICAgIChpMzIub3IgIChpNjQubHRfdSAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA8IGIyXFxuICAgIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA9PSBiMlxcbiAgICAgICAgICAgICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYTMpIChsb2NhbC5nZXQgJGIzKSkpKSkpKSkpKSA7OyBhMyA8IGIzXFxuXFxuICA7OyB6ZXJvICBvdXQgdGhlIHJlc3Qgb2YgdGhlIHN0YWNrIGl0ZW1cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5jb25zdCAwKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJHVFwiOiB7XG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiR1RcXFwiIChmdW5jICRHVCApKVwiLFxuICAgIFwid2FzdFwiOiBcIihmdW5jICRHVFxcbiAgKGxvY2FsICRzcCBpMzIpXFxuXFxuICAobG9jYWwgJGEwIGk2NClcXG4gIChsb2NhbCAkYTEgaTY0KVxcbiAgKGxvY2FsICRhMiBpNjQpXFxuICAobG9jYWwgJGEzIGk2NClcXG4gIChsb2NhbCAkYjAgaTY0KVxcbiAgKGxvY2FsICRiMSBpNjQpXFxuICAobG9jYWwgJGIyIGk2NClcXG4gIChsb2NhbCAkYjMgaTY0KVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGdsb2JhbC5nZXQgJHNwKSlcXG5cXG4gIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYTAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYTEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYTIgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRhMyAoaTY0LmxvYWQgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAobG9jYWwuc2V0ICRiMCAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRiMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRiMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGIzIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgKGk2NC5zdG9yZSAobG9jYWwuZ2V0ICRzcCkgKGk2NC5leHRlbmRfaTMyX3VcXG4gICAgKGkzMi5vciAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPiBiMFxcbiAgICAoaTMyLmFuZCAoaTY0LmVxICAgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPT0gYTFcXG4gICAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID4gYjFcXG4gICAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID09IGIxXFxuICAgIChpMzIub3IgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA+IGIyXFxuICAgIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA9PSBiMlxcbiAgICAgICAgICAgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYTMpIChsb2NhbC5nZXQgJGIzKSkpKSkpKSkpKSA7OyBhMyA+IGIzXFxuXFxuICA7OyB6ZXJvICBvdXQgdGhlIHJlc3Qgb2YgdGhlIHN0YWNrIGl0ZW1cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5jb25zdCAwKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJTTFRcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIlNMVFxcXCIgKGZ1bmMgJFNMVCApKVwiLFxuICAgIFwid2FzdFwiOiBcIihmdW5jICRTTFRcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgKGxvY2FsICRhMCBpNjQpXFxuICAobG9jYWwgJGExIGk2NClcXG4gIChsb2NhbCAkYTIgaTY0KVxcbiAgKGxvY2FsICRhMyBpNjQpXFxuICAobG9jYWwgJGIwIGk2NClcXG4gIChsb2NhbCAkYjEgaTY0KVxcbiAgKGxvY2FsICRiMiBpNjQpXFxuICAobG9jYWwgJGIzIGk2NClcXG5cXG4gIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYTAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGExIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRhMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRhMyAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSkpXFxuXFxuICAobG9jYWwuc2V0ICRzcCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGIwIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGIxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGIyIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkYjMgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKSAoaTY0LmV4dGVuZF9pMzJfdVxcbiAgICAoaTMyLm9yICAoaTY0Lmx0X3MgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPCBiMFxcbiAgICAoaTMyLmFuZCAoaTY0LmVxICAgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPT0gYjBcXG4gICAgKGkzMi5vciAgKGk2NC5sdF91IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExIDwgYjFcXG4gICAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID09IGIxXFxuICAgIChpMzIub3IgIChpNjQubHRfdSAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA8IGIyXFxuICAgIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA9PSBiMlxcbiAgICAgICAgICAgICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYTMpIChsb2NhbC5nZXQgJGIzKSkpKSkpKSkpKSA7OyBhMyA8IGIzXFxuXFxuICA7OyB6ZXJvICBvdXQgdGhlIHJlc3Qgb2YgdGhlIHN0YWNrIGl0ZW1cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5jb25zdCAwKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJTSFJcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIlNIUlxcXCIgKGZ1bmMgJFNIUiApKVwiLFxuICAgIFwid2FzdFwiOiBcIihmdW5jICRTSFJcXG4gICAgKGxvY2FsICRzcCBpMzIpXFxuICAgIChsb2NhbCAkeDEgaTY0KVxcbiAgICAobG9jYWwgJHgyIGk2NClcXG4gICAgKGxvY2FsICR4MyBpNjQpXFxuICAgIChsb2NhbCAkeDQgaTY0KVxcbiAgICAobG9jYWwgJHkxIGk2NClcXG4gICAgKGxvY2FsICR5MiBpNjQpXFxuICAgIChsb2NhbCAkeTMgaTY0KVxcbiAgICAobG9jYWwgJHk0IGk2NClcXG5cXG4gICAgKGxvY2FsICR6MSBpNjQpXFxuICAgIChsb2NhbCAkejIgaTY0KVxcbiAgICAobG9jYWwgJHozIGk2NClcXG4gICAgKGxvY2FsICR6NCBpNjQpXFxuICAgIChsb2NhbCAkdCBpNjQpXFxuXFxuICAgIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgICAobG9jYWwuc2V0ICR4MSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4MiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAgIChsb2NhbC5zZXQgJHg0IChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKSlcXG5cXG4gICAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAgIChsb2NhbC5zZXQgJHkxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeTIgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAobG9jYWwuc2V0ICR5MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeTQgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAgIChibG9ja1xcbiAgICAgICAgKGlmIChpMzIuYW5kIChpNjQuZXF6IChsb2NhbC5nZXQgJHgxKSkgKGk2NC5lcXogKGxvY2FsLmdldCAkeDIpKSkgKHRoZW5cXG4gICAgICAgICAgICAoaWYgKGk2NC5lcXogKGxvY2FsLmdldCAkeDMpKSAodGhlblxcbiAgICAgICAgICAgICAgICAoaWYgKGk2NC5lcXogKGxvY2FsLmdldCAkeDQpKVxcbiAgICAgICAgICAgICAgICAgICAgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MSAobG9jYWwuZ2V0ICR5MSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGxvY2FsLmdldCAkeTIpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHozIChsb2NhbC5nZXQgJHkzKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6NCAobG9jYWwuZ2V0ICR5NCkpXFxuICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgICAgICAoZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpZiAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgMjU2KSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpNjQuZ2VfdSAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCAxMjgpKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTQgKGxvY2FsLmdldCAkeTIpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTMgKGxvY2FsLmdldCAkeTEpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTIgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkxIChpNjQuY29uc3QgMCkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR4NCAoaTY0LnN1YiAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCAxMjgpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpNjQuZ2VfdSAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCA2NCkpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5NCAobG9jYWwuZ2V0ICR5MykpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MyAobG9jYWwuZ2V0ICR5MikpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MiAobG9jYWwuZ2V0ICR5MSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MSAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeDQgKGk2NC5zdWIgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgNjQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vcClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6NCAoY2FsbCAkc2hyX3NpbmdsZSAobG9jYWwuZ2V0ICR5NCkgKGxvY2FsLmdldCAkeDQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHQgKGdsb2JhbC5nZXQgJGdsb2JhbF8pKVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejMgKGNhbGwgJHNocl9zaW5nbGUgKGxvY2FsLmdldCAkeTMpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR0IChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6NCAoaTY0Lm9yIChsb2NhbC5nZXQgJHo0KSAobG9jYWwuZ2V0ICR0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGNhbGwgJHNocl9zaW5nbGUgKGxvY2FsLmdldCAkeTIpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR0IChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MyAoaTY0Lm9yIChsb2NhbC5nZXQgJHozKSAobG9jYWwuZ2V0ICR0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejEgKGNhbGwgJHNocl9zaW5nbGUgKGxvY2FsLmdldCAkeTEpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR0IChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MiAoaTY0Lm9yIChsb2NhbC5nZXQgJHoyKSAobG9jYWwuZ2V0ICR0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICkpXFxuICAgICAgICApKVxcblxcbiAgICApXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICR6MSkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAobG9jYWwuZ2V0ICR6MikpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAobG9jYWwuZ2V0ICR6MykpXFxuICAgIChpNjQuc3RvcmUgICAgICAgICAgKGxvY2FsLmdldCAkc3ApICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICR6NCkpXFxuKVxcblxcbihmdW5jICRzaHJfc2luZ2xlXFxuICAgIChwYXJhbSAkYSBpNjQpXFxuICAgIChwYXJhbSAkYW1vdW50IGk2NClcXG4gICAgKHJlc3VsdCBpNjQpXFxuICAgIChsb2NhbCAkeCBpNjQpXFxuICAgIChsb2NhbCAkeSBpNjQpXFxuICAgIChibG9ja1xcbiAgICAgICAgKGxvY2FsLnNldCAkeSAoaTY0LnNobCAobG9jYWwuZ2V0ICRhKSAoaTY0LnN1YiAoaTY0LmNvbnN0IDY0KSAobG9jYWwuZ2V0ICRhbW91bnQpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICR4IChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYW1vdW50KSkpXFxuXFxuICAgIClcXG4gICAgKGdsb2JhbC5zZXQgJGdsb2JhbF8gKGxvY2FsLmdldCAkeSkpXFxuICAgIChsb2NhbC5nZXQgJHgpXFxuKVxcblwiXG4gIH0sXG4gIFwiRVFcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkVRXFxcIiAoZnVuYyAkRVEgKSlcIixcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkRVFcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKVxcbiAgICAoaTY0LmV4dGVuZF9pMzJfdVxcbiAgICAgIChpMzIuYW5kIChpNjQuZXEgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgNTYpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgICAgIChpMzIuYW5kIChpNjQuZXEgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgNDgpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAgIChpMzIuYW5kIChpNjQuZXEgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgNDApKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgICAgICAgICAgICAgIChpNjQuZXEgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkgKGk2NC5sb2FkICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSkpKSkpKSlcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGk2NC5jb25zdCAwKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJBRERcIjoge1xuICAgIFwiaW5saW5lX2ltcG9ydHNcIjogXCIoaW1wb3J0IFxcXCJld2FzbVxcXCIgXFxcIkFERFxcXCIgKGZ1bmMgJEFERCApKVwiLFxuICAgIFwid2FzdFwiOiBcIihmdW5jICRBRERcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgKGxvY2FsICRhIGk2NClcXG4gIChsb2NhbCAkYyBpNjQpXFxuICAobG9jYWwgJGQgaTY0KVxcbiAgKGxvY2FsICRjYXJyeSBpNjQpXFxuXFxuICAobG9jYWwuc2V0ICRzcCAoZ2xvYmFsLmdldCAkc3ApKVxcblxcbiAgOzsgZCBjIGIgYVxcbiAgOzsgcG9wIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRjIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkZCAoaTY0LmxvYWQgKGxvY2FsLmdldCAkc3ApKSlcXG4gIDs7IGRlY2VtZW50IHRoZSBzdGFjayBwb2ludGVyXFxuICAobG9jYWwuc2V0ICRzcCAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpXFxuXFxuICA7OyBkXFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRkKSAoaTY0LmxvYWQgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpKVxcbiAgOzsgc2F2ZSBkICB0byBtZW1cXG4gIChpNjQuc3RvcmUgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICRjYXJyeSkpXFxuICA7OyBjaGVjayAgZm9yIG92ZXJmbG93XFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkY2FycnkpIChsb2NhbC5nZXQgJGQpKSkpXFxuXFxuICA7OyBjIHVzZSAkZCBhcyByZWdcXG4gIChsb2NhbC5zZXQgJGQgICAgIChpNjQuYWRkIChpNjQubG9hZCAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5leHRlbmRfaTMyX3UgKGk2NC5sdF91IChsb2NhbC5nZXQgJGQpIChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgKGxvY2FsLnNldCAkZCAgICAgKGk2NC5hZGQgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkZCkpKVxcbiAgOzsgc3RvcmUgdGhlIHJlc3VsdFxcbiAgKGk2NC5zdG9yZSAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChsb2NhbC5nZXQgJGQpKVxcbiAgOzsgY2hlY2sgb3ZlcmZsb3dcXG4gIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQub3IgKGk2NC5leHRlbmRfaTMyX3UgIChpNjQubHRfdSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRjKSkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuXFxuICA7OyBiXFxuICA7OyBhZGQgY2FycnlcXG4gIChsb2NhbC5zZXQgJGQgICAgIChpNjQuYWRkIChpNjQubG9hZCAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuXFxuICA7OyB1c2UgcmVnIGNcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkZCAoaTY0LmFkZCAobG9jYWwuZ2V0ICRjKSAobG9jYWwuZ2V0ICRkKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSAobG9jYWwuZ2V0ICRkKSlcXG4gIDs7IGFcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkc3ApXFxuICAgICAgICAgICAgIChpNjQuYWRkICAgICAgICA7OyBhZGQgYVxcbiAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGEpXFxuICAgICAgICAgICAgICAgKGk2NC5hZGRcXG4gICAgICAgICAgICAgICAgIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpICA7OyBsb2FkIHRoZSBvcGVyYW5kXFxuICAgICAgICAgICAgICAgICAoaTY0Lm9yICA7OyBjYXJyeVxcbiAgICAgICAgICAgICAgICAgICAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkYykpKVxcbiAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRjYXJyeSkpKSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiU1VCXCI6IHtcbiAgICBcImlubGluZV9pbXBvcnRzXCI6IFwiKGltcG9ydCBcXFwiZXdhc21cXFwiIFxcXCJTVUJcXFwiIChmdW5jICRTVUIgKSlcIixcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkU1VCXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIChsb2NhbCAkYSBpNjQpXFxuICAobG9jYWwgJGIgaTY0KVxcbiAgKGxvY2FsICRjIGk2NClcXG4gIChsb2NhbCAkZCBpNjQpXFxuXFxuICAobG9jYWwgJGExIGk2NClcXG4gIChsb2NhbCAkYjEgaTY0KVxcbiAgKGxvY2FsICRjMSBpNjQpXFxuICAobG9jYWwgJGQxIGk2NClcXG5cXG4gIChsb2NhbCAkY2FycnkgaTY0KVxcbiAgKGxvY2FsICR0ZW1wIGk2NClcXG5cXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGIgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGQgKGk2NC5sb2FkICAgICAgICAgIChnbG9iYWwuZ2V0ICRzcCkpKVxcbiAgOzsgZGVjZW1lbnQgdGhlIHN0YWNrIHBvaW50ZXJcXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgKGxvY2FsLnNldCAkYTEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYjEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYzEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkZDEgKGk2NC5sb2FkICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICA7OyBhICogNjReMyArIGIqNjReMiArIGMqNjQgKyBkXFxuICA7OyBkXFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkZDEpKSkpXFxuICAobG9jYWwuc2V0ICRkIChpNjQuc3ViIChsb2NhbC5nZXQgJGQpIChsb2NhbC5nZXQgJGQxKSkpXFxuXFxuICA7OyBjXFxuICAobG9jYWwuc2V0ICR0ZW1wIChpNjQuc3ViIChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYykpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5zdWIgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYzEpKSlcXG4gIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQub3IgKGk2NC5leHRlbmRfaTMyX3UgKGk2NC5ndF91IChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJHRlbXApKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG5cXG4gIDs7IGJcXG4gIChsb2NhbC5zZXQgJHRlbXAgKGk2NC5zdWIgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZXh0ZW5kX2kzMl91IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiKSkpKVxcbiAgKGxvY2FsLnNldCAkYiAoaTY0LnN1YiAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiMSkpKVxcblxcbiAgOzsgYVxcbiAgKGxvY2FsLnNldCAkYSAoaTY0LnN1YiAoaTY0LnN1YiAobG9jYWwuZ2V0ICRhKSAoaTY0Lm9yIChpNjQuZXh0ZW5kX2kzMl91IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICR0ZW1wKSkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpIChsb2NhbC5nZXQgJGExKSkpXFxuXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGxvY2FsLmdldCAkYSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkYikpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGxvY2FsLmdldCAkYykpXFxuICAoaTY0LnN0b3JlICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkZCkpXFxuKVxcblwiXG4gIH0sXG4gIFwiU1dBUFwiOiB7XG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiU1dBUFxcXCIgKGZ1bmMgJFNXQVAgKHBhcmFtIGkzMikgKSlcIixcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkU1dBUFxcbiAgKHBhcmFtICRhMCBpMzIpXFxuICAobG9jYWwgJHNwX3JlZiBpMzIpXFxuXFxuICAobG9jYWwgJHRvcGEgaTY0KVxcbiAgKGxvY2FsICR0b3BiIGk2NClcXG4gIChsb2NhbCAkdG9wYyBpNjQpXFxuICAobG9jYWwgJHRvcGQgaTY0KVxcbiAgXFxuICAobG9jYWwuc2V0ICRzcF9yZWYgKGkzMi5zdWIgKGkzMi5hZGQgIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpMzIubXVsIChpMzIuYWRkIChsb2NhbC5nZXQgJGEwKSAoaTMyLmNvbnN0IDEpKSAoaTMyLmNvbnN0IDMyKSkpKVxcblxcbiAgKGxvY2FsLnNldCAkdG9wYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkdG9wYiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkdG9wYyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkdG9wZCAoaTY0LmxvYWQgICAgICAgICAgKGdsb2JhbC5nZXQgJHNwKSkpXFxuICBcXG4gIDs7IHJlcGxhY2UgdGhlIHRvcCBlbGVtZW50XFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcF9yZWYpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGk2NC5sb2FkIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwX3JlZikgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAoaTY0LmxvYWQgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3BfcmVmKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGk2NC5zdG9yZSAgICAgICAgICAoZ2xvYmFsLmdldCAkc3ApICAgICAgICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3BfcmVmKSAoaTMyLmNvbnN0IDI0KSkpKVxcblxcbiAgOzsgc3RvcmUgdGhlIG9sZCB0b3AgZWxlbWVudFxcbiAgKGk2NC5zdG9yZSAobG9jYWwuZ2V0ICRzcF9yZWYpICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICR0b3BhKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3BfcmVmKSAoaTMyLmNvbnN0IDgpKSAgKGxvY2FsLmdldCAkdG9wYikpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwX3JlZikgKGkzMi5jb25zdCAxNikpIChsb2NhbC5nZXQgJHRvcGMpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcF9yZWYpIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICR0b3BkKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJjaGVja19vdmVyZmxvd1wiOiB7XG4gICAgXCJpbmxpbmVfaW1wb3J0c1wiOiBcIihpbXBvcnQgXFxcImV3YXNtXFxcIiBcXFwiY2hlY2tfb3ZlcmZsb3dcXFwiIChmdW5jICRjaGVja19vdmVyZmxvdyAocGFyYW0gaTY0IGk2NCBpNjQgaTY0KSAgKHJlc3VsdCBpMzIpICkpXCIsXG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGNoZWNrX292ZXJmbG93XFxuICAocGFyYW0gJGEgaTY0KVxcbiAgKHBhcmFtICRiIGk2NClcXG4gIChwYXJhbSAkYyBpNjQpXFxuICAocGFyYW0gJGQgaTY0KVxcbiAgKHJlc3VsdCBpMzIpXFxuXFxuICAobG9jYWwgJE1BWF9JTlQgaTMyKVxcbiAgKGxvY2FsLnNldCAkTUFYX0lOVCAoaTMyLmNvbnN0IC0xKSlcXG5cXG4gIChpZlxcbiAgICAoaTMyLmFuZFxcbiAgICAgIChpMzIuYW5kXFxuICAgICAgICAoaTY0LmVxeiAgKGxvY2FsLmdldCAkZCkpXFxuICAgICAgICAoaTY0LmVxeiAgKGxvY2FsLmdldCAkYykpKVxcbiAgICAgIChpMzIuYW5kXFxuICAgICAgICAoaTY0LmVxeiAgKGxvY2FsLmdldCAkYikpXFxuICAgICAgICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkTUFYX0lOVCkpKSkpXFxuICAgICAocmV0dXJuIChpMzIud3JhcF9pNjQgKGxvY2FsLmdldCAkYSkpKSlcXG5cXG4gICAgIChyZXR1cm4gKGxvY2FsLmdldCAkTUFYX0lOVCkpXFxuKVxcblwiXG4gIH0sXG4gIFwiQURETU9EXCI6IHtcbiAgICBcIndhc3RcIjogXCI7OyBzdGFjazpcXG47OyAgMDogQVxcbjs7IC0xOiBCXFxuOzsgLTI6IE1PRFxcbihmdW5jICRBRERNT0RcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgKGxvY2FsICRhIGk2NClcXG4gIChsb2NhbCAkYiBpNjQpXFxuICAobG9jYWwgJGMgaTY0KVxcbiAgKGxvY2FsICRkIGk2NClcXG5cXG4gIChsb2NhbCAkYTEgaTY0KVxcbiAgKGxvY2FsICRiMSBpNjQpXFxuICAobG9jYWwgJGMxIGk2NClcXG4gIChsb2NhbCAkZDEgaTY0KVxcblxcbiAgKGxvY2FsICRtb2RhIGk2NClcXG4gIChsb2NhbCAkbW9kYiBpNjQpXFxuICAobG9jYWwgJG1vZGMgaTY0KVxcbiAgKGxvY2FsICRtb2RkIGk2NClcXG5cXG4gIChsb2NhbCAkY2FycnkgaTY0KVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGdsb2JhbC5nZXQgJHNwKSlcXG5cXG4gIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRiIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRkIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGExIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGIxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGMxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkZDEgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAobG9jYWwuc2V0ICRzcCAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgKGxvY2FsLnNldCAkbW9kYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRtb2RiIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJG1vZGMgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRtb2RkIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgOzsgYSAqIDY0XjMgKyBiKjY0XjIgKyBjKjY0ICsgZFxcbiAgOzsgZFxcbiAgKGxvY2FsLnNldCAkZCAgICAgKGk2NC5hZGQgKGxvY2FsLmdldCAkZDEpIChsb2NhbC5nZXQgJGQpKSlcXG4gIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZXh0ZW5kX2kzMl91IChpNjQubHRfdSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRkMSkpKSlcXG4gIDs7IGNcXG4gIChsb2NhbC5zZXQgJGMgICAgIChpNjQuYWRkIChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAobG9jYWwuc2V0ICRjICAgICAoaTY0LmFkZCAobG9jYWwuZ2V0ICRjMSkgKGxvY2FsLmdldCAkYykpKVxcbiAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5vciAoaTY0LmV4dGVuZF9pMzJfdSAgKGk2NC5sdF91IChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJGMxKSkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICA7OyBiXFxuICAobG9jYWwuc2V0ICRiICAgICAoaTY0LmFkZCAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5leHRlbmRfaTMyX3UgKGk2NC5sdF91IChsb2NhbC5nZXQgJGIpIChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgKGxvY2FsLnNldCAkYiAgICAgKGk2NC5hZGQgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGIpKSlcXG4gIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQub3IgKGk2NC5leHRlbmRfaTMyX3UgIChpNjQubHRfdSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICRiMSkpKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgOzsgYVxcbiAgKGxvY2FsLnNldCAkYSAgICAgKGk2NC5hZGQgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZXh0ZW5kX2kzMl91IChpNjQubHRfdSAobG9jYWwuZ2V0ICRhKSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gIChsb2NhbC5zZXQgJGEgICAgIChpNjQuYWRkIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRhKSkpXFxuICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lm9yIChpNjQuZXh0ZW5kX2kzMl91ICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYTEpKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG5cXG4gIChjYWxsICRtb2RfMzIwXFxuICAgICAgICAobG9jYWwuZ2V0ICRjYXJyeSkgKGxvY2FsLmdldCAkYSkgICAgKGxvY2FsLmdldCAkYikgICAgKGxvY2FsLmdldCAkYykgICAgKGxvY2FsLmdldCAkZClcXG4gICAgICAgIChpNjQuY29uc3QgMCkgICAgICAobG9jYWwuZ2V0ICRtb2RhKSAobG9jYWwuZ2V0ICRtb2RiKSAobG9jYWwuZ2V0ICRtb2RjKSAobG9jYWwuZ2V0ICRtb2RkKSAobG9jYWwuZ2V0ICRzcCkpXFxuKVxcblwiXG4gIH0sXG4gIFwiQU5EXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkQU5EXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkgIChpNjQuYW5kIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuYW5kIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQuYW5kIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkgKGk2NC5hbmQgKGk2NC5sb2FkIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKSAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSkpKVxcbilcXG5cIlxuICB9LFxuICBcIkJZVEVcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IHN0YWNrOlxcbjs7ICAwOiBvZmZzZXRcXG47OyAtMTogdmFsdWVcXG4oZnVuYyAkQllURVxcbiAgICAobG9jYWwgJHNwIGkzMilcXG5cXG4gICAgKGxvY2FsICR4MSBpNjQpXFxuICAgIChsb2NhbCAkeDIgaTY0KVxcbiAgICAobG9jYWwgJHgzIGk2NClcXG4gICAgKGxvY2FsICR4NCBpNjQpXFxuICAgIChsb2NhbCAkeTEgaTY0KVxcbiAgICAobG9jYWwgJHkyIGk2NClcXG4gICAgKGxvY2FsICR5MyBpNjQpXFxuICAgIChsb2NhbCAkeTQgaTY0KVxcblxcbiAgICAobG9jYWwgJHIxIGk2NClcXG4gICAgKGxvY2FsICRyMiBpNjQpXFxuICAgIChsb2NhbCAkcjMgaTY0KVxcbiAgICAobG9jYWwgJHI0IGk2NClcXG4gICAgKGxvY2FsICRjb21wb25lbnQgaTY0KVxcbiAgICAobG9jYWwgJGNvbmRpdGlvbiBpNjQpXFxuXFxuICAgIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgICAobG9jYWwuc2V0ICR4MSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4MiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAgIChsb2NhbC5zZXQgJHg0IChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKSlcXG5cXG4gICAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAgIChsb2NhbC5zZXQgJHkxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeTIgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAobG9jYWwuc2V0ICR5MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeTQgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAgIChibG9ja1xcbiAgICAgICAgKGlmIChpNjQuZXF6IChpNjQub3IgKGk2NC5vciAobG9jYWwuZ2V0ICR4MSkgKGxvY2FsLmdldCAkeDIpKSAobG9jYWwuZ2V0ICR4MykpKSAodGhlblxcbiAgICAgICAgICAgIChub3ApXFxuICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJGNvbmRpdGlvbiAoaTY0LmRpdl91IChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDgpKSlcXG4gICAgICAgICAgICAgICAgKGlmIChpNjQuZXEgKGxvY2FsLmdldCAkY29uZGl0aW9uKSAoaTY0LmNvbnN0IDApKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkY29tcG9uZW50IChsb2NhbC5nZXQgJHkxKSlcXG4gICAgICAgICAgICAgICAgKShlbHNlXFxuICAgICAgICAgICAgICAgICAgICAoaWYgKGk2NC5lcSAobG9jYWwuZ2V0ICRjb25kaXRpb24pIChpNjQuY29uc3QgMSkpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkY29tcG9uZW50IChsb2NhbC5nZXQgJHkyKSlcXG4gICAgICAgICAgICAgICAgICAgICkoZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpZiAoaTY0LmVxIChsb2NhbC5nZXQgJGNvbmRpdGlvbikgKGk2NC5jb25zdCAyKSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkY29tcG9uZW50IChsb2NhbC5nZXQgJHkzKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICApKGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpNjQuZXEgKGxvY2FsLmdldCAkY29uZGl0aW9uKSAoaTY0LmNvbnN0IDMpKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkY29tcG9uZW50IChsb2NhbC5nZXQgJHk0KSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICApKVxcbiAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgKSlcXG5cXG4gICAgICAgICAgICApXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkeDQgKGk2NC5tdWwgKGk2NC5yZW1fdSAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCA4KSkgKGk2NC5jb25zdCA4KSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkcjQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjb21wb25lbnQpIChpNjQuc3ViIChpNjQuY29uc3QgNTYpIChsb2NhbC5nZXQgJHg0KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHI0IChpNjQuYW5kIChpNjQuY29uc3QgMjU1KSAobG9jYWwuZ2V0ICRyNCkpKVxcbiAgICAgICAgKSlcXG5cXG4gICAgKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGxvY2FsLmdldCAkcjEpKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkcjIpKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGxvY2FsLmdldCAkcjMpKVxcbiAgICAoaTY0LnN0b3JlICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkcjQpKVxcbilcXG5cIlxuICB9LFxuICBcIkRJVlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJERJVlxcbiAgKGxvY2FsICRzcCBpMzIpXFxuICA7OyBkaXZpZGVuZFxcbiAgKGxvY2FsICRhIGk2NClcXG4gIChsb2NhbCAkYiBpNjQpXFxuICAobG9jYWwgJGMgaTY0KVxcbiAgKGxvY2FsICRkIGk2NClcXG5cXG4gIDs7IGRpdmlzb3JcXG4gIChsb2NhbCAkYTEgaTY0KVxcbiAgKGxvY2FsICRiMSBpNjQpXFxuICAobG9jYWwgJGMxIGk2NClcXG4gIChsb2NhbCAkZDEgaTY0KVxcblxcbiAgOzsgcXVvdGllbnRcXG4gIChsb2NhbCAkYXEgaTY0KVxcbiAgKGxvY2FsICRicSBpNjQpXFxuICAobG9jYWwgJGNxIGk2NClcXG4gIChsb2NhbCAkZHEgaTY0KVxcblxcbiAgOzsgbWFza1xcbiAgKGxvY2FsICRtYXNrYSBpNjQpXFxuICAobG9jYWwgJG1hc2tiIGk2NClcXG4gIChsb2NhbCAkbWFza2MgaTY0KVxcbiAgKGxvY2FsICRtYXNrZCBpNjQpXFxuICAobG9jYWwgJGNhcnJ5IGkzMilcXG4gIChsb2NhbCAkdGVtcCAgaTY0KVxcbiAgKGxvY2FsICR0ZW1wMiAgaTY0KVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGdsb2JhbC5nZXQgJHNwKSlcXG4gIChsb2NhbC5zZXQgJG1hc2tkIChpNjQuY29uc3QgMSkpXFxuXFxuICA7OyBsb2FkIGFyZ3MgZnJvbSB0aGUgc3RhY2tcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRjIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkZCAoaTY0LmxvYWQgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAobG9jYWwuc2V0ICRhMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRiMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRjMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGQxIChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgKGJsb2NrICRtYWluXFxuICAgIDs7IGNoZWNrIGRpdiBieSAwXFxuICAgIChpZiAoY2FsbCAkaXN6ZXJvXzI1NiAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkpXFxuICAgICAgKGJyICRtYWluKVxcbiAgICApXFxuXFxuICAgIDs7IGFsaWduIGJpdHNcXG4gICAgKGJsb2NrICRkb25lXFxuICAgICAgKGxvb3AgJGxvb3BcXG4gICAgICAgIDs7IGFsaWduIGJpdHM7XFxuICAgICAgICAoaWZcXG4gICAgICAgICAgOzsgY2hlY2sgdG8gbWFrZSBzdXJlIHdlIGFyZSBub3Qgb3ZlcmZsb3dpbmdcXG4gICAgICAgICAgKGkzMi5vciAoaTY0LmVxeiAoaTY0LmNseiAobG9jYWwuZ2V0ICRhMSkpKVxcbiAgICAgICAgICA7OyAgZGl2aXNvciA8IGRpdmlkZW5kXFxuICAgICAgICAgIChjYWxsICRndGVfMjU2IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSAobG9jYWwuZ2V0ICRhKSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICRjKSAobG9jYWwuZ2V0ICRkKSkpXFxuICAgICAgICAgIChiciAkZG9uZSlcXG4gICAgICAgIClcXG5cXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yIDw8IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGExIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGExKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYjEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGQxIChpNjQuc2hsIChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IDEpKSlcXG5cXG4gICAgICAgIDs7IG1hc2sgPSBtYXNrIDw8IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2thIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2thKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2IgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYyAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYykgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tkKSAoaTY0LmNvbnN0IDEpKSlcXG5cXG4gICAgICAgIChiciAkbG9vcClcXG4gICAgICApXFxuICAgIClcXG5cXG5cXG4gICAgKGJsb2NrICRkb25lXFxuICAgICAgKGxvb3AgJGxvb3BcXG4gICAgICAgIDs7IGxvb3Agd2hpbGUgbWFzayAhPSAwXFxuICAgICAgICAoaWYgKGNhbGwgJGlzemVyb18yNTYgKGxvY2FsLmdldCAkbWFza2EpIChsb2NhbC5nZXQgJG1hc2tiKSAobG9jYWwuZ2V0ICRtYXNrYykgKGxvY2FsLmdldCAkbWFza2QpKVxcbiAgICAgICAgICAoYnIgJGRvbmUpXFxuICAgICAgICApXFxuICAgICAgICA7OyBpZiBkaXZpZGVuZCA+PSBkaXZpc29yXFxuICAgICAgICAoaWYgKGNhbGwgJGd0ZV8yNTYgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkYTEpIChsb2NhbC5nZXQgJGIxKSAobG9jYWwuZ2V0ICRjMSkgKGxvY2FsLmdldCAkZDEpKVxcbiAgICAgICAgICAodGhlblxcbiAgICAgICAgICAgIDs7IGRpdmlkZW5kID0gZGl2aWRlbmQgLSBkaXZpc29yXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5sdF91IChsb2NhbC5nZXQgJGQpIChsb2NhbC5nZXQgJGQxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkZCAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGQpIChsb2NhbC5nZXQgJGQxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGMpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRjKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkYyAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGMxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5vciAgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRjKSAobG9jYWwuZ2V0ICR0ZW1wKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkYikgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5ndF91IChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGIpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRiICAgICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYjEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLm9yICAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGIpIChsb2NhbC5nZXQgJHRlbXApKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGEgICAgIChpNjQuc3ViICAoaTY0LnN1YiAobG9jYWwuZ2V0ICRhKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSAobG9jYWwuZ2V0ICRhMSkpKVxcblxcbiAgICAgICAgICAgIDs7IHJlc3VsdCA9IHJlc3VsdCArIG1hc2tcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRkcSAgIChpNjQuYWRkIChsb2NhbC5nZXQgJG1hc2tkKSAobG9jYWwuZ2V0ICRkcSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgKGk2NC5leHRlbmRfaTMyX3UgKGk2NC5sdF91IChsb2NhbC5nZXQgJGRxKSAobG9jYWwuZ2V0ICRtYXNrZCkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjcSAgIChpNjQuYWRkIChsb2NhbC5nZXQgJGNxKSAobG9jYWwuZ2V0ICR0ZW1wKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkY3EpIChsb2NhbC5nZXQgJHRlbXApKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY3EgICAoaTY0LmFkZCAobG9jYWwuZ2V0ICRtYXNrYykgKGxvY2FsLmdldCAkY3EpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wIChpNjQub3IgKGk2NC5leHRlbmRfaTMyX3UgIChpNjQubHRfdSAobG9jYWwuZ2V0ICRjcSkgKGxvY2FsLmdldCAkbWFza2MpKSkgKGxvY2FsLmdldCAkdGVtcCkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGJxICAgKGk2NC5hZGQgKGxvY2FsLmdldCAkYnEpIChsb2NhbC5nZXQgJHRlbXApKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wIChpNjQuZXh0ZW5kX2kzMl91IChpNjQubHRfdSAobG9jYWwuZ2V0ICRicSkgKGxvY2FsLmdldCAkdGVtcCkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRicSAgIChpNjQuYWRkIChsb2NhbC5nZXQgJG1hc2tiKSAobG9jYWwuZ2V0ICRicSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGFxICAgKGk2NC5hZGQgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuYWRkIChsb2NhbC5nZXQgJGFxKSAoaTY0Lm9yIChpNjQuZXh0ZW5kX2kzMl91IChpNjQubHRfdSAobG9jYWwuZ2V0ICRicSkgKGxvY2FsLmdldCAkbWFza2IpKSkgKGxvY2FsLmdldCAkdGVtcCkpKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yID4+IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGQxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYzEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGExIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYTEpIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgICAgOzsgbWFzayA9IG1hc2sgPj4gMVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2QgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYyAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tiIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2thKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2EgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCAxKSkpXFxuICAgICAgICAoYnIgJGxvb3ApXFxuICAgICAgKVxcbiAgICApXFxuICApOzsgZW5kIG9mIG1haW5cXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICRhcSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkYnEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkgIChsb2NhbC5nZXQgJGNxKSlcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkc3ApIChsb2NhbC5nZXQgJGRxKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJFWFBcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRFWFBcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgOzsgYmFzZVxcbiAgKGxvY2FsICRiYXNlMCBpNjQpXFxuICAobG9jYWwgJGJhc2UxIGk2NClcXG4gIChsb2NhbCAkYmFzZTIgaTY0KVxcbiAgKGxvY2FsICRiYXNlMyBpNjQpXFxuXFxuICA7OyBleHBcXG4gIChsb2NhbCAkZXhwMCBpNjQpXFxuICAobG9jYWwgJGV4cDEgaTY0KVxcbiAgKGxvY2FsICRleHAyIGk2NClcXG4gIChsb2NhbCAkZXhwMyBpNjQpXFxuXFxuICAobG9jYWwgJHIwIGk2NClcXG4gIChsb2NhbCAkcjEgaTY0KVxcbiAgKGxvY2FsICRyMiBpNjQpXFxuICAobG9jYWwgJHIzIGk2NClcXG5cXG4gIChsb2NhbCAkZ2FzQ291bnRlciBpMzIpXFxuICAobG9jYWwuc2V0ICRzcCAoZ2xvYmFsLmdldCAkc3ApKVxcblxcbiAgOzsgbG9hZCBhcmdzIGZyb20gdGhlIHN0YWNrXFxuICAobG9jYWwuc2V0ICRiYXNlMCAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRiYXNlMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRiYXNlMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkpXFxuICAobG9jYWwuc2V0ICRiYXNlMyAoaTY0LmxvYWQgICAgICAgICAgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAobG9jYWwuc2V0ICRleHAwIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGV4cDEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkZXhwMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkpXFxuICAobG9jYWwuc2V0ICRleHAzIChpNjQubG9hZCAgICAgICAgICAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgOzsgbGV0IHJlc3VsdCA9IG5ldyBCTlsxXVxcbiAgKGxvY2FsLnNldCAkcjMgKGk2NC5jb25zdCAxKSlcXG5cXG4gIChibG9jayAkZG9uZVxcbiAgICAobG9vcCAkbG9vcFxcbiAgICAgICA7OyB3aGlsZSBbZXhwID4gMF0ge1xcbiAgICAgIChpZiAoY2FsbCAkaXN6ZXJvXzI1NiAobG9jYWwuZ2V0ICRleHAwKSAobG9jYWwuZ2V0ICRleHAxKSAobG9jYWwuZ2V0ICRleHAyKSAobG9jYWwuZ2V0ICRleHAzKSlcXG4gICAgICAgIChiciAkZG9uZSlcXG4gICAgICApXFxuXFxuICAgICAgOzsgaWZbZXhwLm1vZG5bMl0gPT09IDFdXFxuICAgICAgOzsgaXMgb2RkP1xcbiAgICAgIChpZiAoaTY0LmVxeiAoaTY0LmN0eiAobG9jYWwuZ2V0ICRleHAzKSkpXFxuXFxuICAgICAgICA7OyByZXN1bHQgPSByZXN1bHQubXVsW2Jhc2VdLm1vZFtUV09fUE9XMjU2XVxcbiAgICAgICAgOzsgciA9IHIgKiBhXFxuICAgICAgICAodGhlblxcbiAgICAgICAgICAoY2FsbCAkbXVsXzI1NiAobG9jYWwuZ2V0ICRyMCkgKGxvY2FsLmdldCAkcjEpIChsb2NhbC5nZXQgJHIyKSAobG9jYWwuZ2V0ICRyMykgKGxvY2FsLmdldCAkYmFzZTApIChsb2NhbC5nZXQgJGJhc2UxKSAobG9jYWwuZ2V0ICRiYXNlMikgKGxvY2FsLmdldCAkYmFzZTMpIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpXFxuICAgICAgICAgIChsb2NhbC5zZXQgJHIwIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gICAgICAgICAgKGxvY2FsLnNldCAkcjEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAgICAgICAobG9jYWwuc2V0ICRyMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkpXFxuICAgICAgICAgIChsb2NhbC5zZXQgJHIzIChpNjQubG9hZCAgICAgICAgICAobG9jYWwuZ2V0ICRzcCkpKVxcbiAgICAgICAgKVxcbiAgICAgIClcXG4gICAgICA7OyBleHAgPSBleHAuc2hybiAxXFxuICAgICAgKGxvY2FsLnNldCAkZXhwMyAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGV4cDMpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGV4cDIpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkZXhwMiAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGV4cDIpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGV4cDEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkZXhwMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGV4cDEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGV4cDApIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkZXhwMCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGV4cDApIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgIDs7IGJhc2UgPSBiYXNlLm11bHJbYmFzZXJdLm1vZHJbVFdPX1BPVzI1Nl1cXG4gICAgICAoY2FsbCAkbXVsXzI1NiAobG9jYWwuZ2V0ICRiYXNlMCkgKGxvY2FsLmdldCAkYmFzZTEpIChsb2NhbC5nZXQgJGJhc2UyKSAobG9jYWwuZ2V0ICRiYXNlMykgKGxvY2FsLmdldCAkYmFzZTApIChsb2NhbC5nZXQgJGJhc2UxKSAobG9jYWwuZ2V0ICRiYXNlMikgKGxvY2FsLmdldCAkYmFzZTMpIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpXFxuICAgICAgKGxvY2FsLnNldCAkYmFzZTAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGJhc2UxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gICAgICAobG9jYWwuc2V0ICRiYXNlMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYmFzZTMgKGk2NC5sb2FkICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAgICAgKGxvY2FsLnNldCAkZ2FzQ291bnRlciAoaTMyLmFkZCAobG9jYWwuZ2V0ICRnYXNDb3VudGVyKSAoaTMyLmNvbnN0IDEpKSlcXG4gICAgICAoYnIgJGxvb3ApXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IHVzZSBnYXNcXG4gIDs7IExvZzI1NltFeHBvbmVudF0gKiAxMFxcbiAgKGNhbGwgJHVzZUdhc1xcbiAgICAoaTY0LmV4dGVuZF9pMzJfdVxcbiAgICAgIChpMzIubXVsXFxuICAgICAgICAoaTMyLmNvbnN0IDEwKVxcbiAgICAgICAgKGkzMi5kaXZfdVxcbiAgICAgICAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRnYXNDb3VudGVyKSAoaTMyLmNvbnN0IDcpKVxcbiAgICAgICAgICAoaTMyLmNvbnN0IDgpKSkpKVxcblxcbiAgOzsgZGVjZW1lbnQgdGhlIHN0YWNrIHBvaW50ZXJcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICRyMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkcjEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpIChsb2NhbC5nZXQgJHIyKSlcXG4gIChpNjQuc3RvcmUgICAgICAgICAgKGxvY2FsLmdldCAkc3ApICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRyMykpXFxuKVxcblwiXG4gIH0sXG4gIFwiTU9EXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkTU9EXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIDs7IGRpdmlkZW5kXFxuICAobG9jYWwgJGEgaTY0KVxcbiAgKGxvY2FsICRiIGk2NClcXG4gIChsb2NhbCAkYyBpNjQpXFxuICAobG9jYWwgJGQgaTY0KVxcblxcbiAgOzsgZGl2aXNvclxcbiAgKGxvY2FsICRhMSBpNjQpXFxuICAobG9jYWwgJGIxIGk2NClcXG4gIChsb2NhbCAkYzEgaTY0KVxcbiAgKGxvY2FsICRkMSBpNjQpXFxuXFxuICA7OyBxdW90aWVudFxcbiAgKGxvY2FsICRhcSBpNjQpXFxuICAobG9jYWwgJGJxIGk2NClcXG4gIChsb2NhbCAkY3EgaTY0KVxcbiAgKGxvY2FsICRkcSBpNjQpXFxuXFxuICA7OyBtYXNrXFxuICAobG9jYWwgJG1hc2thIGk2NClcXG4gIChsb2NhbCAkbWFza2IgaTY0KVxcbiAgKGxvY2FsICRtYXNrYyBpNjQpXFxuICAobG9jYWwgJG1hc2tkIGk2NClcXG4gIChsb2NhbCAkY2FycnkgaTMyKVxcbiAgKGxvY2FsICR0ZW1wIGk2NClcXG5cXG4gIChsb2NhbC5zZXQgJG1hc2tkIChpNjQuY29uc3QgMSkpXFxuXFxuICA7OyBsb2FkIGFyZ3MgZnJvbSB0aGUgc3RhY2tcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGIgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGQgKGk2NC5sb2FkICAgICAgICAgIChnbG9iYWwuZ2V0ICRzcCkpKVxcbiAgOzsgZGVjZW1lbnQgdGhlIHN0YWNrIHBvaW50ZXJcXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgKGxvY2FsLnNldCAkYTEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYjEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYzEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkZDEgKGk2NC5sb2FkICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuXFxuICAoYmxvY2sgJG1haW5cXG4gICAgOzsgY2hlY2sgZGl2IGJ5IDBcXG4gICAgKGlmIChjYWxsICRpc3plcm9fMjU2IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSlcXG4gICAgICAodGhlblxcbiAgICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYiAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYyAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGJyICRtYWluKVxcbiAgICAgIClcXG4gICAgKVxcblxcbiAgICA7OyBhbGlnbiBiaXRzXFxuICAgIChibG9jayAkZG9uZVxcbiAgICAgICAgKGxvb3AgJGxvb3BcXG4gICAgICAgIDs7IGFsaWduIGJpdHM7XFxuICAgICAgICAoaWYgKGkzMi5vciAoaTY0LmVxeiAoaTY0LmNseiAobG9jYWwuZ2V0ICRhMSkpKSAoY2FsbCAkZ3RlXzI1NiAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkZCkpKVxcbiAgICAgICAgICAoYnIgJGRvbmUpXFxuICAgICAgICApXFxuXFxuICAgICAgICA7OyBkaXZpc29yID0gZGl2aXNvciA8PCAxXFxuICAgICAgICAobG9jYWwuc2V0ICRhMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGIxIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYzEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRkMSAoaTY0LnNobCAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICA7OyBtYXNrID0gbWFzayA8PCAxXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tiIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2MgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICAoYnIgJGxvb3ApXFxuICAgICAgKVxcbiAgICApXFxuXFxuICAgIChibG9jayAkZG9uZVxcbiAgICAgIChsb29wICRsb29wXFxuICAgICAgICA7OyBsb29wIHdoaWxlIG1hc2sgIT0gMFxcbiAgICAgICAgKGlmIChjYWxsICRpc3plcm9fMjU2IChsb2NhbC5nZXQgJG1hc2thKSAobG9jYWwuZ2V0ICRtYXNrYikgKGxvY2FsLmdldCAkbWFza2MpIChsb2NhbC5nZXQgJG1hc2tkKSlcXG4gICAgICAgICAgKGJyICRkb25lKVxcbiAgICAgICAgKVxcbiAgICAgICAgOzsgaWYgZGl2aWRlbmQgPj0gZGl2aXNvclxcbiAgICAgICAgKGlmIChjYWxsICRndGVfMjU2IChsb2NhbC5nZXQgJGEpIChsb2NhbC5nZXQgJGIpIChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJGQpIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSlcXG4gICAgICAgICAgKHRoZW5cXG4gICAgICAgICAgICA7OyBkaXZpZGVuZCA9IGRpdmlkZW5kIC0gZGl2aXNvclxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQubHRfdSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRkMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGQgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRkMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRjKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYykpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGMgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRjMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkdGVtcCkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGIpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkYiAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGIxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5vciAgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICR0ZW1wKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRhICAgICAoaTY0LnN1YiAgKGk2NC5zdWIgKGxvY2FsLmdldCAkYSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkgKGxvY2FsLmdldCAkYTEpKSlcXG4gICAgICAgICAgKVxcbiAgICAgICAgKVxcbiAgICAgICAgOzsgZGl2aXNvciA9IGRpdmlzb3IgPj4gMVxcbiAgICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGIxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGExKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICA7OyBtYXNrID0gbWFzayA+PiAxXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZCAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tkKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYykgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tjIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2IgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2thKSAoaTY0LmNvbnN0IDEpKSlcXG4gICAgICAgIChiciAkbG9vcClcXG4gICAgICApXFxuICAgIClcXG4gICk7OyBlbmQgb2YgbWFpblxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChsb2NhbC5nZXQgJGEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChsb2NhbC5nZXQgJGIpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpIChsb2NhbC5nZXQgJGMpKVxcbiAgKGk2NC5zdG9yZSAgICAgICAgICAobG9jYWwuZ2V0ICRzcCkgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGQpKVxcbilcXG5cIlxuICB9LFxuICBcIk1TSVpFXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkTVNJWkVcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgOzsgdGhlcmUncyBubyBpbnB1dCBpdGVtIGZvciB1cyB0byBvdmVyd3JpdGVcXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAwKSkgXFxuICAgICAgICAgICAgIChpNjQubXVsIChnbG9iYWwuZ2V0ICR3b3JkQ291bnQpIChpNjQuY29uc3QgMzIpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGk2NC5jb25zdCAwKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAoaTY0LmNvbnN0IDApKVxcbilcXG5cIlxuICB9LFxuICBcIk1TVE9SRThcIjoge1xuICAgIFwid2FzdFwiOiBcIjs7IHN0YWNrOlxcbjs7ICAwOiBvZmZzZXRcXG47OyAtMTogd29yZFxcbihmdW5jICRNU1RPUkU4XFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIChsb2NhbCAkb2Zmc2V0IGkzMilcXG5cXG4gIChsb2NhbCAkb2Zmc2V0MCBpNjQpXFxuICAobG9jYWwgJG9mZnNldDEgaTY0KVxcbiAgKGxvY2FsICRvZmZzZXQyIGk2NClcXG4gIChsb2NhbCAkb2Zmc2V0MyBpNjQpXFxuXFxuICA7OyBsb2FkIGFyZ3MgZnJvbSB0aGUgc3RhY2tcXG4gIChsb2NhbC5zZXQgJG9mZnNldDAgKGk2NC5sb2FkICAgICAgICAgIChnbG9iYWwuZ2V0ICRzcCkpKVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0MSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRvZmZzZXQyIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRvZmZzZXQzIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuXFxuICAobG9jYWwuc2V0ICRvZmZzZXQgXFxuICAgICAgICAgICAgIChjYWxsICRjaGVja19vdmVyZmxvdyAobG9jYWwuZ2V0ICRvZmZzZXQwKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkb2Zmc2V0MSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJG9mZnNldDIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRvZmZzZXQzKSkpXFxuXFxuICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJG9mZnNldCkgKGkzMi5jb25zdCAxKSlcXG5cXG4gIDs7IHBvcCBzdGFja1xcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuICAobG9jYWwuc2V0ICRvZmZzZXQgKGkzMi5hZGQgKGxvY2FsLmdldCAkb2Zmc2V0KSAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpKSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJG9mZnNldCkgKGkzMi5jb25zdCAwKSkgKGkzMi5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiTVVMXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkTVVMXFxuICAoY2FsbCAkbXVsXzI1NlxcbiAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKVxcbiAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKVxcbiAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKVxcbiAgICAgICAgKGk2NC5sb2FkICAgICAgICAgIChnbG9iYWwuZ2V0ICRzcCkpXFxuICAgICAgICAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpXFxuICAgICAgICAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpXFxuICAgICAgICAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpXFxuICAgICAgICAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuICAgICAgICAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpXFxuICApXFxuKVxcblwiXG4gIH0sXG4gIFwiTVVMTU9EXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkTVVMTU9EXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIChsb2NhbCAkYSBpNjQpXFxuICAobG9jYWwgJGMgaTY0KVxcbiAgKGxvY2FsICRlIGk2NClcXG4gIChsb2NhbCAkZyBpNjQpXFxuICAobG9jYWwgJGkgaTY0KVxcbiAgKGxvY2FsICRrIGk2NClcXG4gIChsb2NhbCAkbSBpNjQpXFxuICAobG9jYWwgJG8gaTY0KVxcbiAgKGxvY2FsICRiIGk2NClcXG4gIChsb2NhbCAkZCBpNjQpXFxuICAobG9jYWwgJGYgaTY0KVxcbiAgKGxvY2FsICRoIGk2NClcXG4gIChsb2NhbCAkaiBpNjQpXFxuICAobG9jYWwgJGwgaTY0KVxcbiAgKGxvY2FsICRuIGk2NClcXG4gIChsb2NhbCAkcCBpNjQpXFxuICAobG9jYWwgJHRlbXA3IGk2NClcXG4gIChsb2NhbCAkdGVtcDYgaTY0KVxcbiAgKGxvY2FsICR0ZW1wNSBpNjQpXFxuICAobG9jYWwgJHRlbXA0IGk2NClcXG4gIChsb2NhbCAkdGVtcDMgaTY0KVxcbiAgKGxvY2FsICR0ZW1wMiBpNjQpXFxuICAobG9jYWwgJHRlbXAxIGk2NClcXG4gIChsb2NhbCAkdGVtcDAgaTY0KVxcbiAgKGxvY2FsICRyb3dDYXJyeSBpNjQpXFxuXFxuICAobG9jYWwgJG1vZGEgaTY0KVxcbiAgKGxvY2FsICRtb2RiIGk2NClcXG4gIChsb2NhbCAkbW9kYyBpNjQpXFxuICAobG9jYWwgJG1vZGQgaTY0KVxcblxcbiAgOzsgcG9wIHR3byBpdGVtcyBvZiB0aGUgc3RhY2tcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGUgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGcgKGk2NC5sb2FkICAgICAgICAgIChnbG9iYWwuZ2V0ICRzcCkpKVxcbiAgKGxvY2FsLnNldCAkaSAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkayAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkbSAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkbyAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpKVxcblxcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDY0KSkpXFxuXFxuICA7OyBNVUxcXG4gIDs7ICBhIGIgYyBkIGUgZiBnIGhcXG4gIDs7KiBpIGogayBsIG0gbiBvIHBcXG4gIDs7LS0tLS0tLS0tLS0tLS0tLVxcblxcbiAgOzsgc3BsaXQgdGhlIG9wc1xcbiAgKGxvY2FsLnNldCAkYiAoaTY0LmFuZCAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IDMyKSkpIFxcblxcbiAgKGxvY2FsLnNldCAkZCAoaTY0LmFuZCAobG9jYWwuZ2V0ICRjKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjKSAoaTY0LmNvbnN0IDMyKSkpIFxcblxcbiAgKGxvY2FsLnNldCAkZiAoaTY0LmFuZCAobG9jYWwuZ2V0ICRlKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJGUgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRlKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICAobG9jYWwuc2V0ICRoIChpNjQuYW5kIChsb2NhbC5nZXQgJGcpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKVxcbiAgKGxvY2FsLnNldCAkZyAoaTY0LnNocl91IChsb2NhbC5nZXQgJGcpIChpNjQuY29uc3QgMzIpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGogKGk2NC5hbmQgKGxvY2FsLmdldCAkaSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpXFxuICAobG9jYWwuc2V0ICRpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaSkgKGk2NC5jb25zdCAzMikpKSBcXG5cXG4gIChsb2NhbC5zZXQgJGwgKGk2NC5hbmQgKGxvY2FsLmdldCAkaykgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpXFxuICAobG9jYWwuc2V0ICRrIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaykgKGk2NC5jb25zdCAzMikpKSBcXG5cXG4gIChsb2NhbC5zZXQgJG4gKGk2NC5hbmQgKGxvY2FsLmdldCAkbSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpXFxuICAobG9jYWwuc2V0ICRtIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbSkgKGk2NC5jb25zdCAzMikpKVxcblxcbiAgKGxvY2FsLnNldCAkcCAoaTY0LmFuZCAobG9jYWwuZ2V0ICRvKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJG8gKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRvKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICAgOzsgZmlyc3Qgcm93IG11bHRpcGxpY2F0aW9uIFxcbiAgOzsgcCAqIGhcXG4gIChsb2NhbC5zZXQgJHRlbXAwIChpNjQubXVsIChsb2NhbC5nZXQgJHApIChsb2NhbC5nZXQgJGgpKSlcXG4gIDs7IHAgKiBnICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXAxIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJHApIChsb2NhbC5nZXQgJGcpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAwKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgcCAqIGYgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDIgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkZikpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDEpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBwICogZSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wMyAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRwKSAobG9jYWwuZ2V0ICRlKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wMikgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IHAgKiBkICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA0IChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJHApIChsb2NhbC5nZXQgJGQpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAzKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgcCAqIGMgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDUgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkYykpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBwICogYiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRwKSAobG9jYWwuZ2V0ICRiKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNSkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IHAgKiBhICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA3IChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJHApIChsb2NhbC5nZXQgJGEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA2KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgKGxvY2FsLnNldCAkcm93Q2FycnkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNykgKGk2NC5jb25zdCAzMikpKVxcblxcbiAgOzsgc2Vjb25kIHJvd1xcbiAgOzsgbyAqIGggKyAkdGVtcDEgXFxuICAobG9jYWwuc2V0ICR0ZW1wMSAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRoKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDEpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIDs7IG8gKiBnICsgJHRlbXAyICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXAyIChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG8pIChsb2NhbC5nZXQgJGcpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDEpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBvICogZiArICR0ZW1wMyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wMyAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRmKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAyKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbyAqIGUgKyAkdGVtcDQgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDQgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbykgKGxvY2FsLmdldCAkZSkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA0KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wMykgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG8gKiBkICsgJHRlbXA1ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA1IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG8pIChsb2NhbC5nZXQgJGQpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBvICogYyArICR0ZW1wNiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRjKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbyAqIGIgKyAkdGVtcDcgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDcgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbykgKGxvY2FsLmdldCAkYikpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG8gKiBhICsgY2FycnkgKyByb3dDYXJyeVxcbiAgKGxvY2FsLnNldCAkcCAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRhKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNykgKGk2NC5jb25zdCAzMikpKSAobG9jYWwuZ2V0ICRyb3dDYXJyeSkpKVxcbiAgKGxvY2FsLnNldCAkcm93Q2FycnkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRwKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICA7OyB0aGlyZCByb3cgLSBuXFxuICA7OyBuICogaCArICR0ZW1wMiBcXG4gIChsb2NhbC5zZXQgJHRlbXAyIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgOzsgbiAqIGcgKyAkdGVtcDMgIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wMyAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRuKSAobG9jYWwuZ2V0ICRnKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAyKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbiAqIGYgKyAkdGVtcDQpICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA0IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGYpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBuICogZSArICR0ZW1wNSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNSAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRuKSAobG9jYWwuZ2V0ICRlKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA0KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbiAqIGQgKyAkdGVtcDYgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDYgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbikgKGxvY2FsLmdldCAkZCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA2KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNSkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG4gKiBjICsgJHRlbXA3ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA3IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGMpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNykgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBuICogYiArICRwICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHAgICAgIChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGIpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICRwKSAgICAgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDcpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBuICogYSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRvIChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHApIChpNjQuY29uc3QgMzIpKSkgKGxvY2FsLmdldCAkcm93Q2FycnkpKSlcXG4gIChsb2NhbC5zZXQgJHJvd0NhcnJ5IChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbykgKGk2NC5jb25zdCAzMikpKVxcblxcbiAgOzsgZm9ydGggcm93IFxcbiAgOzsgbSAqIGggKyAkdGVtcDNcXG4gIChsb2NhbC5zZXQgJHRlbXAzIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG0pIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMykgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgOzsgbSAqIGcgKyAkdGVtcDQgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDQgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkZykpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA0KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wMykgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG0gKiBmICsgJHRlbXA1ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA1IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG0pIChsb2NhbC5nZXQgJGYpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBtICogZSArICR0ZW1wNiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRtKSAobG9jYWwuZ2V0ICRlKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbSAqIGQgKyAkdGVtcDcgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDcgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkZCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG0gKiBjICsgJHAgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkcCAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkYykpIChpNjQuYW5kIChsb2NhbC5nZXQgJHApICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNykgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG0gKiBiICsgJG8gKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkbyAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkYikpIChpNjQuYW5kIChsb2NhbC5nZXQgJG8pICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRwKSAgICAgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG0gKiBhICsgY2FycnkgKyByb3dDYXJyeVxcbiAgKGxvY2FsLnNldCAkbiAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkYSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbykgKGk2NC5jb25zdCAzMikpKSAobG9jYWwuZ2V0ICRyb3dDYXJyeSkpKVxcbiAgKGxvY2FsLnNldCAkcm93Q2FycnkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRuKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICA7OyBmaXRoIHJvd1xcbiAgOzsgbCAqIGggKyAkdGVtcDRcXG4gIChsb2NhbC5zZXQgJHRlbXA0IChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGwpIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgOzsgbCAqIGcgKyAkdGVtcDUgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDUgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbCkgKGxvY2FsLmdldCAkZykpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGwgKiBmICsgJHRlbXA2ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA2IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGwpIChsb2NhbC5nZXQgJGYpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBsICogZSArICR0ZW1wNyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNyAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRlKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDcpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA2KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbCAqIGQgKyAkcCArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRwICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRkKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkcCkgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbCAqIGMgKyAkbyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRvICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRjKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbykgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHApICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbCAqIGIgKyAkbiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRuICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRiKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbikgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG8pICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbCAqIGEgKyBjYXJyeSArIHJvd0NhcnJ5XFxuICAobG9jYWwuc2V0ICRtICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRhKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRuKSAoaTY0LmNvbnN0IDMyKSkpIChsb2NhbC5nZXQgJHJvd0NhcnJ5KSkpXFxuICAobG9jYWwuc2V0ICRyb3dDYXJyeSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG0pIChpNjQuY29uc3QgMzIpKSlcXG5cXG4gIDs7IHNpeHRoIHJvdyBcXG4gIDs7IGsgKiBoICsgJHRlbXA1XFxuICAobG9jYWwuc2V0ICR0ZW1wNSAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRoKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIDs7IGsgKiBnICsgJHRlbXA2ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA2IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGspIChsb2NhbC5nZXQgJGcpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBrICogZiArICR0ZW1wNyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNyAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRmKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDcpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA2KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgayAqIGUgKyAkcCArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRwICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRlKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkcCkgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgayAqIGQgKyAkbyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRvICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRkKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbykgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHApICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgayAqIGMgKyAkbiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRuICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRjKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbikgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG8pICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgayAqIGIgKyAkbSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRtICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRiKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbSkgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG4pICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgayAqIGEgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkbCAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaykgKGxvY2FsLmdldCAkYSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbSkgKGk2NC5jb25zdCAzMikpKSAobG9jYWwuZ2V0ICRyb3dDYXJyeSkpKVxcbiAgKGxvY2FsLnNldCAkcm93Q2FycnkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRsKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICA7OyBzZXZlbnRoIHJvd1xcbiAgOzsgaiAqIGggKyAkdGVtcDZcXG4gIChsb2NhbC5zZXQgJHRlbXA2IChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGopIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgOzsgaiAqIGcgKyAkdGVtcDcgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDcgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaikgKGxvY2FsLmdldCAkZykpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGogKiBmICsgJHAgK2NhcnJ5XFxuICAobG9jYWwuc2V0ICRwICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRmKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkcCkgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgaiAqIGUgKyAkbyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRvICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRlKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbykgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHApICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgaiAqIGQgKyAkbiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRuICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRkKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbikgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG8pICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgaiAqIGMgKyAkbSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRtICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRjKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbSkgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG4pICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgaiAqIGIgKyAkbCArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRsICAgICAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRiKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbCkgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG0pICAgICAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgaiAqIGEgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkayAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaikgKGxvY2FsLmdldCAkYSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbCkgKGk2NC5jb25zdCAzMikpKSAobG9jYWwuZ2V0ICRyb3dDYXJyeSkpKVxcbiAgKGxvY2FsLnNldCAkcm93Q2FycnkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRrKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICA7OyBlaWd0aCByb3dcXG4gIDs7IGkgKiBoICsgJHRlbXA3IFxcbiAgKGxvY2FsLnNldCAkdGVtcDcgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkaCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA3KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkpXFxuICA7OyBpICogZyArICRwIFxcbiAgKGxvY2FsLnNldCAkcCAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkZykpIChpNjQuYW5kIChsb2NhbC5nZXQgJHApICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNykgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGkgKiBmICsgJG8gKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkbyAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkZikpIChpNjQuYW5kIChsb2NhbC5nZXQgJG8pICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRwKSAgICAgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGkgKiBlICsgJG4gKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkbiAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkZSkpIChpNjQuYW5kIChsb2NhbC5nZXQgJG4pICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRvKSAgICAgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGkgKiBkICsgJG0gKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkbSAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkZCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJG0pICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRuKSAgICAgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGkgKiBjICsgJGwgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkbCAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkYykpIChpNjQuYW5kIChsb2NhbC5nZXQgJGwpICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtKSAgICAgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGkgKiBiICsgJGsgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkayAgICAgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkYikpIChpNjQuYW5kIChsb2NhbC5nZXQgJGspICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRsKSAgICAgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IGkgKiBhICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJGogICAgIChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGkpIChsb2NhbC5nZXQgJGEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGspIChpNjQuY29uc3QgMzIpKSkgKGxvY2FsLmdldCAkcm93Q2FycnkpKSlcXG5cXG4gIDs7IGNvbWJpbmUgdGVybXNcXG4gIChsb2NhbC5zZXQgJGEgKGxvY2FsLmdldCAkaikpXFxuICAobG9jYWwuc2V0ICRiIChpNjQub3IgKGk2NC5zaGwgKGxvY2FsLmdldCAkaykgICAgIChpNjQuY29uc3QgMzIpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICRsKSAgICAgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgKGxvY2FsLnNldCAkYyAoaTY0Lm9yIChpNjQuc2hsIChsb2NhbC5nZXQgJG0pICAgICAoaTY0LmNvbnN0IDMyKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkbikgICAgIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIChsb2NhbC5zZXQgJGQgKGk2NC5vciAoaTY0LnNobCAobG9jYWwuZ2V0ICRvKSAgICAgKGk2NC5jb25zdCAzMikpIChpNjQuYW5kIChsb2NhbC5nZXQgJHApICAgICAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkpXFxuICAobG9jYWwuc2V0ICRlIChpNjQub3IgKGk2NC5zaGwgKGxvY2FsLmdldCAkdGVtcDcpIChpNjQuY29uc3QgMzIpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgKGxvY2FsLnNldCAkZiAoaTY0Lm9yIChpNjQuc2hsIChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIChsb2NhbC5zZXQgJGcgKGk2NC5vciAoaTY0LnNobCAobG9jYWwuZ2V0ICR0ZW1wMykgKGk2NC5jb25zdCAzMikpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXAyKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkpXFxuICAobG9jYWwuc2V0ICRoIChpNjQub3IgKGk2NC5zaGwgKGxvY2FsLmdldCAkdGVtcDEpIChpNjQuY29uc3QgMzIpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMCkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcblxcbiAgOzsgcG9wIHRoZSBNT0QgYXJnbXVuZXQgb2ZmIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkbW9kYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRtb2RiIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJG1vZGMgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkbW9kZCAoaTY0LmxvYWQgICAgICAgICAgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIChjYWxsICRtb2RfNTEyXFxuICAgICAgICAgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkZSkgKGxvY2FsLmdldCAkZikgKGxvY2FsLmdldCAkZykgKGxvY2FsLmdldCAkaCkgXFxuICAgICAgICAgKGk2NC5jb25zdCAwKSAgKGk2NC5jb25zdCAwKSAoaTY0LmNvbnN0IDApICAoaTY0LmNvbnN0IDApICAobG9jYWwuZ2V0ICRtb2RhKSAobG9jYWwuZ2V0ICRtb2RiKSAobG9jYWwuZ2V0ICRtb2RjKSAobG9jYWwuZ2V0ICRtb2RkKSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpXFxuICApXFxuKVxcblwiXG4gIH0sXG4gIFwiTk9UXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkTk9UXFxuICA7OyBGSVhNRTogY29uc2lkZXIgdXNpbmcgMHhmZmZmZmZmZmZmZmZmZmZmIGluc3RlYWQgb2YgLTE/XFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQueG9yIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkgKGk2NC5jb25zdCAtMSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAoaTY0LnhvciAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpIChpNjQuY29uc3QgLTEpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGk2NC54b3IgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgMCkpIChpNjQueG9yIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDApKSkgKGk2NC5jb25zdCAtMSkpKVxcbilcXG5cIlxuICB9LFxuICBcIk9SXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkT1JcXG4gIChpNjQuc3RvcmUgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGk2NC5vciAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAoaTY0Lm9yIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQub3IgKGk2NC5sb2FkIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkgKGk2NC5vciAoaTY0LmxvYWQgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpIChpNjQubG9hZCAgICAgICAgICAoZ2xvYmFsLmdldCAkc3ApKSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiUENcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRQQ1xcbiAgKHBhcmFtICRwYyBpMzIpXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIDs7IGFkZCBvbmUgdG8gdGhlIHN0YWNrXFxuICAobG9jYWwuc2V0ICRzcCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSlcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkc3ApIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJHBjKSkpXFxuXFxuICA7OyB6ZXJvIG91dCByZXN0IG9mIHN0YWNrXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5jb25zdCAwKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJTQVJcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRTQVJcXG4gICAgKGxvY2FsICRzcCBpMzIpXFxuICAgIChsb2NhbCAkeDEgaTY0KVxcbiAgICAobG9jYWwgJHgyIGk2NClcXG4gICAgKGxvY2FsICR4MyBpNjQpXFxuICAgIChsb2NhbCAkeDQgaTY0KVxcbiAgICAobG9jYWwgJHkxIGk2NClcXG4gICAgKGxvY2FsICR5MiBpNjQpXFxuICAgIChsb2NhbCAkeTMgaTY0KVxcbiAgICAobG9jYWwgJHk0IGk2NClcXG5cXG4gICAgKGxvY2FsICR6MSBpNjQpXFxuICAgIChsb2NhbCAkejIgaTY0KVxcbiAgICAobG9jYWwgJHozIGk2NClcXG4gICAgKGxvY2FsICR6NCBpNjQpXFxuXFxuICAgIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgICAobG9jYWwuc2V0ICR4MSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4MiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAgIChsb2NhbC5zZXQgJHg0IChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKSlcXG5cXG4gICAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAgIChsb2NhbC5zZXQgJHkxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeTIgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgICAobG9jYWwuc2V0ICR5MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeTQgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAgIChibG9jayAkbGFiZWxfc2FyX2ludGVybmFsXFxuICAgICAgICAoaWYgKGk2NC5ndF91IChpNjQuY2x6IChsb2NhbC5nZXQgJHkxKSkgKGk2NC5jb25zdCAwKSkgKHRoZW5cXG4gICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejEgKGNhbGwgJHNocl8gKGxvY2FsLmdldCAkeDEpIChsb2NhbC5nZXQgJHgyKSAobG9jYWwuZ2V0ICR4MykgKGxvY2FsLmdldCAkeDQpIChsb2NhbC5nZXQgJHkxKSAobG9jYWwuZ2V0ICR5MikgKGxvY2FsLmdldCAkeTMpIChsb2NhbC5nZXQgJHk0KSkpXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHoyIChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG4gICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejMgKGdsb2JhbC5nZXQgJGdsb2JhbF9fMSkpXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHo0IChnbG9iYWwuZ2V0ICRnbG9iYWxfXzIpKVxcblxcbiAgICAgICAgICAgIClcXG4gICAgICAgICAgICAoYnIgJGxhYmVsX3Nhcl9pbnRlcm5hbClcXG4gICAgICAgICkpXFxuICAgICAgICAoaWYgKGNhbGwgJGd0ZV8yNTZ4MjU2XzY0IChsb2NhbC5nZXQgJHgxKSAobG9jYWwuZ2V0ICR4MikgKGxvY2FsLmdldCAkeDMpIChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDApIChpNjQuY29uc3QgMCkgKGk2NC5jb25zdCAwKSAoaTY0LmNvbnN0IDI1NikpICh0aGVuXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkejEgKGk2NC5jb25zdCAxODQ0Njc0NDA3MzcwOTU1MTYxNSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGk2NC5jb25zdCAxODQ0Njc0NDA3MzcwOTU1MTYxNSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkejMgKGk2NC5jb25zdCAxODQ0Njc0NDA3MzcwOTU1MTYxNSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkejQgKGk2NC5jb25zdCAxODQ0Njc0NDA3MzcwOTU1MTYxNSkpXFxuICAgICAgICApKVxcbiAgICAgICAgKGlmIChjYWxsICRsdF8yNTZ4MjU2XzY0IChsb2NhbC5nZXQgJHgxKSAobG9jYWwuZ2V0ICR4MikgKGxvY2FsLmdldCAkeDMpIChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDApIChpNjQuY29uc3QgMCkgKGk2NC5jb25zdCAwKSAoaTY0LmNvbnN0IDI1NikpICh0aGVuXFxuICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkxIChjYWxsICRzaHJfIChpNjQuY29uc3QgMCkgKGk2NC5jb25zdCAwKSAoaTY0LmNvbnN0IDApIChsb2NhbC5nZXQgJHg0KSAobG9jYWwuZ2V0ICR5MSkgKGxvY2FsLmdldCAkeTIpIChsb2NhbC5nZXQgJHkzKSAobG9jYWwuZ2V0ICR5NCkpKVxcbiAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MiAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkzIChnbG9iYWwuZ2V0ICRnbG9iYWxfXzEpKVxcbiAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5NCAoZ2xvYmFsLmdldCAkZ2xvYmFsX18yKSlcXG5cXG4gICAgICAgICAgICApXFxuICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHoxIChjYWxsICRzaGxfIChpNjQuY29uc3QgMCkgKGk2NC5jb25zdCAwKSAoaTY0LmNvbnN0IDApIChpNjQuc3ViIChpNjQuY29uc3QgMjU2KSAobG9jYWwuZ2V0ICR4NCkpIChpNjQuY29uc3QgMTg0NDY3NDQwNzM3MDk1NTE2MTUpIChpNjQuY29uc3QgMTg0NDY3NDQwNzM3MDk1NTE2MTUpIChpNjQuY29uc3QgMTg0NDY3NDQwNzM3MDk1NTE2MTUpIChpNjQuY29uc3QgMTg0NDY3NDQwNzM3MDk1NTE2MTUpKSlcXG4gICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGdsb2JhbC5nZXQgJGdsb2JhbF8pKVxcbiAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MyAoZ2xvYmFsLmdldCAkZ2xvYmFsX18xKSlcXG4gICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejQgKGdsb2JhbC5nZXQgJGdsb2JhbF9fMikpXFxuXFxuICAgICAgICAgICAgKVxcbiAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MSAoY2FsbCAkb3JfIChsb2NhbC5nZXQgJHkxKSAobG9jYWwuZ2V0ICR5MikgKGxvY2FsLmdldCAkeTMpIChsb2NhbC5nZXQgJHk0KSAobG9jYWwuZ2V0ICR6MSkgKGxvY2FsLmdldCAkejIpIChsb2NhbC5nZXQgJHozKSAobG9jYWwuZ2V0ICR6NCkpKVxcbiAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MiAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHozIChnbG9iYWwuZ2V0ICRnbG9iYWxfXzEpKVxcbiAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6NCAoZ2xvYmFsLmdldCAkZ2xvYmFsX18yKSlcXG5cXG4gICAgICAgICAgICApXFxuICAgICAgICApKVxcblxcbiAgICApXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICR6MSkpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAobG9jYWwuZ2V0ICR6MikpXFxuICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAobG9jYWwuZ2V0ICR6MykpXFxuICAgIChpNjQuc3RvcmUgICAgICAgICAgKGxvY2FsLmdldCAkc3ApICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICR6NCkpXFxuKVxcblxcbihmdW5jICRsdF8yNTZ4MjU2XzY0XFxuICAgIChwYXJhbSAkeDEgaTY0KVxcbiAgICAocGFyYW0gJHgyIGk2NClcXG4gICAgKHBhcmFtICR4MyBpNjQpXFxuICAgIChwYXJhbSAkeDQgaTY0KVxcbiAgICAocGFyYW0gJHkxIGk2NClcXG4gICAgKHBhcmFtICR5MiBpNjQpXFxuICAgIChwYXJhbSAkeTMgaTY0KVxcbiAgICAocGFyYW0gJHk0IGk2NClcXG4gICAgKHJlc3VsdCBpMzIpXFxuICAgIChsb2NhbCAkeiBpMzIpXFxuICAgIChsb2NhbCAkY29uZGl0aW9uXzEwNiBpMzIpXFxuICAgIChsb2NhbCAkY29uZGl0aW9uXzEwNyBpMzIpXFxuICAgIChsb2NhbCAkY29uZGl0aW9uXzEwOCBpMzIpXFxuICAgIChibG9ja1xcbiAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY29uZGl0aW9uXzEwNiAoY2FsbCAkY21wIChsb2NhbC5nZXQgJHgxKSAobG9jYWwuZ2V0ICR5MSkpKVxcbiAgICAgICAgICAgIChpZiAoaTMyLmVxIChsb2NhbC5nZXQgJGNvbmRpdGlvbl8xMDYpIChpMzIuY29uc3QgMCkpICh0aGVuXFxuICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkY29uZGl0aW9uXzEwNyAoY2FsbCAkY21wIChsb2NhbC5nZXQgJHgyKSAobG9jYWwuZ2V0ICR5MikpKVxcbiAgICAgICAgICAgICAgICAgICAgKGlmIChpMzIuZXEgKGxvY2FsLmdldCAkY29uZGl0aW9uXzEwNykgKGkzMi5jb25zdCAwKSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkY29uZGl0aW9uXzEwOCAoY2FsbCAkY21wIChsb2NhbC5nZXQgJHgzKSAobG9jYWwuZ2V0ICR5MykpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaWYgKGkzMi5lcSAobG9jYWwuZ2V0ICRjb25kaXRpb25fMTA4KSAoaTMyLmNvbnN0IDApKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeiAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkeDQpIChsb2NhbC5nZXQgJHk0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkoZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpMzIuZXEgKGxvY2FsLmdldCAkY29uZGl0aW9uXzEwOCkgKGkzMi5jb25zdCAxKSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6IChpMzIuY29uc3QgMCkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6IChpMzIuY29uc3QgMSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgICkoZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpZiAoaTMyLmVxIChsb2NhbC5nZXQgJGNvbmRpdGlvbl8xMDcpIChpMzIuY29uc3QgMSkpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHogKGkzMi5jb25zdCAwKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICApKGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeiAoaTMyLmNvbnN0IDEpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXFxuICAgICAgICAgICAgICAgICAgICApKVxcblxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgKShlbHNlXFxuICAgICAgICAgICAgICAgIChpZiAoaTMyLmVxIChsb2NhbC5nZXQgJGNvbmRpdGlvbl8xMDYpIChpMzIuY29uc3QgMSkpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6IChpMzIuY29uc3QgMCkpXFxuICAgICAgICAgICAgICAgICkoZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeiAoaTMyLmNvbnN0IDEpKVxcbiAgICAgICAgICAgICAgICApKVxcbiAgICAgICAgICAgICkpXFxuXFxuICAgICAgICApXFxuXFxuICAgIClcXG4gICAgKGxvY2FsLmdldCAkeilcXG4pXFxuXFxuKGZ1bmMgJGd0ZV8yNTZ4MjU2XzY0XFxuICAgIChwYXJhbSAkeDEgaTY0KVxcbiAgICAocGFyYW0gJHgyIGk2NClcXG4gICAgKHBhcmFtICR4MyBpNjQpXFxuICAgIChwYXJhbSAkeDQgaTY0KVxcbiAgICAocGFyYW0gJHkxIGk2NClcXG4gICAgKHBhcmFtICR5MiBpNjQpXFxuICAgIChwYXJhbSAkeTMgaTY0KVxcbiAgICAocGFyYW0gJHk0IGk2NClcXG4gICAgKHJlc3VsdCBpMzIpXFxuICAgIChsb2NhbCAkeiBpMzIpXFxuICAgIChibG9ja1xcbiAgICAgICAgKGxvY2FsLnNldCAkeiAoaTMyLmVxeiAoY2FsbCAkbHRfMjU2eDI1Nl82NCAobG9jYWwuZ2V0ICR4MSkgKGxvY2FsLmdldCAkeDIpIChsb2NhbC5nZXQgJHgzKSAobG9jYWwuZ2V0ICR4NCkgKGxvY2FsLmdldCAkeTEpIChsb2NhbC5nZXQgJHkyKSAobG9jYWwuZ2V0ICR5MykgKGxvY2FsLmdldCAkeTQpKSkpXFxuXFxuICAgIClcXG4gICAgKGxvY2FsLmdldCAkeilcXG4pXFxuXFxuXFxuKGZ1bmMgJG9yX1xcbiAgICAocGFyYW0gJHgxIGk2NClcXG4gICAgKHBhcmFtICR4MiBpNjQpXFxuICAgIChwYXJhbSAkeDMgaTY0KVxcbiAgICAocGFyYW0gJHg0IGk2NClcXG4gICAgKHBhcmFtICR5MSBpNjQpXFxuICAgIChwYXJhbSAkeTIgaTY0KVxcbiAgICAocGFyYW0gJHkzIGk2NClcXG4gICAgKHBhcmFtICR5NCBpNjQpXFxuICAgIChyZXN1bHQgaTY0KVxcbiAgICAobG9jYWwgJHIxIGk2NClcXG4gICAgKGxvY2FsICRyMiBpNjQpXFxuICAgIChsb2NhbCAkcjMgaTY0KVxcbiAgICAobG9jYWwgJHI0IGk2NClcXG4gICAgKGJsb2NrXFxuICAgICAgICAobG9jYWwuc2V0ICRyMSAoaTY0Lm9yIChsb2NhbC5nZXQgJHgxKSAobG9jYWwuZ2V0ICR5MSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkcjIgKGk2NC5vciAobG9jYWwuZ2V0ICR4MikgKGxvY2FsLmdldCAkeTIpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJHIzIChpNjQub3IgKGxvY2FsLmdldCAkeDMpIChsb2NhbC5nZXQgJHkzKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRyNCAoaTY0Lm9yIChsb2NhbC5nZXQgJHg0KSAobG9jYWwuZ2V0ICR5NCkpKVxcblxcbiAgICApXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfIChsb2NhbC5nZXQgJHIyKSlcXG4gICAgKGdsb2JhbC5zZXQgJGdsb2JhbF9fMSAobG9jYWwuZ2V0ICRyMykpXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfXzIgKGxvY2FsLmdldCAkcjQpKVxcbiAgICAobG9jYWwuZ2V0ICRyMSlcXG4pXFxuXFxuXFxuKGZ1bmMgJGNtcFxcbiAgICAocGFyYW0gJGEgaTY0KVxcbiAgICAocGFyYW0gJGIgaTY0KVxcbiAgICAocmVzdWx0IGkzMilcXG4gICAgKGxvY2FsICRyIGkzMilcXG4gICAgKGJsb2NrXFxuICAgICAgICAobG9jYWwuc2V0ICRyIChzZWxlY3QgKGkzMi5jb25zdCA0Mjk0OTY3Mjk1KSAoaTY0Lm5lIChsb2NhbC5nZXQgJGEpIChsb2NhbC5nZXQgJGIpKSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYikpKSlcXG5cXG4gICAgKVxcbiAgICAobG9jYWwuZ2V0ICRyKVxcbilcXG5cXG5cXG4oZnVuYyAkc2hyX3NpbmdsZV9cXG4gICAgKHBhcmFtICRhIGk2NClcXG4gICAgKHBhcmFtICRhbW91bnQgaTY0KVxcbiAgICAocmVzdWx0IGk2NClcXG4gICAgKGxvY2FsICR4IGk2NClcXG4gICAgKGxvY2FsICR5IGk2NClcXG4gICAgKGJsb2NrXFxuICAgICAgICAobG9jYWwuc2V0ICR5IChpNjQuc2hsIChsb2NhbC5nZXQgJGEpIChpNjQuc3ViIChpNjQuY29uc3QgNjQpIChsb2NhbC5nZXQgJGFtb3VudCkpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJHggKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhKSAobG9jYWwuZ2V0ICRhbW91bnQpKSlcXG5cXG4gICAgKVxcbiAgICAoZ2xvYmFsLnNldCAkZ2xvYmFsXyAobG9jYWwuZ2V0ICR5KSlcXG4gICAgKGxvY2FsLmdldCAkeClcXG4pXFxuXFxuKGZ1bmMgJHNocl9cXG4gICAgKHBhcmFtICR4MSBpNjQpXFxuICAgIChwYXJhbSAkeDIgaTY0KVxcbiAgICAocGFyYW0gJHgzIGk2NClcXG4gICAgKHBhcmFtICR4NCBpNjQpXFxuICAgIChwYXJhbSAkeTEgaTY0KVxcbiAgICAocGFyYW0gJHkyIGk2NClcXG4gICAgKHBhcmFtICR5MyBpNjQpXFxuICAgIChwYXJhbSAkeTQgaTY0KVxcbiAgICAocmVzdWx0IGk2NClcXG4gICAgKGxvY2FsICR6MSBpNjQpXFxuICAgIChsb2NhbCAkejIgaTY0KVxcbiAgICAobG9jYWwgJHozIGk2NClcXG4gICAgKGxvY2FsICR6NCBpNjQpXFxuICAgIChsb2NhbCAkdCBpNjQpXFxuICAgIChibG9ja1xcbiAgICAgICAgKGlmIChpMzIuYW5kIChpNjQuZXF6IChsb2NhbC5nZXQgJHgxKSkgKGk2NC5lcXogKGxvY2FsLmdldCAkeDIpKSkgKHRoZW5cXG4gICAgICAgICAgICAoaWYgKGk2NC5lcXogKGxvY2FsLmdldCAkeDMpKSAodGhlblxcbiAgICAgICAgICAgICAgICAoaWYgKGk2NC5lcXogKGxvY2FsLmdldCAkeDQpKVxcbiAgICAgICAgICAgICAgICAgICAgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MSAobG9jYWwuZ2V0ICR5MSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGxvY2FsLmdldCAkeTIpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHozIChsb2NhbC5nZXQgJHkzKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6NCAobG9jYWwuZ2V0ICR5NCkpXFxuICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgICAgICAoZWxzZVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChpZiAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgMjU2KSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpNjQuZ2VfdSAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCAxMjgpKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTQgKGxvY2FsLmdldCAkeTIpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTMgKGxvY2FsLmdldCAkeTEpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTIgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkxIChpNjQuY29uc3QgMCkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR4NCAoaTY0LnN1YiAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCAxMjgpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpNjQuZ2VfdSAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCA2NCkpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5NCAobG9jYWwuZ2V0ICR5MykpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MyAobG9jYWwuZ2V0ICR5MikpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MiAobG9jYWwuZ2V0ICR5MSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MSAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeDQgKGk2NC5zdWIgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgNjQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vcClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6NCAoY2FsbCAkc2hyX3NpbmdsZV8gKGxvY2FsLmdldCAkeTQpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR0IChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHozIChjYWxsICRzaHJfc2luZ2xlXyAobG9jYWwuZ2V0ICR5MykgKGxvY2FsLmdldCAkeDQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHQgKGdsb2JhbC5nZXQgJGdsb2JhbF8pKVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHo0IChpNjQub3IgKGxvY2FsLmdldCAkejQpIChsb2NhbC5nZXQgJHQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MiAoY2FsbCAkc2hyX3NpbmdsZV8gKGxvY2FsLmdldCAkeTIpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR0IChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MyAoaTY0Lm9yIChsb2NhbC5nZXQgJHozKSAobG9jYWwuZ2V0ICR0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejEgKGNhbGwgJHNocl9zaW5nbGVfIChsb2NhbC5nZXQgJHkxKSAobG9jYWwuZ2V0ICR4NCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkdCAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGk2NC5vciAobG9jYWwuZ2V0ICR6MikgKGxvY2FsLmdldCAkdCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXFxuICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICApKVxcbiAgICAgICAgKSlcXG5cXG4gICAgKVxcbiAgICAoZ2xvYmFsLnNldCAkZ2xvYmFsXyAobG9jYWwuZ2V0ICR6MikpXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfXzEgKGxvY2FsLmdldCAkejMpKVxcbiAgICAoZ2xvYmFsLnNldCAkZ2xvYmFsX18yIChsb2NhbC5nZXQgJHo0KSlcXG4gICAgKGxvY2FsLmdldCAkejEpXFxuKVxcblxcblxcbihmdW5jICRzaGxfc2luZ2xlX1xcbiAgICAocGFyYW0gJGEgaTY0KVxcbiAgICAocGFyYW0gJGFtb3VudCBpNjQpXFxuICAgIChyZXN1bHQgaTY0KVxcbiAgICAobG9jYWwgJHggaTY0KVxcbiAgICAobG9jYWwgJHkgaTY0KVxcbiAgICAoYmxvY2tcXG4gICAgICAgIChsb2NhbC5zZXQgJHggKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhKSAoaTY0LnN1YiAoaTY0LmNvbnN0IDY0KSAobG9jYWwuZ2V0ICRhbW91bnQpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICR5IChpNjQuc2hsIChsb2NhbC5nZXQgJGEpIChsb2NhbC5nZXQgJGFtb3VudCkpKVxcblxcbiAgICApXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfIChsb2NhbC5nZXQgJHkpKVxcbiAgICAobG9jYWwuZ2V0ICR4KVxcbilcXG5cXG4oZnVuYyAkc2hsX1xcbiAgICAocGFyYW0gJHgxIGk2NClcXG4gICAgKHBhcmFtICR4MiBpNjQpXFxuICAgIChwYXJhbSAkeDMgaTY0KVxcbiAgICAocGFyYW0gJHg0IGk2NClcXG4gICAgKHBhcmFtICR5MSBpNjQpXFxuICAgIChwYXJhbSAkeTIgaTY0KVxcbiAgICAocGFyYW0gJHkzIGk2NClcXG4gICAgKHBhcmFtICR5NCBpNjQpXFxuICAgIChyZXN1bHQgaTY0KVxcbiAgICAobG9jYWwgJHoxIGk2NClcXG4gICAgKGxvY2FsICR6MiBpNjQpXFxuICAgIChsb2NhbCAkejMgaTY0KVxcbiAgICAobG9jYWwgJHo0IGk2NClcXG4gICAgKGxvY2FsICR0IGk2NClcXG4gICAgKGxvY2FsICRyIGk2NClcXG4gICAgKGJsb2NrXFxuICAgICAgICAoaWYgKGkzMi5hbmQgKGk2NC5lcXogKGxvY2FsLmdldCAkeDEpKSAoaTY0LmVxeiAobG9jYWwuZ2V0ICR4MikpKSAodGhlblxcbiAgICAgICAgICAgIChpZiAoaTY0LmVxeiAobG9jYWwuZ2V0ICR4MykpICh0aGVuXFxuICAgICAgICAgICAgICAgIChpZiAoaTY0LmVxeiAobG9jYWwuZ2V0ICR4NCkpXFxuICAgICAgICAgICAgICAgICAgICAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHoxIChsb2NhbC5nZXQgJHkxKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MiAobG9jYWwuZ2V0ICR5MikpXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejMgKGxvY2FsLmdldCAkeTMpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHo0IChsb2NhbC5nZXQgJHk0KSlcXG4gICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgIChlbHNlXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGlmIChpNjQubHRfdSAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCAyNTYpKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaWYgKGk2NC5nZV91IChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDEyOCkpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MSAobG9jYWwuZ2V0ICR5MykpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MiAobG9jYWwuZ2V0ICR5NCkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5MyAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTQgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHg0IChpNjQuc3ViIChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDEyOCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaWYgKGk2NC5nZV91IChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDY0KSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkxIChsb2NhbC5nZXQgJHkyKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkyIChsb2NhbC5nZXQgJHkzKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkzIChsb2NhbC5nZXQgJHk0KSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHk0IChpNjQuY29uc3QgMCkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR4NCAoaTY0LnN1YiAobG9jYWwuZ2V0ICR4NCkgKGk2NC5jb25zdCA2NCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9wKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHQgKGNhbGwgJHNobF9zaW5nbGVfIChsb2NhbC5nZXQgJHk0KSAobG9jYWwuZ2V0ICR4NCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejQgKGdsb2JhbC5nZXQgJGdsb2JhbF8pKVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkciAoY2FsbCAkc2hsX3NpbmdsZV8gKGxvY2FsLmdldCAkeTMpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MyAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejMgKGk2NC5vciAobG9jYWwuZ2V0ICR6MykgKGxvY2FsLmdldCAkdCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHQgKGNhbGwgJHNobF9zaW5nbGVfIChsb2NhbC5nZXQgJHkyKSAobG9jYWwuZ2V0ICR4NCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGdsb2JhbC5nZXQgJGdsb2JhbF8pKVxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHoyIChpNjQub3IgKGxvY2FsLmdldCAkejIpIChsb2NhbC5nZXQgJHIpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJsb2NrXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICRyIChjYWxsICRzaGxfc2luZ2xlXyAobG9jYWwuZ2V0ICR5MSkgKGxvY2FsLmdldCAkeDQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHoxIChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MSAoaTY0Lm9yIChsb2NhbC5nZXQgJHoxKSAobG9jYWwuZ2V0ICR0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgKSlcXG4gICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICkpXFxuICAgICAgICApKVxcblxcbiAgICApXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfIChsb2NhbC5nZXQgJHoyKSlcXG4gICAgKGdsb2JhbC5zZXQgJGdsb2JhbF9fMSAobG9jYWwuZ2V0ICR6MykpXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfXzIgKGxvY2FsLmdldCAkejQpKVxcbiAgICAobG9jYWwuZ2V0ICR6MSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJTRElWXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkU0RJVlxcbiAgKGxvY2FsICRzcCBpMzIpXFxuXFxuICA7OyBkaXZpZGVuZFxcbiAgKGxvY2FsICRhIGk2NClcXG4gIChsb2NhbCAkYiBpNjQpXFxuICAobG9jYWwgJGMgaTY0KVxcbiAgKGxvY2FsICRkIGk2NClcXG5cXG4gIDs7IGRpdmlzb3JcXG4gIChsb2NhbCAkYTEgaTY0KVxcbiAgKGxvY2FsICRiMSBpNjQpXFxuICAobG9jYWwgJGMxIGk2NClcXG4gIChsb2NhbCAkZDEgaTY0KVxcblxcbiAgOzsgcXVvdGllbnRcXG4gIChsb2NhbCAkYXEgaTY0KVxcbiAgKGxvY2FsICRicSBpNjQpXFxuICAobG9jYWwgJGNxIGk2NClcXG4gIChsb2NhbCAkZHEgaTY0KVxcblxcbiAgOzsgbWFza1xcbiAgKGxvY2FsICRtYXNrYSBpNjQpXFxuICAobG9jYWwgJG1hc2tiIGk2NClcXG4gIChsb2NhbCAkbWFza2MgaTY0KVxcbiAgKGxvY2FsICRtYXNrZCBpNjQpXFxuICAobG9jYWwgJGNhcnJ5IGkzMilcXG4gIChsb2NhbCAkdGVtcCAgaTY0KVxcbiAgKGxvY2FsICR0ZW1wMiBpNjQpXFxuICAobG9jYWwgJHNpZ24gaTMyKVxcblxcbiAgKGxvY2FsLnNldCAkbWFza2QgKGk2NC5jb25zdCAxKSlcXG5cXG4gIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRkIChpNjQubG9hZCAoZ2xvYmFsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgKGxvY2FsLnNldCAkYTEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYjEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYzEgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRkMSAoaTY0LmxvYWQgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIDs7IGdldCB0aGUgcmVzdWx0aW5nIHNpZ25cXG4gIChsb2NhbC5zZXQgJHNpZ24gKGkzMi53cmFwX2k2NCAoaTY0LnNocl91IChpNjQueG9yIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRhKSkgKGk2NC5jb25zdCA2MykpKSlcXG5cXG4gIDs7IGNvbnZlcnQgdG8gdW5zaWduZWQgdmFsdWVcXG4gIChpZiAoaTY0LmVxeiAoaTY0LmNseiAobG9jYWwuZ2V0ICRhKSkpXFxuICAgICh0aGVuXFxuICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LnhvciAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYiAoaTY0LnhvciAobG9jYWwuZ2V0ICRiKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYyAoaTY0LnhvciAobG9jYWwuZ2V0ICRjKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LnhvciAobG9jYWwuZ2V0ICRkKSAoaTY0LmNvbnN0IC0xKSkpXFxuXFxuICAgICAgOzsgYSA9IGEgKyAxXFxuICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LmFkZCAobG9jYWwuZ2V0ICRkKSAoaTY0LmNvbnN0IDEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0LmVxeiAobG9jYWwuZ2V0ICRkKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYyAoaTY0LmFkZCAobG9jYWwuZ2V0ICRjKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLmFuZCAoaTY0LmVxeiAobG9jYWwuZ2V0ICRjKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAobG9jYWwuc2V0ICRiIChpNjQuYWRkIChsb2NhbC5nZXQgJGIpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIuYW5kIChpNjQuZXF6IChsb2NhbC5nZXQgJGIpKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGEgKGk2NC5hZGQgKGxvY2FsLmdldCAkYSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgIClcXG4gIClcXG4gIChpZiAoaTY0LmVxeiAoaTY0LmNseiAobG9jYWwuZ2V0ICRhMSkpKVxcbiAgICAodGhlblxcbiAgICAgIChsb2NhbC5zZXQgJGExIChpNjQueG9yIChsb2NhbC5nZXQgJGExKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYjEgKGk2NC54b3IgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgLTEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LnhvciAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCAtMSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGQxIChpNjQueG9yIChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IC0xKSkpXFxuXFxuICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC5hZGQgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgMSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZXF6IChsb2NhbC5nZXQgJGQxKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYzEgKGk2NC5hZGQgKGxvY2FsLmdldCAkYzEpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIuYW5kIChpNjQuZXF6IChsb2NhbC5nZXQgJGMxKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRiMSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5hbmQgKGk2NC5lcXogKGxvY2FsLmdldCAkYjEpKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGExIChpNjQuYWRkIChsb2NhbC5nZXQgJGExKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGJsb2NrICRtYWluXFxuICAgIDs7IGNoZWNrIGRpdiBieSAwXFxuICAgIChpZiAoY2FsbCAkaXN6ZXJvXzI1NiAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkpXFxuICAgICAgKGJyICRtYWluKVxcbiAgICApXFxuXFxuICAgIDs7IGFsaWduIGJpdHNcXG4gICAgKGJsb2NrICRkb25lXFxuICAgICAgKGxvb3AgJGxvb3BcXG4gICAgICAgIDs7IGFsaWduIGJpdHM7XFxuICAgICAgICAoaWYgKGkzMi5vciAoaTY0LmVxeiAoaTY0LmNseiAobG9jYWwuZ2V0ICRhMSkpKSAoY2FsbCAkZ3RlXzI1NiAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkgKGxvY2FsLmdldCAkYSkgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkZCkpKVxcbiAgICAgICAgICAoYnIgJGRvbmUpXFxuICAgICAgICApXFxuXFxuICAgICAgICA7OyBkaXZpc29yID0gZGl2aXNvciA8PCAxXFxuICAgICAgICAobG9jYWwuc2V0ICRhMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGIxIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYzEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRkMSAoaTY0LnNobCAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICA7OyBtYXNrID0gbWFzayA8PCAxXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tiIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2MgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICAoYnIgJGxvb3ApXFxuICAgICAgKVxcbiAgICApXFxuXFxuICAgIChibG9jayAkZG9uZVxcbiAgICAgIChsb29wICRsb29wXFxuICAgICAgICA7OyBsb29wIHdoaWxlIG1hc2sgIT0gMFxcbiAgICAgICAgKGlmIChjYWxsICRpc3plcm9fMjU2IChsb2NhbC5nZXQgJG1hc2thKSAobG9jYWwuZ2V0ICRtYXNrYikgKGxvY2FsLmdldCAkbWFza2MpIChsb2NhbC5nZXQgJG1hc2tkKSlcXG4gICAgICAgICAgKGJyICRkb25lKVxcbiAgICAgICAgKVxcbiAgICAgICAgOzsgaWYgZGl2aWRlbmQgPj0gZGl2aXNvclxcbiAgICAgICAgKGlmIChjYWxsICRndGVfMjU2IChsb2NhbC5nZXQgJGEpIChsb2NhbC5nZXQgJGIpIChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJGQpIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSlcXG4gICAgICAgICAgKHRoZW5cXG4gICAgICAgICAgICA7OyBkaXZpZGVuZCA9IGRpdmlkZW5kIC0gZGl2aXNvclxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQubHRfdSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRkMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGQgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRkMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRjKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYykpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGMgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRjMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYykgKGxvY2FsLmdldCAkdGVtcCkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGIpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkYiAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGIxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5vciAgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICR0ZW1wKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRhICAgICAoaTY0LnN1YiAgKGk2NC5zdWIgKGxvY2FsLmdldCAkYSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkgKGxvY2FsLmdldCAkYTEpKSlcXG5cXG4gICAgICAgICAgICA7OyByZXN1bHQgPSByZXN1bHQgKyBtYXNrXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkZHEgICAgKGk2NC5hZGQgIChsb2NhbC5nZXQgJG1hc2tkKSAobG9jYWwuZ2V0ICRkcSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQubHRfdSAobG9jYWwuZ2V0ICRkcSkgKGxvY2FsLmdldCAkbWFza2QpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LmFkZCAgKGxvY2FsLmdldCAkY3EpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQubHRfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRjcSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNxICAgIChpNjQuYWRkICAobG9jYWwuZ2V0ICRtYXNrYykgKGxvY2FsLmdldCAkdGVtcCkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkY3EpIChsb2NhbC5nZXQgJG1hc2tjKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LmFkZCAgKGxvY2FsLmdldCAkYnEpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQubHRfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRicSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGJxICAgIChpNjQuYWRkICAobG9jYWwuZ2V0ICRtYXNrYikgKGxvY2FsLmdldCAkdGVtcCkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkYnEpIChsb2NhbC5nZXQgJG1hc2tiKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRhcSAgICAoaTY0LmFkZCAgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuYWRkIChsb2NhbC5nZXQgJGFxKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yID4+IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGQxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYzEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGExIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYTEpIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgICAgOzsgbWFzayA9IG1hc2sgPj4gMVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2QgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYyAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tiIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2thKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2EgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCAxKSkpXFxuICAgICAgICAoYnIgJGxvb3ApXFxuICAgICAgKVxcbiAgICApXFxuICApOzsgZW5kIG9mIG1haW5cXG5cXG4gIDs7IGNvbnZlcnQgdG8gc2lnbmVkXFxuICAoaWYgKGxvY2FsLmdldCAkc2lnbilcXG4gICAgKHRoZW5cXG4gICAgICAobG9jYWwuc2V0ICRhcSAoaTY0LnhvciAobG9jYWwuZ2V0ICRhcSkgKGk2NC5jb25zdCAtMSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGJxIChpNjQueG9yIChsb2NhbC5nZXQgJGJxKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkY3EgKGk2NC54b3IgKGxvY2FsLmdldCAkY3EpIChpNjQuY29uc3QgLTEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRkcSAoaTY0LnhvciAobG9jYWwuZ2V0ICRkcSkgKGk2NC5jb25zdCAtMSkpKVxcblxcbiAgICAgIChsb2NhbC5zZXQgJGRxIChpNjQuYWRkIChsb2NhbC5nZXQgJGRxKSAoaTY0LmNvbnN0IDEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjcSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRjcSkgKGk2NC5leHRlbmRfaTMyX3UgKGk2NC5lcXogKGxvY2FsLmdldCAkZHEpKSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGJxIChpNjQuYWRkIChsb2NhbC5nZXQgJGJxKSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0LmVxeiAobG9jYWwuZ2V0ICRjcSkpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYXEgKGk2NC5hZGQgKGxvY2FsLmdldCAkYXEpIChpNjQuZXh0ZW5kX2kzMl91IChpNjQuZXF6IChsb2NhbC5nZXQgJGJxKSkpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChsb2NhbC5nZXQgJGFxKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAobG9jYWwuZ2V0ICRicSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGxvY2FsLmdldCAkY3EpKVxcbiAgKGk2NC5zdG9yZSAgICAgICAgICAobG9jYWwuZ2V0ICRzcCkgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGRxKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJTR1RcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRTR1RcXG4gIChsb2NhbCAkc3AgaTMyKVxcblxcbiAgKGxvY2FsICRhMCBpNjQpXFxuICAobG9jYWwgJGExIGk2NClcXG4gIChsb2NhbCAkYTIgaTY0KVxcbiAgKGxvY2FsICRhMyBpNjQpXFxuICAobG9jYWwgJGIwIGk2NClcXG4gIChsb2NhbCAkYjEgaTY0KVxcbiAgKGxvY2FsICRiMiBpNjQpXFxuICAobG9jYWwgJGIzIGk2NClcXG5cXG4gIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYTAgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGExIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRhMiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAobG9jYWwuc2V0ICRhMyAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSkpXFxuXFxuICAobG9jYWwuc2V0ICRzcCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGIwIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gIChsb2NhbC5zZXQgJGIxIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gIChsb2NhbC5zZXQgJGIyIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGxvY2FsLnNldCAkYjMgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHNwKSkpXFxuXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKSAoaTY0LmV4dGVuZF9pMzJfdVxcbiAgICAoaTMyLm9yICAoaTY0Lmd0X3MgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPiBiMFxcbiAgICAoaTMyLmFuZCAoaTY0LmVxICAgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPT0gYTFcXG4gICAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID4gYjFcXG4gICAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID09IGIxXFxuICAgIChpMzIub3IgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA+IGIyXFxuICAgIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKSA7OyBhMiA9PSBiMlxcbiAgICAgICAgICAgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYTMpIChsb2NhbC5nZXQgJGIzKSkpKSkpKSkpKSA7OyBhMyA+IGIzXFxuXFxuICA7OyB6ZXJvICBvdXQgdGhlIHJlc3Qgb2YgdGhlIHN0YWNrIGl0ZW1cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAoaTY0LmNvbnN0IDApKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5jb25zdCAwKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJTSEEzXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkU0hBM1xcbiAgKGxvY2FsICRkYXRhT2Zmc2V0IGkzMilcXG4gIChsb2NhbCAkZGF0YU9mZnNldDAgaTY0KVxcbiAgKGxvY2FsICRkYXRhT2Zmc2V0MSBpNjQpXFxuICAobG9jYWwgJGRhdGFPZmZzZXQyIGk2NClcXG4gIChsb2NhbCAkZGF0YU9mZnNldDMgaTY0KVxcblxcbiAgKGxvY2FsICRsZW5ndGggaTMyKVxcbiAgKGxvY2FsICRsZW5ndGgwIGk2NClcXG4gIChsb2NhbCAkbGVuZ3RoMSBpNjQpXFxuICAobG9jYWwgJGxlbmd0aDIgaTY0KVxcbiAgKGxvY2FsICRsZW5ndGgzIGk2NClcXG5cXG4gIChsb2NhbCAkY29udGV4dE9mZnNldCBpMzIpXFxuICAobG9jYWwgJG91dHB1dE9mZnNldCBpMzIpXFxuXFxuICAobG9jYWwuc2V0ICRsZW5ndGgwIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkpXFxuICAobG9jYWwuc2V0ICRsZW5ndGgxIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRsZW5ndGgyIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRsZW5ndGgzIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGRhdGFPZmZzZXQwIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMCkpKSlcXG4gIChsb2NhbC5zZXQgJGRhdGFPZmZzZXQxIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGRhdGFPZmZzZXQyIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRkYXRhT2Zmc2V0MyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcblxcbiAgKGxvY2FsLnNldCAkbGVuZ3RoXFxuICAgICAgICAgICAgIChjYWxsICRjaGVja19vdmVyZmxvdyAobG9jYWwuZ2V0ICRsZW5ndGgwKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkbGVuZ3RoMSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGxlbmd0aDIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRsZW5ndGgzKSkpXFxuICAobG9jYWwuc2V0ICRkYXRhT2Zmc2V0XFxuICAgICAgICAgICAgIChjYWxsICRjaGVja19vdmVyZmxvdyAobG9jYWwuZ2V0ICRkYXRhT2Zmc2V0MClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGRhdGFPZmZzZXQxKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkZGF0YU9mZnNldDIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRkYXRhT2Zmc2V0MykpKVxcblxcbiAgOzsgY2hhcmdlIGNvcHkgZmVlIGNlaWwod29yZHMvMzIpICogNlxcbiAgKGNhbGwgJHVzZUdhcyAoaTY0LmV4dGVuZF9pMzJfdSAoaTMyLm11bCAoaTMyLmRpdl91IChpMzIuYWRkIChsb2NhbC5nZXQgJGxlbmd0aCkgKGkzMi5jb25zdCAzMSkpIChpMzIuY29uc3QgMzIpKSAoaTMyLmNvbnN0IDYpKSkpXFxuICAoY2FsbCAkbWVtdXNlZ2FzIChsb2NhbC5nZXQgJGRhdGFPZmZzZXQpIChsb2NhbC5nZXQgJGxlbmd0aCkpXFxuXFxuICAobG9jYWwuc2V0ICRkYXRhT2Zmc2V0IChpMzIuYWRkIChnbG9iYWwuZ2V0ICRtZW1zdGFydCkgKGxvY2FsLmdldCAkZGF0YU9mZnNldCkpKVxcblxcbiAgKGxvY2FsLnNldCAkY29udGV4dE9mZnNldCAoaTMyLmNvbnN0IDMyODA4KSlcXG4gIChsb2NhbC5zZXQgJG91dHB1dE9mZnNldCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSlcXG5cXG4gIChjYWxsICRrZWNjYWsgKGxvY2FsLmdldCAkY29udGV4dE9mZnNldCkgKGxvY2FsLmdldCAkZGF0YU9mZnNldCkgKGxvY2FsLmdldCAkbGVuZ3RoKSAobG9jYWwuZ2V0ICRvdXRwdXRPZmZzZXQpKVxcblxcbiAgKGRyb3AgKGNhbGwgJGJzd2FwX20yNTYgKGxvY2FsLmdldCAkb3V0cHV0T2Zmc2V0KSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiU0hMXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkU0hMXFxuICAgIChsb2NhbCAkc3AgaTMyKVxcbiAgICAobG9jYWwgJHgxIGk2NClcXG4gICAgKGxvY2FsICR4MiBpNjQpXFxuICAgIChsb2NhbCAkeDMgaTY0KVxcbiAgICAobG9jYWwgJHg0IGk2NClcXG4gICAgKGxvY2FsICR5MSBpNjQpXFxuICAgIChsb2NhbCAkeTIgaTY0KVxcbiAgICAobG9jYWwgJHkzIGk2NClcXG4gICAgKGxvY2FsICR5NCBpNjQpXFxuXFxuICAgIChsb2NhbCAkejEgaTY0KVxcbiAgICAobG9jYWwgJHoyIGk2NClcXG4gICAgKGxvY2FsICR6MyBpNjQpXFxuICAgIChsb2NhbCAkejQgaTY0KVxcbiAgICAobG9jYWwgJHQgaTY0KVxcbiAgICAobG9jYWwgJHIgaTY0KVxcblxcbiAgICA7OyBsb2FkIGFyZ3MgZnJvbSB0aGUgc3RhY2tcXG4gICAgKGxvY2FsLnNldCAkeDEgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSlcXG4gICAgKGxvY2FsLnNldCAkeDIgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gICAgKGxvY2FsLnNldCAkeDMgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgICAobG9jYWwuc2V0ICR4NCAoaTY0LmxvYWQgKGdsb2JhbC5nZXQgJHNwKSkpXFxuXFxuICAgIChsb2NhbC5zZXQgJHNwIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpKVxcblxcbiAgICAobG9jYWwuc2V0ICR5MSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAgIChsb2NhbC5zZXQgJHkyIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSlcXG4gICAgKGxvY2FsLnNldCAkeTMgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpXFxuICAgIChsb2NhbC5zZXQgJHk0IChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKVxcblxcbiAgICAoYmxvY2tcXG4gICAgICAgIChpZiAoaTMyLmFuZCAoaTY0LmVxeiAobG9jYWwuZ2V0ICR4MSkpIChpNjQuZXF6IChsb2NhbC5nZXQgJHgyKSkpICh0aGVuXFxuICAgICAgICAgICAgKGlmIChpNjQuZXF6IChsb2NhbC5nZXQgJHgzKSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgKGlmIChpNjQuZXF6IChsb2NhbC5nZXQgJHg0KSlcXG4gICAgICAgICAgICAgICAgICAgICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejEgKGxvY2FsLmdldCAkeTEpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHoyIChsb2NhbC5nZXQgJHkyKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MyAobG9jYWwuZ2V0ICR5MykpXFxuICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejQgKGxvY2FsLmdldCAkeTQpKVxcbiAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgKGVsc2VcXG4gICAgICAgICAgICAgICAgICAgICAgICAoaWYgKGk2NC5sdF91IChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDI1NikpICh0aGVuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpZiAoaTY0LmdlX3UgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgMTI4KSkgKHRoZW5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkxIChsb2NhbC5nZXQgJHkzKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkyIChsb2NhbC5nZXQgJHk0KSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHkzIChpNjQuY29uc3QgMCkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR5NCAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeDQgKGk2NC5zdWIgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgMTI4KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpZiAoaTY0LmdlX3UgKGxvY2FsLmdldCAkeDQpIChpNjQuY29uc3QgNjQpKSAodGhlblxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTEgKGxvY2FsLmdldCAkeTIpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTIgKGxvY2FsLmdldCAkeTMpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTMgKGxvY2FsLmdldCAkeTQpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkeTQgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHg0IChpNjQuc3ViIChsb2NhbC5nZXQgJHg0KSAoaTY0LmNvbnN0IDY0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub3ApXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChibG9ja1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkdCAoY2FsbCAkc2hsX3NpbmdsZSAobG9jYWwuZ2V0ICR5NCkgKGxvY2FsLmdldCAkeDQpKSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHo0IChnbG9iYWwuZ2V0ICRnbG9iYWxfKSlcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHIgKGNhbGwgJHNobF9zaW5nbGUgKGxvY2FsLmdldCAkeTMpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MyAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejMgKGk2NC5vciAobG9jYWwuZ2V0ICR6MykgKGxvY2FsLmdldCAkdCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHQgKGNhbGwgJHNobF9zaW5nbGUgKGxvY2FsLmdldCAkeTIpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MiAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejIgKGk2NC5vciAobG9jYWwuZ2V0ICR6MikgKGxvY2FsLmdldCAkcikpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmxvY2tcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5zZXQgJHIgKGNhbGwgJHNobF9zaW5nbGUgKGxvY2FsLmdldCAkeTEpIChsb2NhbC5nZXQgJHg0KSkpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuc2V0ICR6MSAoZ2xvYmFsLmdldCAkZ2xvYmFsXykpXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLnNldCAkejEgKGk2NC5vciAobG9jYWwuZ2V0ICR6MSkgKGxvY2FsLmdldCAkdCkpKVxcbiAgICAgICAgICAgICAgICAgICAgICAgICkpXFxuICAgICAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICApKVxcbiAgICAgICAgKSlcXG5cXG4gICAgKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGxvY2FsLmdldCAkejEpKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkejIpKVxcbiAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGxvY2FsLmdldCAkejMpKVxcbiAgICAoaTY0LnN0b3JlICAgICAgICAgIChsb2NhbC5nZXQgJHNwKSAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkejQpKVxcbilcXG5cXG4oZnVuYyAkc2hsX3NpbmdsZVxcbiAgICAocGFyYW0gJGEgaTY0KVxcbiAgICAocGFyYW0gJGFtb3VudCBpNjQpXFxuICAgIChyZXN1bHQgaTY0KVxcbiAgICAobG9jYWwgJHggaTY0KVxcbiAgICAobG9jYWwgJHkgaTY0KVxcbiAgICAoYmxvY2tcXG4gICAgICAgIChsb2NhbC5zZXQgJHggKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhKSAoaTY0LnN1YiAoaTY0LmNvbnN0IDY0KSAobG9jYWwuZ2V0ICRhbW91bnQpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICR5IChpNjQuc2hsIChsb2NhbC5nZXQgJGEpIChsb2NhbC5nZXQgJGFtb3VudCkpKVxcblxcbiAgICApXFxuICAgIChnbG9iYWwuc2V0ICRnbG9iYWxfIChsb2NhbC5nZXQgJHkpKVxcbiAgICAobG9jYWwuZ2V0ICR4KVxcbilcXG5cIlxuICB9LFxuICBcIlNJR05FWFRFTkRcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRTSUdORVhURU5EXFxuICAobG9jYWwgJHNwIGkzMilcXG5cXG4gIChsb2NhbCAkYTAgaTY0KVxcbiAgKGxvY2FsICRhMSBpNjQpXFxuICAobG9jYWwgJGEyIGk2NClcXG4gIChsb2NhbCAkYTMgaTY0KVxcblxcbiAgKGxvY2FsICRiMCBpNjQpXFxuICAobG9jYWwgJGIxIGk2NClcXG4gIChsb2NhbCAkYjIgaTY0KVxcbiAgKGxvY2FsICRiMyBpNjQpXFxuICAobG9jYWwgJHNpZ24gaTY0KVxcbiAgKGxvY2FsICR0IGkzMilcXG4gIChsb2NhbCAkZW5kIGkzMilcXG5cXG4gIChsb2NhbC5zZXQgJGEwIChpNjQubG9hZCAoaTMyLmFkZCAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRhMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYTIgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSlcXG4gIChsb2NhbC5zZXQgJGEzIChpNjQubG9hZCAgICAgICAgICAoZ2xvYmFsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJGVuZCAoZ2xvYmFsLmdldCAkc3ApKVxcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAoaWYgKGkzMi5hbmRcXG4gICAgICAgIChpMzIuYW5kXFxuICAgICAgICAgIChpMzIuYW5kXFxuICAgICAgICAgICAgKGk2NC5sdF91IChsb2NhbC5nZXQgJGEzKSAoaTY0LmNvbnN0IDMyKSlcXG4gICAgICAgICAgICAoaTY0LmVxeiAobG9jYWwuZ2V0ICRhMikpKVxcbiAgICAgICAgICAoaTY0LmVxeiAobG9jYWwuZ2V0ICRhMSkpKVxcbiAgICAgICAgKGk2NC5lcXogKGxvY2FsLmdldCAkYTApKSlcXG4gICAgKHRoZW5cXG4gICAgICAobG9jYWwuc2V0ICR0IChpMzIuYWRkIChpMzIud3JhcF9pNjQgKGxvY2FsLmdldCAkYTMpKSAobG9jYWwuZ2V0ICRzcCkpKVxcbiAgICAgIChsb2NhbC5zZXQgJHNpZ24gKGk2NC5zaHJfcyAoaTY0LmxvYWQ4X3MgKGxvY2FsLmdldCAkdCkpIChpNjQuY29uc3QgOCkpKVxcbiAgICAgIChsb2NhbC5zZXQgJHQgKGkzMi5hZGQgKGxvY2FsLmdldCAkdCkgKGkzMi5jb25zdCAxKSkpXFxuICAgICAgKGJsb2NrICRkb25lXFxuICAgICAgICAobG9vcCAkbG9vcFxcbiAgICAgICAgICAoaWYgKGkzMi5sdF91IChsb2NhbC5nZXQgJGVuZCkgKGxvY2FsLmdldCAkdCkpXFxuICAgICAgICAgICAgKGJyICRkb25lKVxcbiAgICAgICAgICApXFxuICAgICAgICAgIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkdCkgKGxvY2FsLmdldCAkc2lnbikpXFxuICAgICAgICAgIChsb2NhbC5zZXQgJHQgKGkzMi5hZGQgKGxvY2FsLmdldCAkdCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgICAgIChiciAkbG9vcClcXG4gICAgICAgIClcXG4gICAgICApXFxuICAgIClcXG4gIClcXG4pXFxuXFxuXCJcbiAgfSxcbiAgXCJTTU9EXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkU01PRFxcbiAgKGxvY2FsICRzcCBpMzIpXFxuICA7OyBkaXZpZGVuZFxcbiAgKGxvY2FsICRhIGk2NClcXG4gIChsb2NhbCAkYiBpNjQpXFxuICAobG9jYWwgJGMgaTY0KVxcbiAgKGxvY2FsICRkIGk2NClcXG5cXG4gIDs7IGRpdmlzb3JcXG4gIChsb2NhbCAkYTEgaTY0KVxcbiAgKGxvY2FsICRiMSBpNjQpXFxuICAobG9jYWwgJGMxIGk2NClcXG4gIChsb2NhbCAkZDEgaTY0KVxcblxcbiAgOzsgcXVvdGllbnRcXG4gIChsb2NhbCAkYXEgaTY0KVxcbiAgKGxvY2FsICRicSBpNjQpXFxuICAobG9jYWwgJGNxIGk2NClcXG4gIChsb2NhbCAkZHEgaTY0KVxcblxcbiAgOzsgbWFza1xcbiAgKGxvY2FsICRtYXNrYSBpNjQpXFxuICAobG9jYWwgJG1hc2tiIGk2NClcXG4gIChsb2NhbCAkbWFza2MgaTY0KVxcbiAgKGxvY2FsICRtYXNrZCBpNjQpXFxuICAobG9jYWwgJGNhcnJ5IGkzMilcXG4gIChsb2NhbCAkc2lnbiBpMzIpXFxuICAobG9jYWwgJHRlbXAgIGk2NClcXG4gIChsb2NhbCAkdGVtcDIgIGk2NClcXG5cXG4gIDs7IGxvYWQgYXJncyBmcm9tIHRoZSBzdGFja1xcbiAgKGxvY2FsLnNldCAkYSAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKVxcbiAgKGxvY2FsLnNldCAkYiAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGxvY2FsLnNldCAkYyAoaTY0LmxvYWQgKGkzMi5hZGQgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkpKVxcbiAgKGxvY2FsLnNldCAkZCAoaTY0LmxvYWQgICAgICAgICAgKGdsb2JhbC5nZXQgJHNwKSkpXFxuICA7OyBkZWNlbWVudCB0aGUgc3RhY2sgcG9pbnRlclxcbiAgKGxvY2FsLnNldCAkc3AgKGkzMi5zdWIgKGdsb2JhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDMyKSkpXFxuXFxuICAobG9jYWwuc2V0ICRhMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkpXFxuICAobG9jYWwuc2V0ICRiMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpXFxuICAobG9jYWwuc2V0ICRjMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkpXFxuICAobG9jYWwuc2V0ICRkMSAoaTY0LmxvYWQgICAgICAgICAgKGxvY2FsLmdldCAkc3ApKSlcXG5cXG4gIChsb2NhbC5zZXQgJG1hc2tkIChpNjQuY29uc3QgMSkpXFxuICAobG9jYWwuc2V0ICRzaWduIChpMzIud3JhcF9pNjQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRkKSAoaTY0LmNvbnN0IDYzKSkpKVxcblxcbiAgOzsgY29udmVydCB0byB1bnNpZ25lZCB2YWx1ZVxcbiAgKGlmIChpNjQuZXF6IChpNjQuY2x6IChsb2NhbC5nZXQgJGEpKSlcXG4gICAgKHRoZW5cXG4gICAgICAobG9jYWwuc2V0ICRhIChpNjQueG9yIChsb2NhbC5nZXQgJGEpIChpNjQuY29uc3QgLTEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRiIChpNjQueG9yIChsb2NhbC5nZXQgJGIpIChpNjQuY29uc3QgLTEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjIChpNjQueG9yIChsb2NhbC5nZXQgJGMpIChpNjQuY29uc3QgLTEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRkIChpNjQueG9yIChsb2NhbC5nZXQgJGQpIChpNjQuY29uc3QgLTEpKSlcXG5cXG4gICAgICA7OyBhID0gYSArIDFcXG4gICAgICAobG9jYWwuc2V0ICRkIChpNjQuYWRkIChsb2NhbC5nZXQgJGQpIChpNjQuY29uc3QgMSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZXF6IChsb2NhbC5nZXQgJGQpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjIChpNjQuYWRkIChsb2NhbC5nZXQgJGMpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIuYW5kIChpNjQuZXF6IChsb2NhbC5nZXQgJGMpKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGIgKGk2NC5hZGQgKGxvY2FsLmdldCAkYikgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5hbmQgKGk2NC5lcXogKGxvY2FsLmdldCAkYikpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRhKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGlmIChpNjQuZXF6IChpNjQuY2x6IChsb2NhbC5nZXQgJGExKSkpXFxuICAgICh0aGVuXFxuICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC54b3IgKGxvY2FsLmdldCAkYTEpIChpNjQuY29uc3QgLTEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LnhvciAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCAtMSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGMxIChpNjQueG9yIChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC54b3IgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgLTEpKSlcXG5cXG4gICAgICAobG9jYWwuc2V0ICRkMSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCAxKSkpXFxuICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5lcXogKGxvY2FsLmdldCAkZDEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRjMSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5hbmQgKGk2NC5lcXogKGxvY2FsLmdldCAkYzEpKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGIxIChpNjQuYWRkIChsb2NhbC5nZXQgJGIxKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLmFuZCAoaTY0LmVxeiAobG9jYWwuZ2V0ICRiMSkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC5hZGQgKGxvY2FsLmdldCAkYTEpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICApXFxuICApXFxuXFxuICAoYmxvY2sgJG1haW5cXG4gICAgOzsgY2hlY2sgZGl2IGJ5IDBcXG4gICAgKGlmIChjYWxsICRpc3plcm9fMjU2IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSlcXG4gICAgICAodGhlblxcbiAgICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYiAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYyAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGJyICRtYWluKVxcbiAgICAgIClcXG4gICAgKVxcblxcbiAgICA7OyBhbGlnbiBiaXRzXFxuICAgIChibG9jayAkZG9uZVxcbiAgICAgIChsb29wICRsb29wXFxuICAgICAgICA7OyBhbGlnbiBiaXRzO1xcbiAgICAgICAgKGlmIChpMzIub3IgKGk2NC5lcXogKGk2NC5jbHogKGxvY2FsLmdldCAkYTEpKSkgKGNhbGwgJGd0ZV8yNTYgKGxvY2FsLmdldCAkYTEpIChsb2NhbC5nZXQgJGIxKSAobG9jYWwuZ2V0ICRjMSkgKGxvY2FsLmdldCAkZDEpIChsb2NhbC5nZXQgJGEpIChsb2NhbC5nZXQgJGIpIChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJGQpKSlcXG4gICAgICAgICAgKGJyICRkb25lKVxcbiAgICAgICAgKVxcblxcbiAgICAgICAgOzsgZGl2aXNvciA9IGRpdmlzb3IgPDwgMVxcbiAgICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkYTEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGMxIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC5zaGwgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgICAgOzsgbWFzayA9IG1hc2sgPDwgMVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2EgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYiAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYykgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tjIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tkKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2QgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgICAgKGJyICRsb29wKVxcbiAgICAgIClcXG4gICAgKVxcblxcbiAgICAoYmxvY2sgJGRvbmVcXG4gICAgICAobG9vcCAkbG9vcFxcbiAgICAgICAgOzsgbG9vcCB3aGlsZSBtYXNrICE9IDBcXG4gICAgICAgIChpZiAoY2FsbCAkaXN6ZXJvXzI1NiAobG9jYWwuZ2V0ICRtYXNrYSkgKGxvY2FsLmdldCAkbWFza2IpIChsb2NhbC5nZXQgJG1hc2tjKSAobG9jYWwuZ2V0ICRtYXNrZCkpXFxuICAgICAgICAgIChiciAkZG9uZSlcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGlmIGRpdmlkZW5kID49IGRpdmlzb3JcXG4gICAgICAgIChpZiAoY2FsbCAkZ3RlXzI1NiAobG9jYWwuZ2V0ICRhKSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICRjKSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkpXFxuICAgICAgICAgICh0aGVuXFxuICAgICAgICAgICAgOzsgZGl2aWRlbmQgPSBkaXZpZGVuZCAtIGRpdmlzb3JcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmx0X3UgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkZDEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRkICAgICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkZCkgKGxvY2FsLmdldCAkZDEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkYykgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5ndF91IChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGMpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjICAgICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYzEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLm9yICAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJHRlbXApKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRiKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYikpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGIgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkdGVtcCkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkYSAgICAgKGk2NC5zdWIgIChpNjQuc3ViIChsb2NhbC5nZXQgJGEpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpIChsb2NhbC5nZXQgJGExKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yID4+IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGQxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYzEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGExIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYTEpIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgICAgOzsgbWFzayA9IG1hc2sgPj4gMVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2QgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYyAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tiIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2thKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2EgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCAxKSkpXFxuICAgICAgICAoYnIgJGxvb3ApXFxuICAgICAgKVxcbiAgICApXFxuICApXFxuXFxuICA7OyBjb252ZXJ0IHRvIHNpZ25lZFxcbiAgKGlmIChsb2NhbC5nZXQgJHNpZ24pXFxuICAgICh0aGVuXFxuICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LnhvciAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYiAoaTY0LnhvciAobG9jYWwuZ2V0ICRiKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYyAoaTY0LnhvciAobG9jYWwuZ2V0ICRjKSAoaTY0LmNvbnN0IC0xKSkpXFxuICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LnhvciAobG9jYWwuZ2V0ICRkKSAoaTY0LmNvbnN0IC0xKSkpXFxuXFxuICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LmFkZCAobG9jYWwuZ2V0ICRkKSAoaTY0LmNvbnN0IDEpKSlcXG4gICAgICAobG9jYWwuc2V0ICRjIChpNjQuYWRkIChsb2NhbC5nZXQgJGMpIChpNjQuZXh0ZW5kX2kzMl91IChpNjQuZXF6IChsb2NhbC5nZXQgJGQpKSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJGIgKGk2NC5hZGQgKGxvY2FsLmdldCAkYikgKGk2NC5leHRlbmRfaTMyX3UgKGk2NC5lcXogKGxvY2FsLmdldCAkYykpKSkpXFxuICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LmFkZCAobG9jYWwuZ2V0ICRhKSAoaTY0LmV4dGVuZF9pMzJfdSAoaTY0LmVxeiAobG9jYWwuZ2V0ICRiKSkpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgOzsgc2F2ZSB0aGUgc3RhY2tcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICRhKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSAobG9jYWwuZ2V0ICRiKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSAobG9jYWwuZ2V0ICRjKSlcXG4gIChpNjQuc3RvcmUgICAgICAgICAgKGxvY2FsLmdldCAkc3ApICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRkKSlcXG4pIDs7IGVuZCBmb3IgU01PRFxcblwiXG4gIH0sXG4gIFwiWE9SXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkWE9SXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpIChpNjQueG9yIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgIDgpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQueG9yIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQueG9yIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgOCkpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAzMikpIChpNjQueG9yIChpNjQubG9hZCAoaTMyLnN1YiAoZ2xvYmFsLmdldCAkc3ApIChpMzIuY29uc3QgMzIpKSkgKGk2NC5sb2FkIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAgMCkpKSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiYnN3YXBfaTMyXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkYnN3YXBfaTMyXFxuICAocGFyYW0gJGludCBpMzIpXFxuICAocmVzdWx0IGkzMilcXG5cXG4gIChpMzIub3JcXG4gICAgKGkzMi5vclxcbiAgICAgIChpMzIuYW5kIChpMzIuc2hyX3UgKGxvY2FsLmdldCAkaW50KSAoaTMyLmNvbnN0IDI0KSkgKGkzMi5jb25zdCAweGZmKSkgOzsgNyAtPiAwXFxuICAgICAgKGkzMi5hbmQgKGkzMi5zaHJfdSAobG9jYWwuZ2V0ICRpbnQpIChpMzIuY29uc3QgOCkpIChpMzIuY29uc3QgMHhmZjAwKSkpIDs7IDYgLT4gMVxcbiAgICAoaTMyLm9yXFxuICAgICAgKGkzMi5hbmQgKGkzMi5zaGwgKGxvY2FsLmdldCAkaW50KSAoaTMyLmNvbnN0IDgpKSAoaTMyLmNvbnN0IDB4ZmYwMDAwKSkgOzsgNSAtPiAyXFxuICAgICAgKGkzMi5hbmQgKGkzMi5zaGwgKGxvY2FsLmdldCAkaW50KSAoaTMyLmNvbnN0IDI0KSkgKGkzMi5jb25zdCAweGZmMDAwMDAwKSkpKSA7OyA0IC0+IDNcXG4pXFxuXCJcbiAgfSxcbiAgXCJic3dhcF9pNjRcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRic3dhcF9pNjRcXG4gIChwYXJhbSAkaW50IGk2NClcXG4gIChyZXN1bHQgaTY0KVxcblxcbiAgKGk2NC5vclxcbiAgICAoaTY0Lm9yXFxuICAgICAgKGk2NC5vclxcbiAgICAgICAgKGk2NC5hbmQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRpbnQpIChpNjQuY29uc3QgNTYpKSAoaTY0LmNvbnN0IDB4ZmYpKSA7OyA3IC0+IDBcXG4gICAgICAgIChpNjQuYW5kIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaW50KSAoaTY0LmNvbnN0IDQwKSkgKGk2NC5jb25zdCAweGZmMDApKSkgOzsgNiAtPiAxXFxuICAgICAgKGk2NC5vclxcbiAgICAgICAgKGk2NC5hbmQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRpbnQpIChpNjQuY29uc3QgMjQpKSAoaTY0LmNvbnN0IDB4ZmYwMDAwKSkgOzsgNSAtPiAyXFxuICAgICAgICAoaTY0LmFuZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGludCkgKGk2NC5jb25zdCAgOCkpIChpNjQuY29uc3QgMHhmZjAwMDAwMCkpKSkgOzsgNCAtPiAzXFxuICAgIChpNjQub3JcXG4gICAgICAoaTY0Lm9yXFxuICAgICAgICAoaTY0LmFuZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRpbnQpIChpNjQuY29uc3QgOCkpICAgKGk2NC5jb25zdCAweGZmMDAwMDAwMDApKSA7OyAzIC0+IDRcXG4gICAgICAgIChpNjQuYW5kIChpNjQuc2hsIChsb2NhbC5nZXQgJGludCkgKGk2NC5jb25zdCAyNCkpICAgKGk2NC5jb25zdCAweGZmMDAwMDAwMDAwMCkpKSA7OyAyIC0+IDVcXG4gICAgICAoaTY0Lm9yXFxuICAgICAgICAoaTY0LmFuZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRpbnQpIChpNjQuY29uc3QgNDApKSAgIChpNjQuY29uc3QgMHhmZjAwMDAwMDAwMDAwMCkpIDs7IDEgLT4gNlxcbiAgICAgICAgKGk2NC5hbmQgKGk2NC5zaGwgKGxvY2FsLmdldCAkaW50KSAoaTY0LmNvbnN0IDU2KSkgICAoaTY0LmNvbnN0IDB4ZmYwMDAwMDAwMDAwMDAwMCkpKSkpIDs7IDAgLT4gN1xcbilcXG5cIlxuICB9LFxuICBcImJzd2FwX20xMjhcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRic3dhcF9tMTI4XFxuICAocGFyYW0gJHNwIGkzMilcXG4gIChyZXN1bHQgaTMyKVxcbiAgKGxvY2FsICR0ZW1wIGk2NClcXG5cXG4gIChsb2NhbC5zZXQgJHRlbXAgKGNhbGwgJGJzd2FwX2k2NCAoaTY0LmxvYWQgKGxvY2FsLmdldCAkc3ApKSkpXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKSAoY2FsbCAkYnN3YXBfaTY0IChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpIChsb2NhbC5nZXQgJHRlbXApKVxcbiAgKGxvY2FsLmdldCAkc3ApXFxuKVxcblwiXG4gIH0sXG4gIFwiYnN3YXBfbTE2MFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGJzd2FwX20xNjBcXG4gIChwYXJhbSAkc3AgaTMyKVxcbiAgKHJlc3VsdCBpMzIpXFxuICAobG9jYWwgJHRlbXAgaTY0KVxcblxcbiAgKGxvY2FsLnNldCAkdGVtcCAoY2FsbCAkYnN3YXBfaTY0IChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKSlcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkc3ApIChjYWxsICRic3dhcF9pNjQgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDEyKSkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTIpKSAobG9jYWwuZ2V0ICR0ZW1wKSlcXG5cXG4gIChpMzIuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpIChjYWxsICRic3dhcF9pMzIgKGkzMi5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSkpKVxcbiAgKGxvY2FsLmdldCAkc3ApXFxuKVxcblwiXG4gIH0sXG4gIFwiYnN3YXBfbTI1NlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGJzd2FwX20yNTZcXG4gIChwYXJhbSAkc3AgaTMyKVxcbiAgKHJlc3VsdCBpMzIpXFxuICAobG9jYWwgJHRlbXAgaTY0KVxcblxcbiAgKGxvY2FsLnNldCAkdGVtcCAoY2FsbCAkYnN3YXBfaTY0IChpNjQubG9hZCAobG9jYWwuZ2V0ICRzcCkpKSlcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkc3ApIChjYWxsICRic3dhcF9pNjQgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMjQpKSAobG9jYWwuZ2V0ICR0ZW1wKSlcXG5cXG4gIChsb2NhbC5zZXQgJHRlbXAgKGNhbGwgJGJzd2FwX2k2NCAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0ICA4KSkgKGNhbGwgJGJzd2FwX2k2NCAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgMTYpKSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChsb2NhbC5nZXQgJHRlbXApKVxcbiAgKGxvY2FsLmdldCAkc3ApXFxuKVxcblwiXG4gIH0sXG4gIFwiY2FsbGJhY2tcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRjYWxsYmFja1xcbiAgKGNhbGwgJG1haW4pXFxuKVxcblwiXG4gIH0sXG4gIFwiY2FsbGJhY2tfMTI4XCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkY2FsbGJhY2tfMTI4XFxuICAocGFyYW0gJHJlc3VsdCBpMzIpXFxuXFxuICAoZHJvcCAoY2FsbCAkYnN3YXBfbTEyOCAoZ2xvYmFsLmdldCAkc3ApKSlcXG4gIChjYWxsICRtYWluKVxcbilcXG5cIlxuICB9LFxuICBcImNhbGxiYWNrXzE2MFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGNhbGxiYWNrXzE2MFxcbiAgKHBhcmFtICRyZXN1bHQgaTMyKVxcblxcbiAgKGRyb3AgKGNhbGwgJGJzd2FwX20xNjAgKGdsb2JhbC5nZXQgJHNwKSkpXFxuICAoY2FsbCAkbWFpbilcXG4pXFxuXCJcbiAgfSxcbiAgXCJjYWxsYmFja18yNTZcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRjYWxsYmFja18yNTZcXG4gIChwYXJhbSAkcmVzdWx0IGkzMilcXG5cXG4gIChkcm9wIChjYWxsICRic3dhcF9tMjU2IChnbG9iYWwuZ2V0ICRzcCkpKVxcbiAgKGNhbGwgJG1haW4pXFxuKVxcblwiXG4gIH0sXG4gIFwiY2FsbGJhY2tfMzJcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRjYWxsYmFja18zMlxcbiAgKHBhcmFtICRyZXN1bHQgaTMyKVxcblxcbiAgKGk2NC5zdG9yZSAoZ2xvYmFsLmdldCAkc3ApIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJHJlc3VsdCkpKVxcbiAgOzsgemVybyBvdXQgbWVtXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChpNjQuY29uc3QgMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChnbG9iYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkgKGk2NC5jb25zdCAwKSlcXG5cXG4gIChjYWxsICRtYWluKVxcbilcXG5cIlxuICB9LFxuICBcImNoZWNrX292ZXJmbG93X2k2NFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGNoZWNrX292ZXJmbG93X2k2NFxcbiAgKHBhcmFtICRhIGk2NClcXG4gIChwYXJhbSAkYiBpNjQpXFxuICAocGFyYW0gJGMgaTY0KVxcbiAgKHBhcmFtICRkIGk2NClcXG4gIChyZXN1bHQgaTY0KVxcblxcbiAgKGlmXFxuICAgIChpMzIuYW5kIFxcbiAgICAgIChpMzIuYW5kIFxcbiAgICAgICAgKGk2NC5lcXogIChsb2NhbC5nZXQgJGQpKVxcbiAgICAgICAgKGk2NC5lcXogIChsb2NhbC5nZXQgJGMpKSlcXG4gICAgICAoaTY0LmVxeiAgKGxvY2FsLmdldCAkYikpKVxcbiAgICAocmV0dXJuIChsb2NhbC5nZXQgJGEpKSlcXG5cXG4gICAgKHJldHVybiAoaTY0LmNvbnN0IDB4ZmZmZmZmZmZmZmZmZmZmZikpXFxuKVxcblwiXG4gIH0sXG4gIFwiZ3RlXzI1NlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgaXMgYSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYiAvLyBhID49IGJcXG4oZnVuYyAkZ3RlXzI1NlxcbiAgKHBhcmFtICRhMCBpNjQpXFxuICAocGFyYW0gJGExIGk2NClcXG4gIChwYXJhbSAkYTIgaTY0KVxcbiAgKHBhcmFtICRhMyBpNjQpXFxuXFxuICAocGFyYW0gJGIwIGk2NClcXG4gIChwYXJhbSAkYjEgaTY0KVxcbiAgKHBhcmFtICRiMiBpNjQpXFxuICAocGFyYW0gJGIzIGk2NClcXG5cXG4gIChyZXN1bHQgaTMyKVxcblxcbiAgOzsgYTAgPiBiMCB8fCBbYTAgPT0gYjAgJiYgW2ExID4gYjEgfHwgW2ExID09IGIxICYmIFthMiA+IGIyIHx8IFthMiA9PSBiMiAmJiBhMyA+PSBiMyBdXV1dXFxuICAoaTMyLm9yICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYTApIChsb2NhbC5nZXQgJGIwKSkgOzsgYTAgPiBiMFxcbiAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGEwKSAobG9jYWwuZ2V0ICRiMCkpXFxuICAoaTMyLm9yICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYTEpIChsb2NhbC5nZXQgJGIxKSkgOzsgYTEgPiBiMVxcbiAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID09IGIxXFxuICAoaTMyLm9yICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYTIpIChsb2NhbC5nZXQgJGIyKSkgOzsgYTIgPiBiMlxcbiAgKGkzMi5hbmQgKGk2NC5lcSAgIChsb2NhbC5nZXQgJGEyKSAobG9jYWwuZ2V0ICRiMikpXFxuICAgICAgICAgICAoaTY0LmdlX3UgKGxvY2FsLmdldCAkYTMpIChsb2NhbC5nZXQgJGIzKSkpKSkpKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJndGVfMzIwXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkZ3RlXzMyMFxcbiAgKHBhcmFtICRhMCBpNjQpXFxuICAocGFyYW0gJGExIGk2NClcXG4gIChwYXJhbSAkYTIgaTY0KVxcbiAgKHBhcmFtICRhMyBpNjQpXFxuICAocGFyYW0gJGE0IGk2NClcXG5cXG4gIChwYXJhbSAkYjAgaTY0KVxcbiAgKHBhcmFtICRiMSBpNjQpXFxuICAocGFyYW0gJGIyIGk2NClcXG4gIChwYXJhbSAkYjMgaTY0KVxcbiAgKHBhcmFtICRiNCBpNjQpXFxuXFxuICAocmVzdWx0IGkzMilcXG5cXG4gIDs7IGEwID4gYjAgfHwgW2EwID09IGIwICYmIFthMSA+IGIxIHx8IFthMSA9PSBiMSAmJiBbYTIgPiBiMiB8fCBbYTIgPT0gYjIgJiYgYTMgPj0gYjMgXV1dXVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGEwKSAobG9jYWwuZ2V0ICRiMCkpIDs7IGEwID4gYjBcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMCkgKGxvY2FsLmdldCAkYjApKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID4gYjFcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpKSA7OyBhMSA9PSBiMVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGEyKSAobG9jYWwuZ2V0ICRiMikpIDs7IGEyID4gYjJcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGEzKSAobG9jYWwuZ2V0ICRiMykpIDs7IGEyID4gYjJcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMykgKGxvY2FsLmdldCAkYjMpKVxcbiAgICAgICAgICAgKGk2NC5nZV91IChsb2NhbC5nZXQgJGE0KSAobG9jYWwuZ2V0ICRiNCkpKSkpKSkpKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJndGVfNTEyXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkZ3RlXzUxMlxcbiAgKHBhcmFtICRhMCBpNjQpXFxuICAocGFyYW0gJGExIGk2NClcXG4gIChwYXJhbSAkYTIgaTY0KVxcbiAgKHBhcmFtICRhMyBpNjQpXFxuICAocGFyYW0gJGE0IGk2NClcXG4gIChwYXJhbSAkYTUgaTY0KVxcbiAgKHBhcmFtICRhNiBpNjQpXFxuICAocGFyYW0gJGE3IGk2NClcXG5cXG4gIChwYXJhbSAkYjAgaTY0KVxcbiAgKHBhcmFtICRiMSBpNjQpXFxuICAocGFyYW0gJGIyIGk2NClcXG4gIChwYXJhbSAkYjMgaTY0KVxcbiAgKHBhcmFtICRiNCBpNjQpXFxuICAocGFyYW0gJGI1IGk2NClcXG4gIChwYXJhbSAkYjYgaTY0KVxcbiAgKHBhcmFtICRiNyBpNjQpXFxuXFxuICAocmVzdWx0IGkzMilcXG5cXG4gIDs7IGEwID4gYjAgfHwgW2EwID09IGIwICYmIFthMSA+IGIxIHx8IFthMSA9PSBiMSAmJiBbYTIgPiBiMiB8fCBbYTIgPT0gYjIgJiYgYTMgPj0gYjMgXV1dXVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGEwKSAobG9jYWwuZ2V0ICRiMCkpIDs7IGEwID4gYjBcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMCkgKGxvY2FsLmdldCAkYjApKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkpIDs7IGExID4gYjFcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpKSA7OyBhMSA9PSBiMVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGEyKSAobG9jYWwuZ2V0ICRiMikpIDs7IGEyID4gYjJcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMikgKGxvY2FsLmdldCAkYjIpKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGEzKSAobG9jYWwuZ2V0ICRiMykpIDs7IGEzID4gYjNcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhMykgKGxvY2FsLmdldCAkYjMpKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGE0KSAobG9jYWwuZ2V0ICRiNCkpIDs7IGE0ID4gYjRcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhNCkgKGxvY2FsLmdldCAkYjQpKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGE1KSAobG9jYWwuZ2V0ICRiNSkpIDs7IGE1ID4gYjVcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhNSkgKGxvY2FsLmdldCAkYjUpKVxcbiAgKGkzMi5vciAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGE2KSAobG9jYWwuZ2V0ICRiNikpIDs7IGE2ID4gYjZcXG4gIChpMzIuYW5kIChpNjQuZXEgICAobG9jYWwuZ2V0ICRhNikgKGxvY2FsLmdldCAkYjYpKVxcbiAgICAgICAgICAgKGk2NC5nZV91IChsb2NhbC5nZXQgJGE3KSAobG9jYWwuZ2V0ICRiNykpKSkpKSkpKSkpKSkpKSlcXG4pXFxuXCJcbiAgfSxcbiAgXCJpc3plcm9fMjU2XCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkaXN6ZXJvXzI1NlxcbiAgKHBhcmFtIGk2NClcXG4gIChwYXJhbSBpNjQpXFxuICAocGFyYW0gaTY0KVxcbiAgKHBhcmFtIGk2NClcXG4gIChyZXN1bHQgaTMyKVxcblxcbiAgKGk2NC5lcXogKGk2NC5vciAoaTY0Lm9yIChpNjQub3IgKGxvY2FsLmdldCAwKSAobG9jYWwuZ2V0IDEpKSAobG9jYWwuZ2V0IDIpKSAobG9jYWwuZ2V0IDMpKSkgXFxuKVxcblwiXG4gIH0sXG4gIFwiaXN6ZXJvXzMyMFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGlzemVyb18zMjBcXG4gIChwYXJhbSBpNjQpXFxuICAocGFyYW0gaTY0KVxcbiAgKHBhcmFtIGk2NClcXG4gIChwYXJhbSBpNjQpXFxuICAocGFyYW0gaTY0KVxcbiAgKHJlc3VsdCBpMzIpXFxuXFxuICAoaTY0LmVxeiAoaTY0Lm9yIChpNjQub3IgKGk2NC5vciAoaTY0Lm9yIChsb2NhbC5nZXQgMCkgKGxvY2FsLmdldCAxKSkgKGxvY2FsLmdldCAyKSkgKGxvY2FsLmdldCAzKSkgKGxvY2FsLmdldCA0KSkpXFxuKVxcblwiXG4gIH0sXG4gIFwiaXN6ZXJvXzUxMlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiKGZ1bmMgJGlzemVyb181MTJcXG4gIChwYXJhbSBpNjQpXFxuICAocGFyYW0gaTY0KVxcbiAgKHBhcmFtIGk2NClcXG4gIChwYXJhbSBpNjQpXFxuICAocGFyYW0gaTY0KVxcbiAgKHBhcmFtIGk2NClcXG4gIChwYXJhbSBpNjQpXFxuICAocGFyYW0gaTY0KVxcbiAgKHJlc3VsdCBpMzIpXFxuICAoaTY0LmVxeiAoaTY0Lm9yIChpNjQub3IgKGk2NC5vciAoaTY0Lm9yIChpNjQub3IgKGk2NC5vciAoaTY0Lm9yIChsb2NhbC5nZXQgMCkgKGxvY2FsLmdldCAxKSkgKGxvY2FsLmdldCAyKSkgKGxvY2FsLmdldCAzKSkgKGxvY2FsLmdldCA0KSkgKGxvY2FsLmdldCA1KSkgKGxvY2FsLmdldCA2KSkgKGxvY2FsLmdldCA3KSkpXFxuKVxcblwiXG4gIH0sXG4gIFwia2VjY2FrXCI6IHtcbiAgICBcIndhc3RcIjogXCI7O1xcbjs7IENvcGllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9heGljL2tlY2Nhay13YXNtIChoYXMgbW9yZSBjb21tZW50cylcXG47O1xcblxcbihmdW5jICRrZWNjYWtfdGhldGFcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcblxcbiAgKGxvY2FsICRDMCBpNjQpXFxuICAobG9jYWwgJEMxIGk2NClcXG4gIChsb2NhbCAkQzIgaTY0KVxcbiAgKGxvY2FsICRDMyBpNjQpXFxuICAobG9jYWwgJEM0IGk2NClcXG4gIChsb2NhbCAkRDAgaTY0KVxcbiAgKGxvY2FsICREMSBpNjQpXFxuICAobG9jYWwgJEQyIGk2NClcXG4gIChsb2NhbCAkRDMgaTY0KVxcbiAgKGxvY2FsICRENCBpNjQpXFxuXFxuICA7OyBDW3hdID0gQVt4XSBeIEFbeCArIDVdIF4gQVt4ICsgMTBdIF4gQVt4ICsgMTVdIF4gQVt4ICsgMjBdO1xcbiAgKGxvY2FsLnNldCAkQzBcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMCkpKVxcbiAgICAgIChpNjQueG9yXFxuICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDApKSlcXG4gICAgICAgIChpNjQueG9yXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4MCkpKVxcbiAgICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjApKSlcXG4gICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTYwKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICApXFxuICAgIClcXG4gIClcXG5cXG4gIChsb2NhbC5zZXQgJEMxXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDgpKSlcXG4gICAgICAoaTY0LnhvclxcbiAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDQ4KSkpXFxuICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgODgpKSlcXG4gICAgICAgICAgKGk2NC54b3JcXG4gICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTI4KSkpXFxuICAgICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE2OCkpKVxcbiAgICAgICAgICApXFxuICAgICAgICApXFxuICAgICAgKVxcbiAgICApXFxuICApXFxuXFxuICAobG9jYWwuc2V0ICRDMlxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNikpKVxcbiAgICAgIChpNjQueG9yXFxuICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNTYpKSlcXG4gICAgICAgIChpNjQueG9yXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA5NikpKVxcbiAgICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMzYpKSlcXG4gICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTc2KSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICApXFxuICAgIClcXG4gIClcXG5cXG4gIChsb2NhbC5zZXQgJEMzXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSkpXFxuICAgICAgKGk2NC54b3JcXG4gICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA2NCkpKVxcbiAgICAgICAgKGk2NC54b3JcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEwNCkpKVxcbiAgICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNDQpKSlcXG4gICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTg0KSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICApXFxuICAgIClcXG4gIClcXG5cXG4gIChsb2NhbC5zZXQgJEM0XFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDMyKSkpXFxuICAgICAgKGk2NC54b3JcXG4gICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA3MikpKVxcbiAgICAgICAgKGk2NC54b3JcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDExMikpKVxcbiAgICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNTIpKSlcXG4gICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTkyKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICApXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IERbMF0gPSBST1RMNjQoQ1sxXSwgMSkgXiBDWzRdO1xcbiAgKGxvY2FsLnNldCAkRDBcXG4gICAgKGk2NC54b3JcXG4gICAgICAobG9jYWwuZ2V0ICRDNClcXG4gICAgICAoaTY0LnJvdGxcXG4gICAgICAgIChsb2NhbC5nZXQgJEMxKVxcbiAgICAgICAgKGk2NC5jb25zdCAxKVxcbiAgICAgIClcXG4gICAgKVxcbiAgKVxcblxcbiAgOzsgRFsxXSA9IFJPVEw2NChDWzJdLCAxKSBeIENbMF07XFxuICAobG9jYWwuc2V0ICREMVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChsb2NhbC5nZXQgJEMwKVxcbiAgICAgIChpNjQucm90bFxcbiAgICAgICAgKGxvY2FsLmdldCAkQzIpXFxuICAgICAgICAoaTY0LmNvbnN0IDEpXFxuICAgICAgKVxcbiAgICApXFxuICApXFxuXFxuICA7OyBEWzJdID0gUk9UTDY0KENbM10sIDEpIF4gQ1sxXTtcXG4gIChsb2NhbC5zZXQgJEQyXFxuICAgIChpNjQueG9yXFxuICAgICAgKGxvY2FsLmdldCAkQzEpXFxuICAgICAgKGk2NC5yb3RsXFxuICAgICAgICAobG9jYWwuZ2V0ICRDMylcXG4gICAgICAgIChpNjQuY29uc3QgMSlcXG4gICAgICApXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IERbM10gPSBST1RMNjQoQ1s0XSwgMSkgXiBDWzJdO1xcbiAgKGxvY2FsLnNldCAkRDNcXG4gICAgKGk2NC54b3JcXG4gICAgICAobG9jYWwuZ2V0ICRDMilcXG4gICAgICAoaTY0LnJvdGxcXG4gICAgICAgIChsb2NhbC5nZXQgJEM0KVxcbiAgICAgICAgKGk2NC5jb25zdCAxKVxcbiAgICAgIClcXG4gICAgKVxcbiAgKVxcblxcbiAgOzsgRFs0XSA9IFJPVEw2NChDWzBdLCAxKSBeIENbM107XFxuICAobG9jYWwuc2V0ICRENFxcbiAgICAoaTY0LnhvclxcbiAgICAgIChsb2NhbC5nZXQgJEMzKVxcbiAgICAgIChpNjQucm90bFxcbiAgICAgICAgKGxvY2FsLmdldCAkQzApXFxuICAgICAgICAoaTY0LmNvbnN0IDEpXFxuICAgICAgKVxcbiAgICApXFxuICApXFxuXFxuICA7OyBBW3hdICAgICAgXj0gRFt4XTtcXG4gIDs7IEFbeCArIDVdICBePSBEW3hdO1xcbiAgOzsgQVt4ICsgMTBdIF49IERbeF07XFxuICA7OyBBW3ggKyAxNV0gXj0gRFt4XTtcXG4gIDs7IEFbeCArIDIwXSBePSBEW3hdO1xcbiAgXFxuICA7OyB4ID0gMFxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAwKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMCkpKVxcbiAgICAgIChsb2NhbC5nZXQgJEQwKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDQwKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDApKSlcXG4gICAgICAobG9jYWwuZ2V0ICREMClcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4MCkpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDgwKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDApXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTIwKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTIwKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDApXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTYwKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTYwKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDApXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IHggPSAxXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDgpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDEpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDgpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA0OCkpKVxcbiAgICAgIChsb2NhbC5nZXQgJEQxKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDg4KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgODgpKSlcXG4gICAgICAobG9jYWwuZ2V0ICREMSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjgpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjgpKSlcXG4gICAgICAobG9jYWwuZ2V0ICREMSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNjgpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNjgpKSlcXG4gICAgICAobG9jYWwuZ2V0ICREMSlcXG4gICAgKVxcbiAgKVxcblxcbiAgOzsgeCA9IDJcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTYpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNikpKVxcbiAgICAgIChsb2NhbC5nZXQgJEQyKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDU2KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNTYpKSlcXG4gICAgICAobG9jYWwuZ2V0ICREMilcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA5NikpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDk2KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDIpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTM2KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTM2KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDIpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTc2KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTc2KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDIpXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IHggPSAzXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMjQpKSlcXG4gICAgICAobG9jYWwuZ2V0ICREMylcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA2NCkpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDY0KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDMpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTA0KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTA0KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDMpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTQ0KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTQ0KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDMpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTg0KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTg0KSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDMpXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IHggPSA0XFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDMyKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMzIpKSlcXG4gICAgICAobG9jYWwuZ2V0ICRENClcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA3MikpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDcyKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDQpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTEyKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTEyKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDQpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTUyKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTUyKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDQpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTkyKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTkyKSkpXFxuICAgICAgKGxvY2FsLmdldCAkRDQpXFxuICAgIClcXG4gIClcXG4pXFxuXFxuKGZ1bmMgJGtlY2Nha19yaG9cXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcbiAgKHBhcmFtICRyb3RhdGlvbl9jb25zdHMgaTMyKVxcblxcbiAgOzsobG9jYWwgJHRtcCBpMzIpXFxuXFxuICA7OyBzdGF0ZVsgMV0gPSBST1RMNjQoc3RhdGVbIDFdLCAgMSk7XFxuICA7Oyhsb2NhbC5zZXQgJHRtcCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxKSkpXFxuICA7OyhpNjQuc3RvcmUgKGxvY2FsLmdldCAkdG1wKSAoaTY0LnJvdGwgKGk2NC5sb2FkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICA7Oyhsb2NhbC5zZXQgJHRtcCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAyKSkpXFxuICA7OyhpNjQuc3RvcmUgKGxvY2FsLmdldCAkdG1wKSAoaTY0LnJvdGwgKGk2NC5sb2FkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSkgKGk2NC5jb25zdCA2MikpKVxcblxcbiAgKGxvY2FsICR0bXAgaTMyKVxcbiAgKGxvY2FsICRpIGkzMilcXG5cXG4gIDs7IGZvciAoaSA9IDA7IGkgPD0gMjQ7IGkrKylcXG4gIChsb2NhbC5zZXQgJGkgKGkzMi5jb25zdCAwKSlcXG4gIChibG9jayAkZG9uZVxcbiAgICAobG9vcCAkbG9vcFxcbiAgICAgIChpZiAoaTMyLmdlX3UgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCAyNCkpXFxuICAgICAgICAoYnIgJGRvbmUpXFxuICAgICAgKVxcblxcbiAgICAgIChsb2NhbC5zZXQgJHRtcCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAoaTMyLmNvbnN0IDEpIChsb2NhbC5nZXQgJGkpKSkpKVxcblxcbiAgICAgIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkdG1wKSAoaTY0LnJvdGwgKGk2NC5sb2FkIChsb2NhbC5nZXQgJHRtcCkpIChpNjQubG9hZDhfdSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChsb2NhbC5nZXQgJGkpKSkpKVxcblxcbiAgICAgIChsb2NhbC5zZXQgJGkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCAxKSkpXFxuICAgICAgKGJyICRsb29wKVxcbiAgICApXFxuICApXFxuKVxcblxcbihmdW5jICRrZWNjYWtfcGlcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcblxcbiAgKGxvY2FsICRBMSBpNjQpXFxuICAobG9jYWwuc2V0ICRBMSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgOCkpKSlcXG5cXG4gIDs7IFN3YXAgbm9uLW92ZXJsYXBwaW5nIGZpZWxkcywgaS5lLiAkQTEgPSAkQTYsIGV0Yy5cXG4gIDs7IE5PVEU6ICRBMCBpcyB1bnRvdWNoZWRcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgOCkpIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA0OCkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDgpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNzIpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDcyKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE3NikpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTc2KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDExMikpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTEyKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE2MCkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTYwKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNikpIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA5NikpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgOTYpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTA0KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMDQpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTUyKSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNTIpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTg0KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxODQpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTIwKSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjApKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMzIpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDMyKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE5MikpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTkyKSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE2OCkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTY4KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDY0KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA2NCkpIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjgpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEyOCkpIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA0MCkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDApKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMjQpKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE0NCkpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTQ0KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEzNikpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTM2KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDg4KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4OCkpIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA1NikpKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNTYpKSAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgODApKSkpXFxuXFxuICA7OyBQbGFjZSB0aGUgcHJldmlvdXNseSBzYXZlZCBvdmVybGFwcGluZyBmaWVsZFxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4MCkpIChsb2NhbC5nZXQgJEExKSlcXG4pXFxuXFxuKGZ1bmMgJGtlY2Nha19jaGlcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcblxcbiAgKGxvY2FsICRBMCBpNjQpXFxuICAobG9jYWwgJEExIGk2NClcXG4gIChsb2NhbCAkaSBpMzIpXFxuXFxuICA7OyBmb3IgKHJvdW5kID0gMDsgcm91bmQgPCAyNTsgaSArPSA1KVxcbiAgKGxvY2FsLnNldCAkaSAoaTMyLmNvbnN0IDApKVxcbiAgKGJsb2NrICRkb25lXFxuICAgIChsb29wICRsb29wXFxuICAgICAgKGlmIChpMzIuZ2VfdSAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDI1KSlcXG4gICAgICAgIChiciAkZG9uZSlcXG4gICAgICApXFxuXFxuICAgICAgKGxvY2FsLnNldCAkQTAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChsb2NhbC5nZXQgJGkpKSkpKVxcbiAgICAgIChsb2NhbC5zZXQgJEExIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDEpKSkpKSlcXG5cXG4gICAgICA7OyBBWzAgKyBpXSBePSB+QTEgJiBBWzIgKyBpXTtcXG4gICAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChsb2NhbC5nZXQgJGkpKSlcXG4gICAgICAgIChpNjQueG9yXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAobG9jYWwuZ2V0ICRpKSkpKVxcbiAgICAgICAgICAoaTY0LmFuZFxcbiAgICAgICAgICAgIChpNjQueG9yIChsb2NhbC5nZXQgJEExKSAoaTY0LmNvbnN0IDB4RkZGRkZGRkZGRkZGRkZGRikpIDs7IGJpdHdpc2Ugbm90XFxuICAgICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChpMzIuYWRkIChsb2NhbC5nZXQgJGkpIChpMzIuY29uc3QgMikpKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICApXFxuXFxuICAgICAgOzsgQVsxICsgaV0gXj0gfkFbMiArIGldICYgQVszICsgaV07XFxuICAgICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDEpKSkpXFxuICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIubXVsIChpMzIuY29uc3QgOCkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCAxKSkpKSlcXG4gICAgICAgICAgKGk2NC5hbmRcXG4gICAgICAgICAgICAoaTY0LnhvciAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIubXVsIChpMzIuY29uc3QgOCkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCAyKSkpKSkgKGk2NC5jb25zdCAweEZGRkZGRkZGRkZGRkZGRkYpKSA7OyBiaXR3aXNlIG5vdFxcbiAgICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDMpKSkpKVxcbiAgICAgICAgICApXFxuICAgICAgICApXFxuICAgICAgKVxcblxcbiAgICAgIDs7IEFbMiArIGldIF49IH5BWzMgKyBpXSAmIEFbNCArIGldO1xcbiAgICAgIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIubXVsIChpMzIuY29uc3QgOCkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCAyKSkpKVxcbiAgICAgICAgKGk2NC54b3JcXG4gICAgICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChpMzIuYWRkIChsb2NhbC5nZXQgJGkpIChpMzIuY29uc3QgMikpKSkpXFxuICAgICAgICAgIChpNjQuYW5kXFxuICAgICAgICAgICAgKGk2NC54b3IgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChpMzIuYWRkIChsb2NhbC5nZXQgJGkpIChpMzIuY29uc3QgMykpKSkpIChpNjQuY29uc3QgMHhGRkZGRkZGRkZGRkZGRkZGKSkgOzsgYml0d2lzZSBub3RcXG4gICAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIubXVsIChpMzIuY29uc3QgOCkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCA0KSkpKSlcXG4gICAgICAgICAgKVxcbiAgICAgICAgKVxcbiAgICAgIClcXG5cXG4gICAgICA7OyBBWzMgKyBpXSBePSB+QVs0ICsgaV0gJiBBMDtcXG4gICAgICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChpMzIuYWRkIChsb2NhbC5nZXQgJGkpIChpMzIuY29uc3QgMykpKSlcXG4gICAgICAgIChpNjQueG9yXFxuICAgICAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDMpKSkpKVxcbiAgICAgICAgICAoaTY0LmFuZFxcbiAgICAgICAgICAgIChpNjQueG9yIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDQpKSkpKSAoaTY0LmNvbnN0IDB4RkZGRkZGRkZGRkZGRkZGRikpIDs7IGJpdHdpc2Ugbm90XFxuICAgICAgICAgICAgKGxvY2FsLmdldCAkQTApXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICApXFxuXFxuICAgICAgOzsgQVs0ICsgaV0gXj0gfkEwICYgQTE7XFxuICAgICAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA4KSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDQpKSkpXFxuICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIubXVsIChpMzIuY29uc3QgOCkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCA0KSkpKSlcXG4gICAgICAgICAgKGk2NC5hbmRcXG4gICAgICAgICAgICAoaTY0LnhvciAobG9jYWwuZ2V0ICRBMCkgKGk2NC5jb25zdCAweEZGRkZGRkZGRkZGRkZGRkYpKSA7OyBiaXR3aXNlIG5vdFxcbiAgICAgICAgICAgIChsb2NhbC5nZXQgJEExKVxcbiAgICAgICAgICApXFxuICAgICAgICApXFxuICAgICAgKVxcblxcbiAgICAgIChsb2NhbC5zZXQgJGkgKGkzMi5hZGQgKGxvY2FsLmdldCAkaSkgKGkzMi5jb25zdCA1KSkpXFxuICAgICAgKGJyICRsb29wKVxcbiAgICApXFxuICApXFxuKVxcblxcbihmdW5jICRrZWNjYWtfcGVybXV0ZVxcbiAgKHBhcmFtICRjb250ZXh0X29mZnNldCBpMzIpXFxuXFxuICAobG9jYWwgJHJvdGF0aW9uX2NvbnN0cyBpMzIpXFxuICAobG9jYWwgJHJvdW5kX2NvbnN0cyBpMzIpXFxuICAobG9jYWwgJHJvdW5kIGkzMilcXG5cXG4gIChsb2NhbC5zZXQgJHJvdW5kX2NvbnN0cyAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA0MDApKSlcXG4gIChsb2NhbC5zZXQgJHJvdGF0aW9uX2NvbnN0cyAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA1OTIpKSlcXG5cXG4gIDs7IGZvciAocm91bmQgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKVxcbiAgKGxvY2FsLnNldCAkcm91bmQgKGkzMi5jb25zdCAwKSlcXG4gIChibG9jayAkZG9uZVxcbiAgICAobG9vcCAkbG9vcFxcbiAgICAgIChpZiAoaTMyLmdlX3UgKGxvY2FsLmdldCAkcm91bmQpIChpMzIuY29uc3QgMjQpKVxcbiAgICAgICAgKGJyICRkb25lKVxcbiAgICAgIClcXG5cXG4gICAgICA7OyB0aGV0YSB0cmFuc2Zvcm1cXG4gICAgICAoY2FsbCAka2VjY2FrX3RoZXRhIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSlcXG5cXG4gICAgICA7OyByaG8gdHJhbnNmb3JtXFxuICAgICAgKGNhbGwgJGtlY2Nha19yaG8gKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykpXFxuXFxuICAgICAgOzsgcGkgdHJhbnNmb3JtXFxuICAgICAgKGNhbGwgJGtlY2Nha19waSAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkpXFxuXFxuICAgICAgOzsgY2hpIHRyYW5zZm9ybVxcbiAgICAgIChjYWxsICRrZWNjYWtfY2hpIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSlcXG5cXG4gICAgICA7OyBpb3RhIHRyYW5zZm9ybVxcbiAgICAgIDs7IGNvbnRleHRfb2Zmc2V0WzBdIF49IEtFQ0NBS19ST1VORF9DT05TVEFOVFNbcm91bmRdO1xcbiAgICAgIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpXFxuICAgICAgICAoaTY0LnhvclxcbiAgICAgICAgICAoaTY0LmxvYWQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpKVxcbiAgICAgICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkcm91bmRfY29uc3RzKSAoaTMyLm11bCAoaTMyLmNvbnN0IDgpIChsb2NhbC5nZXQgJHJvdW5kKSkpKVxcbiAgICAgICAgKVxcbiAgICAgIClcXG5cXG4gICAgICAobG9jYWwuc2V0ICRyb3VuZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3VuZCkgKGkzMi5jb25zdCAxKSkpXFxuICAgICAgKGJyICRsb29wKVxcbiAgICApICBcXG4gICkgXFxuKVxcblxcbihmdW5jICRrZWNjYWtfYmxvY2tcXG4gIChwYXJhbSAkaW5wdXRfb2Zmc2V0IGkzMilcXG4gIChwYXJhbSAkaW5wdXRfbGVuZ3RoIGkzMikgOzsgaWdub3JlZCwgd2UgZXhwZWN0IGtlY2NhazI1NlxcbiAgKHBhcmFtICRjb250ZXh0X29mZnNldCBpMzIpXFxuXFxuICA7OyByZWFkIGJsb2NrcyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIGFuZCBYT1IgYWdhaW5zdCBjb250ZXh0X29mZnNldFxcblxcbiAgKGk2NC5zdG9yZVxcbiAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAwKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMCkpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgMCkpKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlXFxuICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDgpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4KSkpXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCA4KSkpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmVcXG4gICAgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTYpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxNikpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgMTYpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZVxcbiAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAyNCkpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSkpXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCAyNCkpKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlXFxuICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDMyKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMzIpKSlcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkaW5wdXRfb2Zmc2V0KSAoaTMyLmNvbnN0IDMyKSkpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmVcXG4gICAgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDApKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA0MCkpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgNDApKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZVxcbiAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA0OCkpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDQ4KSkpXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCA0OCkpKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlXFxuICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDU2KSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNTYpKSlcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkaW5wdXRfb2Zmc2V0KSAoaTMyLmNvbnN0IDU2KSkpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmVcXG4gICAgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNjQpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA2NCkpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgNjQpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZVxcbiAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA3MikpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDcyKSkpXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCA3MikpKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlXFxuICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDgwKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgODApKSlcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkaW5wdXRfb2Zmc2V0KSAoaTMyLmNvbnN0IDgwKSkpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmVcXG4gICAgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgODgpKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4OCkpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgODgpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZVxcbiAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA5NikpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDk2KSkpXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCA5NikpKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlXFxuICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEwNCkpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEwNCkpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgMTA0KSkpXFxuICAgIClcXG4gIClcXG5cXG4gIChpNjQuc3RvcmVcXG4gICAgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTEyKSlcXG4gICAgKGk2NC54b3JcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMTEyKSkpXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCAxMTIpKSlcXG4gICAgKVxcbiAgKVxcblxcbiAgKGk2NC5zdG9yZVxcbiAgICAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjApKVxcbiAgICAoaTY0LnhvclxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAxMjApKSlcXG4gICAgICAoaTY0LmxvYWQgKGkzMi5hZGQgKGxvY2FsLmdldCAkaW5wdXRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEyMCkpKVxcbiAgICApXFxuICApXFxuXFxuICAoaTY0LnN0b3JlXFxuICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEyOCkpXFxuICAgIChpNjQueG9yXFxuICAgICAgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDEyOCkpKVxcbiAgICAgIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgMTI4KSkpXFxuICAgIClcXG4gIClcXG4gIFxcbiAgKGNhbGwgJGtlY2Nha19wZXJtdXRlIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSlcXG4pXFxuXFxuOztcXG47OyBJbml0aWFsaXNlIHRoZSBjb250ZXh0XFxuOztcXG4oZnVuYyAka2VjY2FrX2luaXRcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcbiAgKGxvY2FsICRyb3VuZF9jb25zdHMgaTMyKVxcbiAgKGxvY2FsICRyb3RhdGlvbl9jb25zdHMgaTMyKVxcblxcbiAgKGNhbGwgJGtlY2Nha19yZXNldCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkpXFxuXFxuICA7OyBpbnNlcnQgdGhlIHJvdW5kIGNvbnN0YW50cyAodXNlZCBieSAkS0VDQ0FLX0lPVEEpXFxuICAobG9jYWwuc2V0ICRyb3VuZF9jb25zdHMgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgNDAwKSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAwKSkgKGk2NC5jb25zdCAweDAwMDAwMDAwMDAwMDAwMDEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3VuZF9jb25zdHMpIChpMzIuY29uc3QgOCkpIChpNjQuY29uc3QgMHgwMDAwMDAwMDAwMDA4MDgyKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkcm91bmRfY29uc3RzKSAoaTMyLmNvbnN0IDE2KSkgKGk2NC5jb25zdCAweDgwMDAwMDAwMDAwMDgwOEEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3VuZF9jb25zdHMpIChpMzIuY29uc3QgMjQpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDA4MDAwODAwMCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAzMikpIChpNjQuY29uc3QgMHgwMDAwMDAwMDAwMDA4MDhCKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkcm91bmRfY29uc3RzKSAoaTMyLmNvbnN0IDQwKSkgKGk2NC5jb25zdCAweDAwMDAwMDAwODAwMDAwMDEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3VuZF9jb25zdHMpIChpMzIuY29uc3QgNDgpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDA4MDAwODA4MSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCA1NikpIChpNjQuY29uc3QgMHg4MDAwMDAwMDAwMDA4MDA5KSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkcm91bmRfY29uc3RzKSAoaTMyLmNvbnN0IDY0KSkgKGk2NC5jb25zdCAweDAwMDAwMDAwMDAwMDAwOEEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3VuZF9jb25zdHMpIChpMzIuY29uc3QgNzIpKSAoaTY0LmNvbnN0IDB4MDAwMDAwMDAwMDAwMDA4OCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCA4MCkpIChpNjQuY29uc3QgMHgwMDAwMDAwMDgwMDA4MDA5KSlcXG4gIChpNjQuc3RvcmUgKGkzMi5hZGQgKGxvY2FsLmdldCAkcm91bmRfY29uc3RzKSAoaTMyLmNvbnN0IDg4KSkgKGk2NC5jb25zdCAweDAwMDAwMDAwODAwMDAwMEEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3VuZF9jb25zdHMpIChpMzIuY29uc3QgOTYpKSAoaTY0LmNvbnN0IDB4MDAwMDAwMDA4MDAwODA4QikpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxMDQpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDAwMDAwMDA4QikpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxMTIpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDAwMDAwODA4OSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxMjApKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDAwMDAwODAwMykpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxMjgpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDAwMDAwODAwMikpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxMzYpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDAwMDAwMDA4MCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxNDQpKSAoaTY0LmNvbnN0IDB4MDAwMDAwMDAwMDAwODAwQSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxNTIpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDA4MDAwMDAwQSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxNjApKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDA4MDAwODA4MSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxNjgpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDAwMDAwODA4MCkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxNzYpKSAoaTY0LmNvbnN0IDB4MDAwMDAwMDA4MDAwMDAwMSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdW5kX2NvbnN0cykgKGkzMi5jb25zdCAxODQpKSAoaTY0LmNvbnN0IDB4ODAwMDAwMDA4MDAwODAwOCkpXFxuXFxuICA7OyBpbnNlcnQgdGhlIHJvdGF0aW9uIGNvbnN0YW50cyAodXNlZCBieSAka2VjY2FrX3JobylcXG4gIChsb2NhbC5zZXQgJHJvdGF0aW9uX2NvbnN0cyAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA1OTIpKSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAwKSkgKGkzMi5jb25zdCAxKSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAxKSkgKGkzMi5jb25zdCA2MikpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgMikpIChpMzIuY29uc3QgMjgpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDMpKSAoaTMyLmNvbnN0IDI3KSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCA0KSkgKGkzMi5jb25zdCAzNikpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgNSkpIChpMzIuY29uc3QgNDQpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDYpKSAoaTMyLmNvbnN0IDYpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDcpKSAoaTMyLmNvbnN0IDU1KSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCA4KSkgKGkzMi5jb25zdCAyMCkpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgOSkpIChpMzIuY29uc3QgMykpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgMTApKSAoaTMyLmNvbnN0IDEwKSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAxMSkpIChpMzIuY29uc3QgNDMpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDEyKSkgKGkzMi5jb25zdCAyNSkpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgMTMpKSAoaTMyLmNvbnN0IDM5KSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAxNCkpIChpMzIuY29uc3QgNDEpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDE1KSkgKGkzMi5jb25zdCA0NSkpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgMTYpKSAoaTMyLmNvbnN0IDE1KSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAxNykpIChpMzIuY29uc3QgMjEpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDE4KSkgKGkzMi5jb25zdCA4KSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAxOSkpIChpMzIuY29uc3QgMTgpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDIwKSkgKGkzMi5jb25zdCAyKSlcXG4gIChpMzIuc3RvcmU4IChpMzIuYWRkIChsb2NhbC5nZXQgJHJvdGF0aW9uX2NvbnN0cykgKGkzMi5jb25zdCAyMSkpIChpMzIuY29uc3QgNjEpKVxcbiAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkcm90YXRpb25fY29uc3RzKSAoaTMyLmNvbnN0IDIyKSkgKGkzMi5jb25zdCA1NikpXFxuICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyb3RhdGlvbl9jb25zdHMpIChpMzIuY29uc3QgMjMpKSAoaTMyLmNvbnN0IDE0KSlcXG4pXFxuXFxuOztcXG47OyBSZXNldCB0aGUgY29udGV4dFxcbjs7XFxuKGZ1bmMgJGtlY2Nha19yZXNldFxcbiAgKHBhcmFtICRjb250ZXh0X29mZnNldCBpMzIpXFxuXFxuICA7OyBjbGVhciBvdXQgdGhlIGNvbnRleHQgbWVtb3J5XFxuICAoZHJvcCAoY2FsbCAkbWVtc2V0IChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDApIChpMzIuY29uc3QgNDAwKSkpXFxuKVxcblxcbjs7XFxuOzsgUHVzaCBpbnB1dCB0byB0aGUgY29udGV4dFxcbjs7XFxuKGZ1bmMgJGtlY2Nha191cGRhdGVcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcbiAgKHBhcmFtICRpbnB1dF9vZmZzZXQgaTMyKVxcbiAgKHBhcmFtICRpbnB1dF9sZW5ndGggaTMyKVxcblxcbiAgKGxvY2FsICRyZXNpZHVlX29mZnNldCBpMzIpXFxuICAobG9jYWwgJHJlc2lkdWVfYnVmZmVyIGkzMilcXG4gIChsb2NhbCAkcmVzaWR1ZV9pbmRleCBpMzIpXFxuICAobG9jYWwgJHRtcCBpMzIpXFxuXFxuICA7OyB0aGlzIGlzIHdoZXJlIHdlIHN0b3JlIHRoZSBwb2ludGVyXFxuICAobG9jYWwuc2V0ICRyZXNpZHVlX29mZnNldCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCAyMDApKSlcXG4gIDs7IHRoaXMgaXMgd2hlcmUgdGhlIGJ1ZmZlciBpc1xcbiAgKGxvY2FsLnNldCAkcmVzaWR1ZV9idWZmZXIgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMjA4KSkpXFxuXFxuICAobG9jYWwuc2V0ICRyZXNpZHVlX2luZGV4IChpMzIubG9hZCAobG9jYWwuZ2V0ICRyZXNpZHVlX29mZnNldCkpKVxcblxcbiAgOzsgcHJvY2VzcyByZXNpZHVlIGZyb20gbGFzdCBibG9ja1xcbiAgKGlmIChpMzIubmUgKGxvY2FsLmdldCAkcmVzaWR1ZV9pbmRleCkgKGkzMi5jb25zdCAwKSlcXG4gICAgKHRoZW5cXG4gICAgICA7OyB0aGUgc3BhY2UgbGVmdCBpbiB0aGUgcmVzaWR1ZSBidWZmZXJcXG4gICAgICAobG9jYWwuc2V0ICR0bXAgKGkzMi5zdWIgKGkzMi5jb25zdCAxMzYpIChsb2NhbC5nZXQgJHJlc2lkdWVfaW5kZXgpKSlcXG5cXG4gICAgICA7OyBsaW1pdCB0byB3aGF0IHdlIGhhdmUgYXMgYW4gaW5wdXRcXG4gICAgICAoaWYgKGkzMi5sdF91IChsb2NhbC5nZXQgJGlucHV0X2xlbmd0aCkgKGxvY2FsLmdldCAkdG1wKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJHRtcCAobG9jYWwuZ2V0ICRpbnB1dF9sZW5ndGgpKVxcbiAgICAgIClcXG5cXG4gICAgICA7OyBmaWxsIHVwIHRoZSByZXNpZHVlIGJ1ZmZlclxcbiAgICAgIChkcm9wIChjYWxsICRtZW1jcHlcXG4gICAgICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJHJlc2lkdWVfYnVmZmVyKSAobG9jYWwuZ2V0ICRyZXNpZHVlX2luZGV4KSlcXG4gICAgICAgIChsb2NhbC5nZXQgJGlucHV0X29mZnNldClcXG4gICAgICAgIChsb2NhbC5nZXQgJHRtcClcXG4gICAgICApKVxcblxcbiAgICAgIChsb2NhbC5zZXQgJHJlc2lkdWVfaW5kZXggKGkzMi5hZGQgKGxvY2FsLmdldCAkcmVzaWR1ZV9pbmRleCkgKGxvY2FsLmdldCAkdG1wKSkpXFxuXFxuICAgICAgOzsgYmxvY2sgY29tcGxldGVcXG4gICAgICAoaWYgKGkzMi5lcSAobG9jYWwuZ2V0ICRyZXNpZHVlX2luZGV4KSAoaTMyLmNvbnN0IDEzNikpXFxuICAgICAgICAoY2FsbCAka2VjY2FrX2Jsb2NrIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCAxMzYpIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSlcXG5cXG4gICAgICAgIChsb2NhbC5zZXQgJHJlc2lkdWVfaW5kZXggKGkzMi5jb25zdCAwKSlcXG4gICAgICApXFxuXFxuICAgICAgKGkzMi5zdG9yZSAobG9jYWwuZ2V0ICRyZXNpZHVlX29mZnNldCkgKGxvY2FsLmdldCAkcmVzaWR1ZV9pbmRleCkpXFxuXFxuICAgICAgKGxvY2FsLnNldCAkaW5wdXRfbGVuZ3RoIChpMzIuc3ViIChsb2NhbC5nZXQgJGlucHV0X2xlbmd0aCkgKGxvY2FsLmdldCAkdG1wKSkpXFxuICAgIClcXG4gIClcXG5cXG4gIDs7IHdoaWxlIChpbnB1dF9sZW5ndGggPiBibG9ja19zaXplKVxcbiAgKGJsb2NrICRkb25lXFxuICAgIChsb29wICRsb29wXFxuICAgICAgKGlmIChpMzIubHRfdSAobG9jYWwuZ2V0ICRpbnB1dF9sZW5ndGgpIChpMzIuY29uc3QgMTM2KSlcXG4gICAgICAgIChiciAkZG9uZSlcXG4gICAgICApXFxuXFxuICAgICAgKGNhbGwgJGtlY2Nha19ibG9jayAobG9jYWwuZ2V0ICRpbnB1dF9vZmZzZXQpIChpMzIuY29uc3QgMTM2KSAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkpXFxuXFxuICAgICAgKGxvY2FsLnNldCAkaW5wdXRfb2Zmc2V0IChpMzIuYWRkIChsb2NhbC5nZXQgJGlucHV0X29mZnNldCkgKGkzMi5jb25zdCAxMzYpKSlcXG4gICAgICAobG9jYWwuc2V0ICRpbnB1dF9sZW5ndGggKGkzMi5zdWIgKGxvY2FsLmdldCAkaW5wdXRfbGVuZ3RoKSAoaTMyLmNvbnN0IDEzNikpKVxcbiAgICAgIChiciAkbG9vcClcXG4gICAgKVxcbiAgKVxcblxcbiAgOzsgY29weSB0byB0aGUgcmVzaWR1ZSBidWZmZXJcXG4gIChpZiAoaTMyLmd0X3UgKGxvY2FsLmdldCAkaW5wdXRfbGVuZ3RoKSAoaTMyLmNvbnN0IDApKVxcbiAgICAodGhlblxcbiAgICAgIChkcm9wIChjYWxsICRtZW1jcHlcXG4gICAgICAgIChpMzIuYWRkIChsb2NhbC5nZXQgJHJlc2lkdWVfYnVmZmVyKSAobG9jYWwuZ2V0ICRyZXNpZHVlX2luZGV4KSlcXG4gICAgICAgIChsb2NhbC5nZXQgJGlucHV0X29mZnNldClcXG4gICAgICAgIChsb2NhbC5nZXQgJGlucHV0X2xlbmd0aClcXG4gICAgICApKVxcblxcbiAgICAgIChsb2NhbC5zZXQgJHJlc2lkdWVfaW5kZXggKGkzMi5hZGQgKGxvY2FsLmdldCAkcmVzaWR1ZV9pbmRleCkgKGxvY2FsLmdldCAkaW5wdXRfbGVuZ3RoKSkpXFxuICAgICAgKGkzMi5zdG9yZSAobG9jYWwuZ2V0ICRyZXNpZHVlX29mZnNldCkgKGxvY2FsLmdldCAkcmVzaWR1ZV9pbmRleCkpXFxuICAgIClcXG4gIClcXG4pXFxuXFxuOztcXG47OyBGaW5hbGlzZSBhbmQgcmV0dXJuIHRoZSBoYXNoXFxuOztcXG47OyBUaGUgMjU2IGJpdCBoYXNoIGlzIHJldHVybmVkIGF0IHRoZSBvdXRwdXQgb2Zmc2V0Llxcbjs7XFxuKGZ1bmMgJGtlY2Nha19maW5pc2hcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcbiAgKHBhcmFtICRvdXRwdXRfb2Zmc2V0IGkzMilcXG5cXG4gIChsb2NhbCAkcmVzaWR1ZV9vZmZzZXQgaTMyKVxcbiAgKGxvY2FsICRyZXNpZHVlX2J1ZmZlciBpMzIpXFxuICAobG9jYWwgJHJlc2lkdWVfaW5kZXggaTMyKVxcbiAgKGxvY2FsICR0bXAgaTMyKVxcblxcbiAgOzsgdGhpcyBpcyB3aGVyZSB3ZSBzdG9yZSB0aGUgcG9pbnRlclxcbiAgKGxvY2FsLnNldCAkcmVzaWR1ZV9vZmZzZXQgKGkzMi5hZGQgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChpMzIuY29uc3QgMjAwKSkpXFxuICA7OyB0aGlzIGlzIHdoZXJlIHRoZSBidWZmZXIgaXNcXG4gIChsb2NhbC5zZXQgJHJlc2lkdWVfYnVmZmVyIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDIwOCkpKVxcblxcbiAgKGxvY2FsLnNldCAkcmVzaWR1ZV9pbmRleCAoaTMyLmxvYWQgKGxvY2FsLmdldCAkcmVzaWR1ZV9vZmZzZXQpKSlcXG4gIChsb2NhbC5zZXQgJHRtcCAobG9jYWwuZ2V0ICRyZXNpZHVlX2luZGV4KSlcXG5cXG4gIDs7IGNsZWFyIHRoZSByZXN0IG9mIHRoZSByZXNpZHVlIGJ1ZmZlclxcbiAgKGRyb3AgKGNhbGwgJG1lbXNldCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyZXNpZHVlX2J1ZmZlcikgKGxvY2FsLmdldCAkdG1wKSkgKGkzMi5jb25zdCAwKSAoaTMyLnN1YiAoaTMyLmNvbnN0IDEzNikgKGxvY2FsLmdldCAkdG1wKSkpKVxcblxcbiAgOzsgKChjaGFyKiljdHgtPm1lc3NhZ2UpW2N0eC0+cmVzdF0gfD0gMHgwMTtcXG4gIChsb2NhbC5zZXQgJHRtcCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyZXNpZHVlX2J1ZmZlcikgKGxvY2FsLmdldCAkcmVzaWR1ZV9pbmRleCkpKVxcbiAgKGkzMi5zdG9yZTggKGxvY2FsLmdldCAkdG1wKSAoaTMyLm9yIChpMzIubG9hZDhfdSAobG9jYWwuZ2V0ICR0bXApKSAoaTMyLmNvbnN0IDB4MDEpKSlcXG5cXG4gIDs7ICgoY2hhciopY3R4LT5tZXNzYWdlKVtibG9ja19zaXplIC0gMV0gfD0gMHg4MDtcXG4gIChsb2NhbC5zZXQgJHRtcCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRyZXNpZHVlX2J1ZmZlcikgKGkzMi5jb25zdCAxMzUpKSlcXG4gIChpMzIuc3RvcmU4IChsb2NhbC5nZXQgJHRtcCkgKGkzMi5vciAoaTMyLmxvYWQ4X3UgKGxvY2FsLmdldCAkdG1wKSkgKGkzMi5jb25zdCAweDgwKSkpXFxuXFxuICAoY2FsbCAka2VjY2FrX2Jsb2NrIChsb2NhbC5nZXQgJHJlc2lkdWVfYnVmZmVyKSAoaTMyLmNvbnN0IDEzNikgKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpKVxcblxcbiAgOzsgdGhlIGZpcnN0IDMyIGJ5dGVzIHBvaW50ZWQgYXQgYnkgJG91dHB1dF9vZmZzZXQgaXMgdGhlIGZpbmFsIGhhc2hcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkb3V0cHV0X29mZnNldCkgKGk2NC5sb2FkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSkpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJG91dHB1dF9vZmZzZXQpIChpMzIuY29uc3QgOCkpIChpNjQubG9hZCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGkzMi5jb25zdCA4KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRvdXRwdXRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE2KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDE2KSkpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRvdXRwdXRfb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSkgKGk2NC5sb2FkIChpMzIuYWRkIChsb2NhbC5nZXQgJGNvbnRleHRfb2Zmc2V0KSAoaTMyLmNvbnN0IDI0KSkpKVxcbilcXG5cXG47O1xcbjs7IENhbGN1bGF0ZSB0aGUgaGFzaC4gSGVscGVyIG1ldGhvZCBpbmNvcnBvcmF0aW5nIHRoZSBhYm92ZSB0aHJlZS5cXG47O1xcbihmdW5jICRrZWNjYWtcXG4gIChwYXJhbSAkY29udGV4dF9vZmZzZXQgaTMyKVxcbiAgKHBhcmFtICRpbnB1dF9vZmZzZXQgaTMyKVxcbiAgKHBhcmFtICRpbnB1dF9sZW5ndGggaTMyKVxcbiAgKHBhcmFtICRvdXRwdXRfb2Zmc2V0IGkzMilcXG5cXG4gIChjYWxsICRrZWNjYWtfaW5pdCAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkpXFxuICAoY2FsbCAka2VjY2FrX3VwZGF0ZSAobG9jYWwuZ2V0ICRjb250ZXh0X29mZnNldCkgKGxvY2FsLmdldCAkaW5wdXRfb2Zmc2V0KSAobG9jYWwuZ2V0ICRpbnB1dF9sZW5ndGgpKVxcbiAgKGNhbGwgJGtlY2Nha19maW5pc2ggKGxvY2FsLmdldCAkY29udGV4dF9vZmZzZXQpIChsb2NhbC5nZXQgJG91dHB1dF9vZmZzZXQpKVxcbilcXG5cIlxuICB9LFxuICBcIm1lbWNweVwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOztcXG47OyBtZW1jcHkgZnJvbSBld2FzbS1saWJjL2V3YXNtLWNsZWFudXBcXG47O1xcbihmdW5jICRtZW1jcHlcXG4gIChwYXJhbSAkZHN0IGkzMilcXG4gIChwYXJhbSAkc3JjIGkzMilcXG4gIChwYXJhbSAkbGVuZ3RoIGkzMilcXG4gIChyZXN1bHQgaTMyKVxcblxcbiAgKGxvY2FsICRpIGkzMilcXG5cXG4gIChsb2NhbC5zZXQgJGkgKGkzMi5jb25zdCAwKSlcXG5cXG4gIChibG9jayAkZG9uZVxcbiAgICAobG9vcCAkbG9vcFxcbiAgICAgIChpZiAoaTMyLmdlX3UgKGxvY2FsLmdldCAkaSkgKGxvY2FsLmdldCAkbGVuZ3RoKSlcXG4gICAgICAgIChiciAkZG9uZSlcXG4gICAgICApXFxuXFxuICAgICAgKGkzMi5zdG9yZTggKGkzMi5hZGQgKGxvY2FsLmdldCAkZHN0KSAobG9jYWwuZ2V0ICRpKSkgKGkzMi5sb2FkOF91IChpMzIuYWRkIChsb2NhbC5nZXQgJHNyYykgKGxvY2FsLmdldCAkaSkpKSlcXG5cXG4gICAgICAobG9jYWwuc2V0ICRpIChpMzIuYWRkIChsb2NhbC5nZXQgJGkpIChpMzIuY29uc3QgMSkpKVxcbiAgICAgIChiciAkbG9vcClcXG4gICAgKVxcbiAgKVxcblxcbiAgKHJldHVybiAobG9jYWwuZ2V0ICRkc3QpKVxcbilcXG5cIlxuICB9LFxuICBcIm1lbXNldFwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOztcXG47OyBtZW1jcHkgZnJvbSBld2FzbS1saWJjL2V3YXNtLWNsZWFudXBcXG47O1xcbihmdW5jICRtZW1zZXRcXG4gIChwYXJhbSAkcHRyIGkzMilcXG4gIChwYXJhbSAkdmFsdWUgaTMyKVxcbiAgKHBhcmFtICRsZW5ndGggaTMyKVxcbiAgKHJlc3VsdCBpMzIpXFxuICAobG9jYWwgJGkgaTMyKVxcblxcbiAgKGxvY2FsLnNldCAkaSAoaTMyLmNvbnN0IDApKVxcblxcbiAgKGJsb2NrICRkb25lXFxuICAgIChsb29wICRsb29wXFxuICAgICAgKGlmIChpMzIuZ2VfdSAobG9jYWwuZ2V0ICRpKSAobG9jYWwuZ2V0ICRsZW5ndGgpKVxcbiAgICAgICAgKGJyICRkb25lKVxcbiAgICAgIClcXG5cXG4gICAgICAoaTMyLnN0b3JlOCAoaTMyLmFkZCAobG9jYWwuZ2V0ICRwdHIpIChsb2NhbC5nZXQgJGkpKSAobG9jYWwuZ2V0ICR2YWx1ZSkpXFxuXFxuICAgICAgKGxvY2FsLnNldCAkaSAoaTMyLmFkZCAobG9jYWwuZ2V0ICRpKSAoaTMyLmNvbnN0IDEpKSlcXG4gICAgICAoYnIgJGxvb3ApXFxuICAgIClcXG4gIClcXG4gIChsb2NhbC5nZXQgJHB0cilcXG4pXFxuXCJcbiAgfSxcbiAgXCJtZW11c2VnYXNcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRtZW11c2VnYXNcXG4gIChwYXJhbSAkb2Zmc2V0IGkzMilcXG4gIChwYXJhbSAkbGVuZ3RoIGkzMilcXG5cXG4gIChsb2NhbCAkY29zdCBpNjQpXFxuICA7OyB0aGUgbnVtYmVyIG9mIG5ldyB3b3JkcyBiZWluZyBhbGxvY2F0ZWRcXG4gIChsb2NhbCAkbmV3V29yZENvdW50IGk2NClcXG5cXG4gIChpZiAoaTMyLmVxeiAobG9jYWwuZ2V0ICRsZW5ndGgpKVxcbiAgICAodGhlbiAocmV0dXJuKSlcXG4gIClcXG5cXG4gIDs7IGNvbnN0IG5ld01lbW9yeVdvcmRDb3VudCA9IE1hdGguY2VpbFtbb2Zmc2V0ICsgbGVuZ3RoXSAvIDMyXVxcbiAgKGxvY2FsLnNldCAkbmV3V29yZENvdW50XFxuICAgIChpNjQuZGl2X3UgKGk2NC5hZGQgKGk2NC5jb25zdCAzMSkgKGk2NC5hZGQgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkb2Zmc2V0KSkgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkbGVuZ3RoKSkpKVxcbiAgICAgICAgICAgICAgIChpNjQuY29uc3QgMzIpKSlcXG5cXG4gIDs7aWYgW3J1blN0YXRlLmhpZ2hlc3RNZW0gPj0gaGlnaGVzdE1lbV0gIHJldHVyblxcbiAgKGlmIChpNjQubGVfdSAobG9jYWwuZ2V0ICRuZXdXb3JkQ291bnQpIChnbG9iYWwuZ2V0ICR3b3JkQ291bnQpKVxcbiAgICAodGhlbiAocmV0dXJuKSlcXG4gIClcXG5cXG4gIDs7IHdvcmRzICogMyArIHdvcmRzIF4yIC8gNTEyXFxuICAobG9jYWwuc2V0ICRjb3N0XFxuICAgICAoaTY0LmFkZFxcbiAgICAgICAoaTY0Lm11bCAobG9jYWwuZ2V0ICRuZXdXb3JkQ291bnQpIChpNjQuY29uc3QgMykpXFxuICAgICAgIChpNjQuZGl2X3VcXG4gICAgICAgICAoaTY0Lm11bCAobG9jYWwuZ2V0ICRuZXdXb3JkQ291bnQpXFxuICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkbmV3V29yZENvdW50KSlcXG4gICAgICAgICAoaTY0LmNvbnN0IDUxMikpKSlcXG5cXG4gIChjYWxsICR1c2VHYXMgIChpNjQuc3ViIChsb2NhbC5nZXQgJGNvc3QpIChnbG9iYWwuZ2V0ICRwcmV2TWVtQ29zdCkpKVxcbiAgKGdsb2JhbC5zZXQgJHByZXZNZW1Db3N0IChsb2NhbC5nZXQgJGNvc3QpKVxcbiAgKGdsb2JhbC5zZXQgJHdvcmRDb3VudCAobG9jYWwuZ2V0ICRuZXdXb3JkQ291bnQpKVxcblxcbiAgOzsgZ3JvdyBhY3R1YWwgbWVtb3J5XFxuICA7OyB0aGUgZmlyc3QgMzE3MDQgYnl0ZXMgYXJlIGd1YXJhbnRlZWQgdG8gYmUgYXZhaWxhYmxlXFxuICA7OyBhZGp1c3QgZm9yIDMyIGJ5dGVzICAtIHRoZSBtYXhpbWFsIHNpemUgb2YgTVNUT1JFIHdyaXRlXFxuICA7OyBUT0RPIGl0IHNob3VsZCBiZSBtZW1vcnkuc2l6ZSAqIHBhZ2Vfc2l6ZVxcbiAgKGxvY2FsLnNldCAkb2Zmc2V0IChpMzIuYWRkIChsb2NhbC5nZXQgJGxlbmd0aCkgKGkzMi5hZGQgKGxvY2FsLmdldCAkb2Zmc2V0KSAoZ2xvYmFsLmdldCAkbWVtc3RhcnQpKSkpXFxuICAoaWYgKGkzMi5ndF91IChsb2NhbC5nZXQgJG9mZnNldCkgKGkzMi5tdWwgKGkzMi5jb25zdCA2NTUzNikgKG1lbW9yeS5zaXplKSkpXFxuICAgICh0aGVuXFxuICAgICAgKGRyb3AgKG1lbW9yeS5ncm93XFxuICAgICAgICAoaTMyLmRpdl91IChpMzIuYWRkIChpMzIuY29uc3QgNjU1MzUpIChpMzIuc3ViIChsb2NhbC5nZXQgJG9mZnNldCkgKG1lbW9yeS5zaXplKSkpIChpMzIuY29uc3QgNjU1MzYpKSkpXFxuICAgIClcXG4gIClcXG4pXFxuXCJcbiAgfSxcbiAgXCJtb2RfMzIwXCI6IHtcbiAgICBcIndhc3RcIjogXCIoZnVuYyAkbW9kXzMyMFxcbiAgOzsgZGl2aWRlbmRcXG4gIChwYXJhbSAkYSBpNjQpXFxuICAocGFyYW0gJGIgaTY0KVxcbiAgKHBhcmFtICRjIGk2NClcXG4gIChwYXJhbSAkZCBpNjQpXFxuICAocGFyYW0gJGUgaTY0KVxcblxcbiAgOzsgZGl2aXNvclxcbiAgKHBhcmFtICRhMSBpNjQpXFxuICAocGFyYW0gJGIxIGk2NClcXG4gIChwYXJhbSAkYzEgaTY0KVxcbiAgKHBhcmFtICRkMSBpNjQpXFxuICAocGFyYW0gJGUxIGk2NClcXG5cXG4gIDs7IHN0YWNrIHBvaW50ZXJcXG4gIChwYXJhbSAkc3AgaTMyKVxcblxcbiAgOzsgcXVvdGllbnRcXG4gIChsb2NhbCAkYXEgaTY0KVxcbiAgKGxvY2FsICRicSBpNjQpXFxuICAobG9jYWwgJGNxIGk2NClcXG4gIChsb2NhbCAkZHEgaTY0KVxcbiAgKGxvY2FsICRlcSBpNjQpXFxuXFxuICA7OyBtYXNrXFxuICAobG9jYWwgJG1hc2thIGk2NClcXG4gIChsb2NhbCAkbWFza2IgaTY0KVxcbiAgKGxvY2FsICRtYXNrYyBpNjQpXFxuICAobG9jYWwgJG1hc2tkIGk2NClcXG4gIChsb2NhbCAkbWFza2UgaTY0KVxcblxcbiAgKGxvY2FsICRjYXJyeSBpMzIpXFxuICAobG9jYWwgJHRlbXAgaTY0KVxcblxcbiAgKGxvY2FsLnNldCAkbWFza2UgKGk2NC5jb25zdCAxKSlcXG4gIChibG9jayAkbWFpblxcbiAgICA7OyBjaGVjayBkaXYgYnkgMFxcbiAgICAoaWYgKGNhbGwgJGlzemVyb18zMjAgKGxvY2FsLmdldCAkYTEpIChsb2NhbC5nZXQgJGIxKSAobG9jYWwuZ2V0ICRjMSkgKGxvY2FsLmdldCAkZDEpIChsb2NhbC5nZXQgJGUxKSlcXG4gICAgICAodGhlblxcbiAgICAgICAgKGxvY2FsLnNldCAkYSAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYiAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYyAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZCAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZSAoaTY0LmNvbnN0IDApKVxcbiAgICAgICAgKGJyICRtYWluKVxcbiAgICAgIClcXG4gICAgKVxcblxcbiAgICAoYmxvY2sgJGRvbmVcXG4gICAgICA7OyBhbGlnbiBiaXRzXFxuICAgICAgKGxvb3AgJGxvb3BcXG4gICAgICAgIDs7IGFsaWduIGJpdHM7XFxuICAgICAgICAoaWYgKGkzMi5vciAoaTY0LmVxeiAoaTY0LmNseiAobG9jYWwuZ2V0ICRhMSkpKSAoY2FsbCAkZ3RlXzMyMFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSAobG9jYWwuZ2V0ICRlMSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobG9jYWwuZ2V0ICRhKSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICRjKSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRlKSkpXFxuICAgICAgICAgIChiciAkZG9uZSlcXG4gICAgICAgIClcXG5cXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yIDw8IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGExIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGExKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGIxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYjEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGQxIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGUxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZTEgKGk2NC5zaGwgKGxvY2FsLmdldCAkZTEpIChpNjQuY29uc3QgMSkpKVxcblxcbiAgICAgICAgOzsgbWFzayA9IG1hc2sgPDwgMVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2EgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYiAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYykgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tjIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tkKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2QgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2UpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZSkgKGk2NC5jb25zdCAxKSkpXFxuICAgICAgICAoYnIgJGxvb3ApXFxuICAgICAgKVxcbiAgICApXFxuXFxuICAgIChibG9jayAkZG9uZVxcbiAgICAgIChsb29wICRsb29wXFxuICAgICAgICA7OyBsb29wIHdoaWxlIG1hc2sgIT0gMFxcbiAgICAgICAgKGlmIChjYWxsICRpc3plcm9fMzIwIChsb2NhbC5nZXQgJG1hc2thKSAobG9jYWwuZ2V0ICRtYXNrYikgKGxvY2FsLmdldCAkbWFza2MpIChsb2NhbC5nZXQgJG1hc2tkKSAobG9jYWwuZ2V0ICRtYXNrZSkpXFxuICAgICAgICAgIChiciAkZG9uZSlcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGlmIGRpdmlkZW5kID49IGRpdmlzb3JcXG4gICAgICAgIChpZiAoY2FsbCAkZ3RlXzMyMCAobG9jYWwuZ2V0ICRhKSAobG9jYWwuZ2V0ICRiKSAobG9jYWwuZ2V0ICRjKSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICRlKSAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkgKGxvY2FsLmdldCAkZTEpKVxcbiAgICAgICAgICAodGhlblxcbiAgICAgICAgICAgIDs7IGRpdmlkZW5kID0gZGl2aWRlbmQgLSBkaXZpc29yXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5sdF91IChsb2NhbC5nZXQgJGUpIChsb2NhbC5nZXQgJGUxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkZSAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGUpIChsb2NhbC5nZXQgJGUxKSkpXFxuXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGQpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRkKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkZCAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGQxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5vciAgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICR0ZW1wKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG5cXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkYykgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5ndF91IChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGMpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjICAgICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYzEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLm9yICAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJHRlbXApKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcblxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRiKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYikpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGIgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkdGVtcCkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkYSAgICAgKGk2NC5zdWIgIChpNjQuc3ViIChsb2NhbC5nZXQgJGEpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpIChsb2NhbC5nZXQgJGExKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yID4+IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGUxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZTEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGIxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGExKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICA7OyBtYXNrID0gbWFzayA+PiAxXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tlKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tkIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2MgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYykgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYiAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2thIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuY29uc3QgMSkpKVxcbiAgICAgICAgKGJyICRsb29wKVxcbiAgICAgIClcXG4gICAgKVxcbiAgKTs7IGVuZCBvZiBtYWluXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGxvY2FsLmdldCAkYikpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkYykpXFxuICAoaTY0LnN0b3JlIChpMzIuYWRkIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDgpKSAgKGxvY2FsLmdldCAkZCkpXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKSAgICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkZSkpXFxuKVxcblwiXG4gIH0sXG4gIFwibW9kXzUxMlwiOiB7XG4gICAgXCJ3YXN0XCI6IFwiOzsgTW9kdWxvIDB4MDZcXG4oZnVuYyAkbW9kXzUxMlxcbiAgOzsgZGl2aWRlbmRcXG4gIChwYXJhbSAkYSBpNjQpXFxuICAocGFyYW0gJGIgaTY0KVxcbiAgKHBhcmFtICRjIGk2NClcXG4gIChwYXJhbSAkZCBpNjQpXFxuICAocGFyYW0gJGUgaTY0KVxcbiAgKHBhcmFtICRmIGk2NClcXG4gIChwYXJhbSAkZyBpNjQpXFxuICAocGFyYW0gJGggaTY0KVxcblxcbiAgOzsgZGl2aXNvclxcbiAgKHBhcmFtICRhMSBpNjQpXFxuICAocGFyYW0gJGIxIGk2NClcXG4gIChwYXJhbSAkYzEgaTY0KVxcbiAgKHBhcmFtICRkMSBpNjQpXFxuICAocGFyYW0gJGUxIGk2NClcXG4gIChwYXJhbSAkZjEgaTY0KVxcbiAgKHBhcmFtICRnMSBpNjQpXFxuICAocGFyYW0gJGgxIGk2NClcXG5cXG4gIChwYXJhbSAkc3AgaTMyKVxcblxcbiAgOzsgcXVvdGllbnRcXG4gIChsb2NhbCAkYXEgaTY0KVxcbiAgKGxvY2FsICRicSBpNjQpXFxuICAobG9jYWwgJGNxIGk2NClcXG4gIChsb2NhbCAkZHEgaTY0KVxcblxcbiAgOzsgbWFza1xcbiAgKGxvY2FsICRtYXNrYSBpNjQpXFxuICAobG9jYWwgJG1hc2tiIGk2NClcXG4gIChsb2NhbCAkbWFza2MgaTY0KVxcbiAgKGxvY2FsICRtYXNrZCBpNjQpXFxuICAobG9jYWwgJG1hc2tlIGk2NClcXG4gIChsb2NhbCAkbWFza2YgaTY0KVxcbiAgKGxvY2FsICRtYXNrZyBpNjQpXFxuICAobG9jYWwgJG1hc2toIGk2NClcXG5cXG4gIChsb2NhbCAkY2FycnkgaTMyKVxcbiAgKGxvY2FsICR0ZW1wIGk2NClcXG5cXG4gIChsb2NhbC5zZXQgJG1hc2toIChpNjQuY29uc3QgMSkpXFxuXFxuICAoYmxvY2sgJG1haW5cXG4gICAgOzsgY2hlY2sgZGl2IGJ5IDBcXG4gICAgKGlmIChjYWxsICRpc3plcm9fNTEyIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSAobG9jYWwuZ2V0ICRlMSkgKGxvY2FsLmdldCAkZjEpIChsb2NhbC5nZXQgJGcxKSAobG9jYWwuZ2V0ICRoMSkpXFxuICAgICAgKHRoZW5cXG4gICAgICAgIChsb2NhbC5zZXQgJGUgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGYgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGcgKGk2NC5jb25zdCAwKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGggKGk2NC5jb25zdCAwKSlcXG4gICAgICAgIChiciAkbWFpbilcXG4gICAgICApXFxuICAgIClcXG5cXG4gICAgOzsgYWxpZ24gYml0c1xcbiAgICAoYmxvY2sgJGRvbmVcXG4gICAgICAobG9vcCAkbG9vcFxcbiAgICAgICAgOzsgYWxpZ24gYml0cztcXG4gICAgICAgIChpZiAoaTMyLm9yIChpNjQuZXF6IChpNjQuY2x6IChsb2NhbC5nZXQgJGExKSkpXFxuICAgICAgICAgIChjYWxsICRndGVfNTEyIChsb2NhbC5nZXQgJGExKSAobG9jYWwuZ2V0ICRiMSkgKGxvY2FsLmdldCAkYzEpIChsb2NhbC5nZXQgJGQxKSAobG9jYWwuZ2V0ICRlMSkgKGxvY2FsLmdldCAkZjEpIChsb2NhbC5nZXQgJGcxKSAobG9jYWwuZ2V0ICRoMSlcXG4gICAgICAgICAgICAgICAgICAgICAgICAgKGxvY2FsLmdldCAkYSkgIChsb2NhbC5nZXQgJGIpICAobG9jYWwuZ2V0ICRjKSAgKGxvY2FsLmdldCAkZCkgIChsb2NhbC5nZXQgJGUpICAobG9jYWwuZ2V0ICRmKSAgKGxvY2FsLmdldCAkZykgIChsb2NhbC5nZXQgJGgpKSlcXG4gICAgICAgICAgKGJyICRkb25lKVxcbiAgICAgICAgKVxcblxcbiAgICAgICAgOzsgZGl2aXNvciA9IGRpdmlzb3IgPDwgMVxcbiAgICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkYTEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRiMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGMxIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkZDEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZTEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRlMSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRlMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRmMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGYxIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJGYxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJGcxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZzEgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkZzEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaDEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRoMSAoaTY0LnNobCAobG9jYWwuZ2V0ICRoMSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICA7OyBtYXNrID0gbWFzayA8PCAxXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYSAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYikgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tiIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2MgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2MpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZCAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrZSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tlIChpNjQuYWRkIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tlKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tmKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2YgKGk2NC5hZGQgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2YpIChpNjQuY29uc3QgMSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2cpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZyAoaTY0LmFkZCAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZykgKGk2NC5jb25zdCAxKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNraCkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2toIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2toKSAoaTY0LmNvbnN0IDEpKSlcXG4gICAgICAgIChiciAkbG9vcClcXG4gICAgICApXFxuICAgIClcXG5cXG4gICAgKGJsb2NrICRkb25lXFxuICAgICAgKGxvb3AgJGxvb3BcXG4gICAgICAgIDs7IGxvb3Agd2hpbGUgbWFzayAhPSAwXFxuICAgICAgICAoaWYgKGNhbGwgJGlzemVyb181MTIgKGxvY2FsLmdldCAkbWFza2EpIChsb2NhbC5nZXQgJG1hc2tiKSAobG9jYWwuZ2V0ICRtYXNrYykgKGxvY2FsLmdldCAkbWFza2QpIChsb2NhbC5nZXQgJG1hc2tlKSAobG9jYWwuZ2V0ICRtYXNrZikgKGxvY2FsLmdldCAkbWFza2cpIChsb2NhbC5nZXQgJG1hc2toKSlcXG4gICAgICAgICAgKGJyICRkb25lKVxcbiAgICAgICAgKVxcbiAgICAgICAgOzsgaWYgZGl2aWRlbmQgPj0gZGl2aXNvclxcbiAgICAgICAgKGlmIChjYWxsICRndGVfNTEyXFxuICAgICAgICAgIChsb2NhbC5nZXQgJGEpICAobG9jYWwuZ2V0ICRiKSAgKGxvY2FsLmdldCAkYykgIChsb2NhbC5nZXQgJGQpICAobG9jYWwuZ2V0ICRlKSAgKGxvY2FsLmdldCAkZikgIChsb2NhbC5nZXQgJGcpICAobG9jYWwuZ2V0ICRoKVxcbiAgICAgICAgICAobG9jYWwuZ2V0ICRhMSkgKGxvY2FsLmdldCAkYjEpIChsb2NhbC5nZXQgJGMxKSAobG9jYWwuZ2V0ICRkMSkgKGxvY2FsLmdldCAkZTEpIChsb2NhbC5nZXQgJGYxKSAobG9jYWwuZ2V0ICRnMSkgKGxvY2FsLmdldCAkaDEpKVxcbiAgICAgICAgICAodGhlblxcbiAgICAgICAgICAgIDs7IGRpdmlkZW5kID0gZGl2aWRlbmQgLSBkaXZpc29yXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5sdF91IChsb2NhbC5nZXQgJGgpIChsb2NhbC5nZXQgJGgxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkaCAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGgpIChsb2NhbC5nZXQgJGgxKSkpXFxuXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGcpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRnKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkZyAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGcxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5vciAgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRnKSAobG9jYWwuZ2V0ICR0ZW1wKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG5cXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkZikgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5ndF91IChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGYpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRmICAgICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkZjEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLm9yICAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGYpIChsb2NhbC5nZXQgJHRlbXApKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcblxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRlKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkZSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGUgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRlMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkZSkgKGxvY2FsLmdldCAkdGVtcCkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkdGVtcCAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJGQpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpNjQuZ3RfdSAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRkKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkZCAgICAgKGk2NC5zdWIgIChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGQxKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGkzMi5vciAgIChpNjQuZ3RfdSAobG9jYWwuZ2V0ICRkKSAobG9jYWwuZ2V0ICR0ZW1wKSkgKGxvY2FsLmdldCAkY2FycnkpKSlcXG5cXG4gICAgICAgICAgICAobG9jYWwuc2V0ICR0ZW1wICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkYykgKGk2NC5leHRlbmRfaTMyX3UgKGxvY2FsLmdldCAkY2FycnkpKSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkY2FycnkgKGk2NC5ndF91IChsb2NhbC5nZXQgJHRlbXApIChsb2NhbC5nZXQgJGMpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjICAgICAoaTY0LnN1YiAgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYzEpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTMyLm9yICAgKGk2NC5ndF91IChsb2NhbC5nZXQgJGMpIChsb2NhbC5nZXQgJHRlbXApKSAobG9jYWwuZ2V0ICRjYXJyeSkpKVxcblxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJHRlbXAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICRiKSAoaTY0LmV4dGVuZF9pMzJfdSAobG9jYWwuZ2V0ICRjYXJyeSkpKSlcXG4gICAgICAgICAgICAobG9jYWwuc2V0ICRjYXJyeSAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkdGVtcCkgKGxvY2FsLmdldCAkYikpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGIgICAgIChpNjQuc3ViICAobG9jYWwuZ2V0ICR0ZW1wKSAobG9jYWwuZ2V0ICRiMSkpKVxcbiAgICAgICAgICAgIChsb2NhbC5zZXQgJGNhcnJ5IChpMzIub3IgICAoaTY0Lmd0X3UgKGxvY2FsLmdldCAkYikgKGxvY2FsLmdldCAkdGVtcCkpIChsb2NhbC5nZXQgJGNhcnJ5KSkpXFxuICAgICAgICAgICAgKGxvY2FsLnNldCAkYSAgICAgKGk2NC5zdWIgIChpNjQuc3ViIChsb2NhbC5nZXQgJGEpIChpNjQuZXh0ZW5kX2kzMl91IChsb2NhbC5nZXQgJGNhcnJ5KSkpIChsb2NhbC5nZXQgJGExKSkpXFxuICAgICAgICAgIClcXG4gICAgICAgIClcXG4gICAgICAgIDs7IGRpdmlzb3IgPSBkaXZpc29yID4+IDFcXG4gICAgICAgIChsb2NhbC5zZXQgJGgxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaDEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGcxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZzEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRnMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkZjEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRmMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGYxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRlMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGUxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkZTEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGQxKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkZDEgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRkMSkgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkYzEpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRjMSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJGMxKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRiMSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJGIxIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkYjEpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJGExKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkYTEgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhMSkgKGk2NC5jb25zdCAxKSkpXFxuXFxuICAgICAgICA7OyBtYXNrID0gbWFzayA+PiAxXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNraCAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2toKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZykgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tnIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2cpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tmKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2YgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrZikgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2UpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrZSAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tlKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrZCkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2tkIChpNjQuYWRkIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2QpIChpNjQuY29uc3QgMSkpIChpNjQuc2hsIChsb2NhbC5nZXQgJG1hc2tjKSAoaTY0LmNvbnN0IDYzKSkpKVxcbiAgICAgICAgKGxvY2FsLnNldCAkbWFza2MgKGk2NC5hZGQgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRtYXNrYykgKGk2NC5jb25zdCAxKSkgKGk2NC5zaGwgKGxvY2FsLmdldCAkbWFza2IpIChpNjQuY29uc3QgNjMpKSkpXFxuICAgICAgICAobG9jYWwuc2V0ICRtYXNrYiAoaTY0LmFkZCAoaTY0LnNocl91IChsb2NhbC5nZXQgJG1hc2tiKSAoaTY0LmNvbnN0IDEpKSAoaTY0LnNobCAobG9jYWwuZ2V0ICRtYXNrYSkgKGk2NC5jb25zdCA2MykpKSlcXG4gICAgICAgIChsb2NhbC5zZXQgJG1hc2thIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbWFza2EpIChpNjQuY29uc3QgMSkpKVxcbiAgICAgICAgKGJyICRsb29wKVxcbiAgICAgIClcXG4gICAgKVxcbiAgKTs7IGVuZCBvZiBtYWluXFxuXFxuICAoaTY0LnN0b3JlIChsb2NhbC5nZXQgJHNwKSAobG9jYWwuZ2V0ICRlKSlcXG4gIChpNjQuc3RvcmUgKGkzMi5zdWIgKGxvY2FsLmdldCAkc3ApIChpMzIuY29uc3QgOCkpIChsb2NhbC5nZXQgJGYpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAxNikpIChsb2NhbC5nZXQgJGcpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCAyNCkpIChsb2NhbC5nZXQgJGgpKVxcbilcXG5cIlxuICB9LFxuICBcIm11bF8yNTZcIjoge1xuICAgIFwid2FzdFwiOiBcIihmdW5jICRtdWxfMjU2XFxuICA7OyAgYSBiIGMgZCBlIGYgZyBoXFxuICA7OyogaSBqIGsgbCBtIG4gbyBwXFxuICA7Oy0tLS0tLS0tLS0tLS0tLS1cXG4gIChwYXJhbSAkYSBpNjQpXFxuICAocGFyYW0gJGMgaTY0KVxcbiAgKHBhcmFtICRlIGk2NClcXG4gIChwYXJhbSAkZyBpNjQpXFxuXFxuICAocGFyYW0gJGkgaTY0KVxcbiAgKHBhcmFtICRrIGk2NClcXG4gIChwYXJhbSAkbSBpNjQpXFxuICAocGFyYW0gJG8gaTY0KVxcblxcbiAgKHBhcmFtICRzcCBpMzIpXFxuXFxuICAobG9jYWwgJGIgaTY0KVxcbiAgKGxvY2FsICRkIGk2NClcXG4gIChsb2NhbCAkZiBpNjQpXFxuICAobG9jYWwgJGggaTY0KVxcbiAgKGxvY2FsICRqIGk2NClcXG4gIChsb2NhbCAkbCBpNjQpXFxuICAobG9jYWwgJG4gaTY0KVxcbiAgKGxvY2FsICRwIGk2NClcXG4gIChsb2NhbCAkdGVtcDYgaTY0KVxcbiAgKGxvY2FsICR0ZW1wNSBpNjQpXFxuICAobG9jYWwgJHRlbXA0IGk2NClcXG4gIChsb2NhbCAkdGVtcDMgaTY0KVxcbiAgKGxvY2FsICR0ZW1wMiBpNjQpXFxuICAobG9jYWwgJHRlbXAxIGk2NClcXG4gIChsb2NhbCAkdGVtcDAgaTY0KVxcblxcbiAgOzsgc3BsaXQgdGhlIG9wc1xcbiAgKGxvY2FsLnNldCAkYiAoaTY0LmFuZCAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IDMyKSkpIFxcblxcbiAgKGxvY2FsLnNldCAkZCAoaTY0LmFuZCAobG9jYWwuZ2V0ICRjKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJGMgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRjKSAoaTY0LmNvbnN0IDMyKSkpIFxcblxcbiAgKGxvY2FsLnNldCAkZiAoaTY0LmFuZCAobG9jYWwuZ2V0ICRlKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJGUgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRlKSAoaTY0LmNvbnN0IDMyKSkpXFxuXFxuICAobG9jYWwuc2V0ICRoIChpNjQuYW5kIChsb2NhbC5nZXQgJGcpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKVxcbiAgKGxvY2FsLnNldCAkZyAoaTY0LnNocl91IChsb2NhbC5nZXQgJGcpIChpNjQuY29uc3QgMzIpKSlcXG5cXG4gIChsb2NhbC5zZXQgJGogKGk2NC5hbmQgKGxvY2FsLmdldCAkaSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpXFxuICAobG9jYWwuc2V0ICRpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaSkgKGk2NC5jb25zdCAzMikpKSBcXG5cXG4gIChsb2NhbC5zZXQgJGwgKGk2NC5hbmQgKGxvY2FsLmdldCAkaykgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpXFxuICAobG9jYWwuc2V0ICRrIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkaykgKGk2NC5jb25zdCAzMikpKSBcXG5cXG4gIChsb2NhbC5zZXQgJG4gKGk2NC5hbmQgKGxvY2FsLmdldCAkbSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpXFxuICAobG9jYWwuc2V0ICRtIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkbSkgKGk2NC5jb25zdCAzMikpKVxcblxcbiAgKGxvY2FsLnNldCAkcCAoaTY0LmFuZCAobG9jYWwuZ2V0ICRvKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSlcXG4gIChsb2NhbC5zZXQgJG8gKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICRvKSAoaTY0LmNvbnN0IDMyKSkpXFxuICA7OyBmaXJzdCByb3cgbXVsdGlwbGljYXRpb24gXFxuICA7OyBwICogaFxcbiAgKGxvY2FsLnNldCAkdGVtcDAgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkaCkpKVxcbiAgOzsgcCAqIGcgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDEgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkZykpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDApIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBwICogZiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wMiAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRwKSAobG9jYWwuZ2V0ICRmKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wMSkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IHAgKiBlICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXAzIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJHApIChsb2NhbC5nZXQgJGUpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAyKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgcCAqIGQgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkZCkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBwICogYyArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNSAgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkYykpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBwICogYiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkcCkgKGxvY2FsLmdldCAkYikpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBwICogYSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRhICAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRwKSAobG9jYWwuZ2V0ICRhKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IHNlY29uZCByb3dcXG4gIDs7IG8gKiBoICsgJHRlbXAxIFxcXCJwZ1xcXCJcXG4gIChsb2NhbC5zZXQgJHRlbXAxIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG8pIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgOzsgbyAqIGcgKyAkdGVtcDIgXFxcInBmXFxcIiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wMiAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRnKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDIpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAxKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbyAqIGYgKyAkdGVtcDMgXFxcInBlXFxcIiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wMyAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRmKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAyKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbyAqIGUgKyAkdGVtcDQgICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA0IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG8pIChsb2NhbC5nZXQgJGUpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBvICogZCArICR0ZW1wNSAgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDUgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbykgKGxvY2FsLmdldCAkZCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG8gKiBjICsgJHRlbXA2ICArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRjKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbyAqIGIgKyAkYSAgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkYSAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRvKSAobG9jYWwuZ2V0ICRiKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkYSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyB0aGlyZCByb3cgLSBuXFxuICA7OyBuICogaCArICR0ZW1wMiBcXG4gIChsb2NhbC5zZXQgJHRlbXAyIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgOzsgbiAqIGcgKyAkdGVtcDMgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDMgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbikgKGxvY2FsLmdldCAkZykpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXAzKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wMikgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG4gKiBmICsgJHRlbXA0ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA0IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG4pIChsb2NhbC5nZXQgJGYpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDMpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBuICogZSArICR0ZW1wNSAgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDUgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbikgKGxvY2FsLmdldCAkZSkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG4gKiBkICsgJHRlbXA2ICArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRuKSAobG9jYWwuZ2V0ICRkKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbiAqIGMgKyAkYSAgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkYSAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRuKSAobG9jYWwuZ2V0ICRjKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkYSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgMzIpKSkpXFxuXFxuICA7OyBmb3J0aCByb3cgXFxuICA7OyBtICogaCArICR0ZW1wM1xcbiAgKGxvY2FsLnNldCAkdGVtcDMgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkaCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXAzKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkpXFxuICA7OyBtICogZyArICR0ZW1wNCArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNCAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRtKSAobG9jYWwuZ2V0ICRnKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXAzKSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbSAqIGYgKyAkdGVtcDUgKyBjYXJyeVxcbiAgKGxvY2FsLnNldCAkdGVtcDUgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkZikpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNCkgKGk2NC5jb25zdCAzMikpKSlcXG4gIDs7IG0gKiBlICsgJHRlbXA2ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA2IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJG0pIChsb2NhbC5nZXQgJGUpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBtICogZCArICRhICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkbSkgKGxvY2FsLmdldCAkZCkpIChpNjQuYW5kIChsb2NhbC5nZXQgJGEpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA2KSAoaTY0LmNvbnN0IDMyKSkpKVxcblxcbiAgOzsgZml0aCByb3dcXG4gIDs7IGwgKiBoICsgJHRlbXA0XFxuICAobG9jYWwuc2V0ICR0ZW1wNCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRoKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIDs7IGwgKiBnICsgJHRlbXA1ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA1IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGwpIChsb2NhbC5nZXQgJGcpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBsICogZiArICR0ZW1wNiArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRsKSAobG9jYWwuZ2V0ICRmKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkpKVxcbiAgOzsgbCAqIGUgKyAkYSArIGNhcnJ5XFxuICAobG9jYWwuc2V0ICRhIChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGwpIChsb2NhbC5nZXQgJGUpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICRhKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkgKGk2NC5zaHJfdSAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCAzMikpKSlcXG5cXG4gIDs7IHNpeHRoIHJvdyBcXG4gIDs7IGsgKiBoICsgJHRlbXA1XFxuICAobG9jYWwuc2V0ICR0ZW1wNSAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRrKSAobG9jYWwuZ2V0ICRoKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIDs7IGsgKiBnICsgJHRlbXA2ICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJHRlbXA2IChpNjQuYWRkIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGspIChsb2NhbC5nZXQgJGcpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDUpIChpNjQuY29uc3QgMzIpKSkpXFxuICA7OyBrICogZiArICRhICsgY2FycnlcXG4gIChsb2NhbC5zZXQgJGEgKGk2NC5hZGQgKGk2NC5hZGQgKGk2NC5tdWwgKGxvY2FsLmdldCAkaykgKGxvY2FsLmdldCAkZikpIChpNjQuYW5kIChsb2NhbC5nZXQgJGEpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSAoaTY0LnNocl91IChsb2NhbC5nZXQgJHRlbXA2KSAoaTY0LmNvbnN0IDMyKSkpKVxcblxcbiAgOzsgc2V2ZW50aCByb3dcXG4gIDs7IGogKiBoICsgJHRlbXA2XFxuICAobG9jYWwuc2V0ICR0ZW1wNiAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRoKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIDs7IGogKiBnICsgJGEgKyBjYXJyeVxcblxcbiAgOzsgZWlndGggcm93XFxuICA7OyBpICogaCArICRhXFxuICAobG9jYWwuc2V0ICRhIChpNjQuYWRkIChpNjQubXVsIChsb2NhbC5nZXQgJGkpIChsb2NhbC5nZXQgJGgpKSAoaTY0LmFuZCAoaTY0LmFkZCAoaTY0LmFkZCAoaTY0Lm11bCAobG9jYWwuZ2V0ICRqKSAobG9jYWwuZ2V0ICRnKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkYSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpIChpNjQuc2hyX3UgKGxvY2FsLmdldCAkdGVtcDYpIChpNjQuY29uc3QgMzIpKSkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcblxcbiAgOzsgY29tYmluZSB0ZXJtc1xcbiAgKGxvY2FsLnNldCAkYSAoaTY0Lm9yIChpNjQuc2hsIChsb2NhbC5nZXQgJGEpIChpNjQuY29uc3QgMzIpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wNikgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcbiAgKGxvY2FsLnNldCAkYyAoaTY0Lm9yIChpNjQuc2hsIChsb2NhbC5nZXQgJHRlbXA1KSAoaTY0LmNvbnN0IDMyKSkgKGk2NC5hbmQgKGxvY2FsLmdldCAkdGVtcDQpIChpNjQuY29uc3QgNDI5NDk2NzI5NSkpKSlcXG4gIChsb2NhbC5zZXQgJGUgKGk2NC5vciAoaTY0LnNobCAobG9jYWwuZ2V0ICR0ZW1wMykgKGk2NC5jb25zdCAzMikpIChpNjQuYW5kIChsb2NhbC5nZXQgJHRlbXAyKSAoaTY0LmNvbnN0IDQyOTQ5NjcyOTUpKSkpXFxuICAobG9jYWwuc2V0ICRnIChpNjQub3IgKGk2NC5zaGwgKGxvY2FsLmdldCAkdGVtcDEpIChpNjQuY29uc3QgMzIpKSAoaTY0LmFuZCAobG9jYWwuZ2V0ICR0ZW1wMCkgKGk2NC5jb25zdCA0Mjk0OTY3Mjk1KSkpKVxcblxcbiAgOzsgc2F2ZSBzdGFjayBcXG4gIChpNjQuc3RvcmUgKGxvY2FsLmdldCAkc3ApIChsb2NhbC5nZXQgJGEpKVxcbiAgKGk2NC5zdG9yZSAoaTMyLnN1YiAobG9jYWwuZ2V0ICRzcCkgKGkzMi5jb25zdCA4KSkgKGxvY2FsLmdldCAkYykpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDE2KSkgKGxvY2FsLmdldCAkZSkpXFxuICAoaTY0LnN0b3JlIChpMzIuc3ViIChsb2NhbC5nZXQgJHNwKSAoaTMyLmNvbnN0IDI0KSkgKGxvY2FsLmdldCAkZykpXFxuKVxcblwiXG4gIH1cbn0iXX0=
